<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Bulk Math Problem Creator – Combined Version</title>
  <!-- Include html2canvas for saving images and preview rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.6.4/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fraction.js@4.0.12/fraction.min.js"></script>
  <script src="./mathlive/mathlive.min.js"></script>
  <link rel="stylesheet" href="mathlive/mathlivefonts.css">

  <link href="https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-lite.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-lite.min.js"></script>


  <script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    /* Basic resets */
    * { box-sizing: border-box; }
    body, html {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
    /* Grid layout */
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto auto auto;
      grid-template-areas:
        "problem-image variables"
        "answer preview"
        "answer-image answer-image";
      gap: 5px;
      padding: 5px;
    }
    .section {
      border: 1px solid #ccc;
      padding: 5px;
      overflow: auto;
    }
    /* Grid areas */
    #problem-image { grid-area: problem-image; }
    #variables    { grid-area: variables; }
    #answer       { grid-area: answer; }
    #preview      { grid-area: preview; }
    #answer-image { grid-area: answer-image; }
    /* Toolbar and size controls */
    .toolbar button, .toolbar select, .toolbar input {
      margin: 2px 5px 2px 0;
    }
    .size-controls { margin: 5px 0; font-size: 13px; }
    /* Problem canvas styling */
    #problem-canvas {
      position: relative;
      width: 600px;
      height: 300px;
      border: 1px solid #ddd;
      /* NEW: Make background white */
      background-color: white;
    }
    /* Draggable element container */
    .draggable-element {
  position: relative; /* So the toolbar can position absolutely within this container */
}
.element-controls {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;       /* So the toolbar spans the top of the container */
  z-index: 9999;     /* Big number so it stays above shapes or text */
  display: none;     /* stays hidden by default until clicked */
  background: #f0f0f0;
  padding: 2px;
  font-size: 12px;
  align-items: center;
}
    .drag-handle {
      cursor: move;
      background: #ccc;
      padding: 2px 4px;
      margin-right: 4px;
    }
    .layer-button, .adjust-button, .delete-button {
      margin-right: 4px;
      cursor: pointer;
    }
    /* Text box styling */
    .text-box {
  direction: ltr;
  unicode-bidi: normal;
  text-align: left;
  min-width: 80px;
  min-height: 30px;
  padding: 2px;
  border: none;
  outline: none;
}

.triangle-container {
    min-width: 150px;
    min-height: 170px; /* Height + toolbar space */
}

.triangle-point {
    z-index: 10;
}

    /* Resize handle styling */
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: blue;
      right: 0;
      bottom: 0;
      cursor: se-resize;
      z-index: 10;
    }
    /* Preview area styling */
    .preview-area {
      border: 1px solid #ddd;
      padding: 10px;
      background-color: #fff;
      display: inline-block;
      pointer-events: none;
    }
    /* Answer image section styling */
    #answer-image {
      border: 1px solid #ddd;
      padding: 10px;
      background-color: #fff;
      width: 600px;
    }
    #answer-image-content {
      font-size: 24px;
      text-align: center;
      padding: 20px;
      width: 600px;
      height: 100px;
    }
    /* Variables panel styling */
    .variable-item {
      margin-bottom: 10px;
      border-bottom: 1px dashed #ccc;
      padding-bottom: 5px;
    }
    .fraction {
      display: inline-block;
      text-align: center;
      vertical-align: middle;
      margin: 0 2px;
    }
    .fraction .num {
      display: block;
      border-bottom: 1px solid;
      padding: 0 2px;
    }
    .fraction .den {
      display: block;
      padding: 0 2px;
    }
    /* NEW: Style for a selected table cell */
    .selected-cell {
      outline: 2px dashed red;
    }
    /* NEW: Variable Options Toolbar */
    #variable-options {
      margin-bottom: 5px;
    }
    #variable-options button {
      margin-right: 5px;
      font-size: 12px;
    }

    /* === New Styles for Multiple Choice Answer Options === */
    .mc-answer-option {
      border: 1px solid #ccc;
      padding: 5px;
      margin-bottom: 5px;
      min-height: 40px;
      position: relative;
    }
    .mc-option-toolbar {
      background: #f9f9f9;
      border-bottom: 1px solid #ddd;
      padding: 2px;
      margin-bottom: 3px;
    }
    .mc-option-toolbar button {
      margin-right: 5px;
      font-size: 12px;
    }
    /* New Styles for Equation Modal */
    #equationModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background: white;
      border: 1px solid #ccc;
      padding: 10px;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
    }
    #equationModal h3 {
      margin-top: 0;
    }
    #equationModal button {
      margin: 2px;
      font-size: 12px;
    }

    .division {
      display: inline-block;
      vertical-align: middle;
    }

    .fraction, .sqrt, .nth-root, .division {
      /* Ensure these elements align well with text */
      vertical-align: middle;
    }
    .grid-expression {
      min-height: 40px;
      border: 1px solid #ccc;
      padding: 4px;
      margin-bottom: 4px;
      outline: none;
    }
    .mjx-tex {
  display: none !important;
}

.triangle-toolbar {
  display: flex; /* Remove !important */
  align-items: center;
  background: #f0f0f0;
  padding: 2px;
  font-size: 12px;
  height: 20px;
  box-sizing: border-box;
}
.triangle-content {
  position: absolute;
  top: 20px; /* leave space for the toolbar */
  left: 0;
  width: 100%;
  bottom: 0;
  overflow: hidden;
}

/* Circle container styling */
.circle-container {
  min-width: 150px;
  min-height: 170px; /* Height + toolbar space */
}

/* ==== sidebar ==== */
#element-sidebar{
  position:fixed;          /* stays put while you scroll */
  top:10px; left:10px;
  width:180px; max-height:90vh;
  overflow-y:auto;
  padding:4px;
  background:#fafafa;
  border:1px solid #bbb;
  border-radius:4px;
  font:13px/1.3 sans-serif;
  z-index:100000;          /* above everything else */
}
.sidebar-item{
  padding:4px 6px; margin-bottom:2px;
  cursor:pointer; border-radius:3px;
}
.sidebar-item:hover{background:#ececec;}
.sidebar-item.active{


/* Circle content (SVG container) */
.circle-content {
  position: absolute;
  top: 20px; /* Leave space for the toolbar */
  left: 0;
  width: 100%;
  bottom: 0;
  overflow: hidden;
}

/* Center marker styling */
.circle-center {
  z-index: 10; /* Ensure it’s above the SVG */
}

/* Toolbar styling (reuse existing triangle-toolbar styles where possible) */
.circle-toolbar {
  display: flex;
  align-items: center;
  background: #f0f0f0;
  padding: 2px;
  font-size: 12px;
  height: 20px;
  box-sizing: border-box;
}

/* Ensure dropdowns and input fit nicely in the toolbar */
.circle-toolbar select,
.circle-toolbar input[type="number"] {
  height: 18px; /* Fit within 20px toolbar height */
  padding: 0 2px;
  border: 1px solid #ccc;
  background: #fff;
}

/* Optional: Adjust toolbar elements for better spacing */
.circle-toolbar .stroke-display,
.circle-toolbar .fill-display {
  width: 20px;
  height: 20px;
  border: 1px solid #ccc;
  cursor: pointer;
}

/* Ensure the SVG scales correctly */
.circle-content svg {
  width: 100%;
  height: 100%;
}


.element-controls {
  z-index: 1000;
  position: relative;
}

.line-container {
  overflow: visible !important;  /* ensure endpoints/toolbar remain clickable */
}
.line-content {
  overflow: visible !important;
}

.draggable-element:focus {
  outline: none !important;
}

mjx-assistive-mml, .MJX_Assistive_MathML{
  position:absolute!important;
  width:0!important;
  height:0!important;
  overflow:hidden!important;
  clip:rect(0 0 0 0)!important;
}


  </style>
</head>
<body>
        <!-- Modal overlay for image code input (hidden by default) -->
<div id="modalOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:900;"></div>

<!-- Pie Chart Settings Modal -->
<!-- Pie Chart Settings Modal -->
<div id="pieChartModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
      z-index:1000; background:white; border:1px solid #ccc; padding:10px; box-shadow: 2px 2px 8px rgba(0,0,0,0.3);">
  <h3>Pie Chart Settings</h3>
  <div style="margin-bottom:8px;">
    <label>Total Pieces: <input type="text" id="pie-total-pieces" placeholder="e.g., 8 or {a}" style="width:150px;"></label>
  </div>
  <div style="margin-bottom:8px;">
    <label>Shaded Pieces: <input type="text" id="pie-shaded-pieces" placeholder="e.g., 3 or {b}" style="width:150px;"></label>
  </div>
  <div style="margin-bottom:8px;">
    <label>Shaded Color: <input type="color" id="pie-shaded-color" value="#ff0000" style="width:60px; height:25px;"></label>
  </div>
  <div style="margin-bottom:8px;">
    <label>Unshaded Color: <input type="color" id="pie-unshaded-color" value="#ffffff" style="width:60px; height:25px;"></label>
  </div>
  <div style="margin-top:12px;">
    <button id="pieChartOK">OK</button>
    <button id="pieChartCancel">Cancel</button>
  </div>
</div>
<!--  ███  ELEMENT SIDEBAR  ███  -->
<div id="element-sidebar"></div>

<!-- Modal for entering/editing image code (hidden by default) -->
<div id="imageCodeModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
      z-index:1000; background:white; border:1px solid #ccc; padding:10px; box-shadow: 2px 2px 8px rgba(0,0,0,0.3);">
  <h3>Enter Image Code</h3>
  <textarea id="imageCodeTextarea" style="width:400px; height:200px;"></textarea><br>
  <button id="imageCodeOK">OK</button>
  <button id="imageCodeCancel">Cancel</button>
</div>
<!-- NEW: Modal for Equation Insertion -->
<!-- NEW: Modal for Equation Insertion -->
<div id="equationModal">
    <h3>Insert Equation Element</h3>
    <div id="equationButtons">
      <button onclick="insertEquationElement('fraction')">Fraction</button>
      <button onclick="insertEquationElement('division')">Division</button>
      <button onclick="insertEquationElement('sqrt')">Square Root</button>
      <button onclick="insertEquationElement('nthroot')">Nth Root</button>
      <button onclick="insertEquationElement('pi')">π</button>
      <button onclick="insertEquationElement('superscript')">Superscript</button>
      <button onclick="insertEquationElement('subscript')">Subscript</button>
    </div>
    <br>
    <button onclick="closeEquationModal()">Close</button>
  </div>
  <!-- NEW: Modal for Text With Code -->
<div id="textCodeModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
     z-index:1000; background:white; border:1px solid #ccc; padding:10px; box-shadow:2px 2px 8px rgba(0,0,0,0.3);">
  <h3>Insert Text With Code</h3>
  <textarea id="textCodeTextarea" style="width:400px; height:150px;" placeholder="Enter LaTeX code here"></textarea><br>
  <button id="textCodeOK">OK</button>
  <button id="textCodeCancel">Cancel</button>
</div>
  <div class="container">
    <!-- Problem Image Section -->
    <div id="problem-image" class="section">
      <h2>Problem Image</h2>
      <div class="toolbar">
        <button onclick="execCmd('bold')"><b>B</b></button>
        <button onclick="execCmd('italic')"><i>I</i></button>
        <button onclick="execCmd('underline')"><u>U</u></button>
        <button onclick="execCmd('superscript')">Sup</button>
        <button onclick="execCmd('subscript')">Sub</button>
        <button onclick="execCmd('justifyLeft')">Left</button>
        <button onclick="execCmd('justifyCenter')">Center</button>
        <button onclick="execCmd('justifyRight')">Right</button>
        <button onclick="addTextBox()">Add Text Box</button>
        <button onclick="addCircle()">Add Circle</button>
        <button onclick="addSemicircle()">Add Semicircle</button>
        <button onclick="addBarGraph()">Add Bar Graph</button>
        <button onclick="addFourQuadrantGraph()">Add Four Quadrant Graph</button>
        <button onclick="addQuadOneGraph()">Add Quadrant One Graph</button>
        <button onclick="addOval()">Add Oval</button>
        <button onclick="addCircleChordsAndSectors()">Add Circle with Chords</button>
        <button onclick="addAngle()" class="toolbar-button">Add Angle</button>
        <button onclick="addNumberLine()">Add Number Line</button>
        <button onclick="addRectangle()">Add Rectangle</button>
        <button onclick="addLineGraph()">Add Line Graph</button>
        <button onclick="addPieChart()">Add Pie Chart</button>
        <button onclick="addRectangle()">Add Rectangle</button>
        <button onclick="addGriddedRectangularPrism()">Add Gridded Rectangular Prism</button>
        <button onclick="addStemLeaf()" class="action-button">Add Stem-and-Leaf Plot</button>
        <button onclick="addRegularPolygon()">Add Regular Polygon</button>

        <button onclick="addCone()">Add Cone</button>
        <button onclick="addCylinder()">Add Cylinder</button>
        <button onclick="addSphere()">Add Sphere</button>
        <button onclick="addParallelogram()">Add Parallelogram</button>
        <button onclick="addRectangularPrism()">Add Rectangular Prism</button>
        <button onclick="addTriangularPrism()">Add Triangular Prism</button>
        <button onclick="addTriangle()">Add Triangle</button>
        <button onclick="addPolygon()">Add Polygon</button>
        <button onclick="addLine()">Add Line</button>
        <button onclick="addImageViaModal()">Add Image</button>
        <button onclick="addBoxAndWhisker()">Add Box and Whisker</button>

	<button onclick="addImageWithCode()">Add Image with Code</button>
        <button onclick="addTable()">Add Table</button>
        <button onclick="addGraph()">Add Graph</button>
        <button onclick="deleteActiveElement()">Delete Selected</button>
        <label for="highlight-color">Highlight Color:</label>
        <input type="color" id="highlight-color" value="#ffff99">
        <button onclick="applyHighlight('row')">Highlight Row</button>
        <button onclick="applyHighlight('column')">Highlight Column</button>
      </div>
      <div class="size-controls">
        Saved Problem Image Size: Width:
        <input type="number" id="problem-width" value="600" style="width:60px;"> px,
        Height: <input type="number" id="problem-height" value="300" style="width:60px;"> px
        <button onclick="updateProblemSize()">Update Size</button>
      </div>
      <div id="global-toolbar" style="position: relative; margin-bottom: 10px; border: 1px solid #ccc; padding: 5px;">
        <!-- Active toolbar content will be moved here -->
      </div>
      <div id="problem-canvas"></div>
    </div>
    
      
    <!-- Variables Section -->
<div id="variables" class="section">
  <h2>Variables</h2>

  <!-- Mode selection toggle -->
  <div id="variable-mode-selection">
    <label>
      <input type="radio" name="variable-mode" value="ui" checked> User Friendly Mode
    </label>
    &nbsp;&nbsp;
    <label>
      <input type="radio" name="variable-mode" value="code"> Code Mode
    </label>
  </div>

  <!-- UI Mode: Your original variable UI -->
  <div id="variable-ui-container">
    <div id="variable-options">
      <button onclick="setVariableFormula('random-int')">Random Integer</button>
      <button onclick="setVariableFormula('random-number')">Random Number</button>
      <button onclick="setVariableFormula('round')">Round</button>
      <button onclick="setVariableFormula('unreduced-fraction')">Unreduced Fraction</button>
      <button onclick="setVariableFormula('improper-fraction')">Reduced Improper Fraction</button>
      <button onclick="setVariableFormula('mixed-number')">Reduced Mixed Number</button>
      <button onclick="setVariableFormula('choose-from-list')">Choose from Word List</button>
      <button onclick="setVariableFormula('choose-from-list-number')">Choose from Number List</button>
      <button onclick="setVariableFormula('arrange-asc')">Arrange Ascending</button>
      <button onclick="setVariableFormula('arrange-desc')">Arrange Descending</button>
    </div>
    <p>
      All text using the <code>{variable}</code> notation is automatically detected.
      You may define its “rule” below.
    </p>
    <button onclick="addVariable()">Add Variable</button>
    <div id="variable-list"></div>
  </div>

  <!-- Code Mode: A single textarea for all variable rules (initially hidden) -->
  <div id="variable-code-container" style="display:none;">
    <div id="variable-code-toolbar">
      <button onclick="setVariableFormula('random-int')">Random Integer</button>
      <button onclick="setVariableFormula('random-number')">Random Number</button>
      <button onclick="setVariableFormula('round')">Round</button>
      <button onclick="setVariableFormula('unreduced-fraction')">Unreduced Fraction</button>
      <button onclick="setVariableFormula('improper-fraction')">Reduced Improper Fraction</button>
      <button onclick="setVariableFormula('mixed-number')">Reduced Mixed Number</button>
      <button onclick="setVariableFormula('choose-from-list')">Choose from Word List</button>
      <button onclick="setVariableFormula('choose-from-list-number')">Choose from Number List</button>
      <button onclick="setVariableFormula('arrange-asc')">Arrange Ascending</button>
      <button onclick="setVariableFormula('arrange-desc')">Arrange Descending</button>
    </div>
    <textarea id="variable-code" placeholder="For example:
a = randomInt(1,10)
b = randomNumber(1,10,2)
c = a + b"></textarea>
  </div>

  <br>
  <button onclick="updateVariables()">Update Variables</button>
</div>
    
    <!-- Answer Configuration Section -->
    <!-- Answer Configuration Section -->
    <div id="answer" class="section">
        <h2>Answer Configuration</h2>
        <label for="answer-type">Select Answer Type:</label>
        <select id="answer-type" onchange="updateAnswerOptions()">
          <option value="box">Answer Box</option>
          <option value="multiple">Multiple Choice</option>
          <option value="multi-select">Multi-Select</option>
          <option value="grid">Single Select Grid</option>
        </select>
        
        <!-- Answer Box Options -->
        <div id="box-options" class="answer-config">
          <h3>Answer Box Options</h3>
          <label for="label-position">Label Position:</label>
          <select id="label-position">
            <option value="none">No Label</option>
            <option value="before">Label Before</option>
            <option value="after">Label After</option>
          </select>
          <input type="text" id="label-text" placeholder="Enter label text (e.g., cm, in)">
          <br><br>
          <label for="answer-rule">Answer Rule:</label>
          <select id="answer-rule">
            <option value="exact">Exact Match</option>
            <option value="equiv">Equivalent Answer</option>
          </select>
          <input type="text" id="correct-answer" placeholder="Enter correct answer (you may use {variable})">
        </div>
        
        <!-- Multiple Choice / Multi-Select Options -->
        <div id="multiple-options" class="answer-config" style="display:none;">
          <h3>Multiple Choice / Multi-Select Options</h3>
          <div id="mc-global-settings">
            <label>
              Total Options: 
              <input type="number" id="mc-total-options" value="5" min="1">
            </label>
            <label style="margin-left:10px;">
              Correct Options Range: 
              <input type="number" id="mc-correct-min" value="2" min="0"> 
              - 
              <input type="number" id="mc-correct-max" value="4" min="0">
            </label>
          </div>
          <div id="mc-options">
            <h4>Correct Answers</h4>
            <div id="mc-correct"></div>
            <button onclick="addMCOption('correct')">Add Correct Answer</button>
            <h4>Incorrect Answers</h4>
            <div id="mc-incorrect"></div>
            <button onclick="addMCOption('incorrect')">Add Incorrect Answer</button>
          </div>
        </div>
        
        <!-- Begin Grid Options Panel -->
        <div id="grid-options" class="answer-config" style="display:none;">
          <h3>Single Select Grid Options</h3>
          
          <!-- Input for number of rows -->
          <label for="grid-rows">Number of Rows:</label>
          <input type="number" id="grid-rows" value="3" min="1">
          <br>
          
          <!-- Input for number of columns -->
          <label for="grid-columns">Number of Columns:</label>
          <input type="number" id="grid-columns" value="3" min="1">
          <br>
          
          <!-- Div for Column Name Inputs -->
          <div id="grid-column-names">
            <h4>Column Names</h4>
            <!-- Column name inputs will be generated here -->
          </div>  <!-- End of grid-column-names -->
          
          <button onclick="updateGridColumnNames()">Update Column Names</button>
          <br>
          
          <!-- Div for Row Expressions -->
          <div id="grid-row-expressions">
            <h4>Row Expressions</h4>
            <!-- Row expression entries will appear here -->
          </div>  <!-- End of grid-row-expressions -->
          
          <button onclick="addGridRowExpression()">Add Expression</button>
          <br>
  <!-- New shuffle checkbox -->
  <label>
    <input type="checkbox" id="grid-shuffle">
    Shuffle Expressions
  </label>
        </div>  <!-- End of grid-options panel -->
        <!-- End Grid Options Panel -->
        
      </div>
      

    
    <!-- Preview Section -->
   <div id="preview" class="section">
  <h2>Preview</h2>
  <button onclick="previewProblemInteractive()">Preview Problem</button>
  <div id="preview-area" class="preview-area"></div>
</div>

    
    <!-- Answer Image Section -->
    <!-- Answer Image Section -->
<div id="answer-image" class="section">
  <h2>Answer Image</h2>
  <div class="size-controls">
    Saved Answer Image Size: Width:
    <input type="number" id="answer-width" value="600" style="width:60px;"> px,
    Height: <input type="number" id="answer-height" value="100" style="width:60px;"> px
    <button onclick="updateSavedAnswerSize()">Update Saved Size</button>
  </div>
  <div id="answer-image-content"></div>
  <br>
  <button onclick="saveProblemImages()">Save Problem Images</button>
<br>
<button onclick="makeAroundTheRoomActivity()">Make Around the Room Activity</button>
</div>
<script>

    // ===== Dependency Graph Globals =====
  var varDefinitions = {};    // Holds each variable’s definition (e.g., { a: "5", b: "a+5" })
  var dependencyGraph = {};   // Maps a variable to a set of variables that depend on it
  var computedValues = {};    // Holds the current computed value for each variable
  
      /******** Global Variables ********/
      let savedProblemWidth = 600, savedProblemHeight = 300;
      let savedAnswerWidth = 600, savedAnswerHeight = 100;
      let nextElementOffset = 10;
      let activeElement = null, activeTextBox = null;
      let globalTopZ = 100;  // or any starting number you like
      let ignoreNextClick = false;
      // Pie‑ID counter for assigning unique IDs to each pie
if (typeof window.nextPieId === 'undefined') window.nextPieId = 1;

      const problemCanvas = document.getElementById("problem-canvas");
      
       
      // NEW: Global variable to hold the currently focused formula input
      let currentFormulaInput = null;
   
      /* ==== sidebar logic ==== */
(function () {
  const sidebar = document.getElementById('element-sidebar');
  if (!sidebar) return;

  /* keep clicks inside the sidebar from closing toolbars */
  sidebar.addEventListener('click', e => e.stopPropagation());

  /* --- helpers -------------------------------------------------------- */

  // give the chosen element focus, outline, toolbar & top z-index
  function focusElement(el) {
    activeElement = el;                   // set FIRST
    raiseElementTemporarily(el);          // your existing helper
    highlightActiveElement();             // uses activeElement

    sidebar.querySelectorAll('.sidebar-item.active')
           .forEach(i => i.classList.remove('active'));
    if (el.__row) el.__row.classList.add('active');

    const ctrls = el.querySelector('.element-controls');
    if (ctrls) ctrls.style.display = 'flex';
  }

  // prompt-to-rename on double-click
  function renameRow(row, el) {
    const current = row.textContent.trim();
    const name = prompt('Rename element:', current);
    if (!name) return;
    row.textContent = name.trim();
    el.dataset.sidebarLabel = name.trim();    // persist label
  }

  /* --- sidebar row management ---------------------------------------- */

  function register(el) {
    if (el.__row) return;                     // already listed

    const row = document.createElement('div');
    row.className = 'sidebar-item';
    row.textContent =
      el.dataset.sidebarLabel
      ?? el.querySelector('.text-box')?.innerText.trim().slice(0, 25)
      ?? el.className.split(' ')[1];

      row.addEventListener('click', e => {
  e.stopPropagation();                     // keep the sidebar click inside

  // ► simulate a full click on the real element ◄
  el.dispatchEvent(new MouseEvent('mousedown', {bubbles:true}));
  el.dispatchEvent(new MouseEvent('click',     {bubbles:true}));

  focusElement(el);                        // raise + outline + sidebar highlight
});

    row.addEventListener('dblclick', () => renameRow(row, el));

    sidebar.appendChild(row);
    el.__row = row;                           // link for cleanup
  }

  function unregister(el) {
    if (el.__row) { el.__row.remove(); delete el.__row; }
  }

  /* --- watch the canvas for adds/removes ----------------------------- */

  const canvas = document.getElementById('problem-canvas');

  new MutationObserver(muts => {
    muts.forEach(m => {
      m.addedNodes.forEach(n => {
        if (n.nodeType === 1 &&
            n.classList.contains('draggable-element')) register(n);
      });
      m.removedNodes.forEach(n => { if (n.__row) unregister(n); });
    });
  }).observe(canvas, { childList: true });

  /* register anything already on the canvas when the page loads */
  canvas.querySelectorAll('.draggable-element').forEach(register);
})();


  // ===== Dependency Extraction =====
  function extractDependencies(expression) {
    // Find all word tokens (e.g., a, b, myVar, etc.)
    let tokens = expression.match(/\b[a-zA-Z]\w*\b/g) || [];
    // Filter out tokens that are known function names or reserved words.
    const reserved = new Set(["Math", "randomInt", "randomNumber", "reduceFraction", "gcd", "round", "unreducedfraction", "mixedFraction"]);
    return tokens.filter(token => !reserved.has(token));
  }
  
  // ===== Build Dependency Graph =====
  function buildDependencyGraph() {
    dependencyGraph = {};
    // Initialize a dependency set for every variable defined.
    for (let varName in varDefinitions) {
      dependencyGraph[varName] = new Set();
    }
    // For each variable, parse its expression and add dependency edges.
    for (let varName in varDefinitions) {
      let expr = varDefinitions[varName];
      let deps = extractDependencies(expr);
      deps.forEach(dep => {
        if (varDefinitions.hasOwnProperty(dep)) {
          dependencyGraph[dep].add(varName);
        }
      });
    }
  }

  // First, add a function to find all draggable elements at a specific point
  function findElementsAtPoint(x, y) {
  // Get all draggable elements in the problem canvas
  const elements = Array.from(document.querySelectorAll("#problem-canvas .draggable-element"));
  const elementsAtPoint = [];
  
  // Check each element to see if it contains the point (x, y)
  elements.forEach(element => {
    const rect = element.getBoundingClientRect();
    if (
      x >= rect.left && 
      x <= rect.right && 
      y >= rect.top && 
      y <= rect.bottom
    ) {
      elementsAtPoint.push(element);
    }
  });
  
  // Sort elements by z-index (highest to lowest)
  elementsAtPoint.sort((a, b) => {
    const zIndexA = parseInt(getComputedStyle(a).zIndex) || 0;
    const zIndexB = parseInt(getComputedStyle(b).zIndex) || 0;
    return zIndexB - zIndexA;
  });
  
  return elementsAtPoint;
}

// Add a cycling index to track which element in the stack is currently active


// Helper function to highlight the active element



// Function to add a hint to the UI

// Function to create draggable endpoints for the line

function createDraggableEndpoints(svgContainer) {
  const line = svgContainer.currentLine;
  if (!line) return;
  
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));
  
  // Create endpoint markers (circles)
  const endpoint1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  endpoint1.setAttribute("cx", x1);
  endpoint1.setAttribute("cy", y1);
  endpoint1.setAttribute("r", "6");
  endpoint1.setAttribute("fill", "rgba(0, 0, 255, 0.5)");
  endpoint1.setAttribute("stroke", "blue");
  endpoint1.setAttribute("stroke-width", "1.5");
  endpoint1.style.cursor = "move";
  endpoint1.style.pointerEvents = "all"; // Ensure it catches events
  
  const endpoint2 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  endpoint2.setAttribute("cx", x2);
  endpoint2.setAttribute("cy", y2);
  endpoint2.setAttribute("r", "6");
  endpoint2.setAttribute("fill", "rgba(0, 0, 255, 0.5)");
  endpoint2.setAttribute("stroke", "blue");
  endpoint2.setAttribute("stroke-width", "1.5");
  endpoint2.style.cursor = "move";
  endpoint2.style.pointerEvents = "all"; // Ensure it catches events
  
  // Add endpoints to SVG
  svgContainer.appendChild(endpoint1);
  svgContainer.appendChild(endpoint2);
  
  // Store references
  svgContainer.endpoint1 = endpoint1;
  svgContainer.endpoint2 = endpoint2;
  
  // Add event listeners for dragging
  endpoint1.addEventListener("mousedown", function(e) {
    e.stopPropagation(); // Prevent parent container's drag from activating
    dragEndpoint(e, endpoint1, line, "start", svgContainer);
  });
  
  endpoint2.addEventListener("mousedown", function(e) {
    e.stopPropagation(); // Prevent parent container's drag from activating
    dragEndpoint(e, endpoint2, line, "end", svgContainer);
  });
}


// Helper function to adjust SVG container size based on line endpoints
function adjustSVGContainer(svgElement) {
  const line = svgElement.currentLine;
  if (!line) return;
  
  // Get current endpoint positions from the line (in the current SVG coordinate system)
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));
  
  // Determine the bounding box of the line
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);
  
  // Set a desired padding (in SVG coordinate units)
  const padding = 20;
  
  // Compute new dimensions: add padding on all sides
  const newWidth = (maxX - minX) + 2 * padding;
  const newHeight = (maxY - minY) + 2 * padding;
  
  // Adjust the SVG element:
  svgElement.setAttribute("width", newWidth);
  svgElement.setAttribute("height", newHeight);
  // Now make the viewBox start at 0,0 with the new width/height
  svgElement.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);
  
  // Offset the line so that its previous coordinates are preserved:
  line.setAttribute("x1", x1 - minX + padding);
  line.setAttribute("y1", y1 - minY + padding);
  line.setAttribute("x2", x2 - minX + padding);
  line.setAttribute("y2", y2 - minY + padding);
  
  // Update the endpoints similarly if they exist
  if (svgElement.endpoint1) {
    svgElement.endpoint1.setAttribute("cx", x1 - minX + padding);
    svgElement.endpoint1.setAttribute("cy", y1 - minY + padding);
  }
  if (svgElement.endpoint2) {
    svgElement.endpoint2.setAttribute("cx", x2 - minX + padding);
    svgElement.endpoint2.setAttribute("cy", y2 - minY + padding);
  }
  
  // Now adjust the outer container (the draggable element that wraps the SVG)
  // In addLine(), you create a container that holds the toolbar and a content div,
  // which in turn holds this SVG.
  // We assume the toolbar height is fixed (e.g., 20px).
  const toolbarHeight = 20;
  // The SVG is placed inside a content div that starts at top=toolbarHeight.
  // Find the outer container:
  const contentDiv = svgElement.parentElement;
  const outerContainer = contentDiv.parentElement;
  
  // Get the container’s current position:
  let currentLeft = parseFloat(outerContainer.style.left) || 0;
  let currentTop = parseFloat(outerContainer.style.top) || 0;
  
  // We want to reposition the container so that the new SVG is not cut off.
  // Shift the container’s position by (minX - padding, minY - padding)
  outerContainer.style.left = (currentLeft + minX - padding) + "px";
  outerContainer.style.top  = (currentTop + minY - padding) + "px";
  
  // Also update the outer container’s dimensions:
  outerContainer.style.width  = newWidth + "px";
  outerContainer.style.height = (toolbarHeight + newHeight) + "px";
}






function substituteLatexVariables(latex, computed){
  return latex.replace(/#([^#\s]+)#/g, (_,v)=>
           computed.hasOwnProperty(v) ? computed[v] : _);
}


  // ===== Evaluation and Update Propagation =====
  function evaluateExpression(expression) {
    if (!expression || expression.trim() === "") {
      return "";
    }
    try {
      // Build a context that includes the current computedValues and helper functions.
      let context = Object.assign({}, computedValues, {
        randomInt: randomInt,
        randomNumber: randomNumber,
        round: round,
        reduceFraction: reduceFraction,
        gcd: gcd,
        unreducedfraction: unreducedfraction,
        mixedFraction: mixedFraction,
        chooseFromWordList: chooseFromWordList,
        chooseFromNumberList: chooseFromNumberList,
        arrangeAscending: arrangeAscending,
        arrangeDescending: arrangeDescending,
        Math: Math
      });
      return new Function("with(this){ return (" + expression + "); }").call(context);
    } catch (e) {
      console.error("Error evaluating expression:", expression, e);
      return null;
    }
  }
  
  function propagateUpdate(varName) {
    // Get the set of variables that depend on varName.
    let dependents = dependencyGraph[varName];
    if (dependents) {
      dependents.forEach(dependentVar => {
        // Recalculate the dependent variable using its expression.
        let expr = varDefinitions[dependentVar];
        computedValues[dependentVar] = evaluateExpression(expr);
        // Recursively propagate changes further down the dependency chain.
        propagateUpdate(dependentVar);
      });
    }
  }
  
      // NEW: Function to set the current formula input when it receives focus.
      function setCurrentFormulaInput(input) {
        currentFormulaInput = input;
      }
      
      /******** Helper Functions (for formulas) ********/
   function randomInt(min, max) {
    min = Number(min);
    max = Number(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  
  
  function randomNumber(min, max, decimals) {
    return Number((Math.random() * (max - min) + min).toFixed(decimals));
  }
  
  function round(num, decimals) {
    return Number(Math.round(num + 'e' + decimals) + 'e-' + decimals);
  }
  
  function createDraggableElement(innerContentHTML, isText) {
  const container = document.createElement('div');
  container.setAttribute('tabindex', '0');
  container.id = "draggable_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
  container.className = 'draggable-element';
  container.style.position = 'absolute';
  container.style.left = nextElementOffset + 'px';
  container.style.top = nextElementOffset + 'px';
  nextElementOffset += 20;
  if (nextElementOffset > 100) nextElementOffset = 10;
  
  // NEW: Set default z-index if not already set and record it.
  if (!container.style.zIndex || container.style.zIndex === "") {
    container.style.zIndex = "1";
    container.dataset.originalZ = "1";
  }
  
  const controls = document.createElement('div');
  controls.className = 'element-controls';
  
  const handle = document.createElement('span');
  handle.className = 'drag-handle';
  handle.innerHTML = '&#9776;';
  controls.appendChild(handle);
  
  const forwardBtn = document.createElement('button');
forwardBtn.className = 'layer-button';
forwardBtn.innerHTML = '↑';
forwardBtn.addEventListener('click', function(e) {
  let z = parseInt(container.style.zIndex) || 1;
  z += 1;
  container.style.zIndex = z;
  // Update the original z-index
  container.dataset.originalZ = z.toString();
  e.stopPropagation();
});
controls.appendChild(forwardBtn);

const backBtn = document.createElement('button');
backBtn.className = 'layer-button';
backBtn.innerHTML = '↓';
backBtn.addEventListener('click', function(e) {
  let z = parseInt(container.style.zIndex) || 1;
  z = Math.max(1, z - 1); // Don't go below 1
  container.style.zIndex = z;
  // Update the original z-index
  container.dataset.originalZ = z.toString();
  e.stopPropagation();
});
controls.appendChild(backBtn);
  
  const adjustBtn = document.createElement('button');
  adjustBtn.className = 'adjust-button';
  // If the element has image code, show "Change Code"; otherwise, "Adjust"
  adjustBtn.innerHTML = container.dataset.imageCode ? 'Change Code' : 'Adjust';
  adjustBtn.addEventListener('click', function(e) {
    const contentDiv = container.querySelector('.element-content');
    if (container.dataset.imageCode) {
      editImageCode(container);
    } else if (contentDiv.querySelector('svg')) {
      editGraph(container);
    } else {
      const textBox = contentDiv.querySelector('.text-box');
      if (textBox) {
        let newSize = prompt("Enter new font size (e.g., 16px):", textBox.style.fontSize || "16px");
        if (newSize) textBox.style.fontSize = newSize;
      }
    }
    e.stopPropagation();
  });
  controls.appendChild(adjustBtn);

  const delBtn = document.createElement('button');
  delBtn.className = 'delete-button';
  delBtn.innerHTML = 'X';
  delBtn.addEventListener('click', function(e) {
    deleteElement(delBtn);
    e.stopPropagation();
  });
  controls.appendChild(delBtn);
  
  container.appendChild(controls);
  
  const contentDiv = document.createElement('div');
  contentDiv.className = 'element-content';
  if (isText) {
    const textBox = document.createElement('div');
    textBox.className = 'text-box';
    textBox.contentEditable = true;
    textBox.innerHTML = innerContentHTML;
    // Save the original text (with {variable} placeholders) for later substitution.
    textBox.setAttribute("data-original-text", innerContentHTML);
    textBox.setAttribute("data-mode", "manual"); // default to manual
    textBox.addEventListener('click', function(e) {
      activeElement = container;
      activeTextBox = textBox;
    });
    textBox.addEventListener('input', function() {
      textBox.setAttribute("data-original-text", textBox.innerHTML);
      updateVariables();
    });
    contentDiv.appendChild(textBox);

    // --- Add radio buttons for mode selection in the toolbar ---
    const modeContainer = document.createElement('span');
    modeContainer.className = "mode-container";
    modeContainer.style.marginRight = "4px";

    // Create the Manual radio button.
    const manualLabel = document.createElement('label');
    manualLabel.style.marginRight = "4px";
    const manualRadio = document.createElement('input');
    manualRadio.type = "radio";
    manualRadio.name = "mode_" + container.id;
    manualRadio.value = "manual";
    manualRadio.checked = true; // default
    manualRadio.addEventListener('change', function(e) {
      if (manualRadio.checked && activeTextBox) {
        activeTextBox.setAttribute("data-mode", "manual");
        updateVariables();
      }
    });
    manualLabel.appendChild(manualRadio);
    manualLabel.appendChild(document.createTextNode("Manual"));

    // Create the LaTeX radio button.
    const latexLabel = document.createElement('label');
    latexLabel.style.marginRight = "4px";
    const latexRadio = document.createElement('input');
    latexRadio.type = "radio";
    latexRadio.name = "mode_" + container.id;
    latexRadio.value = "latex";
    latexRadio.checked = false;
    latexRadio.addEventListener('change', function(e) {
      if (latexRadio.checked && activeTextBox) {
        activeTextBox.setAttribute("data-mode", "latex");
        updateVariables();
      }
    });
    latexLabel.appendChild(latexRadio);
    latexLabel.appendChild(document.createTextNode("LaTeX"));

    modeContainer.appendChild(manualLabel);
    modeContainer.appendChild(latexLabel);
    controls.appendChild(modeContainer);
    // --- End of mode radio button group ---
    
  } else {
    contentDiv.innerHTML = innerContentHTML;
    contentDiv.addEventListener('click', function(e) {
      activeElement = container;
      e.stopPropagation();
    });
  }
  container.appendChild(contentDiv);

  container.addEventListener('click', function(e) {
    e.stopPropagation();
    hideAllControls();
    controls.style.display = 'flex';
  });
  makeDraggable(handle, container);
  
  // Resize handle for non-text elements.
  if (!isText && (contentDiv.querySelector('.shape') || contentDiv.querySelector('table') || contentDiv.querySelector('svg') || container.dataset.imageCode)) {
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle';
    container.appendChild(resizeHandle);
    resizeHandle.addEventListener('mousedown', function(e) {
      e.stopPropagation();
      let startX = e.clientX, startY = e.clientY;
      let startWidth, startHeight;
      let resizableElem;
      if (container.dataset.imageCode) {
        resizableElem = container;
        startWidth = container.offsetWidth;
        startHeight = container.offsetHeight;
      } else {
        resizableElem = contentDiv.querySelector('.shape') ||
                        contentDiv.querySelector('table') ||
                        contentDiv.querySelector('svg');
        startWidth = parseFloat(getComputedStyle(resizableElem).width);
        startHeight = parseFloat(getComputedStyle(resizableElem).height);
      }
      function onMouseMove(e) {
        let newWidth = startWidth + (e.clientX - startX);
        let newHeight = startHeight + (e.clientY - startY);
        if (newWidth > 10) resizableElem.style.width = newWidth + 'px';
        if (newHeight > 10) resizableElem.style.height = newHeight + 'px';
      }
      function onMouseUp(e) {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      }
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }
  // Make inner SVG responsive if added via image code.
  if (container.dataset.imageCode) {
    let svgElem = contentDiv.querySelector('svg');
    if (svgElem) {
      svgElem.removeAttribute('width');
      svgElem.removeAttribute('height');
      svgElem.style.width = "100%";
      svgElem.style.height = "100%";
    }
  }
  // Additional toolbar buttons for text elements.
  if (isText) {
    let eqBtn = document.createElement('button');
    eqBtn.innerHTML = "Eq";
    eqBtn.title = "Insert Equation Element";
    eqBtn.style.marginRight = "4px";
    eqBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      showEquationModal();
    });
    controls.appendChild(eqBtn);
    
    let textCodeBtn = document.createElement('button');
    textCodeBtn.innerHTML = "Text Code";
    textCodeBtn.title = "Insert Text With Code (LaTeX)";
    textCodeBtn.style.marginRight = "4px";
    textCodeBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      let textBox = container.querySelector('.text-box');
      if (textBox) {
        activeTextBox = textBox;
      }
      showTextCodeModal();
    });
    controls.appendChild(textCodeBtn);
  }

  if (container.dataset.imageCode) {
    let svgElem = contentDiv.querySelector('svg');
    if (svgElem) {
      svgElem.removeAttribute('width');
      svgElem.removeAttribute('height');
      svgElem.style.width = "100%";
      svgElem.style.height = "100%";
    }
  }
  return container;
}

function updateLayerButtons() {
  document.querySelectorAll('.layer-button').forEach(button => {
    // Remove existing event listeners (if possible)
    const newButton = button.cloneNode(true);
    button.parentNode.replaceChild(newButton, button);
    
    if (newButton.innerHTML === '↑') {
      newButton.addEventListener('click', function(e) {
        const container = this.closest('.draggable-element');
        if (container) {
          let z = parseInt(container.style.zIndex) || 1;
          z += 1;
          container.style.zIndex = z;
          // Update the original z-index
          container.dataset.originalZ = z.toString();
        }
        e.stopPropagation();
      });
    } else if (newButton.innerHTML === '↓') {
      newButton.addEventListener('click', function(e) {
        const container = this.closest('.draggable-element');
        if (container) {
          let z = parseInt(container.style.zIndex) || 1;
          z = Math.max(1, z - 1);
          container.style.zIndex = z;
          // Update the original z-index
          container.dataset.originalZ = z.toString();
        }
        e.stopPropagation();
      });
    }
  });
}

function sanitizeHex(color) {
  return /^#[0-9A-Fa-f]{6}$/.test(color)
    ? color
    : '#ffeb3b';
}

  function updateSVGElement(container, computedVars) {
    // Get the original SVG code (with placeholders)
    let rawCode = container.dataset.imageCode;
    // Replace all placeholders with their computed values
    let substitutedCode = substituteValue(rawCode, computedVars);
    console.log("Substituted SVG code:", substitutedCode);
    
    // Use DOMParser to convert the substituted string into an SVG element
    let parser = new DOMParser();
    let doc = parser.parseFromString(substitutedCode, "image/svg+xml");
    let newSVG = doc.documentElement;
    
    // Replace the old SVG with the new one
    let contentDiv = container.querySelector('.element-content');
    contentDiv.innerHTML = "";
    contentDiv.appendChild(newSVG);
  }
  
  // Functions to show/close the equation modal and insert equation elements
  function showEquationModal() {
    document.getElementById("equationModal").style.display = "block";
  }
  function closeEquationModal() {
    document.getElementById("equationModal").style.display = "none";
  }
  
  // Show the Text With Code modal
  function showTextCodeModal() {
    let modal = document.getElementById("textCodeModal");
    modal.style.display = "block";
  }
  
  // Close the Text With Code modal
  function closeTextCodeModal() {
    let modal = document.getElementById("textCodeModal");
    modal.style.display = "none";
  }
  
  // Set up OK/Cancel events for the text code modal
  document.getElementById("textCodeOK").addEventListener("click", function() {
    let code = document.getElementById("textCodeTextarea").value;
    if (code) {
      // Perform variable substitution on the pasted code.
      let computedVars = computeAllVariables();
      let substitutedCode = substituteValue(code, computedVars);
      // Use MathJax to convert LaTeX to HTML.
      // MathJax.tex2chtmlPromise returns a promise that resolves to an HTML node.
      MathJax.tex2chtmlPromise(substitutedCode, {display: false}).then(function(node) {
        // Convert the node to HTML string
        let htmlSnippet = node.outerHTML;
        // Insert the resulting HTML into the active text box at the current caret position.
        activeTextBox.innerHTML += htmlSnippet;
        activeTextBox.focus();
        // Clear the textarea for next use.
        document.getElementById("textCodeTextarea").value = "";
      }).catch(function(err) {
        console.error("MathJax conversion error:", err);
      });
    }
    closeTextCodeModal();
  });
  
  document.getElementById("textCodeCancel").addEventListener("click", function() {
    closeTextCodeModal();
  });

// Function to create and append the necessary SVG marker definitions
// Modified createSVGMarkerDefs to create colored markers


// Function to update marker colors


  function insertEquationElement(type) {
  let snippet = "";
  switch(type) {
    case 'fraction':
      snippet = '<span class="fraction">' +
                  '<table style="display:inline-table; border-collapse:collapse;">' +
                    '<tr><td contenteditable="true" style="text-align:center; border-bottom:1px solid; padding:0 2px;">numerator</td></tr>' +
                    '<tr><td contenteditable="true" style="text-align:center; padding:0 2px;">denominator</td></tr>' +
                  '</table>' +
                '</span>';
      break;
    case 'division':
      // Division is represented the same as a fraction.
      snippet = '<span class="division">' +
              '<table style="display:inline-table; border-collapse:collapse;">' +
                '<tr>' +
                  '<td contenteditable="true" style="text-align:center; border-right:1px solid; padding:0 2px;">divisor</td>' +
                  '<td contenteditable="true" style="text-align:center; border-top:1px solid; padding:0 2px;">dividend</td>' +
                '</tr>' +
              '</table>' +
            '</span>';
  break;
    case 'sqrt':
      snippet = '<span class="sqrt">√' +
                  '<span class="radicand" contenteditable="true" ' +
                        'style="display:inline-block; border-top:1px solid; padding:0 2px;">radicand</span>' +
                '</span>';
      break;
    case 'nthroot':
      snippet = '<span class="nth-root">' +
                  '<sup contenteditable="true" style="display:inline-block; padding:0 2px;">n</sup>' +
                  '√' +
                  '<span class="radicand" contenteditable="true" ' +
                        'style="display:inline-block; border-top:1px solid; padding:0 2px;">radicand</span>' +
                '</span>';
      break;
    case 'pi':
      snippet = 'π';
      break;
    case 'superscript':
        snippet = '<sup contenteditable="true" style="display:inline-block;" onkeydown="exitOnArrowRight(event)">sup</sup>';
  break;
    case 'subscript':
        snippet = '<sub contenteditable="true" style="display:inline-block;" onkeydown="exitOnArrowRight(event)">sub</sub>';
  break;

    default:
      snippet = "";
  }
  if (activeTextBox) {
    document.execCommand('insertHTML', false, snippet);
    activeTextBox.focus();
  } else {
    alert("Please click inside a text box before inserting an equation element.");
  }
  closeEquationModal();
}



// Modal for image code input
function showImageCodeModal(defaultCode, callback) {
  const modal = document.getElementById("imageCodeModal");
  const overlay = document.getElementById("modalOverlay");
  const textarea = document.getElementById("imageCodeTextarea");
  const okButton = document.getElementById("imageCodeOK");
  const cancelButton = document.getElementById("imageCodeCancel");

  // Set default code into the textarea.
  textarea.value = defaultCode || "";
  // Show modal and overlay.
  modal.style.display = "block";
  overlay.style.display = "block";

  // Define cleanup and event handlers.
  function cleanup() {
    modal.style.display = "none";
    overlay.style.display = "none";
    okButton.removeEventListener("click", onOK);
    cancelButton.removeEventListener("click", onCancel);
  }
  function onOK() {
    const code = textarea.value;
    cleanup();
    callback(code);
  }
  function onCancel() {
    cleanup();
    callback(null);
  }
  okButton.addEventListener("click", onOK);
  cancelButton.addEventListener("click", onCancel);
}

function showColorPicker(title, initialColor, allowNone, callback) {
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  // Ensure the modal is always on top.
  overlay.style.zIndex = "10000";

  const modal = document.createElement("div");
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.border = "1px solid #ccc";
  modal.style.fontSize = "14px";
  modal.innerHTML = `<div style="margin-bottom:10px;">${title}</div>`;

  const colorInput = document.createElement("input");
  colorInput.type = "color";
  colorInput.value = initialColor;
  modal.appendChild(colorInput);

  if (allowNone) {
    const noneBtn = document.createElement("button");
    noneBtn.textContent = "None";
    noneBtn.style.marginLeft = "10px";
    modal.appendChild(noneBtn);
    noneBtn.addEventListener("click", () => {
      cleanup();
      callback("none");
    });
  }

  const okBtn = document.createElement("button");
  okBtn.textContent = "OK";
  okBtn.style.marginLeft = "10px";
  modal.appendChild(okBtn);
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.marginLeft = "10px";
  modal.appendChild(cancelBtn);

  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  okBtn.addEventListener("click", () => {
    cleanup();
    callback(colorInput.value);
  });
  cancelBtn.addEventListener("click", () => {
    cleanup();
    callback(null);
  });
  function cleanup() {
    document.body.removeChild(overlay);
  }
}



// The first issue in your code is that there's a misplaced closing brace
// And the showAdvancedLineToolbar function isn't being found
// Here's the correct implementation for these functions:
function createSVGMarkerDefs() {
  // Check if markers already exist to avoid duplicates
  if (document.getElementById('arrowMarkerEnd')) return;
  
  // Create a defs element if it doesn't exist
  let svgDefs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  svgDefs.id = "markerDefs";
  
  // Arrow marker for end points (points right)
  let arrowMarkerEnd = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  arrowMarkerEnd.setAttribute("id", "arrowMarkerEnd");
  arrowMarkerEnd.setAttribute("markerWidth", "10");
  arrowMarkerEnd.setAttribute("markerHeight", "7");
  arrowMarkerEnd.setAttribute("refX", "9");
  arrowMarkerEnd.setAttribute("refY", "3.5");
  arrowMarkerEnd.setAttribute("orient", "auto");
  arrowMarkerEnd.setAttribute("markerUnits", "strokeWidth");
  
  let arrowPathEnd = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  arrowPathEnd.setAttribute("points", "0 0, 10 3.5, 0 7");
  arrowPathEnd.setAttribute("fill", "#000000");
  arrowMarkerEnd.appendChild(arrowPathEnd);
  svgDefs.appendChild(arrowMarkerEnd);
  
  // Arrow marker for start points (points left)
  let arrowMarkerStart = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  arrowMarkerStart.setAttribute("id", "arrowMarkerStart");
  arrowMarkerStart.setAttribute("markerWidth", "10");
  arrowMarkerStart.setAttribute("markerHeight", "7");
  arrowMarkerStart.setAttribute("refX", "1");
  arrowMarkerStart.setAttribute("refY", "3.5");
  arrowMarkerStart.setAttribute("orient", "auto");
  arrowMarkerStart.setAttribute("markerUnits", "strokeWidth");
  
  let arrowPathStart = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  arrowPathStart.setAttribute("points", "10 0, 0 3.5, 10 7");
  arrowPathStart.setAttribute("fill", "#000000");
  arrowMarkerStart.appendChild(arrowPathStart);
  svgDefs.appendChild(arrowMarkerStart);
  
  // Closed circle marker (for points/endpoints)
  let circleMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  circleMarker.setAttribute("id", "closedCircleMarker");
  circleMarker.setAttribute("markerWidth", "8");
  circleMarker.setAttribute("markerHeight", "8");
  circleMarker.setAttribute("refX", "4");
  circleMarker.setAttribute("refY", "4");
  circleMarker.setAttribute("orient", "auto");
  circleMarker.setAttribute("markerUnits", "strokeWidth");
  
  let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", "4");
  circle.setAttribute("cy", "4");
  circle.setAttribute("r", "3");
  circle.setAttribute("fill", "#000000");
  circleMarker.appendChild(circle);
  svgDefs.appendChild(circleMarker);
  
  // Open circle marker (hollow circle for rays)
  let openCircleMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  openCircleMarker.setAttribute("id", "openCircleMarker");
  openCircleMarker.setAttribute("markerWidth", "8");
  openCircleMarker.setAttribute("markerHeight", "8");
  openCircleMarker.setAttribute("refX", "4");
  openCircleMarker.setAttribute("refY", "4");
  openCircleMarker.setAttribute("orient", "auto");
  openCircleMarker.setAttribute("markerUnits", "strokeWidth");
  
  let openCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  openCircle.setAttribute("cx", "4");
  openCircle.setAttribute("cy", "4");
  openCircle.setAttribute("r", "3");
  openCircle.setAttribute("fill", "white");
  openCircle.setAttribute("stroke", "#000000");
  openCircle.setAttribute("stroke-width", "1");
  openCircleMarker.appendChild(openCircle);
  svgDefs.appendChild(openCircleMarker);
  
  // Square marker (for special segment endpoints)
  let squareMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  squareMarker.setAttribute("id", "squareMarker");
  squareMarker.setAttribute("markerWidth", "8");
  squareMarker.setAttribute("markerHeight", "8");
  squareMarker.setAttribute("refX", "4");
  squareMarker.setAttribute("refY", "4");
  squareMarker.setAttribute("orient", "auto");
  squareMarker.setAttribute("markerUnits", "strokeWidth");
  
  let square = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  square.setAttribute("x", "1");
  square.setAttribute("y", "1");
  square.setAttribute("width", "6");
  square.setAttribute("height", "6");
  square.setAttribute("fill", "#000000");
  squareMarker.appendChild(square);
  svgDefs.appendChild(squareMarker);
  
  // Span marker (vertical line) for start points
  let spanMarkerStart = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  spanMarkerStart.setAttribute("id", "spanMarkerStart");
  spanMarkerStart.setAttribute("markerWidth", "4");
  spanMarkerStart.setAttribute("markerHeight", "10");
  spanMarkerStart.setAttribute("refX", "2");
  spanMarkerStart.setAttribute("refY", "5");
  spanMarkerStart.setAttribute("orient", "auto");
  spanMarkerStart.setAttribute("markerUnits", "strokeWidth");
  
  let spanLineStart = document.createElementNS("http://www.w3.org/2000/svg", "line");
  spanLineStart.setAttribute("x1", "2");
  spanLineStart.setAttribute("y1", "0");
  spanLineStart.setAttribute("x2", "2");
  spanLineStart.setAttribute("y2", "10");
  spanLineStart.setAttribute("stroke", "#000000");
  spanLineStart.setAttribute("stroke-width", "2");
  spanMarkerStart.appendChild(spanLineStart);
  svgDefs.appendChild(spanMarkerStart);
  
  // Span marker (vertical line) for end points
  let spanMarkerEnd = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  spanMarkerEnd.setAttribute("id", "spanMarkerEnd");
  spanMarkerEnd.setAttribute("markerWidth", "4");
  spanMarkerEnd.setAttribute("markerHeight", "10");
  spanMarkerEnd.setAttribute("refX", "2");
  spanMarkerEnd.setAttribute("refY", "5");
  spanMarkerEnd.setAttribute("orient", "auto");
  spanMarkerEnd.setAttribute("markerUnits", "strokeWidth");
  
  let spanLineEnd = document.createElementNS("http://www.w3.org/2000/svg", "line");
  spanLineEnd.setAttribute("x1", "2");
  spanLineEnd.setAttribute("y1", "0");
  spanLineEnd.setAttribute("x2", "2");
  spanLineEnd.setAttribute("y2", "10");
  spanLineEnd.setAttribute("stroke", "#000000");
  spanLineEnd.setAttribute("stroke-width", "2");
  spanMarkerEnd.appendChild(spanLineEnd);
  svgDefs.appendChild(spanMarkerEnd);
  
  // Add the defs to the first SVG in the document
  const firstSvg = document.querySelector('svg');
  if (firstSvg) {
    firstSvg.insertBefore(svgDefs, firstSvg.firstChild);
  } else {
    // Create a hidden SVG element to hold the defs if no SVG exists yet
    const hiddenSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    hiddenSvg.style.position = "absolute";
    hiddenSvg.style.width = "0";
    hiddenSvg.style.height = "0";
    hiddenSvg.style.overflow = "hidden";
    hiddenSvg.appendChild(svgDefs);
    document.body.appendChild(hiddenSvg);
  }
}
// Add Circle, Chords and Sectors component to the canvas
function addCircleChordsAndSectors() {
  // limit to 5 circles max
  const MAX_CIRCLES = 5;
  if (document.querySelectorAll('.circle-container').length >= MAX_CIRCLES) {
    alert(`You can only create up to ${MAX_CIRCLES} circles at once.`);
    return;
  }

  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeCircleElement) {
    window.activeCircleElement = null;
  }
  // Global counter for circle IDs
  if (!window.globalCircleCounter) {
    window.globalCircleCounter = 1;
  } else {
    window.globalCircleCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element circle-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "400px";
  container.style.height = "400px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this circle
  container.circleID = window.globalCircleCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-circle-id', container.circleID);

  // IMPORTANT: Initialize the circleData property
  container.circleData = {
    // Core settings
    centerPoint: {
      name: 'O',
      color: '#000',
      visible: true,
      labelOffsetX: 10,
      labelOffsetY: -10
    },
    userPoints: [],
    sectors: [],
    chords: [],
    intersectionRegistry: {},
    visibleIntersections: [],
    
    // Display settings
    fontSize: 20,
    pointSize: 6,
    radiusThickness: 2,
    draggableLabels: false
  };

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "circle-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);
  
  // Create content div
  const content = document.createElement("div");
  content.className = "circle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden";
  
  container.appendChild(content);

  // Create canvas for the circle
  const circleCanvas = document.createElement("canvas");
  circleCanvas.id = `circleCanvas-${container.circleID}`;
  circleCanvas.width = 400;
  circleCanvas.height = 400;
  circleCanvas.style.width = "100%";
  circleCanvas.style.height = "100%";
  content.appendChild(circleCanvas);
  
  // Get the context
  const ctx = circleCanvas.getContext('2d');

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Function to update the global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    
    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Circle " + container.circleID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Style button
    const styleBtn = document.createElement("button");
    styleBtn.textContent = "Style";
    styleBtn.className = "toolbar-button";
    styleBtn.style.marginRight = "10px";
    styleBtn.style.padding = "4px 8px";
    styleBtn.style.cursor = "pointer";
    styleBtn.addEventListener("click", function() {
      showStyleDialog();
    });
    controls.appendChild(styleBtn);
    
    // Points button
    const pointsBtn = document.createElement("button");
    pointsBtn.textContent = "Points";
    pointsBtn.className = "toolbar-button";
    pointsBtn.style.marginRight = "10px";
    pointsBtn.style.padding = "4px 8px";
    pointsBtn.style.cursor = "pointer";
    pointsBtn.addEventListener("click", function() {
      showPointsDialog();
    });
    controls.appendChild(pointsBtn);
    
    // Radius button
    const radiusBtn = document.createElement("button");
    radiusBtn.textContent = "Radius";
    radiusBtn.className = "toolbar-button";
    radiusBtn.style.marginRight = "10px";
    radiusBtn.style.padding = "4px 8px";
    radiusBtn.style.cursor = "pointer";
    radiusBtn.addEventListener("click", function() {
      showRadiusDialog();
    });
    controls.appendChild(radiusBtn);
    
    // Sectors button
    const sectorsBtn = document.createElement("button");
    sectorsBtn.textContent = "Sectors";
    sectorsBtn.className = "toolbar-button";
    sectorsBtn.style.marginRight = "10px";
    sectorsBtn.style.padding = "4px 8px";
    sectorsBtn.style.cursor = "pointer";
    sectorsBtn.addEventListener("click", function() {
      showSectorsDialog();
    });
    controls.appendChild(sectorsBtn);
    
    // Chords button
    const chordsBtn = document.createElement("button");
    chordsBtn.textContent = "Chords";
    chordsBtn.className = "toolbar-button";
    chordsBtn.style.marginRight = "10px";
    chordsBtn.style.padding = "4px 8px";
    chordsBtn.style.cursor = "pointer";
    chordsBtn.addEventListener("click", function() {
      showChordsDialog();
    });
    controls.appendChild(chordsBtn);
    
    globalToolbar.appendChild(controls);
  }

  // Style dialog
  function showStyleDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Style Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Font Size input
    const fontSizeRow = document.createElement("div");
    fontSizeRow.style.display = "flex";
    fontSizeRow.style.alignItems = "center";
    fontSizeRow.style.marginBottom = "10px";
    
    const fontSizeLabel = document.createElement("label");
    fontSizeLabel.textContent = "Font Size:";
    fontSizeLabel.style.display = "inline-block";
    fontSizeLabel.style.width = "140px";
    fontSizeLabel.style.marginRight = "10px";
    fontSizeRow.appendChild(fontSizeLabel);
    
    // Create stepper for font size
    const fontSizeStepperDiv = document.createElement("div");
    fontSizeStepperDiv.className = "stepper-control";
    fontSizeStepperDiv.style.display = "flex";
    fontSizeStepperDiv.style.alignItems = "center";
    
    const fontSizeDecreaseBtn = document.createElement("button");
    fontSizeDecreaseBtn.textContent = "-";
    fontSizeDecreaseBtn.style.width = "24px";
    fontSizeDecreaseBtn.style.height = "24px";
    fontSizeStepperDiv.appendChild(fontSizeDecreaseBtn);
    
    const fontSizeInput = document.createElement("input");
    fontSizeInput.type = "number";
    fontSizeInput.min = "8";
    fontSizeInput.max = "48";
    fontSizeInput.value = container.circleData.fontSize;
    fontSizeInput.style.width = "40px";
    fontSizeInput.style.textAlign = "center";
    fontSizeInput.style.margin = "0 5px";
    fontSizeInput.readOnly = true;
    fontSizeStepperDiv.appendChild(fontSizeInput);
    
    const fontSizeIncreaseBtn = document.createElement("button");
    fontSizeIncreaseBtn.textContent = "+";
    fontSizeIncreaseBtn.style.width = "24px";
    fontSizeIncreaseBtn.style.height = "24px";
    fontSizeStepperDiv.appendChild(fontSizeIncreaseBtn);
    
    fontSizeRow.appendChild(fontSizeStepperDiv);
    dialogBox.appendChild(fontSizeRow);
    
    // Point Size input
    const pointSizeRow = document.createElement("div");
    pointSizeRow.style.display = "flex";
    pointSizeRow.style.alignItems = "center";
    pointSizeRow.style.marginBottom = "10px";
    
    const pointSizeLabel = document.createElement("label");
    pointSizeLabel.textContent = "Point Size:";
    pointSizeLabel.style.display = "inline-block";
    pointSizeLabel.style.width = "140px";
    pointSizeLabel.style.marginRight = "10px";
    pointSizeRow.appendChild(pointSizeLabel);
    
    // Create stepper control for point size
    const pointSizeStepperDiv = document.createElement("div");
    pointSizeStepperDiv.className = "stepper-control";
    pointSizeStepperDiv.style.display = "flex";
    pointSizeStepperDiv.style.alignItems = "center";
    
    const pointSizeDecreaseBtn = document.createElement("button");
    pointSizeDecreaseBtn.textContent = "-";
    pointSizeDecreaseBtn.style.width = "24px";
    pointSizeDecreaseBtn.style.height = "24px";
    pointSizeStepperDiv.appendChild(pointSizeDecreaseBtn);
    
    const pointSizeInput = document.createElement("input");
    pointSizeInput.type = "number";
    pointSizeInput.min = "2";
    pointSizeInput.max = "20";
    pointSizeInput.value = container.circleData.pointSize;
    pointSizeInput.style.width = "40px";
    pointSizeInput.style.textAlign = "center";
    pointSizeInput.style.margin = "0 5px";
    pointSizeInput.readOnly = true;
    pointSizeStepperDiv.appendChild(pointSizeInput);
    
    const pointSizeIncreaseBtn = document.createElement("button");
    pointSizeIncreaseBtn.textContent = "+";
    pointSizeIncreaseBtn.style.width = "24px";
    pointSizeIncreaseBtn.style.height = "24px";
    pointSizeStepperDiv.appendChild(pointSizeIncreaseBtn);
    
    pointSizeRow.appendChild(pointSizeStepperDiv);
    dialogBox.appendChild(pointSizeRow);
    
    // Radius Thickness input
    const radiusThicknessRow = document.createElement("div");
    radiusThicknessRow.style.display = "flex";
    radiusThicknessRow.style.alignItems = "center";
    radiusThicknessRow.style.marginBottom = "10px";
    
    const radiusThicknessLabel = document.createElement("label");
    radiusThicknessLabel.textContent = "Radius Thickness:";
    radiusThicknessLabel.style.display = "inline-block";
    radiusThicknessLabel.style.width = "140px";
    radiusThicknessLabel.style.marginRight = "10px";
    radiusThicknessRow.appendChild(radiusThicknessLabel);
    
    // Create stepper for radius thickness
    const radiusThicknessStepperDiv = document.createElement("div");
    radiusThicknessStepperDiv.className = "stepper-control";
    radiusThicknessStepperDiv.style.display = "flex";
    radiusThicknessStepperDiv.style.alignItems = "center";
    
    const radiusThicknessDecreaseBtn = document.createElement("button");
    radiusThicknessDecreaseBtn.textContent = "-";
    radiusThicknessDecreaseBtn.style.width = "24px";
    radiusThicknessDecreaseBtn.style.height = "24px";
    radiusThicknessStepperDiv.appendChild(radiusThicknessDecreaseBtn);
    
    const radiusThicknessInput = document.createElement("input");
    radiusThicknessInput.type = "number";
    radiusThicknessInput.min = "1";
    radiusThicknessInput.max = "10";
    radiusThicknessInput.value = container.circleData.radiusThickness;
    radiusThicknessInput.style.width = "40px";
    radiusThicknessInput.style.textAlign = "center";
    radiusThicknessInput.style.margin = "0 5px";
    radiusThicknessInput.readOnly = true;
    radiusThicknessStepperDiv.appendChild(radiusThicknessInput);
    
    const radiusThicknessIncreaseBtn = document.createElement("button");
    radiusThicknessIncreaseBtn.textContent = "+";
    radiusThicknessIncreaseBtn.style.width = "24px";
    radiusThicknessIncreaseBtn.style.height = "24px";
    radiusThicknessStepperDiv.appendChild(radiusThicknessIncreaseBtn);
    
    radiusThicknessRow.appendChild(radiusThicknessStepperDiv);
    dialogBox.appendChild(radiusThicknessRow);
    
    // Draggable Labels checkbox
    const draggableLabelsRow = document.createElement("div");
    draggableLabelsRow.style.display = "flex";
    draggableLabelsRow.style.alignItems = "center";
    draggableLabelsRow.style.marginBottom = "10px";
    
    const draggableLabelsCheckbox = document.createElement("input");
    draggableLabelsCheckbox.type = "checkbox";
    draggableLabelsCheckbox.id = `draggableLabels-${container.circleID}`;
    draggableLabelsCheckbox.checked = container.circleData.draggableLabels;
    draggableLabelsCheckbox.addEventListener("change", function() {
      container.circleData.draggableLabels = this.checked;
      drawCircle();
    });
    draggableLabelsRow.appendChild(draggableLabelsCheckbox);
    
    const draggableLabelsLabel = document.createElement("label");
    draggableLabelsLabel.textContent = "Draggable Labels";
    draggableLabelsLabel.setAttribute("for", `draggableLabels-${container.circleID}`);
    draggableLabelsLabel.style.marginLeft = "5px";
    draggableLabelsRow.appendChild(draggableLabelsLabel);
    
    dialogBox.appendChild(draggableLabelsRow);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.padding = "8px 16px";
    applyButton.style.marginRight = "10px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      drawCircle();
    });
    buttonsContainer.appendChild(applyButton);
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    // Add event listeners for steppers
    fontSizeDecreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(fontSizeInput.value);
      if (currentValue > parseInt(fontSizeInput.min)) {
        fontSizeInput.value = currentValue - 1;
        container.circleData.fontSize = currentValue - 1;
        drawCircle();
      }
    });
    
    fontSizeIncreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(fontSizeInput.value);
      if (currentValue < parseInt(fontSizeInput.max)) {
        fontSizeInput.value = currentValue + 1;
        container.circleData.fontSize = currentValue + 1;
        drawCircle();
      }
    });
    
    pointSizeDecreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(pointSizeInput.value);
      if (currentValue > parseInt(pointSizeInput.min)) {
        pointSizeInput.value = currentValue - 1;
        container.circleData.pointSize = currentValue - 1;
        drawCircle();
      }
    });
    
    pointSizeIncreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(pointSizeInput.value);
      if (currentValue < parseInt(pointSizeInput.max)) {
        pointSizeInput.value = currentValue + 1;
        container.circleData.pointSize = currentValue + 1;
        drawCircle();
      }
    });
    
    radiusThicknessDecreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(radiusThicknessInput.value);
      if (currentValue > parseInt(radiusThicknessInput.min)) {
        radiusThicknessInput.value = currentValue - 1;
        container.circleData.radiusThickness = currentValue - 1;
        drawCircle();
      }
    });
    
    radiusThicknessIncreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(radiusThicknessInput.value);
      if (currentValue < parseInt(radiusThicknessInput.max)) {
        radiusThicknessInput.value = currentValue + 1;
        container.circleData.radiusThickness = currentValue + 1;
        drawCircle();
      }
    });
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Points dialog
  function showPointsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Points & Intersection Points";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Add Point button
    const addPointBtn = document.createElement("button");
    addPointBtn.textContent = "Add Point";
    addPointBtn.style.marginBottom = "15px";
    addPointBtn.addEventListener("click", function() {
      addNewPoint();
      updatePointsList(dialogBox);
      drawCircle();
    });
    dialogBox.appendChild(addPointBtn);
    
    // Points list container
    const pointsList = document.createElement("div");
    pointsList.id = `pointsList-${container.circleID}`;
    dialogBox.appendChild(pointsList);
    
    // Update button for changes
    const updatePointsBtn = document.createElement("button");
    updatePointsBtn.textContent = "Update Points";
    updatePointsBtn.style.marginTop = "15px";
    updatePointsBtn.style.marginBottom = "15px";
    updatePointsBtn.addEventListener("click", function() {
      // Redraw everything with current data
      findIntersections();
      drawCircle();
    });
    dialogBox.appendChild(updatePointsBtn);
    
    // Initialize points list
    updatePointsList(dialogBox);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Radius dialog
  function showRadiusDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Radius";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    const radiusInfo = document.createElement("div");
    radiusInfo.textContent = "Select points to show radius:";
    radiusInfo.style.marginBottom = "10px";
    dialogBox.appendChild(radiusInfo);
    
    // Radius list
    const radiusList = document.createElement("div");
    radiusList.id = `radiusList-${container.circleID}`;
    dialogBox.appendChild(radiusList);
    
    // Update radius button
    const updateRadiusBtn = document.createElement("button");
    updateRadiusBtn.textContent = "Update Radii";
    updateRadiusBtn.style.marginTop = "15px";
    updateRadiusBtn.addEventListener("click", function() {
      const checkboxes = radiusList.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => {
        const idx = +cb.dataset.idx;
        container.circleData.userPoints[idx].r = cb.checked;
      });
      findIntersections();
      drawCircle();
    });
    dialogBox.appendChild(updateRadiusBtn);
    
    // Initialize radius list
    updateRadiusList(radiusList);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Sectors dialog
  function showSectorsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Sectors";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    const sectorInfo = document.createElement("div");
    sectorInfo.textContent = "Select two points:";
    sectorInfo.style.marginBottom = "10px";
    dialogBox.appendChild(sectorInfo);
    
    // Sector points list
    const sectorList = document.createElement("div");
    sectorList.id = `sectorList-${container.circleID}`;
    sectorList.className = "checkbox-list";
    dialogBox.appendChild(sectorList);
    
    // Controls container
    const sectorControls = document.createElement("div");
    sectorControls.style.marginTop = "15px";
    
    // Angle input
    const angleLabel = document.createElement("label");
    angleLabel.textContent = "Angle (°):";
    sectorControls.appendChild(angleLabel);
    
    const angleInput = document.createElement("input");
    angleInput.type = "text"; // Text to allow variable input like #a#
    angleInput.id = `sectorAngle-${container.circleID}`;
    angleInput.value = "0";
    angleInput.style.width = "60px";
    angleInput.style.marginLeft = "5px";
    angleInput.style.marginRight = "10px";
    sectorControls.appendChild(angleInput);
    
    // Update button
    const updateBtn = document.createElement("button");
    updateBtn.textContent = "Update";
    updateBtn.style.marginRight = "10px";
    updateBtn.addEventListener("click", function() {
      updateSectorAngle(sectorList, angleInput);
    });
    sectorControls.appendChild(updateBtn);
    
    // Add button
    const addBtn = document.createElement("button");
    addBtn.textContent = "Add";
    addBtn.addEventListener("click", function() {
      addSector(sectorList, colorInput);
      updateEditSectorList(editSectorList);
    });
    sectorControls.appendChild(addBtn);
    
    dialogBox.appendChild(sectorControls);
    
    // Color input
    const colorRow = document.createElement("div");
    colorRow.style.marginTop = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Fill Color:";
    colorRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = "#6496FF";
    colorInput.style.marginLeft = "5px";
    colorRow.appendChild(colorInput);
    
    dialogBox.appendChild(colorRow);
    
    // Edit sectors section
    const editTitle = document.createElement("h3");
    editTitle.textContent = "Edit Sectors";
    editTitle.style.marginTop = "20px";
    dialogBox.appendChild(editTitle);
    
    const editSectorList = document.createElement("div");
    editSectorList.id = `editSectorList-${container.circleID}`;
    dialogBox.appendChild(editSectorList);
    
    // Initialize lists
    updateCheckboxList(sectorList, 'sector');
    updateEditSectorList(editSectorList);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Chords dialog
  function showChordsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Chords";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    const chordInfo = document.createElement("div");
    chordInfo.textContent = "Select two points:";
    chordInfo.style.marginBottom = "10px";
    dialogBox.appendChild(chordInfo);
    
    // Chord points list
    const chordList = document.createElement("div");
    chordList.id = `chordList-${container.circleID}`;
    chordList.className = "checkbox-list";
    dialogBox.appendChild(chordList);
    
    // Add chord button
    const addBtn = document.createElement("button");
    addBtn.textContent = "Add";
    addBtn.style.marginTop = "10px";
    addBtn.addEventListener("click", function() {
      addChord(chordList);
      updateEditChordList(editChordList);
    });
    dialogBox.appendChild(addBtn);
    
    // Edit chords section
    const editTitle = document.createElement("h3");
    editTitle.textContent = "Edit Chords";
    editTitle.style.marginTop = "20px";
    dialogBox.appendChild(editTitle);
    
    const editChordList = document.createElement("div");
    editChordList.id = `editChordList-${container.circleID}`;
    dialogBox.appendChild(editChordList);
    
    // Initialize lists
    updateCheckboxList(chordList, 'chord');
    updateEditChordList(editChordList);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Helper functions
  function getMousePos(e) {
    const rect = circleCanvas.getBoundingClientRect();
    return { 
      x: e.clientX - rect.left, 
      y: e.clientY - rect.top 
    };
  }

  // Function to find intersections
  function findIntersections() {
    const data = container.circleData;
    // Clear the visible intersections array
    data.visibleIntersections = [];
    
    // Set to track which stored intersections are still valid
    const validIntersectionKeys = new Set();
    
    const cx = circleCanvas.width/2, cy = circleCanvas.height/2;
    let newIntersectionCount = 0;
    
    // Helper function to find segment intersection
    function segmentIntersection(p1, p2, p3, p4) {
      const [x1, y1, x2, y2] = [p1.x, p1.y, p2.x, p2.y];
      const [x3, y3, x4, y4] = [p3.x, p3.y, p4.x, p4.y];
      const denom = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
      if (Math.abs(denom) < 1e-6) return null;
      const xi = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/denom;
      const yi = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/denom;
      const onSeg = xi>=Math.min(x1,x2)-1e-6 && xi<=Math.max(x1,x2)+1e-6 && 
                    yi>=Math.min(y1,y2)-1e-6 && yi<=Math.max(y1,y2)+1e-6 && 
                    xi>=Math.min(x3,x4)-1e-6 && xi<=Math.max(x3,x4)+1e-6 && 
                    yi>=Math.min(y3,y4)-1e-6 && yi<=Math.max(y3,y4)+1e-6;
      return onSeg ? { x: xi, y: yi } : null;
    }
    
    // Process chord-chord intersections
    for (let i=0; i<data.chords.length; i++) {
      for (let j=i+1; j<data.chords.length; j++) {
        const ip = segmentIntersection(
          data.userPoints[data.chords[i].a], 
          data.userPoints[data.chords[i].b],
          data.userPoints[data.chords[j].a], 
          data.userPoints[data.chords[j].b]
        );
        
        if (ip) {
          // Create a unique key for this intersection
          const key = `chord${data.chords[i].a}-${data.chords[i].b}_chord${data.chords[j].a}-${data.chords[j].b}`;
          const reverseKey = `chord${data.chords[j].a}-${data.chords[j].b}_chord${data.chords[i].a}-${data.chords[i].b}`;
          
          let intersectionKey = null;
          
          // Check if we already have this intersection
          if (data.intersectionRegistry[key]) {
            intersectionKey = key;
          } else if (data.intersectionRegistry[reverseKey]) {
            intersectionKey = reverseKey;
          } else {
            // New intersection
            intersectionKey = key;
            data.intersectionRegistry[key] = {
              name: `I${++newIntersectionCount}`,
              color: '#000',
              visible: true,
              labelOffsetX: 10,
              labelOffsetY: -10
            };
          }
          
          // Mark this intersection as still valid
          validIntersectionKeys.add(intersectionKey);
          
          // Add to visible intersections if it's set to be visible
          if (data.intersectionRegistry[intersectionKey].visible) {
            data.visibleIntersections.push({
              x: ip.x,
              y: ip.y,
              key: intersectionKey,
              ...data.intersectionRegistry[intersectionKey]
            });
          }
        }
      }
    }
    
    // Process chord-radius intersections
    for (let i=0; i<data.chords.length; i++) {
      for (let j=0; j<data.userPoints.length; j++) {
        if (data.userPoints[j].r && data.userPoints[j].visible) {
          // Create a radius segment from center to point
          const radiusEnd = data.userPoints[j];
          const ip = segmentIntersection(
            data.userPoints[data.chords[i].a], 
            data.userPoints[data.chords[i].b],
            {x: cx, y: cy}, 
            radiusEnd
          );
          
          if (ip && 
              Math.hypot(ip.x-cx, ip.y-cy) > 1e-3 && // Not at center
              Math.hypot(ip.x-radiusEnd.x, ip.y-radiusEnd.y) > 1e-3 && // Not at end point
              Math.hypot(ip.x-data.userPoints[data.chords[i].a].x, ip.y-data.userPoints[data.chords[i].a].y) > 1e-3 && // Not at chord endpoints
              Math.hypot(ip.x-data.userPoints[data.chords[i].b].x, ip.y-data.userPoints[data.chords[i].b].y) > 1e-3)
          {
            // Create a unique key for this intersection
            const key = `chord${data.chords[i].a}-${data.chords[i].b}_radius${j}`;
            
            let intersectionKey = null;
            
            // Check if we already have this intersection
            if (data.intersectionRegistry[key]) {
              intersectionKey = key;
            } else {
              // New intersection
              intersectionKey = key;
              data.intersectionRegistry[key] = {
                name: `I${++newIntersectionCount}`,
                color: '#000',
                visible: true,
                labelOffsetX: 10,
                labelOffsetY: -10
              };
            }
            
            // Mark this intersection as still valid
            validIntersectionKeys.add(intersectionKey);
            
            // Add to visible intersections if it's set to be visible
            if (data.intersectionRegistry[intersectionKey].visible) {
              data.visibleIntersections.push({
                x: ip.x,
                y: ip.y,
                key: intersectionKey,
                ...data.intersectionRegistry[intersectionKey]
              });
            }
          }
        }
      }
    }
    
    // Remove any stored intersections that are no longer valid
    Object.keys(data.intersectionRegistry).forEach(key => {
      if (!validIntersectionKeys.has(key)) {
        delete data.intersectionRegistry[key];
      }
    });
  }

  // Function to update points list - FIXED to add immediate update
  function updatePointsList(dialogBox) {
    const data = container.circleData;
    findIntersections();
    
    const list = dialogBox.querySelector(`#pointsList-${container.circleID}`);
    if (!list) return;
    
    list.innerHTML = '';
    
    // Add center point to the list
    const centerRow = document.createElement('div');
    centerRow.className = 'row';
    
    const centerLabel = document.createElement('span');
    centerLabel.textContent = 'Center:';
    
    const centerNameInput = document.createElement('input');
    centerNameInput.type = 'text';
    centerNameInput.value = data.centerPoint.name;
    centerNameInput.oninput = e => {
      data.centerPoint.name = e.target.value;
      // Immediate update
      requestAnimationFrame(() => drawCircle());
    };
    
    const centerColorInput = document.createElement('input');
    centerColorInput.type = 'color';
    centerColorInput.value = data.centerPoint.color;
    centerColorInput.oninput = e => {
      data.centerPoint.color = e.target.value;
      // Immediate update
      requestAnimationFrame(() => drawCircle());
    };
    
    const centerVisInput = document.createElement('input');
    centerVisInput.type = 'checkbox';
    centerVisInput.checked = data.centerPoint.visible;
    centerVisInput.onchange = e => {
      data.centerPoint.visible = e.target.checked;
      // Immediate update
      requestAnimationFrame(() => drawCircle());
    };
    
    const centerVisLabel = document.createElement('label');
    centerVisLabel.textContent = 'Display';
    
    centerRow.append(centerLabel, centerNameInput, centerColorInput, centerVisInput, centerVisLabel);
    list.append(centerRow);
    
    // Display user points
    data.userPoints.forEach((p, i) => {
      const row = document.createElement('div'); 
      row.className = 'row';
      
      const lbl = document.createElement('span'); 
      lbl.textContent = p.name;
      
      const nm = document.createElement('input'); 
      nm.type = 'text'; 
      nm.value = p.name; 
      nm.oninput = e => {
        p.name = e.target.value;
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      
      const clr = document.createElement('input'); 
      clr.type = 'color'; 
      clr.value = p.color; 
      clr.oninput = e => {
        p.color = e.target.value;
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      
      const vis = document.createElement('input'); 
      vis.type = 'checkbox'; 
      vis.checked = p.visible; 
      vis.onchange = e => {
        // Just toggle visibility, don't delete the point
        p.visible = e.target.checked;
        // Immediate update
        findIntersections();
        requestAnimationFrame(() => drawCircle());
      };
      
      const vLBL = document.createElement('label'); 
      vLBL.textContent = 'Display';
      
      // Add delete button for points
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.style.marginLeft = '5px';
      deleteBtn.onclick = () => {
        deletePoint(i);
        updatePointsList(dialogBox);
      };
      
      row.append(lbl, nm, clr, vis, vLBL, deleteBtn); 
      list.append(row);
    });
    
    // Display intersection points
    data.visibleIntersections.forEach((p, i) => {
      const row = document.createElement('div'); 
      row.className = 'row';
      
      const lbl = document.createElement('span'); 
      lbl.textContent = p.name;
      
      const nm = document.createElement('input'); 
      nm.type = 'text'; 
      nm.value = p.name; 
      nm.dataset.key = p.key;
      nm.oninput = e => {
        // Update the name in the registry
        data.intersectionRegistry[p.key].name = e.target.value;
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      
      const clr = document.createElement('input'); 
      clr.type = 'color'; 
      clr.value = p.color; 
      clr.dataset.key = p.key;
      clr.oninput = e => {
        // Update the color in the registry
        data.intersectionRegistry[p.key].color = e.target.value;
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      
      const vis = document.createElement('input'); 
      vis.type = 'checkbox'; 
      vis.checked = p.visible; 
      vis.dataset.key = p.key;
      vis.onchange = e => {
        // Update visibility in the registry
        data.intersectionRegistry[p.key].visible = e.target.checked;
        findIntersections(); // Recalculate intersections
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      
      const vLBL = document.createElement('label'); 
      vLBL.textContent = 'Display';
      
      row.append(lbl, nm, clr, vis, vLBL); 
      list.append(row);
    });
  }

  // Function to update radius list
  function updateRadiusList(listElement) {
    const data = container.circleData;
    if (!listElement) return;
    
    listElement.innerHTML = '';
    data.userPoints.forEach((p, i) => {
      const row = document.createElement('div');
      row.className = 'row';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.dataset.idx = i;
      cb.checked = p.r;
      const lbl = document.createElement('span');
      lbl.textContent = p.name;
      row.append(cb, lbl);
      listElement.append(row);
    });
  }

  // Function to update checkbox lists (for sectors and chords)
  function updateCheckboxList(listElement, type) {
    const data = container.circleData;
    if (!listElement) return;
    
    listElement.innerHTML = '';
    data.userPoints.forEach((p, i) => {
      const row = document.createElement('div');
      row.className = 'row';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.dataset.idx = i;
      const lbl = document.createElement('span');
      lbl.textContent = p.name;
      row.append(cb, lbl);
      listElement.append(row);
    });
  }

  // Function to update edit sector list
  function updateEditSectorList(listElement) {
    const data = container.circleData;
    if (!listElement) return;
    
    listElement.innerHTML = '';
    data.sectors.forEach((s, i) => {
      const row = document.createElement('div');
      row.className = 'row';
      const lbl = document.createElement('span');
      // Just show the two point names
      lbl.textContent = `${data.userPoints[s.a].name}${data.userPoints[s.b].name}`;
      const clr = document.createElement('input');
      clr.type = 'color';
      clr.value = s.color;
      clr.oninput = e => {
        s.color = e.target.value;
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      const btn = document.createElement('button');
      btn.textContent = 'Delete';
      btn.onclick = () => {
        data.sectors.splice(i, 1);
        updateEditSectorList(listElement);
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      row.append(lbl, clr, btn);
      listElement.append(row);
    });
  }

  // Function to update edit chord list
  function updateEditChordList(listElement) {
    const data = container.circleData;
    if (!listElement) return;
    
    listElement.innerHTML = '';
    data.chords.forEach((c, i) => {
      const row = document.createElement('div');
      row.className = 'row';
      const lbl = document.createElement('span');
      // Just show the two point names
      lbl.textContent = `${data.userPoints[c.a].name}${data.userPoints[c.b].name}`;
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = c.shade;
      cb.onchange = e => {
        c.shade = e.target.checked;
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      const slbl = document.createElement('label');
      slbl.textContent = 'Shade';
      const clr = document.createElement('input');
      clr.type = 'color';
      clr.value = c.color;
      clr.oninput = e => {
        c.color = e.target.value;
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      const btn = document.createElement('button');
      btn.textContent = 'Delete';
      btn.onclick = () => {
        data.chords.splice(i, 1);
        updateEditChordList(listElement);
        findIntersections();
        // Immediate update
        requestAnimationFrame(() => drawCircle());
      };
      row.append(lbl, cb, slbl, clr, btn);
      listElement.append(row);
    });
  }

  // Function to add a new point
  function addNewPoint() {
    const data = container.circleData;
    const cx = circleCanvas.width/2;
    const cy = circleCanvas.height/2;
    const rad = Math.min(circleCanvas.width, circleCanvas.height) * 0.35;
    const ang = Math.random() * 2 * Math.PI;
    
    data.userPoints.push({
      x: cx + rad * Math.cos(ang),
      y: cy + rad * Math.sin(ang),
      name: String.fromCharCode(65 + data.userPoints.length),
      r: false,
      color: '#000',
      visible: true,
      labelOffsetX: 10,
      labelOffsetY: -10
    });
  }

  // Function to delete a point
  function deletePoint(pointIndex) {
    const data = container.circleData;
    
    // Remove the point
    data.userPoints.splice(pointIndex, 1);
    
    // Update sectors - remove any sectors that use this point
    for (let i = data.sectors.length - 1; i >= 0; i--) {
      if (data.sectors[i].a === pointIndex || data.sectors[i].b === pointIndex) {
        // This sector uses the deleted point - remove it
        data.sectors.splice(i, 1);
      } else {
        // Adjust indices for points that come after the deleted point
        if (data.sectors[i].a > pointIndex) data.sectors[i].a--;
        if (data.sectors[i].b > pointIndex) data.sectors[i].b--;
      }
    }
    
    // Update chords - remove any chords that use this point
    for (let i = data.chords.length - 1; i >= 0; i--) {
      if (data.chords[i].a === pointIndex || data.chords[i].b === pointIndex) {
        // This chord uses the deleted point - remove it
        data.chords.splice(i, 1);
      } else {
        // Adjust indices for points that come after the deleted point
        if (data.chords[i].a > pointIndex) data.chords[i].a--;
        if (data.chords[i].b > pointIndex) data.chords[i].b--;
      }
    }
    
    findIntersections();
    drawCircle();
  }

  // Function to update sector angle - now works with text inputs for variable support
  function updateSectorAngle(sectorList, angleInput) {
    const data = container.circleData;
    const sel = [...sectorList.querySelectorAll('input:checked')].map(cb => +cb.dataset.idx);
    if (sel.length === 2) {
      const cx = circleCanvas.width/2, cy = circleCanvas.height/2;
      const rad = Math.min(circleCanvas.width, circleCanvas.height) * 0.35;
      const a1 = Math.atan2(data.userPoints[sel[0]].y - cy, data.userPoints[sel[0]].x - cx);
      
      // Store the angle value (which might be a variable like #a#)
      const angleValue = angleInput.value;
      
      // For positioning the point, if it's a number use it directly
      const numValue = parseFloat(angleValue);
      const ang = isNaN(numValue) ? 0 : numValue * Math.PI / 180;
      
      data.userPoints[sel[1]].x = cx + rad * Math.cos(ang + a1);
      data.userPoints[sel[1]].y = cy + rad * Math.sin(ang + a1);
      
      // Ensure radii are drawn for the two points
      data.userPoints[sel[0]].r = true;
      data.userPoints[sel[1]].r = true;
      
      findIntersections();
      drawCircle();
    } else {
      alert('Select 2 points');
    }
  }

  // Function to add a sector
  function addSector(sectorList, colorInput) {
    const data = container.circleData;
    const sel = [...sectorList.querySelectorAll('input:checked')].map(cb => +cb.dataset.idx);
    if (sel.length === 2) {
      // Add the sector
      data.sectors.push({
        a: sel[0],
        b: sel[1],
        color: colorInput.value,
        // Store any angle value input as well
        angle: document.getElementById(`sectorAngle-${container.circleID}`).value
      });
      
      // Ensure radii are drawn for the two points
      data.userPoints[sel[0]].r = true;
      data.userPoints[sel[1]].r = true;
      
      findIntersections();
      drawCircle();
    } else {
      alert('Select 2 points');
    }
  }

  // Function to add a chord
  function addChord(chordList) {
    const data = container.circleData;
    const sel = [...chordList.querySelectorAll('input:checked')].map(cb => +cb.dataset.idx);
    if (sel.length === 2) {
      data.chords.push({
        a: sel[0],
        b: sel[1],
        shade: false,
        color: '#F00'
      });
      
      findIntersections();
      drawCircle();
    } else {
      alert('Select 2 points');
    }
  }

  // Main draw function
  function drawCircle() {
    const data = container.circleData;
    
    // Ensure we have the current canvas dimensions
    const w = circleCanvas.width;
    const h = circleCanvas.height;
    const cx = w/2;
    const cy = h/2;
    const rad = Math.min(w, h) * 0.35;
    
    // Get style settings
    const fs = data.fontSize;
    const ps = data.pointSize;
    const th = data.radiusThickness;
    
    // Clear canvas
    ctx.clearRect(0, 0, w, h);
    
    // Set font size for all text
    ctx.font = `${fs}px Arial`;
    
    // Draw sectors
    data.sectors.forEach(s => {
      const p1 = data.userPoints[s.a];
      const p2 = data.userPoints[s.b];
      let a1 = Math.atan2(p1.y-cy, p1.x-cx);
      let a2 = Math.atan2(p2.y-cy, p2.x-cx);
      if (a2 < a1) a2 += 2*Math.PI;
      
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, rad, a1, a2);
      ctx.closePath();
      ctx.fill();
    });
    
    // Draw chord shades
    data.chords.forEach(c => {
      if (c.shade) {
        const p1 = data.userPoints[c.a];
        const p2 = data.userPoints[c.b];
        let a1 = (Math.atan2(p1.y-cy, p1.x-cx) + 2*Math.PI) % (2*Math.PI);
        let a2 = (Math.atan2(p2.y-cy, p2.x-cx) + 2*Math.PI) % (2*Math.PI);
        let diff = (a2-a1+2*Math.PI) % (2*Math.PI);
        let ac = diff <= Math.PI;
        
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.arc(cx, cy, rad, a2, a1, ac);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    });
    
    // Draw chord outlines
    data.chords.forEach(c => {
      const p1 = data.userPoints[c.a];
      const p2 = data.userPoints[c.b];
      ctx.strokeStyle = '#000';
      ctx.lineWidth = th;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    });
    
    // Draw circle
    ctx.strokeStyle = '#000';
    ctx.lineWidth = th;
    ctx.beginPath();
    ctx.arc(cx, cy, rad, 0, 2*Math.PI);
    ctx.stroke();
    
    // Draw radii
    data.userPoints.forEach(p => {
      if (p.r && p.visible) {
        ctx.strokeStyle = '#000';
        ctx.lineWidth = th;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
    });
    
    // Draw center
    if (data.centerPoint.visible) {
      ctx.fillStyle = data.centerPoint.color;
      ctx.beginPath();
      ctx.arc(cx, cy, ps, 0, 2*Math.PI);
      ctx.fill();
      
      // Draw center label
      ctx.fillText(data.centerPoint.name, 
                   cx + data.centerPoint.labelOffsetX, 
                   cy + data.centerPoint.labelOffsetY);
    }
    
    // Draw user points and their labels
    data.userPoints.forEach(p => {
      if (p.visible) {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, ps, 0, 2*Math.PI);  // Increased point size for easier clicking
        ctx.fill();
        
        // Initialize labelOffset if not present
        if (p.labelOffsetX === undefined) p.labelOffsetX = ps;
        if (p.labelOffsetY === undefined) p.labelOffsetY = -ps;
        
        // Draw label
        ctx.fillText(p.name, p.x + p.labelOffsetX, p.y + p.labelOffsetY);
      }
    });
    
    // Draw intersection points and their labels
    data.visibleIntersections.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, ps, 0, 2*Math.PI);
      ctx.fill();
      
      // Draw label
      ctx.fillText(p.name, p.x + p.labelOffsetX, p.y + p.labelOffsetY);
    });
  }

  // Drag and drop state variables
  let draggingIndex = null;
  let draggingLabelIndex = null;
  let draggingIntersectionKey = null;

  // Handle mouse down for dragging points or labels - IMPROVED hit detection
  circleCanvas.addEventListener('mousedown', e => {
    if (!container.contains(e.target)) return;
    
    const pos = getMousePos(e);
    const data = container.circleData;
    const ps = data.pointSize;
    const cx = circleCanvas.width/2, cy = circleCanvas.height/2;
    
    // Only allow dragging labels if the draggable option is enabled
    if (data.draggableLabels) {
      // Check if we're dragging the center label
      if (data.centerPoint.visible) {
        const labelX = cx + data.centerPoint.labelOffsetX;
        const labelY = cy + data.centerPoint.labelOffsetY;
        const labelWidth = ctx.measureText(data.centerPoint.name).width;
        const labelHeight = data.fontSize;
        
        if (pos.x >= labelX && pos.x <= labelX + labelWidth && 
            pos.y >= labelY - labelHeight && pos.y <= labelY) {
          draggingLabelIndex = 'center';
          e.stopPropagation();
          return;
        }
      }
      
      // Check for user point labels
      for (let i = 0; i < data.userPoints.length; i++) {
        const p = data.userPoints[i];
        if (p.visible) {
          const labelX = p.x + p.labelOffsetX;
          const labelY = p.y + p.labelOffsetY;
          const labelWidth = ctx.measureText(p.name).width;
          const labelHeight = data.fontSize;
          
          if (pos.x >= labelX && pos.x <= labelX + labelWidth && 
              pos.y >= labelY - labelHeight && pos.y <= labelY) {
            draggingLabelIndex = i;
            e.stopPropagation();
            return;
          }
        }
      }
      
      // Check for intersection point labels
      if (data.visibleIntersections) {
        for (let i = 0; i < data.visibleIntersections.length; i++) {
          const p = data.visibleIntersections[i];
          const labelX = p.x + p.labelOffsetX;
          const labelY = p.y + p.labelOffsetY;
          const labelWidth = ctx.measureText(p.name).width;
          const labelHeight = data.fontSize;
          
          if (pos.x >= labelX && pos.x <= labelX + labelWidth && 
              pos.y >= labelY - labelHeight && pos.y <= labelY) {
            draggingIntersectionKey = p.key;
            e.stopPropagation();
            return;
          }
        }
      }
    }
    
    // Check if clicking on a point - using bigger hitbox for easier selection
    for (let i = 0; i < data.userPoints.length; i++) {
      const p = data.userPoints[i];
      // Increased hit radius from ps+4 to ps*2
      if (p.visible && Math.hypot(pos.x - p.x, pos.y - p.y) <= ps * 2.5) {
        draggingIndex = i;
        e.stopPropagation();
        return;
      }
    }
  });

  // Handle mouse move for dragging points or labels
  circleCanvas.addEventListener('mousemove', e => {
    if (!container.contains(e.target)) return;
    if (draggingIndex === null && draggingLabelIndex === null && draggingIntersectionKey === null) return;
    
    const pos = getMousePos(e);
    const data = container.circleData;
    const cx = circleCanvas.width/2, cy = circleCanvas.height/2;
    const rad = Math.min(circleCanvas.width, circleCanvas.height) * 0.35;
    
    // Handle dragging points - constrain to circle circumference
    if (draggingIndex !== null) {
      const ang = Math.atan2(pos.y - cy, pos.x - cx);
      
      data.userPoints[draggingIndex].x = cx + rad * Math.cos(ang);
      data.userPoints[draggingIndex].y = cy + rad * Math.sin(ang);
      
      findIntersections();
      drawCircle();
      e.stopPropagation();
    }
    // Handle dragging center point label
    else if (draggingLabelIndex === 'center') {
      const maxDistance = 80; // Maximum distance the label can be from the point
      
      // Calculate relative position from center to cursor
      let dx = pos.x - cx;
      let dy = pos.y - cy;
      
      // Limit the distance
      const distance = Math.hypot(dx, dy);
      if (distance > maxDistance) {
        const scale = maxDistance / distance;
        dx *= scale;
        dy *= scale;
      }
      
      // Update the center label offset
      data.centerPoint.labelOffsetX = dx;
      data.centerPoint.labelOffsetY = dy;
      
      drawCircle();
      e.stopPropagation();
    }
    // Handle dragging user point labels
    else if (draggingLabelIndex !== null && typeof draggingLabelIndex === 'number') {
      const p = data.userPoints[draggingLabelIndex];
      const maxDistance = 80; // Maximum distance the label can be from the point
      
      // Calculate relative position from point to cursor
      let dx = pos.x - p.x;
      let dy = pos.y - p.y;
      
      // Limit the distance
      const distance = Math.hypot(dx, dy);
      if (distance > maxDistance) {
        const scale = maxDistance / distance;
        dx *= scale;
        dy *= scale;
      }
      
      // Update the label offset
      p.labelOffsetX = dx;
      p.labelOffsetY = dy;
      
      drawCircle();
      e.stopPropagation();
    }
    // Handle dragging intersection point labels
    else if (draggingIntersectionKey !== null) {
      // Find the intersection point
      const intersectionPoint = data.visibleIntersections.find(p => p.key === draggingIntersectionKey);
      if (intersectionPoint) {
        const maxDistance = 80; // Maximum distance the label can be from the point
        
        // Calculate relative position from point to cursor
        let dx = pos.x - intersectionPoint.x;
        let dy = pos.y - intersectionPoint.y;
        
        // Limit the distance
        const distance = Math.hypot(dx, dy);
        if (distance > maxDistance) {
          const scale = maxDistance / distance;
          dx *= scale;
          dy *= scale;
        }
        
        // Update the label offset in the registry
        data.intersectionRegistry[draggingIntersectionKey].labelOffsetX = dx;
        data.intersectionRegistry[draggingIntersectionKey].labelOffsetY = dy;
        
        drawCircle();
        e.stopPropagation();
      }
    }
  });

  // Handle mouseup to stop dragging
  window.addEventListener('mouseup', () => {
    draggingIndex = null;
    draggingLabelIndex = null;
    draggingIntersectionKey = null;
  });

  // Functions for element activation and deactivation
  function activateCircle() {
    // Deactivate the previously active element if any
    if (window.activeCircleElement && window.activeCircleElement !== container) {
      window.activeCircleElement.style.border = "none";
      
      const prevToolbar = window.activeCircleElement.querySelector(".circle-toolbar");
      const prevResizeHandle = window.activeCircleElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeCircleElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivateCircle() {
    if (window.activeCircleElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeCircleElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  function deleteCircle() {
    if (window.activeCircleElement === container) {
      window.activeCircleElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Event listeners for container
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateCircle();
    }
  });

  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteCircle();
  });

  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteCircle();
  });

  // Resize handle functionality
 // ==== Replace your existing resize Handle listener with this block ====
resizeHandle.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();

  // Record starting mouse position and container size:
  const startX = e.clientX;
  const startY = e.clientY;
  const startWidth = container.offsetWidth;
  const startHeight = container.offsetHeight;
  const initialRatio = startWidth / startHeight;

  // Compute the old center and radius (before resizing begins):
  const oldCx = startWidth / 2;
  const oldCy = startHeight / 2;
  const oldRadius = Math.min(startWidth, startHeight) * 0.35;

  // Immediately capture each userPoint’s original angle (θ) relative to that old center:
  const data = container.circleData;
  const initialAngles = data.userPoints.map(p => {
    return Math.atan2(p.y - oldCy, p.x - oldCx);
  });

  function onMouseMove(event) {
    // How far has the mouse moved horizontally?
    const deltaX = event.clientX - startX;

    // New width clamped to at least 100px:
    const newWidth = Math.max(100, startWidth + deltaX);
    // Maintain aspect ratio:
    const newHeight = Math.max(100, newWidth / initialRatio);

    // Compute new center and new radius:
    const newCx = newWidth / 2;
    const newCy = newHeight / 2;
    const newRadius = Math.min(newWidth, newHeight) * 0.35;

    // Re‐project every userPoint onto the new circumference using its original θ:
    data.userPoints.forEach((p, i) => {
      const θ = initialAngles[i];
      p.x = newCx + newRadius * Math.cos(θ);
      p.y = newCy + newRadius * Math.sin(θ);
    });

    // Resize container DIV and the inner canvas:
    container.style.width = newWidth + "px";
    container.style.height = newHeight + "px";
    circleCanvas.width = newWidth;
    circleCanvas.height = newHeight;

    // Redraw everything
    drawCircle();
  }

  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }

  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});
// ==== End replacement block ====


  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    // Don't deactivate if clicked on the circle container
    if (container.contains(e.target)) {
      return;
    }
    
    // Don't deactivate if clicked on the global toolbar
    const globalToolbar = document.getElementById("global-toolbar");
    if (globalToolbar && globalToolbar.contains(e.target)) {
      return;
    }
    
    // Only deactivate if actually active
    if (window.activeCircleElement === container) {
      deactivateCircle();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);

  // Store the draw function on the container so it can be called externally
  container.drawCircle = drawCircle;

  // Initialize with a couple of points
  addNewPoint();
  addNewPoint();

  // Initialize
  drawCircle();

  // Activate the circle
  activateCircle();

  return container;
}


// Add Angle component to the canvas
function addAngle() {


  // Helper function to adjust ray endpoints to stay within canvas bounds
function adjustEndpoint(center, point, width, height, margin) {
  // Calculate direction vector
  const dx = point.x - center.x;
  const dy = point.y - center.y;
  
  // Calculate position where ray would intersect with container boundary
  const boundX = dx > 0 ? width - margin : margin;
  const boundY = dy > 0 ? height - margin : margin;
  
  // Calculate how far along each axis we need to scale to hit the boundary
  const scaleX = Math.abs((boundX - center.x) / dx);
  const scaleY = Math.abs((boundY - center.y) / dy);
  
  // Use the smaller scale to ensure we don't exceed either boundary
  const scale = Math.min(scaleX, scaleY, 1);
  
  // Return adjusted endpoint
  return {
    x: center.x + dx * scale,
    y: center.y + dy * scale
  };
}
    // limit to 5 angles max
const MAX_ANGLES = 8;
if (document.querySelectorAll('.angle-container').length >= MAX_ANGLES) {
  alert(`You can only create up to ${MAX_ANGLES} angles at once.`);
  return;
}


  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeAngleElement) {
    window.activeAngleElement = null;
  }
  // Global counter for angle IDs
  if (!window.globalAngleCounter) {
    window.globalAngleCounter = 1;
  } else {
    window.globalAngleCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element angle-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
 const M = 10;  // margin in px to accommodate arrowheads
container.style.width  = `${300 + M*2}px`;
container.style.height = `${300 + M*2}px`;

  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this angle
  container.angleID = window.globalAngleCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-angle-id', container.angleID);

  // IMPORTANT: Initialize the angleData property BEFORE calling any functions that use it
  container.angleData = {
    // Core settings
    angleDegrees: 90,          // Use variable for angle value
    subdivisions: 1,              // Number of subdivisions
    
    // Display settings
    pointSize: 8,
    fontSize: 20,
    labelFontSize: 20,
    showPoints: true,
    showLabels: false,
    draggableLabels: false,
    
    // Labels
    labels: ['A', 'B', 'C'],
    subLabels: [],                // Will be populated when subdivisions change
    subAngleValues: [],           // Values for each subangle
    subAngles: [],                // Absolute positions for subangles
    
    // Span settings
    spanMode: "all",              // "all", "whole", "custom", or "none"
    customSpans: [],              // Array to store custom spans
    showAngleNotation: true,      // Show angle notation like ∠ABC
    showAngleMeasure: true,       // Show angle measure in degrees
    
    // Points and offsets
    points: [
      { x: 300, y: 300 },
      { x: 400, y: 200 },
      { x: 500, y: 300 }
    ],
    labelOffsets: {},             // Store relative offsets for labels
    spanLabelOffsets: {},         // Store relative offsets for span labels
    mainAngleLabelOffset: { x: 0, y: 0 }  // Offset for main angle label
  };



  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "angle-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);
  
  // Create content div
  const content = document.createElement("div");
  content.className = "angle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden";
  
  container.appendChild(content);

  // Create canvas for the angle
  const angleCanvas = document.createElement("canvas");
  angleCanvas.id = `angleCanvas-${container.angleID}`;
  angleCanvas.style.width = "100%";
  angleCanvas.style.height = "100%";
  content.appendChild(angleCanvas);
  
  // Get the context
  const ctx = angleCanvas.getContext('2d');

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Constants used for drawing
  const handleFactor = 0.78;
  const headLen = 15;
  const arcR = 40;
  const baseSpanRadius = arcR + 5;
  const spanRadiusIncrement = 8;
  const labelDragRadius = 60;

  // Function to update the global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    
    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Angle " + container.angleID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Angle value input
    const angleControlGroup = document.createElement("div");
    angleControlGroup.className = "control-group";
    angleControlGroup.style.display = "flex";
    angleControlGroup.style.alignItems = "center";
    angleControlGroup.style.marginRight = "10px";
    
    const angleLabel = document.createElement("label");
    angleLabel.textContent = "Angle (ABC):";
    angleLabel.style.marginRight = "5px";
    angleControlGroup.appendChild(angleLabel);
    
    const angleValueInput = document.createElement("input");
    angleValueInput.type = "text";
    angleValueInput.id = `angleValue-${container.angleID}`;
    angleValueInput.value = container.angleData.angleDegrees;
    angleValueInput.style.width = "60px";
    angleValueInput.style.marginRight = "5px";
    angleControlGroup.appendChild(angleValueInput);
    
    const setAngleBtn = document.createElement("button");
    setAngleBtn.textContent = "Set";
    setAngleBtn.style.padding = "3px 6px";
    setAngleBtn.style.cursor = "pointer";
    setAngleBtn.addEventListener("click", function() {
      // Update angle value
      container.angleData.angleDegrees = angleValueInput.value;
      
      // If it's a numeric value, update the visual immediately
      const numericValue = parseFloat(angleValueInput.value);
      if (!isNaN(numericValue)) {
        // Update the angle
        const data = container.angleData;
        const deg = Math.min(360, Math.max(0, numericValue));
        const rad = deg * Math.PI / 180;
        const len = Math.hypot(data.points[2].x - data.points[1].x, data.points[2].y - data.points[1].y);
        const v1 = Math.atan2(data.points[0].y - data.points[1].y, data.points[0].x - data.points[1].x);
        const newAng = v1 + rad;
        data.points[2].x = data.points[1].x + len * Math.cos(newAng);
        data.points[2].y = data.points[1].y + len * Math.sin(newAng);
        
        // Reset subangle values when total angle changes
        data.subAngleValues = [];
        
        // Update spans instead of clearing them
        if (data.customSpans.length > 0) {
          data.customSpans.forEach(span => {
            if (span.type === 'whole') {
              span.measure = numericValue;
            }
          });
        }
        
        // Recompute and draw
        computeSubAngles();
        drawAngle();
      }
    });
    angleControlGroup.appendChild(setAngleBtn);
    
    controls.appendChild(angleControlGroup);
    
    // Subdivisions input
    const subdivisionGroup = document.createElement("div");
    subdivisionGroup.className = "control-group";
    subdivisionGroup.style.display = "flex";
    subdivisionGroup.style.alignItems = "center";
    subdivisionGroup.style.marginRight = "10px";
    
    const subdivisionLabel = document.createElement("label");
    subdivisionLabel.textContent = "Subangles:";
    subdivisionLabel.style.marginRight = "5px";
    subdivisionGroup.appendChild(subdivisionLabel);
    
    const subdivisionsInput = document.createElement("input");
    subdivisionsInput.type = "number";
    subdivisionsInput.id = `subdivisions-${container.angleID}`;
    subdivisionsInput.min = "1";
    subdivisionsInput.max = "10";
    subdivisionsInput.value = container.angleData.subdivisions;
    subdivisionsInput.style.width = "50px";
    subdivisionsInput.style.marginRight = "5px";
    subdivisionGroup.appendChild(subdivisionsInput);
    
    const applySubdivisionsBtn = document.createElement("button");
    applySubdivisionsBtn.textContent = "Apply";
    applySubdivisionsBtn.style.padding = "3px 6px";
    applySubdivisionsBtn.style.cursor = "pointer";
    applySubdivisionsBtn.addEventListener("click", function() {
  // force n between 1 and 10
  let n = parseInt(subdivisionsInput.value, 10) || 1;
  if (n < 1) n = 1;
  if (n > 10) n = 10;
  container.angleData.subdivisions = n;

  setupSubLabels();
  computeSubAngles();
  drawAngle();
});

    subdivisionGroup.appendChild(applySubdivisionsBtn);
    
    controls.appendChild(subdivisionGroup);
    
    // Format button
    const formatBtn = document.createElement("button");
    formatBtn.textContent = "Format";
    formatBtn.className = "toolbar-button";
    formatBtn.style.marginRight = "10px";
    formatBtn.style.padding = "4px 8px";
    formatBtn.style.cursor = "pointer";
    formatBtn.addEventListener("click", function() {
      showFormatDialog();
    });
    controls.appendChild(formatBtn);
    
    // Points button
    const pointsBtn = document.createElement("button");
    pointsBtn.textContent = "Points";
    pointsBtn.className = "toolbar-button";
    pointsBtn.style.marginRight = "10px";
    pointsBtn.style.padding = "4px 8px";
    pointsBtn.style.cursor = "pointer";
    pointsBtn.addEventListener("click", function() {
      showPointsDialog();
    });
    controls.appendChild(pointsBtn);
    
    // Spans button
    const spansBtn = document.createElement("button");
    spansBtn.textContent = "Spans";
    spansBtn.className = "toolbar-button";
    spansBtn.style.marginRight = "10px";
    spansBtn.style.padding = "4px 8px";
    spansBtn.style.cursor = "pointer";
    spansBtn.addEventListener("click", function() {
      showSpansDialog();
    });
    controls.appendChild(spansBtn);
    
    globalToolbar.appendChild(controls);
  }
  
  // Format dialog
  function showFormatDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Format Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Point Size input
    const pointSizeRow = document.createElement("div");
    pointSizeRow.style.display = "flex";
    pointSizeRow.style.alignItems = "center";
    pointSizeRow.style.marginBottom = "10px";
    
    const pointSizeLabel = document.createElement("label");
    pointSizeLabel.textContent = "Point Size:";
    pointSizeLabel.style.display = "inline-block";
    pointSizeLabel.style.width = "140px";
    pointSizeLabel.style.marginRight = "10px";
    pointSizeRow.appendChild(pointSizeLabel);
    
    // Create stepper control for point size
    const pointSizeStepperDiv = document.createElement("div");
    pointSizeStepperDiv.className = "stepper-control";
    pointSizeStepperDiv.style.display = "flex";
    pointSizeStepperDiv.style.alignItems = "center";
    
    const pointSizeDecreaseBtn = document.createElement("button");
    pointSizeDecreaseBtn.textContent = "-";
    pointSizeDecreaseBtn.style.width = "24px";
    pointSizeDecreaseBtn.style.height = "24px";
    pointSizeStepperDiv.appendChild(pointSizeDecreaseBtn);
    
    const pointSizeInput = document.createElement("input");
    pointSizeInput.type = "number";
    pointSizeInput.min = "4";
    pointSizeInput.max = "20";
    pointSizeInput.value = container.angleData.pointSize;
    pointSizeInput.style.width = "40px";
    pointSizeInput.style.textAlign = "center";
    pointSizeInput.style.margin = "0 5px";
    pointSizeInput.readOnly = true;
    pointSizeStepperDiv.appendChild(pointSizeInput);
    
    const pointSizeIncreaseBtn = document.createElement("button");
    pointSizeIncreaseBtn.textContent = "+";
    pointSizeIncreaseBtn.style.width = "24px";
    pointSizeIncreaseBtn.style.height = "24px";
    pointSizeStepperDiv.appendChild(pointSizeIncreaseBtn);
    
    pointSizeRow.appendChild(pointSizeStepperDiv);
    dialogBox.appendChild(pointSizeRow);
    
    // Font Size (Measure Font) input
    const fontSizeRow = document.createElement("div");
    fontSizeRow.style.display = "flex";
    fontSizeRow.style.alignItems = "center";
    fontSizeRow.style.marginBottom = "10px";
    
    const fontSizeLabel = document.createElement("label");
    fontSizeLabel.textContent = "Measure Font:";
    fontSizeLabel.style.display = "inline-block";
    fontSizeLabel.style.width = "140px";
    fontSizeLabel.style.marginRight = "10px";
    fontSizeRow.appendChild(fontSizeLabel);
    
    // Create stepper for font size
    const fontSizeStepperDiv = document.createElement("div");
    fontSizeStepperDiv.className = "stepper-control";
    fontSizeStepperDiv.style.display = "flex";
    fontSizeStepperDiv.style.alignItems = "center";
    
    const fontSizeDecreaseBtn = document.createElement("button");
    fontSizeDecreaseBtn.textContent = "-";
    fontSizeDecreaseBtn.style.width = "24px";
    fontSizeDecreaseBtn.style.height = "24px";
    fontSizeStepperDiv.appendChild(fontSizeDecreaseBtn);
    
    const fontSizeInput = document.createElement("input");
    fontSizeInput.type = "number";
    fontSizeInput.min = "8";
    fontSizeInput.max = "30";
    fontSizeInput.value = container.angleData.fontSize;
    fontSizeInput.style.width = "40px";
    fontSizeInput.style.textAlign = "center";
    fontSizeInput.style.margin = "0 5px";
    fontSizeInput.readOnly = true;
    fontSizeStepperDiv.appendChild(fontSizeInput);
    
    const fontSizeIncreaseBtn = document.createElement("button");
    fontSizeIncreaseBtn.textContent = "+";
    fontSizeIncreaseBtn.style.width = "24px";
    fontSizeIncreaseBtn.style.height = "24px";
    fontSizeStepperDiv.appendChild(fontSizeIncreaseBtn);
    
    fontSizeRow.appendChild(fontSizeStepperDiv);
    dialogBox.appendChild(fontSizeRow);
    
    // Label Font Size input
    const labelFontSizeRow = document.createElement("div");
    labelFontSizeRow.style.display = "flex";
    labelFontSizeRow.style.alignItems = "center";
    labelFontSizeRow.style.marginBottom = "10px";
    
    const labelFontSizeLabel = document.createElement("label");
    labelFontSizeLabel.textContent = "Label Font:";
    labelFontSizeLabel.style.display = "inline-block";
    labelFontSizeLabel.style.width = "140px";
    labelFontSizeLabel.style.marginRight = "10px";
    labelFontSizeRow.appendChild(labelFontSizeLabel);
    
    // Create stepper for label font size
    const labelFontSizeStepperDiv = document.createElement("div");
    labelFontSizeStepperDiv.className = "stepper-control";
    labelFontSizeStepperDiv.style.display = "flex";
    labelFontSizeStepperDiv.style.alignItems = "center";
    
    const labelFontSizeDecreaseBtn = document.createElement("button");
    labelFontSizeDecreaseBtn.textContent = "-";
    labelFontSizeDecreaseBtn.style.width = "24px";
    labelFontSizeDecreaseBtn.style.height = "24px";
    labelFontSizeStepperDiv.appendChild(labelFontSizeDecreaseBtn);
    
    const labelFontSizeInput = document.createElement("input");
    labelFontSizeInput.type = "number";
    labelFontSizeInput.min = "8";
    labelFontSizeInput.max = "36";
    labelFontSizeInput.value = container.angleData.labelFontSize;
    labelFontSizeInput.style.width = "40px";
    labelFontSizeInput.style.textAlign = "center";
    labelFontSizeInput.style.margin = "0 5px";
    labelFontSizeInput.readOnly = true;
    labelFontSizeStepperDiv.appendChild(labelFontSizeInput);
    
    const labelFontSizeIncreaseBtn = document.createElement("button");
    labelFontSizeIncreaseBtn.textContent = "+";
    labelFontSizeIncreaseBtn.style.width = "24px";
    labelFontSizeIncreaseBtn.style.height = "24px";
    labelFontSizeStepperDiv.appendChild(labelFontSizeIncreaseBtn);
    
    labelFontSizeRow.appendChild(labelFontSizeStepperDiv);
    dialogBox.appendChild(labelFontSizeRow);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    // Add event listeners for steppers
    pointSizeDecreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(pointSizeInput.value);
      if (currentValue > parseInt(pointSizeInput.min)) {
        pointSizeInput.value = currentValue - 1;
        container.angleData.pointSize = currentValue - 1;
        drawAngle();
      }
    });
    
    pointSizeIncreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(pointSizeInput.value);
      if (currentValue < parseInt(pointSizeInput.max)) {
        pointSizeInput.value = currentValue + 1;
        container.angleData.pointSize = currentValue + 1;
        drawAngle();
      }
    });
    
    fontSizeDecreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(fontSizeInput.value);
      if (currentValue > parseInt(fontSizeInput.min)) {
        fontSizeInput.value = currentValue - 1;
        container.angleData.fontSize = currentValue - 1;
        drawAngle();
      }
    });
    
    fontSizeIncreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(fontSizeInput.value);
      if (currentValue < parseInt(fontSizeInput.max)) {
        fontSizeInput.value = currentValue + 1;
        container.angleData.fontSize = currentValue + 1;
        drawAngle();
      }
    });
    
    labelFontSizeDecreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(labelFontSizeInput.value);
      if (currentValue > parseInt(labelFontSizeInput.min)) {
        labelFontSizeInput.value = currentValue - 1;
        container.angleData.labelFontSize = currentValue - 1;
        drawAngle();
      }
    });
    
    labelFontSizeIncreaseBtn.addEventListener("click", function() {
      const currentValue = parseInt(labelFontSizeInput.value);
      if (currentValue < parseInt(labelFontSizeInput.max)) {
        labelFontSizeInput.value = currentValue + 1;
        container.angleData.labelFontSize = currentValue + 1;
        drawAngle();
      }
    });
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Points dialog
  function showPointsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Point Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Show Points checkbox
    const showPointsRow = document.createElement("div");
    showPointsRow.style.display = "flex";
    showPointsRow.style.alignItems = "center";
    showPointsRow.style.marginBottom = "10px";
    
    const showPointsCheckbox = document.createElement("input");
    showPointsCheckbox.type = "checkbox";
    showPointsCheckbox.id = `showPoints-${container.angleID}`;
    showPointsCheckbox.checked = container.angleData.showPoints;
    showPointsCheckbox.addEventListener("change", function() {
      container.angleData.showPoints = this.checked;
      drawAngle();
    });
    showPointsRow.appendChild(showPointsCheckbox);
    
    const showPointsLabel = document.createElement("label");
    showPointsLabel.textContent = "Show Points";
    showPointsLabel.setAttribute("for", `showPoints-${container.angleID}`);
    showPointsLabel.style.marginLeft = "5px";
    showPointsRow.appendChild(showPointsLabel);
    
    dialogBox.appendChild(showPointsRow);
    
    // Show Labels checkbox
    const showLabelsRow = document.createElement("div");
    showLabelsRow.style.display = "flex";
    showLabelsRow.style.alignItems = "center";
    showLabelsRow.style.marginBottom = "10px";
    
    const showLabelsCheckbox = document.createElement("input");
    showLabelsCheckbox.type = "checkbox";
    showLabelsCheckbox.id = `showLabels-${container.angleID}`;
    showLabelsCheckbox.checked = container.angleData.showLabels;
    showLabelsCheckbox.addEventListener("change", function() {
      container.angleData.showLabels = this.checked;
      drawAngle();
    });
    showLabelsRow.appendChild(showLabelsCheckbox);
    
    const showLabelsLabel = document.createElement("label");
    showLabelsLabel.textContent = "Show Labels";
    showLabelsLabel.setAttribute("for", `showLabels-${container.angleID}`);
    showLabelsLabel.style.marginLeft = "5px";
    showLabelsRow.appendChild(showLabelsLabel);
    
    dialogBox.appendChild(showLabelsRow);
    
    // Draggable Labels checkbox
    const draggableLabelsRow = document.createElement("div");
    draggableLabelsRow.style.display = "flex";
    draggableLabelsRow.style.alignItems = "center";
    draggableLabelsRow.style.marginBottom = "10px";
    
    const draggableLabelsCheckbox = document.createElement("input");
    draggableLabelsCheckbox.type = "checkbox";
    draggableLabelsCheckbox.id = `draggableLabels-${container.angleID}`;
    draggableLabelsCheckbox.checked = container.angleData.draggableLabels;
    draggableLabelsCheckbox.addEventListener("change", function() {
      container.angleData.draggableLabels = this.checked;
      drawAngle();
    });
    draggableLabelsRow.appendChild(draggableLabelsCheckbox);
    
    const draggableLabelsLabel = document.createElement("label");
    draggableLabelsLabel.textContent = "Draggable Labels";
    draggableLabelsLabel.setAttribute("for", `draggableLabels-${container.angleID}`);
    draggableLabelsLabel.style.marginLeft = "5px";
    draggableLabelsRow.appendChild(draggableLabelsLabel);
    
    dialogBox.appendChild(draggableLabelsRow);
    
    // Label A input
    const labelARow = document.createElement("div");
    labelARow.style.display = "flex";
    labelARow.style.alignItems = "center";
    labelARow.style.marginBottom = "10px";
    
    const labelALabel = document.createElement("label");
    labelALabel.textContent = "A:";
    labelALabel.style.width = "30px";
    labelALabel.style.marginRight = "10px";
    labelARow.appendChild(labelALabel);
    
    const labelAInput = document.createElement("input");
    labelAInput.type = "text";
    labelAInput.value = container.angleData.labels[0];
    labelAInput.style.width = "80px";
    labelAInput.addEventListener("input", function() {
      container.angleData.labels[0] = this.value;
      drawAngle();
    });
    labelARow.appendChild(labelAInput);
    
    dialogBox.appendChild(labelARow);
    
    // Label B input
    const labelBRow = document.createElement("div");
    labelBRow.style.display = "flex";
    labelBRow.style.alignItems = "center";
    labelBRow.style.marginBottom = "10px";
    
    const labelBLabel = document.createElement("label");
    labelBLabel.textContent = "B:";
    labelBLabel.style.width = "30px";
    labelBLabel.style.marginRight = "10px";
    labelBRow.appendChild(labelBLabel);
    
    const labelBInput = document.createElement("input");
    labelBInput.type = "text";
    labelBInput.value = container.angleData.labels[1];
    labelBInput.style.width = "80px";
    labelBInput.addEventListener("input", function() {
      container.angleData.labels[1] = this.value;
      drawAngle();
    });
    labelBRow.appendChild(labelBInput);
    
    dialogBox.appendChild(labelBRow);
    
    // Label C input
    const labelCRow = document.createElement("div");
    labelCRow.style.display = "flex";
    labelCRow.style.alignItems = "center";
    
    const labelCLabel = document.createElement("label");
    labelCLabel.textContent = "C:";
    labelCLabel.style.width = "30px";
    labelCLabel.style.marginRight = "10px";
    labelCRow.appendChild(labelCLabel);
    
    const labelCInput = document.createElement("input");
    labelCInput.type = "text";
    labelCInput.value = container.angleData.labels[2];
    labelCInput.style.width = "80px";
    labelCInput.addEventListener("input", function() {
      container.angleData.labels[2] = this.value;
      drawAngle();
    });
    labelCRow.appendChild(labelCInput);
    
    dialogBox.appendChild(labelCRow);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  

  // Spans dialog
  function showSpansDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Span Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Span Mode selector
    const spanModeRow = document.createElement("div");
    spanModeRow.style.display = "flex";
    spanModeRow.style.alignItems = "center";
    spanModeRow.style.marginBottom = "15px";
    
    const spanModeLabel = document.createElement("label");
    spanModeLabel.textContent = "Mode:";
    spanModeLabel.style.width = "100px";
    spanModeLabel.style.marginRight = "10px";
    spanModeRow.appendChild(spanModeLabel);
    
    const spanModeSelect = document.createElement("select");
    spanModeSelect.style.width = "150px";
    
    const allOption = document.createElement("option");
    allOption.value = "all";
    allOption.textContent = "Draw Subangles";
    spanModeSelect.appendChild(allOption);
    
    const wholeOption = document.createElement("option");
    wholeOption.value = "whole";
    wholeOption.textContent = "Draw Whole Angle";
    spanModeSelect.appendChild(wholeOption);
    
    const customOption = document.createElement("option");
    customOption.value = "custom";
    customOption.textContent = "Custom Spans";
    spanModeSelect.appendChild(customOption);
    
    const noneOption = document.createElement("option");
    noneOption.value = "none";
    noneOption.textContent = "No Spans";
    spanModeSelect.appendChild(noneOption);
    
    // Set the current value
    spanModeSelect.value = container.angleData.spanMode;
    
    spanModeSelect.addEventListener("change", function() {
      container.angleData.spanMode = this.value;
      
      // Show/hide custom span controls
      if (this.value === "custom") {
        spanControlsDiv.style.display = "block";
        addSpanBtn.style.display = "inline-block";
        setupSpanCheckboxes();
      } else {
        spanControlsDiv.style.display = "none";
        addSpanBtn.style.display = "none";
        // Clear custom spans when switching away
        container.angleData.customSpans = [];
        drawAngle();
      }
      
      drawAngle();
    });
    
    spanModeRow.appendChild(spanModeSelect);
    dialogBox.appendChild(spanModeRow);
    
    // Add Span button
    const addSpanBtn = document.createElement("button");
    addSpanBtn.textContent = "Add Span";
    addSpanBtn.className = "toolbar-button";
    addSpanBtn.style.marginBottom = "15px";
    addSpanBtn.style.display = container.angleData.spanMode === "custom" ? "inline-block" : "none";
    addSpanBtn.addEventListener("click", function() {
      setupSpanCheckboxes();
      spanControlsDiv.style.display = "block";
    });
    dialogBox.appendChild(addSpanBtn);
    
    // Custom Span Controls
    const spanControlsDiv = document.createElement("div");
    spanControlsDiv.id = `spanControls-${container.angleID}`;
    spanControlsDiv.style.display = container.angleData.spanMode === "custom" ? "block" : "none";
    
    // Span checkboxes
    const spanCheckboxes = document.createElement("div");
    spanCheckboxes.className = "span-checkbox-group";
    spanCheckboxes.style.display = "flex";
    spanCheckboxes.style.gap = "8px";
    spanCheckboxes.style.alignItems = "center";
    spanCheckboxes.style.flexWrap = "wrap";
    spanCheckboxes.style.marginTop = "5px";
    spanControlsDiv.appendChild(spanCheckboxes);
    
    // Error message
    const errorMsg = document.createElement("div");
    errorMsg.style.color = "#e00";
    errorMsg.style.fontSize = "12px";
    errorMsg.style.marginTop = "5px";
    errorMsg.style.display = "none";
    errorMsg.textContent = "Please select adjacent angles only";
    spanControlsDiv.appendChild(errorMsg);
    
    // Span color row
    const spanColorRow = document.createElement("div");
    spanColorRow.style.marginTop = "10px";
    spanColorRow.style.display = "flex";
    spanColorRow.style.alignItems = "center";
    
    const spanColorLabel = document.createElement("label");
    spanColorLabel.textContent = "Span Color:";
    spanColorLabel.style.marginRight = "10px";
    spanColorRow.appendChild(spanColorLabel);
    
    const spanColorInput = document.createElement("input");
    spanColorInput.type = "color";
    spanColorInput.value = "#ff6600";
    spanColorInput.style.marginRight = "10px";
    spanColorRow.appendChild(spanColorInput);
    
    const createSpanBtn = document.createElement("button");
    createSpanBtn.textContent = "Create Span";
    createSpanBtn.style.marginRight = "10px";
    createSpanBtn.addEventListener("click", function() {
      // Logic to create a custom span
      createCustomSpan(spanCheckboxes, spanColorInput, errorMsg);
    });
    spanColorRow.appendChild(createSpanBtn);
    
    const cancelEditBtn = document.createElement("button");
    cancelEditBtn.textContent = "Cancel Edit";
    cancelEditBtn.style.display = "none";
    cancelEditBtn.style.marginRight = "10px";
    cancelEditBtn.addEventListener("click", function() {
      cancelEdit();
    });
    spanColorRow.appendChild(cancelEditBtn);
    
    const clearSpansBtn = document.createElement("button");
    clearSpansBtn.textContent = "Clear All";
    clearSpansBtn.addEventListener("click", function() {
      container.angleData.customSpans = [];
      resetSpanSelections(spanCheckboxes, errorMsg);
      cancelEdit();
      updateSpansList();
      drawAngle();
    });
    spanColorRow.appendChild(clearSpansBtn);
    
    spanControlsDiv.appendChild(spanColorRow);
    
    // Editing message
    const editingMessage = document.createElement("div");
    editingMessage.style.color = "#0066cc";
    editingMessage.style.fontWeight = "bold";
    editingMessage.style.marginTop = "8px";
    editingMessage.style.display = "none";
    editingMessage.innerHTML = "Editing Span: <span id='editingSpanName-" + container.angleID + "'></span>";
    spanControlsDiv.appendChild(editingMessage);
    
    // Span display options
    const spanDisplayOptions = document.createElement("div");
    spanDisplayOptions.className = "span-display-options";
    spanDisplayOptions.style.marginTop = "15px";
    spanDisplayOptions.style.paddingTop = "8px";
    spanDisplayOptions.style.borderTop = "1px solid #eee";
    
    const showAngleNotationRow = document.createElement("div");
    showAngleNotationRow.style.marginBottom = "5px";
    
    const showAngleNotationCheckbox = document.createElement("input");
    showAngleNotationCheckbox.type = "checkbox";
    showAngleNotationCheckbox.id = `showAngleNotation-${container.angleID}`;
    showAngleNotationCheckbox.checked = container.angleData.showAngleNotation;
    showAngleNotationCheckbox.addEventListener("change", function() {
      container.angleData.showAngleNotation = this.checked;
      drawAngle();
    });
    showAngleNotationRow.appendChild(showAngleNotationCheckbox);
    
    const showAngleNotationLabel = document.createElement("label");
    showAngleNotationLabel.textContent = "Show Angle Notation (∠ABC)";
    showAngleNotationLabel.setAttribute("for", `showAngleNotation-${container.angleID}`);
    showAngleNotationLabel.style.marginLeft = "5px";
    showAngleNotationRow.appendChild(showAngleNotationLabel);
    
    spanDisplayOptions.appendChild(showAngleNotationRow);
    
    const showAngleMeasureRow = document.createElement("div");
    
    const showAngleMeasureCheckbox = document.createElement("input");
    showAngleMeasureCheckbox.type = "checkbox";
    showAngleMeasureCheckbox.id = `showAngleMeasure-${container.angleID}`;
    showAngleMeasureCheckbox.checked = container.angleData.showAngleMeasure;
    showAngleMeasureCheckbox.addEventListener("change", function() {
      container.angleData.showAngleMeasure = this.checked;
      drawAngle();
    });
    showAngleMeasureRow.appendChild(showAngleMeasureCheckbox);
    
    const showAngleMeasureLabel = document.createElement("label");
    showAngleMeasureLabel.textContent = "Show Angle Measure";
    showAngleMeasureLabel.setAttribute("for", `showAngleMeasure-${container.angleID}`);
    showAngleMeasureLabel.style.marginLeft = "5px";
    showAngleMeasureRow.appendChild(showAngleMeasureLabel);
    
    spanDisplayOptions.appendChild(showAngleMeasureRow);
    
    spanControlsDiv.appendChild(spanDisplayOptions);
    
    // Spans list
    const spansList = document.createElement("div");
    spansList.id = `spansList-${container.angleID}`;
    spansList.style.marginTop = "10px";
    spansList.style.padding = "8px";
    spansList.style.background = "#f9f9f9";
    spansList.style.border = "1px solid #ddd";
    spansList.style.borderRadius = "4px";
    spansList.style.maxHeight = "150px";
    spansList.style.overflowY = "auto";
    spansList.style.fontSize = "13px";
    spanControlsDiv.appendChild(spansList);
    
    dialogBox.appendChild(spanControlsDiv);
    
    // Setup span checkboxes
    setupSpanCheckboxes();
    
    // Update spans list
    updateSpansList(spansList);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
    
    // Variables for editing state
    let editingSpanIndex = -1;
    
    // Helper function: Set up span checkboxes
    function setupSpanCheckboxes() {
      spanCheckboxes.innerHTML = '';
      const totalAngleDegrees = parseFloat(container.angleData.angleDegrees) || 60;
      
      // Add whole angle checkbox
      const wholeGroup = document.createElement("div");
      const wholeCheck = document.createElement("input");
      wholeCheck.type = "checkbox";
      wholeCheck.id = `spanWhole-${container.angleID}`;
      wholeCheck.dataset.spanType = "whole";
      
      const wholeLabel = document.createElement("label");
      wholeLabel.textContent = `∠${container.angleData.labels[0]}${container.angleData.labels[1]}${container.angleData.labels[2]} (${totalAngleDegrees}°)`;
      wholeLabel.setAttribute("for", `spanWhole-${container.angleID}`);
      
      wholeGroup.appendChild(wholeCheck);
      wholeGroup.appendChild(wholeLabel);
      spanCheckboxes.appendChild(wholeGroup);
      
      // Add subangles if we have any
      const subdivisions = container.angleData.subdivisions;
      
      if (subdivisions > 1) {
        // For each subangle segment
        for (let i = 0; i < subdivisions; i++) {
          const group = document.createElement("div");
          const check = document.createElement("input");
          check.type = "checkbox";
          check.id = `spanSub${i}-${container.angleID}`;
          check.dataset.spanType = "sub";
          check.dataset.index = i;
          
          const label = document.createElement("label");
          let labelText = '';
          let angleMeasure = '';
          
          const subLabels = container.angleData.subLabels;
          const subAngleValues = container.angleData.subAngleValues;
          
          if (i === 0) {
            // First segment
            labelText = `∠${container.angleData.labels[0]}${container.angleData.labels[1]}${subLabels[0] || 'D'}`;
            angleMeasure = `(${subAngleValues[0] || Math.round(totalAngleDegrees / subdivisions)}°)`;
          } else if (i === subdivisions - 1) {
            // Last segment
            labelText = `∠${subLabels[i-1] || 'D'}${container.angleData.labels[1]}${container.angleData.labels[2]}`;
            // Calculate remaining angle
            const totalSubAngles = subAngleValues.reduce((sum, val) => sum + val, 0);
            angleMeasure = `(${Math.round((totalAngleDegrees - totalSubAngles))}°)`;
          } else {
            // Middle segments
            labelText = `∠${subLabels[i-1] || 'Sub'+(i)}${container.angleData.labels[1]}${subLabels[i] || 'Sub'+(i+1)}`;
            angleMeasure = `(${subAngleValues[i] || Math.round(totalAngleDegrees / subdivisions)}°)`;
          }
          
          label.textContent = `${labelText} ${angleMeasure}`;
          label.setAttribute("for", `spanSub${i}-${container.angleID}`);
          
          group.appendChild(check);
          group.appendChild(label);
          spanCheckboxes.appendChild(group);
        }
      }
    }
    
    // Function to update spans list
    function updateSpansList() {
      spansList.innerHTML = '';
      if (container.angleData.customSpans.length === 0) {
        spansList.innerHTML = '<div class="span-item">No spans created</div>';
        return;
      }
      
      container.angleData.customSpans.forEach((span, index) => {
        const item = document.createElement('div');
        item.className = 'span-item';
        item.style.marginBottom = "5px";
        item.style.paddingBottom = "5px";
        item.style.borderBottom = "1px solid #eee";
        item.style.display = "flex";
        item.style.alignItems = "center";
        item.style.justifyContent = "space-between";
        
        // Create left side content with span info
        const contentDiv = document.createElement('div');
        contentDiv.className = 'span-item-content';
        contentDiv.style.display = "flex";
        contentDiv.style.alignItems = "center";
        
        // Create span number
        const spanNumber = document.createElement('span');
        spanNumber.textContent = `Span ${index + 1}: `;
        spanNumber.style.fontWeight = 'bold';
        
        // Create color dot
        const colorDot = document.createElement('span');
        colorDot.className = 'span-color-dot';
        colorDot.style.display = "inline-block";
        colorDot.style.width = "10px";
        colorDot.style.height = "10px";
        colorDot.style.borderRadius = "50%";
        colorDot.style.marginRight = "5px";
        colorDot.style.backgroundColor = span.color;
        
        // Create span text
        let spanText = '';
        if (span.type === 'whole') {
          spanText = `∠${container.angleData.labels[0]}${container.angleData.labels[1]}${container.angleData.labels[2]}: ${span.measure}°`;
        } else if (span.type === 'sub') {
          spanText = `${span.notation}: ${span.measure}°`;
        }
        
        const spanTextElem = document.createTextNode(spanText);
        
        // Add elements to content div
        contentDiv.appendChild(spanNumber);
        contentDiv.appendChild(colorDot);
        contentDiv.appendChild(spanTextElem);
        
        // Create buttons div for edit/delete
        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'span-buttons';
        buttonsDiv.style.display = "flex";
        buttonsDiv.style.gap = "5px";
        
        // Add edit button
        const editBtn = document.createElement('button');
        editBtn.textContent = 'Edit';
        editBtn.style.fontSize = '11px';
        editBtn.style.padding = '2px 5px';
        editBtn.addEventListener('click', () => {
          startEditingSpan(index);
        });
        
        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.style.fontSize = '11px';
        deleteBtn.style.padding = '2px 5px';
        deleteBtn.addEventListener('click', () => {
          container.angleData.customSpans.splice(index, 1);
          if (editingSpanIndex === index) {
            cancelEdit();
          } else if (editingSpanIndex > index) {
            // Adjust editing index if we deleted an element before it
            editingSpanIndex--;
          }
          updateSpansList();
          drawAngle();
        });
        
        // Add buttons to button div
        buttonsDiv.appendChild(editBtn);
        buttonsDiv.appendChild(deleteBtn);
        
        // Add content and buttons to item
        item.appendChild(contentDiv);
        item.appendChild(buttonsDiv);
        
        spansList.appendChild(item);
      });
    }
    
    // Function to start editing a span
    function startEditingSpan(index) {
      editingSpanIndex = index;
      const span = container.angleData.customSpans[index];
      
      // Update UI to show we're in edit mode
      createSpanBtn.textContent = "Update Span";
      cancelEditBtn.style.display = "inline-block";
      editingMessage.style.display = "block";
      const editingSpanName = document.getElementById(`editingSpanName-${container.angleID}`);
      if (editingSpanName) {
        editingSpanName.textContent = `Span ${index + 1}`;
      }
      
      // Set color input to match span color
      spanColorInput.value = span.color;
      
      // Reset all checkboxes first
      resetSpanSelections();
      
      // Check the right checkboxes based on span type and indices
      if (span.type === 'whole') {
        const wholeCheckbox = document.getElementById(`spanWhole-${container.angleID}`);
        if (wholeCheckbox) wholeCheckbox.checked = true;
      } else if (span.type === 'sub') {
        span.indices.forEach(idx => {
          const checkbox = document.getElementById(`spanSub${idx}-${container.angleID}`);
          if (checkbox) checkbox.checked = true;
        });
      }
    }
    
    // Function to cancel editing
    function cancelEdit() {
      editingSpanIndex = -1;
      createSpanBtn.textContent = "Create Span";
      cancelEditBtn.style.display = "none";
      editingMessage.style.display = "none";
      resetSpanSelections();
    }
    
    // Helper: reset span selections
    function resetSpanSelections() {
      const checkboxes = spanCheckboxes.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      if (errorMsg) errorMsg.style.display = 'none';
    }
    
    // Helper: check if angles are adjacent
    function areAnglesAdjacent(selectedIndices) {
      if (selectedIndices.length <= 1) return true;
      
      // Sort the indices
      selectedIndices.sort((a, b) => a - b);
      
      // Check if they form a continuous sequence
      for (let i = 1; i < selectedIndices.length; i++) {
        if (selectedIndices[i] !== selectedIndices[i-1] + 1) {
          return false;
        }
      }
      
      return true;
    }
    
    // Create a custom span
    function createCustomSpan() {
      const checkboxes = spanCheckboxes.querySelectorAll('input[type="checkbox"]:checked');
      const totalAngleDegrees = parseFloat(container.angleData.angleDegrees) || 60;
      
      // Check if whole angle selected
      const wholeCheckbox = document.getElementById(`spanWhole-${container.angleID}`);
      if (wholeCheckbox && wholeCheckbox.checked) {
        const newSpan = {
          type: 'whole',
          color: spanColorInput.value,
          notation: `∠${container.angleData.labels[0]}${container.angleData.labels[1]}${container.angleData.labels[2]}`,
          measure: totalAngleDegrees
        };
        
        // Add or update the span
        if (editingSpanIndex >= 0) {
          container.angleData.customSpans[editingSpanIndex] = newSpan;
          cancelEdit();
        } else {
          container.angleData.customSpans.push(newSpan);
        }
        
        resetSpanSelections();
        updateSpansList();
        drawAngle();
        return;
      }
      
      // Get all subangle indices that are selected
      const selectedIndices = [];
      checkboxes.forEach(checkbox => {
        if (checkbox.dataset.spanType === 'sub') {
          selectedIndices.push(parseInt(checkbox.dataset.index));
        }
      });
      
      // Check if selected angles are adjacent
      if (!areAnglesAdjacent(selectedIndices)) {
        errorMsg.style.display = 'block';
        return;
      }
      
      // Hide error message if visible
      errorMsg.style.display = 'none';
      
      if (selectedIndices.length > 0) {
        // Determine the start and end labels
        const startIdx = selectedIndices[0];
        const endIdx = selectedIndices[selectedIndices.length - 1];
        let startLabel, endLabel;
        
        if (startIdx === 0) {
          startLabel = container.angleData.labels[0]; // A
        } else {
          startLabel = container.angleData.subLabels[startIdx - 1];
        }
        
        if (endIdx === container.angleData.subdivisions - 1) {
          endLabel = container.angleData.labels[2]; // C
        } else {
          endLabel = container.angleData.subLabels[endIdx];
        }
        
        // Calculate the measure of this span
        let spanMeasure = 0;
        for (let i = startIdx; i <= endIdx; i++) {
          if (i === container.angleData.subdivisions - 1) {
            // Last segment
            const totalSubAngles = container.angleData.subAngleValues.reduce((sum, val) => sum + val, 0);
            spanMeasure += totalAngleDegrees - totalSubAngles;
          } else {
            spanMeasure += container.angleData.subAngleValues[i];
          }
        }
        
        const newSpan = {
          type: 'sub',
          indices: selectedIndices,
          color: spanColorInput.value,
          notation: `∠${startLabel}${container.angleData.labels[1]}${endLabel}`,
          measure: Math.round(spanMeasure)
        };
        
        if (editingSpanIndex >= 0) {
          // Update existing span
          container.angleData.customSpans[editingSpanIndex] = newSpan;
          cancelEdit();
        } else {
          // Add new span
          container.angleData.customSpans.push(newSpan);
        }
        
        resetSpanSelections();
        updateSpansList();
        drawAngle();
      }
    }
  }

  // Helper function: ray length
  function rayLength(p) {
    return Math.hypot(p.x - container.angleData.points[1].x, p.y - container.angleData.points[1].y);
  }
  
  // Helper function: set up sub labels
  function setupSubLabels() {
    const data = container.angleData;
    data.subLabels = [];
    
    // Generate sublabels automatically
    for (let i = 1; i < data.subdivisions; i++) {
      const char = String.fromCharCode('A'.charCodeAt(0) + 2 + i);
      data.subLabels.push(char);
    }
    
    // After updating labels, set up subangle inputs
    setupSubangleInputs();
  }
  
  // Helper function: set up subangle inputs
  function setupSubangleInputs() {
    const data = container.angleData;
    
    // Reset values
    data.subAngleValues = [];
    data.subAngles = [];
    
    // Get the total angle to divide evenly
    let angleDegrees = parseFloat(data.angleDegrees) || 60;
    angleDegrees = Math.min(360, Math.max(0, angleDegrees));
    const rad = angleDegrees * Math.PI / 180;
    
    // Calculate even distribution
    const evenValue = Math.round(angleDegrees / data.subdivisions);
    
    // Create evenly distributed subangles
    const v1 = Math.atan2(data.points[0].y - data.points[1].y, data.points[0].x - data.points[1].x);
    const v2 = Math.atan2(data.points[2].y - data.points[1].y, data.points[2].x - data.points[1].x);
    let start = v1, end = v2;
    if (end < start) end += 2 * Math.PI;
    
    for (let i = 1; i < data.subdivisions; i++) {
      // Add evenly distributed angle value
      data.subAngleValues.push(evenValue);
      // Add the absolute position of this subangle
      data.subAngles.push(start + (end - start) * i / data.subdivisions);
    }
  }
  
  // Helper function: compute subangles
  function computeSubAngles() {
    const data = container.angleData;
    data.subAngles = [];
    
    const v1 = Math.atan2(data.points[0].y - data.points[1].y, data.points[0].x - data.points[1].x);
    const v2 = Math.atan2(data.points[2].y - data.points[1].y, data.points[2].x - data.points[1].x);
    let start = v1, end = v2;
    if (end < start) end += 2 * Math.PI;
    
    const totalAngleRad = end - start;
    let angleDegrees = parseFloat(data.angleDegrees) || 60;
    
    // If we have user-defined values and they're valid, use them
    if (data.subAngleValues.length > 0 && data.subAngleValues.length >= data.subdivisions - 1) {
      let sumDefined = 0;
      let countUndefined = 0;
      
      // Calculate sum of defined angles and count undefined
      for (let i = 0; i < data.subdivisions - 1; i++) {
        if (i < data.subAngleValues.length && data.subAngleValues[i] !== undefined && !isNaN(data.subAngleValues[i])) {
          sumDefined += data.subAngleValues[i] * Math.PI / 180; // Convert to radians
        } else {
          countUndefined++;
          if (i < data.subAngleValues.length) {
            data.subAngleValues[i] = undefined;
          } else {
            data.subAngleValues.push(undefined); // Extend array if needed
          }
        }
      }
      
      // Check if sum of defined angles exceeds total angle
      if (sumDefined > totalAngleRad) {
        // Scale down all values proportionally
        const scale = totalAngleRad / sumDefined;
        for (let i = 0; i < data.subdivisions - 1; i++) {
          if (data.subAngleValues[i] !== undefined) {
            data.subAngleValues[i] *= scale * 180 / Math.PI; // Back to degrees
          }
        }
        sumDefined = totalAngleRad;
      }
      
      // Calculate remaining angle to distribute
      const remainingAngle = totalAngleRad - sumDefined;
      
      // Distribute remaining angle among undefined values
      const defaultValue = countUndefined > 0 ? remainingAngle / countUndefined : 0;
      
      let currentAngle = start;
      for (let i = 0; i < data.subdivisions - 1; i++) {
        let anglePortion;
        if (data.subAngleValues[i] !== undefined && !isNaN(data.subAngleValues[i])) {
          anglePortion = data.subAngleValues[i] * Math.PI / 180;
        } else {
          anglePortion = defaultValue;
          data.subAngleValues[i] = Math.round(anglePortion * 180 / Math.PI);
        }
        
        // Ensure angles are properly ordered
        if (i > 0) {
          const minAngle = currentAngle + 0.01; // Ensure small minimum separation
          anglePortion = Math.max(anglePortion, minAngle - (currentAngle - start));
        }
        
        // Ensure we don't exceed the total angle
        if (i === data.subdivisions - 2) {
          const maxAngle = end - 0.01;
          currentAngle = Math.min(currentAngle + anglePortion, maxAngle);
        } else {
          currentAngle += anglePortion;
        }
        
        // Store the absolute angle position
        data.subAngles.push(currentAngle);
      }
      
      // Make sure subAngles are always properly ordered
      data.subAngles.sort((a, b) => a - b);
      
      // Update the angle values to match the sorted positions
      for (let i = 0; i < data.subAngles.length; i++) {
        if (i === 0) {
          data.subAngleValues[i] = Math.round((data.subAngles[i] - start) * 180 / Math.PI);
        } else {
          data.subAngleValues[i] = Math.round((data.subAngles[i] - data.subAngles[i-1]) * 180 / Math.PI);
        }
      }
    } else {
      // Default: evenly distribute
      for (let i = 1; i < data.subdivisions; i++) {
        const angleValue = Math.round((totalAngleRad / data.subdivisions) * 180 / Math.PI);
        
        // Ensure we have enough values in the array
        if (i-1 < data.subAngleValues.length) {
          data.subAngleValues[i-1] = angleValue;
        } else {
          data.subAngleValues.push(angleValue);
        }
        
        data.subAngles.push(start + (end-start)*i/data.subdivisions);
      }
      
      // Make sure array size matches subdivisions
      data.subAngleValues = data.subAngleValues.slice(0, data.subdivisions - 1);
    }
  }
  
  // Update custom spans measures
  function updateCustomSpansMeasures() {
    const data = container.angleData;
    const v1 = Math.atan2(data.points[0].y - data.points[1].y, data.points[0].x - data.points[1].x);
    const v2 = Math.atan2(data.points[2].y - data.points[1].y, data.points[2].x - data.points[1].x);
    let start = v1, end = v2;
    if (end < start) end += 2 * Math.PI;
    const totalAngleDegrees = Math.round((end - start) * 180 / Math.PI);
    
    data.customSpans.forEach(span => {
      if (span.type === 'whole') {
        span.measure = totalAngleDegrees;
      } else if (span.type === 'sub') {
        // Calculate the measure of this span
        let spanMeasure = 0;
        for (let i = span.indices[0]; i <= span.indices[span.indices.length - 1]; i++) {
          if (i === data.subdivisions - 1) {
            // Last segment - use remaining angle
            const totalSubAngles = data.subAngleValues.reduce((sum, val) => sum + val, 0);
            spanMeasure += totalAngleDegrees - totalSubAngles;
          } else {
            spanMeasure += data.subAngleValues[i];
          }
        }
        span.measure = Math.round(spanMeasure);
      }
    });
  }
  
  // Draw solid arrow
  function drawSolidArrow(x1, y1, x2, y2) {
    const ang = Math.atan2(y2 - y1, x2 - x1);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.stroke();
    
    const p1x = x2 - headLen * Math.cos(ang - Math.PI/6);
    const p1y = y2 - headLen * Math.sin(ang - Math.PI/6);
    const p2x = x2 - headLen * Math.cos(ang + Math.PI/6);
    const p2y = y2 - headLen * Math.sin(ang + Math.PI/6);
    
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(p1x, p1y);
    ctx.lineTo(p2x, p2y);
    ctx.closePath();
    ctx.fillStyle = '#333';
    ctx.fill();
  }
  
  // Function to draw a right angle symbol with perpendicular lines that meet
  function drawRightAngleSymbol(x, y, angle1, angle2) {
    const radius = arcR * 0.6;  // Distance from center
    const markSize = 22;  // Size of the right angle mark
    
    // Find points along each ray at radius distance
    const p1x = x + radius * Math.cos(angle1);
    const p1y = y + radius * Math.sin(angle1);
    
    const p2x = x + radius * Math.cos(angle2);
    const p2y = y + radius * Math.sin(angle2);
    
    // Calculate perpendicular directions
    const perpAngle1 = angle1 + Math.PI/2;  // Perpendicular to first ray
    const perpAngle2 = angle2 - Math.PI/2;  // Perpendicular to second ray
    
    // Calculate the endpoints of the perpendicular lines
    const end1x = p1x + markSize * Math.cos(perpAngle1);
    const end1y = p1y + markSize * Math.sin(perpAngle1);
    
    const end2x = p2x + markSize * Math.cos(perpAngle2);
    const end2y = p2y + markSize * Math.sin(perpAngle2);
    
    // Draw the perpendicular lines as a single path
    ctx.beginPath();
    ctx.moveTo(p1x, p1y);
    ctx.lineTo(end1x, end1y);
    ctx.lineTo(end2x, end2y);
    ctx.lineTo(p2x, p2y);
    
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }
  
  // Function to check if an angle is exactly 90 degrees



// always returns the smaller of the two angles between a→b
function getInteriorAngle(a, b) {
  let d = (b - a + 2*Math.PI) % (2*Math.PI);
  return d > Math.PI ? 2*Math.PI - d : d;
}

function isRightAngleRad(rad) {
  const deg = ((rad + 2*Math.PI) % (2*Math.PI)) * 180/Math.PI;
  // flip to interior if >180°
  const interior = deg > 180 ? 360 - deg : deg;
  return Math.abs(interior - 90) < 1.0;  // Increased tolerance from 0.5 to 1.0
}

// now takes only B, start/end, and your sub‐angle data
function drawAnyRightAngles(B, start, end, subVals, subAngles) {
  const rays = [ start, ...subAngles, end ];
  const drawn = [];

  // single segments
  for (let i = 0; i < rays.length - 1; i++) {
    const a = rays[i], b = rays[i+1];
    if (isRightAngleRad(b - a)) {
      drawRightAngleSymbol(B.x, B.y, a, b);
      drawn.push(`${i}-${i+1}`);
    }
  }

  // contiguous sums of sub‐angles
  for (let i = 0; i < subVals.length; i++) {
    let sumDeg = 0;
    for (let j = i; j < subVals.length; j++) {
      sumDeg += subVals[j];
      if (Math.abs(sumDeg - 90) < 1) {
        const a = rays[i], b = rays[j+1];
        const key = `${i}-${j+1}`;
        if (!drawn.includes(key)) {
          drawRightAngleSymbol(B.x, B.y, a, b);
          drawn.push(key);
        }
      }
    }
  }
}

  // ——— align C to the starting angleDegrees ———
(function alignStartAngle() {
  const data = container.angleData;
  const deg  = parseFloat(data.angleDegrees);
  if (isNaN(deg)) return;
  // current length of BC
  const len = Math.hypot(
    data.points[2].x - data.points[1].x,
    data.points[2].y - data.points[1].y
  );
  // base direction BA
  const baseAng = Math.atan2(
    data.points[0].y - data.points[1].y,
    data.points[0].x - data.points[1].x
  );
  const rad = deg * Math.PI / 180;
  // rotate C to baseAng + rad
  data.points[2].x = data.points[1].x + len * Math.cos(baseAng + rad);
  data.points[2].y = data.points[1].y + len * Math.sin(baseAng + rad);
})();


  // Main draw function
  function drawAngle() {
    const data = container.angleData;
    
    // Get current canvas dimensions
    const width = angleCanvas.width;
    const height = angleCanvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    const B = data.points[1];
    
    // Draw arrows
  // Calculate the maximum ray length (90% of the smallest container dimension)
const maxRayLength = Math.min(width, height) * 0.45; // 45% from center = 90% of dimension

// Function to extend ray to fixed length
function getFixedLengthRayEnd(center, direction, length) {
  const angle = Math.atan2(direction.y - center.y, direction.x - center.x);
  return {
    x: center.x + length * Math.cos(angle),
    y: center.y + length * Math.sin(angle)
  };
}

// Get fixed-length endpoints for main rays
const rayEnd0 = getFixedLengthRayEnd(B, data.points[0], maxRayLength);
const rayEnd2 = getFixedLengthRayEnd(B, data.points[2], maxRayLength);

// Draw arrows with fixed-length endpoints
drawSolidArrow(B.x, B.y, rayEnd0.x, rayEnd0.y);
drawSolidArrow(B.x, B.y, rayEnd2.x, rayEnd2.y);
    
    // Draw subdivisions if any
    // Draw subdivisions if any
if (data.subAngles && data.subAngles.length > 0) {
  data.subAngles.forEach(theta => {
    // Create a fixed-length ray at this angle
    const rx = B.x + maxRayLength * Math.cos(theta);
    const ry = B.y + maxRayLength * Math.sin(theta);
    
    // Draw the subdivision ray
    drawSolidArrow(B.x, B.y, rx, ry);
  });
}
    // Get angle information
    const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
    const v2 = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
    let start = v1, end = v2;
  if (end < start) end += 2 * Math.PI;

// **1) your existing generic check**
// ① generic right-angle detection
drawAnyRightAngles(B, start, end, data.subAngleValues, data.subAngles);

// ② extra check: start at the rightmost segment and accumulate backwards
const segmentValues = data.subAngleValues.slice(); 
const totalDeg = Math.round((end - start) * 180 / Math.PI);
const sumOfSubs = segmentValues.reduce((sum, v) => sum + v, 0);
// now push the “last” segment measure
segmentValues.push(totalDeg - sumOfSubs);

// build the full ray-angles array
const raysExtra = [ start, ...data.subAngles, end ];

let acc = 0;
// walk from the last segment backwards
for (let i = segmentValues.length - 1; i >= 0; i--) {
  acc += segmentValues[i];
  if (Math.abs(acc - 90) < 0.5) {
    // raysExtra[i] is the start ray for this 90° span, raysExtra[last] is 'end'
    drawRightAngleSymbol(B.x, B.y, raysExtra[i], raysExtra[raysExtra.length - 1]);
    break;
  }
}

// ③ big-angle fallback (your existing hack)
const mainDeg = ((end - start) * 180/Math.PI + 360) % 360;
const interior = mainDeg > 180 ? 360 - mainDeg : mainDeg;
if (Math.abs(interior - 90) < 0.5) {
  drawRightAngleSymbol(B.x, B.y, start, end);
}

// …then continue drawing your spans/arcs/etc.


    drawAnyRightAngles(B, start, end, data.subAngleValues, data.subAngles);
    
    // Draw spans based on span mode
    if (data.spanMode === 'all') {
      // Draw sub-arcs if there are subdivisions
      if (data.subdivisions > 1) {
        let currentStart = start;
        const colors = ['#0000ff', '#ff0000', '#00A000', '#A000A0']; // Blue, red, green, purple
        
        // Draw each subarc
        data.subAngles.forEach((theta, i) => {
          ctx.beginPath();
          ctx.arc(B.x, B.y, arcR, currentStart, theta);
          ctx.lineWidth = 3;
          ctx.strokeStyle = colors[i % colors.length];
          ctx.stroke();
          
          // Add notation and measure
          const midAngle = (currentStart + theta) / 2;
          
          // Get label position with offset if it exists
          const arcLabelKey = `arc-${i}`;
          let offset = data.labelOffsets[arcLabelKey] || { x: 0, y: 0 };
          const labelX = B.x + (arcR + 20) * Math.cos(midAngle) + offset.x;
          const labelY = B.y + (arcR + 20) * Math.sin(midAngle) + offset.y;
          
          const angleDeg = Math.round((theta - currentStart) * 180 / Math.PI);
          ctx.font = `${Math.round(data.fontSize * 0.85)}px sans-serif`;
          ctx.fillStyle = colors[i % colors.length];
          
          let labelText = '';
          if (data.showAngleNotation) {
            if (i === 0) {
              labelText += `∠${data.labels[0]}${data.labels[1]}${data.subLabels[0] || 'D'} `;
            } else {
              labelText += `∠${data.subLabels[i-1] || 'X'}${data.labels[1]}${data.subLabels[i] || 'Y'} `;
            }
          }
          if (data.showAngleMeasure) {
            labelText += `${angleDeg}°`;
          }
          
          ctx.fillText(labelText, labelX, labelY);
          
          currentStart = theta;
        });
        
        // Last segment
        ctx.beginPath();
        ctx.arc(B.x, B.y, arcR, currentStart, end);
        ctx.lineWidth = 3;
        ctx.strokeStyle = colors[data.subAngles.length % colors.length];
        ctx.stroke();
        
        // Add notation and measure for last segment
        const midAngle = (currentStart + end) / 2;
        
        // Get label position with offset if it exists
        const arcLabelKey = `arc-${data.subAngles.length}`;
        let offset = data.labelOffsets[arcLabelKey] || { x: 0, y: 0 };
        const labelX = B.x + (arcR + 20) * Math.cos(midAngle) + offset.x;
        const labelY = B.y + (arcR + 20) * Math.sin(midAngle) + offset.y;
        
        const angleDeg = Math.round((end - currentStart) * 180 / Math.PI);
        ctx.font = `${Math.round(data.fontSize * 0.85)}px sans-serif`;
        ctx.fillStyle = colors[data.subAngles.length % colors.length];
        
        let labelText = '';
        if (data.showAngleNotation) {
          labelText += `∠${data.subLabels[data.subAngles.length-1] || 'X'}${data.labels[1]}${data.labels[2]} `;
        }
        if (data.showAngleMeasure) {
          labelText += `${angleDeg}°`;
        }
        
        ctx.fillText(labelText, labelX, labelY);
      } else {
        // If no subdivisions, just draw the main arc
        ctx.beginPath();
        ctx.arc(B.x, B.y, arcR, start, end);
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#0000ff'; // Blue for single arc
        ctx.stroke();
        
        // Add angle notation and measure to main arc
        const midAngle = (start + end) / 2;
        
        // Get position with offset
        const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
        const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
        const offset = data.mainAngleLabelOffset || { x: 0, y: 0 };
        const labelX = baseX + offset.x;
        const labelY = baseY + offset.y;
        
        ctx.font = `${data.fontSize}px sans-serif`;
        ctx.fillStyle = '#0000ff';
        
        let labelText = '';
        if (data.showAngleNotation) {
          labelText += `∠${data.labels[0]}${data.labels[1]}${data.labels[2]} `;
        }
        if (data.showAngleMeasure) {
          labelText += `${parseFloat(data.angleDegrees) || 60}°`;
        }
        
        ctx.fillText(labelText, labelX, labelY);
      }
    } else if (data.spanMode === 'whole') {
      // Draw whole angle arc
      ctx.beginPath();
      ctx.arc(B.x, B.y, arcR, start, end);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#0000ff'; // Blue for whole arc
      ctx.stroke();
      
      // Add angle notation and measure
      const midAngle = (start + end) / 2;
      
      // Calculate position with offset
      const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
      const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
      const offset = data.mainAngleLabelOffset || { x: 0, y: 0 };
      const labelX = baseX + offset.x;
      const labelY = baseY + offset.y;
      
      ctx.font = `${data.fontSize}px sans-serif`;
      ctx.fillStyle = '#0000ff';
      
      let labelText = '';
      if (data.showAngleNotation) {
        labelText += `∠${data.labels[0]}${data.labels[1]}${data.labels[2]} `;
      }
      if (data.showAngleMeasure) {
        labelText += `${parseFloat(data.angleDegrees) || 60}°`;
      }
      
      ctx.fillText(labelText, labelX, labelY);
    } else if (data.spanMode === 'custom') {
      // Custom spans mode
      if (data.customSpans.length === 0) {
        // If no custom spans, just draw a light outline of the total angle
        ctx.beginPath();
        ctx.arc(B.x, B.y, arcR, start, end);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#aaaaaa';
        ctx.stroke();
        
        // Add total angle notation and measure with light color
        if (data.showAngleNotation || data.showAngleMeasure) {
          const midAngle = (start + end) / 2;
          
          // Calculate position with offset
          const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
          const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
          const offset = data.mainAngleLabelOffset || { x: 0, y: 0 };
          const labelX = baseX + offset.x;
          const labelY = baseY + offset.y;
          
          ctx.font = `${data.fontSize}px sans-serif`;
          ctx.fillStyle = '#aaaaaa';
          
          let labelText = '';
          if (data.showAngleNotation) {
            labelText += `∠${data.labels[0]}${data.labels[1]}${data.labels[2]} `;
          }
          if (data.showAngleMeasure) {
            labelText += `${parseFloat(data.angleDegrees) || 60}°`;
          }
          
          ctx.fillText(labelText, labelX, labelY);
        }
      } else {
        // Draw each custom span
        
        // Create a mapping to track which radius is used at each angular position
        const spanRadiusMap = new Map();
        
        // First pass to determine minimum required radius for each span
        data.customSpans.forEach((span, index) => {
          // Start with base radius
          let radiusOffset = baseSpanRadius;
          
          // Get angular range for this span
          let spanStart, spanEnd;
          if (span.type === 'whole') {
            spanStart = start;
            spanEnd = end;
          } else if (span.type === 'sub') {
            // For start angle: if first index is 0, use global start, else use subAngles[index - 1]
            if (span.indices[0] === 0) {
              spanStart = start;
            } else {
              spanStart = data.subAngles[span.indices[0] - 1];
            }
            
            // For end angle: if last index is the last segment, use global end, else use subAngles[index]
            if (span.indices[span.indices.length - 1] === data.subdivisions - 1) {
              spanEnd = end;
            } else {
              spanEnd = data.subAngles[span.indices[span.indices.length - 1]];
            }
          }
          
          // Check for overlaps with previously assigned spans
          for (let i = 0; i < index; i++) {
            const otherSpan = data.customSpans[i];
            let otherStart, otherEnd;
            
            if (otherSpan.type === 'whole') {
              otherStart = start;
              otherEnd = end;
            } else if (otherSpan.type === 'sub') {
              if (otherSpan.indices[0] === 0) {
                otherStart = start;
              } else {
                otherStart = data.subAngles[otherSpan.indices[0] - 1];
              }
              
              if (otherSpan.indices[otherSpan.indices.length - 1] === data.subdivisions - 1) {
                otherEnd = end;
              } else {
                otherEnd = data.subAngles[otherSpan.indices[otherSpan.indices.length - 1]];
              }
            }
            
            // Check for overlap
            const overlaps = 
              (spanStart < otherEnd && otherStart < spanEnd);
            
            if (overlaps) {
              const otherRadius = otherSpan.radius || baseSpanRadius;
              if (radiusOffset <= otherRadius) {
                radiusOffset = otherRadius + spanRadiusIncrement;
              }
            }
          }
          
          // Store the determined radius
          span.radius = radiusOffset;
        });
        
        // Second pass to draw spans
        data.customSpans.forEach((span, index) => {
          const radiusOffset = span.radius || baseSpanRadius;
          
          if (span.type === 'whole') {
            // Draw whole angle span
            ctx.beginPath();
            ctx.arc(B.x, B.y, radiusOffset, start, end);
            ctx.lineWidth = 3;
            ctx.strokeStyle = span.color;
            ctx.stroke();
            
            // Add notation and measure
            const midAngle = (start + end) / 2;
            
            // Get position with offset
            const baseX = B.x + (radiusOffset + 20) * Math.cos(midAngle);
            const baseY = B.y + (radiusOffset + 20) * Math.sin(midAngle);
            const spanKey = `span-${index}`;
            const offset = data.spanLabelOffsets[spanKey] || { x: 0, y: 0 };
            const labelX = baseX + offset.x;
            const labelY = baseY + offset.y;
            
            ctx.font = `${data.fontSize}px sans-serif`;
            ctx.fillStyle = span.color;
            
            let labelText = '';
            if (data.showAngleNotation) {
              labelText += `${span.notation} `;
            }
            if (data.showAngleMeasure) {
              labelText += `${span.measure}°`;
            }
            
            ctx.fillText(labelText, labelX, labelY);
          } else if (span.type === 'sub') {
            // Draw subangle span
            let segmentStart, segmentEnd;
            
            // For start angle: if first index is 0, use global start, else use subAngles[index - 1]
            if (span.indices[0] === 0) {
              segmentStart = start;
            } else {
              segmentStart = data.subAngles[span.indices[0] - 1];
            }
            
            // For end angle: if last index is the last segment, use global end, else use subAngles[index]
            if (span.indices[span.indices.length - 1] === data.subdivisions - 1) {
              segmentEnd = end;
            } else {
              segmentEnd = data.subAngles[span.indices[span.indices.length - 1]];
            }
            
            ctx.beginPath();
            ctx.arc(B.x, B.y, radiusOffset, segmentStart, segmentEnd);
            ctx.lineWidth = 3;
            ctx.strokeStyle = span.color;
            ctx.stroke();
            
            // Add notation and measure
            const midAngle = (segmentStart + segmentEnd) / 2;
            
            // Get position with offset
            const baseX = B.x + (radiusOffset + 20) * Math.cos(midAngle);
            const baseY = B.y + (radiusOffset + 20) * Math.sin(midAngle);
            const spanKey = `span-${index}`;
            const offset = data.spanLabelOffsets[spanKey] || { x: 0, y: 0 };
            const labelX = baseX + offset.x;
            const labelY = baseY + offset.y;
            
            ctx.font = `${data.fontSize}px sans-serif`;
            ctx.fillStyle = span.color;
            
            let labelText = '';
            if (data.showAngleNotation) {
              labelText += `${span.notation} `;
            }
            if (data.showAngleMeasure) {
              labelText += `${span.measure}°`;
            }
            
            ctx.fillText(labelText, labelX, labelY);
          }
        });
      }
    }
    
 
    
    // Draw points
    if (data.showPoints) {
      // Draw handles for main points
    // Draw handles for main points - positioned at 80% of the fixed ray length
[data.points[0], data.points[2]].forEach((p, i) => {
  const ang = Math.atan2(p.y - B.y, p.x - B.x);
  
  // Use 80% of the fixed ray length for handle positioning
  const handleFactor = 0.8;
  const hx = B.x + maxRayLength * handleFactor * Math.cos(ang);
  const hy = B.y + maxRayLength * handleFactor * Math.sin(ang);
  
  ctx.beginPath();
  ctx.arc(hx, hy, data.pointSize, 0, 2 * Math.PI);
  ctx.fillStyle = '#000';
  ctx.fill();
});
      
      // Draw handles for subdivision points
 // Draw handles for subdivision points - positioned at 80% of the fixed ray length
if (data.subAngles && data.subAngles.length > 0) {
  data.subAngles.forEach(theta => {
    // Use 80% of the fixed ray length for handle positioning
    const handleFactor = 0.8;
    const hx = B.x + maxRayLength * handleFactor * Math.cos(theta);
    const hy = B.y + maxRayLength * handleFactor * Math.sin(theta);
    
    ctx.beginPath();
    ctx.arc(hx, hy, data.pointSize, 0, 2 * Math.PI);
    ctx.fillStyle = '#000';
    ctx.fill();
  });
}
      
      // Draw center point B
      ctx.beginPath();
      ctx.arc(B.x, B.y, data.pointSize, 0, 2 * Math.PI);
      ctx.fillStyle = '#000';
      ctx.fill();
    }
    
    // Draw labels
    if (data.showLabels) {
      // Draw main labels
      data.points.forEach((p, i) => {
        const ang = Math.atan2(p.y - B.y, p.x - B.x);
        const len = rayLength(p);
        
        let baseX, baseY;
        if (i === 1) {
          baseX = p.x;
          baseY = p.y;
        } else {
          baseX = B.x + len * handleFactor * Math.cos(ang);
          baseY = B.y + len * handleFactor * Math.sin(ang);
        }
        
        // Get offset
        const labelKey = `main-${i}`;
        const offset = data.labelOffsets[labelKey] || { x: 4, y: -4 };
        
        const labelX = baseX + offset.x;
        const labelY = baseY + offset.y;
        
        ctx.font = `${data.labelFontSize}px sans-serif`;
        ctx.fillStyle = '#333';
        ctx.fillText(data.labels[i], labelX, labelY);
      });
      
      // Draw sublabels
      if (data.subLabels && data.subLabels.length > 0 && data.subAngles && data.subAngles.length > 0) {
        data.subAngles.forEach((theta, i) => {
          const baseX = B.x + lenAvg * handleFactor * Math.cos(theta);
          const baseY = B.y + lenAvg * handleFactor * Math.sin(theta);
          
          // Get offset
          const labelKey = `sub-${i}`;
          const offset = data.labelOffsets[labelKey] || { x: 4, y: -4 };
          
          const labelX = baseX + offset.x;
          const labelY = baseY + offset.y;
          
          ctx.font = `${data.labelFontSize}px sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(data.subLabels[i] || '', labelX, labelY);
        });
      }
    }
  }
  
  // Resize and initialize
// Resize and initialize
// Resize and initialize (with proportional scaling)
function resize() {
  const angleContent = angleCanvas.parentElement;
  const newWidth  = angleContent.clientWidth;
  const newHeight = angleContent.clientHeight;

  // Remember old canvas size & center
  const oldWidth  = angleCanvas.width;
  const oldCenter = {
    x: container.angleData.points[1].x,
    y: container.angleData.points[1].y
  };

  // Compute uniform scale factor (your resize handle maintains aspect ratio)
  const scale = newWidth / oldWidth;

  // Resize the drawing surface
  angleCanvas.width  = newWidth;
  angleCanvas.height = newHeight;

  // New canvas center
  const newCenter = {
    x: newWidth  / 2,
    y: newHeight / 2
  };

  // Scale each point about the canvas center
  container.angleData.points.forEach(p => {
    p.x = newCenter.x + (p.x - oldCenter.x) * scale;
    p.y = newCenter.y + (p.y - oldCenter.y) * scale;
  });

  // (Optional) scale any label‐offsets the same way
  Object.values(container.angleData.labelOffsets).forEach(off => {
    off.x *= scale;
    off.y *= scale;
  });
  Object.values(container.angleData.spanLabelOffsets).forEach(off => {
    off.x *= scale;
    off.y *= scale;
  });

  // Recompute sub‐angles (if you’re using dynamic subdivisions)
  computeSubAngles();

  // Redraw at the new size
  drawAngle();
}

  
  // Mouse event handlers for interactivity
  let dragType = null;
let dragIndex = null;
let dragLabelType = null;
let dragLabelIndex = null;
  
angleCanvas.addEventListener('mousedown', function(e) {
  if (!container.contains(e.target)) return;
  
  const rect = angleCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const data = container.angleData;
  const B = data.points[1];
  const lenAvg = (rayLength(data.points[0]) + rayLength(data.points[2])) / 2;
  
  // Check for label dragging if enabled
  if (data.draggableLabels) {
    // Check for main angle label dragging
    if ((data.spanMode === 'all' && data.subdivisions === 1) || 
        data.spanMode === 'whole' || 
        (data.spanMode === 'custom' && data.customSpans.length === 0)) {
      
      const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
      const v2 = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
      let start = v1, end = v2;
      if (end < start) end += 2 * Math.PI;
      
      // Calculate midpoint for main angle
      const midAngle = (start + end) / 2;
      
      // Get position with offset
      const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
      const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
      const offset = data.mainAngleLabelOffset || { x: 0, y: 0 };
      const labelX = baseX + offset.x;
      const labelY = baseY + offset.y;
      
      // Build label text
      let labelText = '';
      if (data.showAngleNotation) {
        labelText += `∠${data.labels[0]}${data.labels[1]}${data.labels[2]} `;
      }
      if (data.showAngleMeasure) {
        labelText += `${parseFloat(data.angleDegrees) || 60}°`;
      }
      
      // Check if mouse is within label area
      const labelWidth = labelText.length * data.fontSize * 0.6;
      const labelHeight = data.fontSize;
      
      if (mx >= labelX - 5 && mx <= labelX + labelWidth + 5 && 
          my >= labelY - labelHeight - 5 && my <= labelY + 5) {
        dragLabelType = 'main-angle';
        return;
      }
    }
    
    // Check for arc label dragging
    if (data.spanMode === 'all' && data.subdivisions > 1) {
      let currentStart = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
      const end = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
      let normalizedEnd = end < currentStart ? end + 2 * Math.PI : end;
      
      // Check each subarc label
      for (let i = 0; i <= data.subAngles.length; i++) {
        let segmentEnd;
        if (i < data.subAngles.length) {
          segmentEnd = data.subAngles[i];
        } else {
          segmentEnd = normalizedEnd;
        }
        
        // Calculate midpoint angle
        const midAngle = (currentStart + segmentEnd) / 2;
        
        // Get label position with offset
        const arcLabelKey = `arc-${i}`;
        let offset = data.labelOffsets[arcLabelKey] || { x: 0, y: 0 };
        const labelX = B.x + (arcR + 20) * Math.cos(midAngle) + offset.x;
        const labelY = B.y + (arcR + 20) * Math.sin(midAngle) + offset.y;
        
        // Determine label size
        let labelText;
        if (i === 0) {
          labelText = `∠${data.labels[0]}${data.labels[1]}${data.subLabels[0] || 'D'} ${Math.round((segmentEnd - currentStart) * 180 / Math.PI)}°`;
        } else if (i === data.subAngles.length) {
          labelText = `∠${data.subLabels[i-1] || 'X'}${data.labels[1]}${data.labels[2]} ${Math.round((segmentEnd - currentStart) * 180 / Math.PI)}°`;
        } else {
          labelText = `∠${data.subLabels[i-1] || 'X'}${data.labels[1]}${data.subLabels[i] || 'Y'} ${Math.round((segmentEnd - currentStart) * 180 / Math.PI)}°`;
        }
        
        // Check if mouse is in label area
        const labelWidth = labelText.length * data.fontSize * 0.6;
        const labelHeight = data.fontSize;
        
        if (mx >= labelX - 5 && mx <= labelX + labelWidth + 5 && 
            my >= labelY - labelHeight - 5 && my <= labelY + 5) {
          dragLabelType = 'arc';
          dragLabelIndex = i;
          return;
        }
        
        currentStart = segmentEnd;
      }
    }
    
    // Check for span label dragging
    if (data.spanMode === 'custom' && data.customSpans.length > 0) {
      for (let index = 0; index < data.customSpans.length; index++) {
        const span = data.customSpans[index];
        
        // Calculate midAngle
        let midAngle;
        if (span.type === 'whole') {
          const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
          const v2 = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
          let start = v1, end = v2;
          if (end < start) end += 2 * Math.PI;
          midAngle = (start + end) / 2;
        } else {
          let segmentStart, segmentEnd;
          if (span.indices[0] === 0) {
            segmentStart = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
          } else {
            segmentStart = data.subAngles[span.indices[0] - 1];
          }
          
          if (span.indices[span.indices.length - 1] === data.subdivisions - 1) {
            segmentEnd = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
            if (segmentEnd < segmentStart) segmentEnd += 2 * Math.PI;
          } else {
            segmentEnd = data.subAngles[span.indices[span.indices.length - 1]];
          }
          
          midAngle = (segmentStart + segmentEnd) / 2;
        }
        
        // Calculate position
        const radiusOffset = span.radius || baseSpanRadius;
        const baseX = B.x + (radiusOffset + 20) * Math.cos(midAngle);
        const baseY = B.y + (radiusOffset + 20) * Math.sin(midAngle);
        const spanKey = `span-${index}`;
        const offset = data.spanLabelOffsets[spanKey] || { x: 0, y: 0 };
        const labelX = baseX + offset.x;
        const labelY = baseY + offset.y;
        
        // Check if mouse is on this label
        let labelText = '';
        if (data.showAngleNotation) {
          labelText += `${span.notation} `;
        }
        if (data.showAngleMeasure) {
          labelText += `${span.measure}°`;
        }
        
        const labelWidth = labelText.length * data.fontSize * 0.6;
        const labelHeight = data.fontSize;
        
        if (mx >= labelX - 5 && mx <= labelX + labelWidth + 5 && 
            my >= labelY - labelHeight - 5 && my <= labelY + 5) {
          dragLabelType = 'span';
          dragLabelIndex = index;
          return;
        }
      }
    }
    
    // Check for main point labels
    if (data.showLabels) {
      // Check main labels
      for (let i = 0; i < data.points.length; i++) {
        const p = data.points[i];
        const ang = Math.atan2(p.y - B.y, p.x - B.x);
        const len = rayLength(p);
        
        let baseX, baseY;
        if (i === 1) {
          baseX = p.x;
          baseY = p.y;
        } else {
          baseX = B.x + len * handleFactor * Math.cos(ang);
          baseY = B.y + len * handleFactor * Math.sin(ang);
        }
        
        // Get offset
        const labelKey = `main-${i}`;
        const offset = data.labelOffsets[labelKey] || { x: 4, y: -4 };
        
        const labelX = baseX + offset.x;
        const labelY = baseY + offset.y;
        
        // Check if clicked on label
        const labelWidth = data.labels[i].length * data.labelFontSize * 0.6;
        const labelHeight = data.labelFontSize;
        
        if (mx >= labelX - 5 && mx <= labelX + labelWidth + 5 && 
            my >= labelY - labelHeight - 5 && my <= labelY + 5) {
          dragLabelType = 'main';
          dragLabelIndex = i;
          return;
        }
      }
      
      // Check sublabels
      if (data.subLabels && data.subLabels.length > 0 && data.subAngles && data.subAngles.length > 0) {
        for (let i = 0; i < data.subAngles.length; i++) {
          const theta = data.subAngles[i];
          const baseX = B.x + lenAvg * handleFactor * Math.cos(theta);
          const baseY = B.y + lenAvg * handleFactor * Math.sin(theta);
          
          // Get offset
          const labelKey = `sub-${i}`;
          const offset = data.labelOffsets[labelKey] || { x: 4, y: -4 };
          
          const labelX = baseX + offset.x;
          const labelY = baseY + offset.y;
          
          // Check if clicked on label
          const labelText = data.subLabels[i] || '';
          const labelWidth = labelText.length * data.labelFontSize * 0.6;
          const labelHeight = data.labelFontSize;
          
          if (mx >= labelX - 5 && mx <= labelX + labelWidth + 5 && 
              my >= labelY - labelHeight - 5 && my <= labelY + 5) {
            dragLabelType = 'sub';
            dragLabelIndex = i;
            return;
          }
        }
      }
    }
  }
  
  // Check for point dragging
  // First find all possible points that could be selected
  let candidatePoints = [];
  
  // Add subhandles to candidates
  if (data.subAngles && data.subAngles.length > 0) {
    for (let i = 0; i < data.subAngles.length; i++) {
      const theta = data.subAngles[i];
      const hx = B.x + lenAvg * handleFactor * Math.cos(theta);
      const hy = B.y + lenAvg * handleFactor * Math.sin(theta);
      const distance = Math.hypot(mx - hx, my - hy);
      
      if (distance < data.pointSize * 1.5) {
        candidatePoints.push({
          type: 'sub',
          index: i,
          distance: distance,
          x: hx,
          y: hy
        });
      }
    }
  }
  
  // Add main handles to candidates
  data.points.forEach((p, i) => {
    if (i !== 1) { // Skip center point B
      const ang = Math.atan2(p.y - B.y, p.x - B.x);
      const len = rayLength(p);
      const hx = B.x + len * handleFactor * Math.cos(ang);
      const hy = B.y + len * handleFactor * Math.sin(ang);
      const distance = Math.hypot(mx - hx, my - hy);
      
      if (distance < data.pointSize * 1.5) {
        candidatePoints.push({
          type: 'main',
          index: i,
          distance: distance,
          x: hx,
          y: hy
        });
      }
    }
  });
  
  // Sort candidates by distance to find the closest one
  if (candidatePoints.length > 0) {
    candidatePoints.sort((a, b) => a.distance - b.distance);
    const closest = candidatePoints[0];
    dragType = closest.type;
    dragIndex = closest.index;
  }
});

angleCanvas.addEventListener('mousemove', function(e) {
  if (!container.contains(e.target)) return;
  if (!dragType && !dragLabelType) return;
  
  const rect = angleCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const data = container.angleData;
  const B = data.points[1];
  
  // Handle main angle label dragging
  if (dragLabelType === 'main-angle') {
    const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
    const v2 = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
    let start = v1, end = v2;
    if (end < start) end += 2 * Math.PI;
    
    // Calculate midpoint for main angle
    const midAngle = (start + end) / 2;
    
    // Calculate base position (without offset)
    const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
    const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
    
    // Update main angle label offset
    data.mainAngleLabelOffset = {
      x: mx - baseX,
      y: my - baseY
    };
    
    drawAngle();
    return;
  }
  
  // Handle arc label dragging
  if (dragLabelType === 'arc') {
    // Calculate the base position for this arc label
    let currentStart = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
    const end = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
    let normalizedEnd = end < currentStart ? end + 2 * Math.PI : end;
    
    // Find the start and end angles for this segment
    for (let i = 0; i < dragLabelIndex; i++) {
      if (i < data.subAngles.length) {
        currentStart = data.subAngles[i];
      }
    }
    
    let segmentEnd;
    if (dragLabelIndex < data.subAngles.length) {
      segmentEnd = data.subAngles[dragLabelIndex];
    } else {
      segmentEnd = normalizedEnd;
    }
    
    // Calculate midpoint angle
    const midAngle = (currentStart + segmentEnd) / 2;
    
    // Calculate base position (without offset)
    const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
    const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
    
    // Store the new offset
    const arcLabelKey = `arc-${dragLabelIndex}`;
    data.labelOffsets[arcLabelKey] = {
      x: mx - baseX,
      y: my - baseY
    };
    
    drawAngle();
    return;
  }
  
  // Handle span label dragging
  if (dragLabelType === 'span') {
    const span = data.customSpans[dragLabelIndex];
    
    // Calculate midAngle based on span type
    let midAngle;
    if (span.type === 'whole') {
      const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
      const v2 = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
      let start = v1, end = v2;
      if (end < start) end += 2 * Math.PI;
      midAngle = (start + end) / 2;
    } else {
      let segmentStart, segmentEnd;
      if (span.indices[0] === 0) {
        segmentStart = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
      } else {
        segmentStart = data.subAngles[span.indices[0] - 1];
      }
      
      if (span.indices[span.indices.length - 1] === data.subdivisions - 1) {
        segmentEnd = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
        if (segmentEnd < segmentStart) segmentEnd += 2 * Math.PI;
      } else {
        segmentEnd = data.subAngles[span.indices[span.indices.length - 1]];
      }
      
      midAngle = (segmentStart + segmentEnd) / 2;
    }
    
    // Calculate radius offset
    const radiusOffset = span.radius || baseSpanRadius;
    
    // Calculate anchor point (position without offset)
    const anchorX = B.x + (radiusOffset + 20) * Math.cos(midAngle);
    const anchorY = B.y + (radiusOffset + 20) * Math.sin(midAngle);
    
    // Calculate and store offset
    const spanKey = `span-${dragLabelIndex}`;
    data.spanLabelOffsets[spanKey] = {
      x: mx - anchorX,
      y: my - anchorY
    };
    
    drawAngle();
    return;
  }
  
  // Handle regular label dragging
  if (dragLabelType) {
    const labelKey = `${dragLabelType}-${dragLabelIndex}`;
    let anchorX, anchorY;
    
    if (dragLabelType === 'main') {
      // Get anchor point for main label
      const p = data.points[dragLabelIndex];
      const ang = Math.atan2(p.y - B.y, p.x - B.x);
      const len = rayLength(p);
      
      if (dragLabelIndex === 1) {
        anchorX = B.x;
        anchorY = B.y;
      } else {
        anchorX = B.x + len * handleFactor * Math.cos(ang);
        anchorY = B.y + len * handleFactor * Math.sin(ang);
      }
    } else {
      // Get anchor point for sublabel
      const theta = data.subAngles[dragLabelIndex];
      const lenAvg = (rayLength(data.points[0]) + rayLength(data.points[2])) / 2;
      anchorX = B.x + lenAvg * handleFactor * Math.cos(theta);
      anchorY = B.y + lenAvg * handleFactor * Math.sin(theta);
    }
    
    // Calculate offset from anchor
    const dx = mx - anchorX;
    const dy = my - anchorY;
    const dist = Math.hypot(dx, dy);
    
    if (dist <= labelDragRadius) {
      // Within radius, use exact offset
      data.labelOffsets[labelKey] = { x: dx, y: dy };
    } else {
      // Outside radius, clamp to the edge of the circle
      const scale = labelDragRadius / dist;
      data.labelOffsets[labelKey] = {
        x: dx * scale,
        y: dy * scale
      };
    }
    
    drawAngle();
    return;
  }
  
  // Handle point dragging
  if (dragType === 'main') {
    const len = rayLength(data.points[dragIndex]);
    const ang = Math.atan2(my - B.y, mx - B.x);
    data.points[dragIndex].x = B.x + len * Math.cos(ang);
    data.points[dragIndex].y = B.y + len * Math.sin(ang);
    
    // Update angle value
    const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
    const v2 = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
    let start = v1, end = v2;
    if (end < start) end += 2 * Math.PI;
    const angleDegrees = Math.round((end - start) * 180 / Math.PI);
    data.angleDegrees = angleDegrees;
    
    // Reset subangle values
    data.subAngleValues = [];
    computeSubAngles();
    
    // Update custom spans if any
    if (data.customSpans.length > 0) {
      updateCustomSpansMeasures();
    }
    
    drawAngle();
  } else if (dragType === 'sub') {
    // Get the angle boundaries for this subpoint
    const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
    let prevAngle = v1;
    let nextAngle = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
    if (nextAngle < prevAngle) nextAngle += 2 * Math.PI;
    
    // If this isn't the first subpoint, get the previous subpoint angle
    if (dragIndex > 0) {
      prevAngle = data.subAngles[dragIndex - 1];
    }
    
    // If this isn't the last subpoint, get the next subpoint angle
    if (dragIndex < data.subAngles.length - 1) {
      nextAngle = data.subAngles[dragIndex + 1];
    }
    
    // Calculate new angle from mouse position
    let newAng = Math.atan2(my - B.y, mx - B.x);
    
    // Normalize angles
    if (newAng < v1) newAng += 2 * Math.PI;
    
    // Constrain new angle to be between previous and next point
    newAng = Math.max(prevAngle, Math.min(nextAngle, newAng));
    
    // Update subangle array with new position
    data.subAngles[dragIndex] = newAng;
    
    // Calculate angle values for all subangles
    let currentAngle = v1;
    for (let i = 0; i < data.subAngles.length; i++) {
      const angleDiff = (i === dragIndex) ?
        (newAng - currentAngle) :
        (data.subAngles[i] - currentAngle);
      
      data.subAngleValues[i] = Math.round(angleDiff * 180 / Math.PI);
      currentAngle = data.subAngles[i];
    }
    
    // Update custom spans if needed
    if (data.customSpans.length > 0) {
      updateCustomSpansMeasures();
    }
    
    drawAngle();
  }
});

['mouseup', 'mouseleave'].forEach(ev => {
  angleCanvas.addEventListener(ev, function() {
    if (dragType || dragLabelType) {
      dragType = null;
      dragIndex = null;
      dragLabelType = null;
      dragLabelIndex = null;
    }
  });
});

// Functions for element activation and deactivation
function activateAngle() {
  // Deactivate the previously active element if any
  if (window.activeAngleElement && window.activeAngleElement !== container) {
    window.activeAngleElement.style.border = "none";
    
    const prevToolbar = window.activeAngleElement.querySelector(".angle-toolbar");
    const prevResizeHandle = window.activeAngleElement.querySelector(".resize-handle");
    
    if (prevToolbar) prevToolbar.style.display = "none";
    if (prevResizeHandle) prevResizeHandle.style.display = "none";
  }
  
  window.activeAngleElement = container;
  
  container.style.border = "1px dashed #ccc";
  localToolbar.style.display = "flex";
  resizeHandle.style.display = "block";
  
  updateGlobalToolbar();
}

function deactivateAngle() {
  if (window.activeAngleElement === container) {
    container.style.border = "none";
    localToolbar.style.display = "none";
    resizeHandle.style.display = "none";
    window.activeAngleElement = null;
    
    const globalToolbar = document.getElementById("global-toolbar");
    if (globalToolbar) {
      globalToolbar.innerHTML = "";
    }
  }
}

function deleteAngle() {
  if (window.activeAngleElement === container) {
    window.activeAngleElement = null;
  }
  
  try {
    if (container.parentNode) {
      container.parentNode.removeChild(container);
    }
    
    const globalToolbar = document.getElementById("global-toolbar");
    if (globalToolbar) globalToolbar.innerHTML = "";
  } catch (err) {
    console.error("Error removing container:", err);
  }
}

// Event listeners for container
container.addEventListener("mousedown", function(e) {
  if (e.target !== dragHandle && e.target !== resizeHandle) {
    activateAngle();
  }
});

deleteButton.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();
  deleteAngle();
});

deleteButton.addEventListener("click", function(e) {
  e.preventDefault();
  e.stopPropagation();
  deleteAngle();
});

// Resize handle functionality
// Resize handle functionality
resizeHandle.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  const startX = e.clientX;
  const startY = e.clientY;
  const startWidth = container.offsetWidth;
  const startHeight = container.offsetHeight;
  const initialRatio = startWidth / startHeight;
  
  function onMouseMove(e) {
    // Get new width based on mouse movement
  const newWidth  = Math.max(100, startWidth  + (e.clientX - startX));
const newHeight = Math.max(100, newWidth      / initialRatio);

    
    container.style.width = newWidth + "px";
    container.style.height = newHeight + "px";
    
    // Resize and redraw canvas
    resize();
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// Drag handle functionality
dragHandle.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  container.isDragging = false;
  const canvasRect = canvas.getBoundingClientRect();
  const rect = container.getBoundingClientRect();
  const startX = e.clientX;
  const startY = e.clientY;
  const shiftX = e.clientX - rect.left;
  const shiftY = e.clientY - rect.top;
  
  function onMouseMove(e) {
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    if (Math.sqrt(dx * dx + dy * dy) > 5) {
      container.isDragging = true;
    }
    
    const newLeft = e.clientX - shiftX - canvasRect.left;
    const newTop = e.clientY - shiftY - canvasRect.top;
    
    container.style.left = newLeft + "px";
    container.style.top = newTop + "px";
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// Document click for deactivation
// Document click for deactivation
document.addEventListener("click", function(e) {
  // Don't deactivate if clicked on the angle container
  if (container.contains(e.target)) {
    return;
  }
  
  // Don't deactivate if clicked on the global toolbar
  const globalToolbar = document.getElementById("global-toolbar");
  if (globalToolbar && globalToolbar.contains(e.target)) {
    return;
  }
  
  // Only deactivate if actually active
  if (window.activeAngleElement === container) {
    deactivateAngle();
  }
});

// Append to canvas and activate
canvas.appendChild(container);

// Store the draw function on the container so it can be called externally
container.drawAngle = drawAngle;

// Initialize
resize();

// Activate the angle
activateAngle();

return container;
}

// Add Number Line component to the canvas
function addNumberLine() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeNumberLineElement) {
    window.activeNumberLineElement = null;
  }
  // Global counter for number line IDs
  if (!window.globalNumberLineCounter) {
    window.globalNumberLineCounter = 1;
  } else {
    window.globalNumberLineCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element number-line-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "600px";
  container.style.height = (toolbarHeight + 150) + "px"; // Number line is shorter than quadrant graph
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this number line
  container.numberLineID = window.globalNumberLineCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-number-line-id', container.numberLineID);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "number-line-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);
  
  // Create content div
  const content = document.createElement("div");
  content.className = "number-line-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG for the number line
  const svgContainer = document.createElement("div");
  svgContainer.id = "numberLineSVG-" + container.numberLineID;
  svgContainer.style.width = "100%";
  svgContainer.style.height = "100%";
  content.appendChild(svgContainer);

  // Store the data needed for the number line
  container.numberLineData = {
    minValue: -10,
    maxValue: 10,
    tickInterval: 1,
    labelInterval: 1,
    points: [],
    inequalities: [],
    spans: []
  };

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Safe HTML encoding
  function escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function parseInput(input) {
  if (!input) {
    return null;
  }
  
  // If input is not a string, convert it to a string
  if (typeof input !== 'string') {
    input = String(input);
  }
  
  // Now we can safely trim
  input = input.trim();
  
  // Check if it's a fraction
  if (input.includes('/')) {
    const parts = input.split('/');
    if (parts.length !== 2) {
      return null;
    }
    
    const numerator = parseFloat(parts[0]);
    const denominator = parseFloat(parts[1]);
    
    if (isNaN(numerator) || isNaN(denominator) || denominator === 0) {
      return null;
    }
    
    return numerator / denominator;
  }
  
  // Otherwise, it's a regular number
  const num = parseFloat(input);
  return isNaN(num) ? null : num;
}

  // Fix for AND inequality checking
  function isNoSolutionAnd(ineq) {
    if (ineq.type !== 'and') return false;
    // Collect all ">" bounds as lows, all "<" bounds as highs
    const lows = [];
    const highs = [];

    [['operator1','value1'], ['operator2','value2']].forEach(([opKey,valKey])=>{
      const op = ineq[opKey], v = ineq[valKey];
      if (op === '>' || op === '>=') lows.push({v, inc: op==='>='}); 
      if (op === '<' || op === '<=') highs.push({v, inc: op==='<='});
    });

    if (!lows.length || !highs.length) return false;
    // Pick the strictest: max(low.v) and min(high.v)
    const low = lows.reduce((a,b)=> b.v>a.v?b:a);
    const high = highs.reduce((a,b)=> b.v<a.v?b:a);
    // No solution if low > high,
    // or if low==high but at least one is open
    if (low.v > high.v) return true;
    if (low.v === high.v && !(low.inc && high.inc)) return true;
    return false;
  }

  // Normalize inequalities
  function normalizeInequalities(raw) {
    return raw.map(ineq => {
      // Shallow copy so we don't mutate the original
      let q = { ...ineq };

      if (q.type === 'and') {
        // Two lower bounds: collapse to the stricter >-type
        if ((q.operator1 === '>' || q.operator1 === '>=') &&
            (q.operator2 === '>' || q.operator2 === '>=')) {
          const v = Math.max(q.value1, q.value2);
          let op;
          if (q.value1 > q.value2) op = q.operator1;
          else if (q.value2 > q.value1) op = q.operator2;
          else op = (q.operator1==='>'||q.operator2==='>')?'>':'>=';
          q = { type:'simple', operator: op, value: v, color: q.color };
        }
        // Two upper bounds: collapse to the stricter <-type
        if ((q.operator1 === '<' || q.operator1 === '<=') &&
            (q.operator2 === '<' || q.operator2 === '<=')) {
          const v = Math.min(q.value1, q.value2);
          let op;
          if (q.value1 < q.value2) op = q.operator1;
          else if (q.value2 < q.value1) op = q.operator2;
          else op = (q.operator1==='<'||q.operator2==='<')?'<':'<=';
          q = { type:'simple', operator: op, value: v, color: q.color };
        }
      }

      if (q.type === 'or') {
        // Two "<" parts collapse to the stricter one
        if ((q.operator1 === '<' || q.operator1 === '<=') &&
            (q.operator2 === '<' || q.operator2 === '<=')) {
          const v = Math.max(q.value1, q.value2);
          let op;
          if (q.value1 > q.value2) op = q.operator1;
          else if (q.value2 > q.value1) op = q.operator2;
          else op = (q.operator1==='<'||q.operator2==='<')?'<':'<=';
          q = { type:'simple', operator: op, value: v, color: q.color };
        }
        // Two ">" parts collapse to the stricter one
        if ((q.operator1 === '>' || q.operator1 === '>=') &&
            (q.operator2 === '>' || q.operator2 === '>=')) {
          const v = Math.min(q.value1, q.value2);
          let op;
          if (q.value1 < q.value2) op = q.operator1;
          else if (q.value2 < q.value1) op = q.operator2;
          else op = (q.operator1==='>'||q.operator2==='>')?'>':'>=';
          q = { type:'simple', operator: op, value: v, color: q.color };
        }

        // Truly "everything covered" only when the <-cutoff ≥ the >-cutoff
        if ((q.operator1 === '<' || q.operator1 === '<=') &&
            (q.operator2 === '>' || q.operator2 === '>=') &&
            q.value1 >= q.value2) {
          q = { type:'all', color: q.color };
        }
        if ((q.operator1 === '>' || q.operator1 === '>=') &&
            (q.operator2 === '<' || q.operator2 === '<=') &&
            q.value1 <= q.value2) {
          q = { type:'all', color: q.color };
        }
      }

      return q;
    });
  }

  // Function to draw the number line
  function drawNumberLine() {
    // Get SVG container
    const svgContainer = document.getElementById("numberLineSVG-" + container.numberLineID);
    if (!svgContainer) return;
    
    // Get number line data
    const data = container.numberLineData;
    
    // Validate and process input
    let minValue = parseFloat(data.minValue);
    let maxValue = parseFloat(data.maxValue);
    let tickInterval = parseInput(data.tickInterval);
    let labelInterval = parseInput(data.labelInterval);
    
    // Use defaults if invalid
    if (isNaN(minValue)) minValue = -10;
    if (isNaN(maxValue)) maxValue = 10;
    if (tickInterval === null) tickInterval = 1;
    if (labelInterval === null) labelInterval = 1;
    
    // Ensure min is less than max
    if (minValue >= maxValue) {
      const temp = minValue;
      minValue = maxValue - 10;
      maxValue = temp + 10;
    }
    
    // Ensure intervals are positive
    if (tickInterval <= 0) tickInterval = 1;
    if (labelInterval <= 0) labelInterval = 1;
    
    // Enforce limits to prevent browser hanging
    const MAX_TICKS = 1000;
    const totalWidth = maxValue - minValue;
    const expectedTicks = totalWidth / tickInterval;
    
    if (expectedTicks > MAX_TICKS) {
      tickInterval = totalWidth / MAX_TICKS;
    }
    
    // Generate tick positions
    const tickPositions = [];
    for (let i = minValue; i <= maxValue; i = parseFloat((i + tickInterval).toFixed(6))) {
      tickPositions.push(i);
    }
    
    // Generate label positions
    const labelPositions = [];
    const MAX_LABELS = 200;
    for (let i = minValue; i <= maxValue; i = parseFloat((i + labelInterval).toFixed(6))) {
      if (labelPositions.length > MAX_LABELS) break;
      labelPositions.push(i);
    }
    
    // Fixed positions for visual elements
    const leftEdge = 50; // Position for minValue
    const rightEdge = 550; // Position for maxValue
    const lineY = 80; // Y-position of the number line
    const arrowElevation = 25; // How high above the number line the arrows should be
    
    // Convert a value to an x-position on the SVG
    const valueToPosition = (value) => {
      const percentage = (value - minValue) / (maxValue - minValue);
      return leftEdge + percentage * (rightEdge - leftEdge);
    };
    
    // Start building SVG content
    let svgContent = `<svg viewBox="0 0 600 150" xmlns="http://www.w3.org/2000/svg">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Computer+Modern&amp;display=swap');
  </style>`;
    
    // Add inequalities as elevated arrows
    // Check if any AND-compound has no overlap
    const noSolution = data.inequalities.some(isNoSolutionAnd);
    const normIneq = noSolution ? [] : normalizeInequalities(data.inequalities);
    
    normIneq.forEach(ineq => {
      const color = ineq.color || '#0000FF';

      if (ineq.type === 'all') {
        // Full-width band
        svgContent += `
  <line
    x1="${leftEdge}" y1="${lineY - arrowElevation}"
    x2="${rightEdge}" y2="${lineY - arrowElevation}"
    stroke="${color}" stroke-width="4" />`;
      }
      else if (ineq.type === 'simple') {
        // x < a  or  x > a
        const startX = valueToPosition(ineq.value);
        const endX = (ineq.operator === '<' || ineq.operator === '<=')
                       ? leftEdge
                       : rightEdge;
        const includeStart = ineq.operator === '<=' || ineq.operator === '>=';

        // Line + arrowhead
        svgContent += `
  <line x1="${startX}" y1="${lineY - arrowElevation}"
        x2="${endX}"   y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;

        if (startX < endX) {
          // Right-pointing
          svgContent += `
  <polygon points="${endX},${lineY - arrowElevation}
                  ${endX-10},${lineY - arrowElevation-5}
                  ${endX-10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />`;
        } else {
          // Left-pointing
          svgContent += `
  <polygon points="${endX},${lineY - arrowElevation}
                  ${endX+10},${lineY - arrowElevation-5}
                  ${endX+10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />`;
        }

        // Open vs closed circle
        svgContent += `
  <circle
    cx="${startX}" cy="${lineY - arrowElevation}"
    r="5"
    fill="${includeStart ? color : 'white'}"
    stroke="${color}"stroke-width="${ineq.strokeWidth || 2}" />`;
      }
      else if (ineq.type === 'and') {
        // a < x < b  (or variants)
        let leftPoint, rightPoint, leftOp, rightOp;
        if (ineq.value1 <= ineq.value2) {
          leftPoint = ineq.value1;  leftOp = ineq.operator1;
          rightPoint = ineq.value2; rightOp = ineq.operator2;
        } else {
          leftPoint = ineq.value2;  leftOp = ineq.operator2;
          rightPoint = ineq.value1; rightOp = ineq.operator1;
        }
        const x1 = valueToPosition(leftPoint);
        const x2 = valueToPosition(rightPoint);
        const fill1 = (leftOp === '>=' ? color : 'white');
        const fill2 = (rightOp === '<=' ? color : 'white');

        // Connecting line
        svgContent += `
  <line x1="${x1}" y1="${lineY - arrowElevation}"
        x2="${x2}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;

        // Endpoints
        svgContent += `
  <circle cx="${x1}" cy="${lineY - arrowElevation}"
          r="5" fill="${fill1}" stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <circle cx="${x2}" cy="${lineY - arrowElevation}"
          r="5" fill="${fill2}" stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
      }
      else if (ineq.type === 'or') {
        // x < a OR x > b
        const v1 = ineq.value1, v2 = ineq.value2;
        const x1 = valueToPosition(v1), x2 = valueToPosition(v2);
        const inc1 = ineq.operator1.includes('=');
        const inc2 = ineq.operator2.includes('=');

        // Left-side
        if (ineq.operator1.startsWith('<')) {
          svgContent += `
  <line x1="${x1}" y1="${lineY - arrowElevation}"
        x2="${leftEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <polygon points="${leftEdge},${lineY - arrowElevation}
                  ${leftEdge+10},${lineY - arrowElevation-5}
                  ${leftEdge+10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x1}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc1 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
        } else {
          svgContent += `
  <line x1="${x1}" y1="${lineY - arrowElevation}"
        x2="${rightEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <polygon points="${rightEdge},${lineY - arrowElevation}
                  ${rightEdge-10},${lineY - arrowElevation-5}
                  ${rightEdge-10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x1}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc1 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}"/>`;
        }

        // Right-side
        if (ineq.operator2.startsWith('<')) {
          svgContent += `
  <line x1="${x2}" y1="${lineY - arrowElevation}"
        x2="${leftEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <polygon points="${leftEdge},${lineY - arrowElevation}
                  ${leftEdge+10},${lineY - arrowElevation-5}
                  ${leftEdge+10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x2}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc2 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
        } else {
          svgContent += `
  <line x1="${x2}" y1="${lineY - arrowElevation}"
        x2="${rightEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}"stroke-width="${ineq.strokeWidth || 2}"/>
  <polygon points="${rightEdge},${lineY - arrowElevation}
                  ${rightEdge-10},${lineY - arrowElevation-5}
                  ${rightEdge-10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x2}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc2 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
        }
      }
    });
    
   // Add spans
// Initial Y position for the first span (higher than default)
let currentSpanY = lineY - 20;        // vertical offset for first span
const spanVerticalSpacing = 13;       // space between spans

data.spans.forEach((span) => {
  // Validate span data
  if (
    isNaN(span.startValue) || isNaN(span.endValue) ||
    span.startValue < minValue || span.startValue > maxValue ||
    span.endValue   < minValue || span.endValue   > maxValue
  ) {
    return;
  }

  const x1 = valueToPosition(span.startValue);
  const x2 = valueToPosition(span.endValue);
  const y  = currentSpanY;
  const safeColor = /^#[0-9A-Fa-f]{6}$/.test(span.color) ? span.color : "#0000FF";
  const width     = Math.min(Math.max(1, span.width), 5);

  if (span.type === 'line') {
    // Simple span with vertical end-bars: |-----|
    svgContent += `
  <line x1="${x1}" y1="${y-5}" x2="${x1}" y2="${y+5}"
        stroke="${safeColor}" stroke-width="${width}" />
  <line x1="${x1}" y1="${y}"   x2="${x2}" y2="${y}"
        stroke="${safeColor}" stroke-width="${width}" />
  <line x1="${x2}" y1="${y-5}" x2="${x2}" y2="${y+5}"
        stroke="${safeColor}" stroke-width="${width}" />`;
  }
  else if (span.type === 'arrow') {
    // Straight arrow with head inset by 4px
    const inset      = 4;              // how far from tip the head starts
    const arrowLen   = width * 4;      // base head length
    const headLength = width * 4;

    // shaft
    svgContent += `
  <line x1="${x1}" y1="${y}" x2="${x2}" y2="${y}"
        stroke="${safeColor}" stroke-width="${width}" />`;

    // head
    if (x1 < x2) {
      svgContent += `
  <polygon points="
    ${x2},${y}
    ${x2 - headLength},${y - headLength/2}
    ${x2 - headLength},${y + headLength/2}
  " fill="${safeColor}" stroke="${safeColor}" />`;
    } else {
      svgContent += `
  <polygon points="
    ${x2},${y}
    ${x2 + headLength},${y - headLength/2}
    ${x2 + headLength},${y + headLength/2}
  " fill="${safeColor}" stroke="${safeColor}" />`;
    }
  }
  else if (span.type === 'bouncy') {
    // Bouncy (curved) arrow with inset head
    const midX       = (x1 + x2) / 2;
    const controlY   = y - 20;
    const inset      = 4;
    const arrowLen   = width * 4;
    const headLength = width * 4;

    // curve
    svgContent += `
  <path d="M ${x1} ${y} Q ${midX} ${controlY} ${x2} ${y}"
        fill="none" stroke="${safeColor}" stroke-width="${width}" />`;

    // compute head angle
    let angle;
    if (x1 < x2) {
      const dx = x2 - (midX + (x2-midX)*0.1);
      const dy = y - (controlY + (y-controlY)*0.1);
      angle = Math.atan2(dy, dx);
    } else {
      const dx = x2 - (midX + (x2-midX)*0.1);
      const dy = y - (controlY + (y-controlY)*0.1);
      angle = Math.atan2(dy, dx) + Math.PI;
    }

    const ax1 = x2 - headLength * Math.cos(angle - Math.PI/6);
    const ay1 = y  - headLength * Math.sin(angle - Math.PI/6);
    const ax2 = x2 - headLength * Math.cos(angle + Math.PI/6);
    const ay2 = y  - headLength * Math.sin(angle + Math.PI/6);

    svgContent += `
  <polygon points="
    ${x2},${y}
    ${ax1},${ay1}
    ${ax2},${ay2}
  " fill="${safeColor}" stroke="${safeColor}" />`;
  }

  // move next span down
  currentSpanY -= spanVerticalSpacing;
});

    
    // Continue with base SVG elements
    svgContent += `
  <!-- Number Line with Short Ticks and Compact Spacing -->
  <line x1="25" y1="${lineY}" x2="575" y2="${lineY}" stroke="black" stroke-width="3"/>
  <polygon points="0,${lineY} 25,${lineY-8} 25,${lineY+8}" fill="black"/>
  <polygon points="600,${lineY} 575,${lineY-8} 575,${lineY+8}" fill="black"/>
  
  <!-- Tick marks and numbers -->`;
    
    // Add tick marks
    tickPositions.forEach((value) => {
      const xPosition = valueToPosition(value);
      
      svgContent += `
  <line x1="${xPosition}" y1="${lineY-10}" x2="${xPosition}" y2="${lineY+10}" stroke="black" stroke-width="2"/>`;
    });
    
    // Add labels
    labelPositions.forEach((value) => {
      const xPosition = valueToPosition(value);
      
      let labelText = Number.isInteger(value) ? value : parseFloat(value.toFixed(3));
      
      svgContent += `
  <text x="${xPosition}" y="${lineY+30}" font-family="Computer Modern, serif" font-size="16" text-anchor="middle" font-weight="bold">${escapeHtml(labelText.toString())}</text>`;
    });
    
    // Add points
    data.points.forEach((point) => {
      // Validate point data
      if (isNaN(point.value) || point.value < minValue || point.value > maxValue) {
        return; // Skip invalid points
      }
      
      const xPosition = valueToPosition(point.value);
      
      // Validate and limit size
      const size = Math.min(Math.max(1, point.size || 4), 20);
      const safeColor = /^#[0-9A-Fa-f]{6}$/.test(point.color) ? point.color : "#000000";
      
      // Add point
      svgContent += `
  <circle cx="${xPosition}" cy="${lineY}" r="${size}" fill="${safeColor}"/>`;
      
      // Calculate label position
      let labelX = xPosition;
      let labelY = lineY;
      const fontSize = Math.min(Math.max(6, point.fontSize || 12), 48);
      const offset = 10 + fontSize / 2;
      
      // If showLabel is false, don't draw the label
      if (!point.showLabel) return;
      
      // Validate position
      const position = ['up', 'down', 'left', 'right', 'upleft', 'upright', 'downleft', 'downright'].includes(point.position) ? point.position : 'up';
      
      switch(position) {
        case 'up':
          labelY -= offset;
          break;
        case 'down':
          labelY += offset;
          break;
        case 'left':
          labelX -= offset;
          break;
        case 'right':
          labelX += offset;
          break;
          case 'upleft':
          labelX -= offset/1.5;
          labelY -= offset/1.5;
          break;
        case 'upright':
          labelX += offset/1.5;
          labelY -= offset/1.5;
          break;
        case 'downleft':
          labelX -= offset/1.5;
          labelY += offset/1.5;
          break;
        case 'downright':
          labelX += offset/1.5;
          labelY += offset/1.5;
          break;
        default:
          labelY -= offset;
      }
      
      // Sanitize and limit label length
      const safeLabel = escapeHtml(point.label.substring(0, 10) || "");
      
      // Add label
      svgContent += `
  <text x="${labelX}" y="${labelY}"
        font-family="Computer Modern, serif"
        font-size="${fontSize}"
        text-anchor="middle"
        fill="${safeColor}">
    ${safeLabel}
  </text>`;
    });
    
    // Close SVG
    svgContent += `
</svg>`;
    
    // Update preview
    svgContainer.innerHTML = svgContent;
  }
  
  // Function to update the global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    
    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Number Line " + container.numberLineID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Adjust Number Line button
    const adjustNumberLineBtn = document.createElement("button");
    adjustNumberLineBtn.textContent = "Adjust Number Line";
    adjustNumberLineBtn.style.marginRight = "10px";
    adjustNumberLineBtn.style.padding = "5px 10px";
    adjustNumberLineBtn.style.cursor = "pointer";
    adjustNumberLineBtn.addEventListener("click", function() {
      showNumberLineSettingsDialog();
    });
    controls.appendChild(adjustNumberLineBtn);
    
    // Points button
    const pointsBtn = document.createElement("button");
    pointsBtn.textContent = "Points";
    pointsBtn.style.marginRight = "10px";
    pointsBtn.style.padding = "5px 10px";
    pointsBtn.style.cursor = "pointer";
    pointsBtn.addEventListener("click", function() {
      showPointsDialog();
    });
    controls.appendChild(pointsBtn);
    
    // Inequalities button
    const inequalitiesBtn = document.createElement("button");
    inequalitiesBtn.textContent = "Inequalities";
    inequalitiesBtn.style.marginRight = "10px";
    inequalitiesBtn.style.padding = "5px 10px";
    inequalitiesBtn.style.cursor = "pointer";
    inequalitiesBtn.addEventListener("click", function() {
      showInequalitiesDialog();
    });
    controls.appendChild(inequalitiesBtn);
    
    // Spans button
    const spansBtn = document.createElement("button");
    spansBtn.textContent = "Spans";
    spansBtn.style.marginRight = "10px";
    spansBtn.style.padding = "5px 10px";
    spansBtn.style.cursor = "pointer";
    spansBtn.addEventListener("click", function() {
      showSpansDialog();
    });
    controls.appendChild(spansBtn);
    
    globalToolbar.appendChild(controls);
  }

  // Function to show Number Line Settings dialog
  function showNumberLineSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Adjust Number Line";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Min Value input
    const minValueRow = document.createElement("div");
    minValueRow.style.display = "flex";
    minValueRow.style.alignItems = "center";
    minValueRow.style.marginBottom = "10px";
    
    const minValueLabel = document.createElement("label");
    minValueLabel.textContent = "Min Value:";
    minValueLabel.style.width = "140px";
    minValueLabel.style.marginRight = "10px";
    minValueRow.appendChild(minValueLabel);
    
    const minValueInput = document.createElement("input");
minValueInput.type = "text";
minValueInput.placeholder = "#a# or numeric";
minValueInput.value = container.numberLineData.minValue;

    minValueInput.style.marginRight = "10px";
    minValueRow.appendChild(minValueInput);
    
    dialogBox.appendChild(minValueRow);
    
    // Max Value input
    const maxValueRow = document.createElement("div");
    maxValueRow.style.display = "flex";
    maxValueRow.style.alignItems = "center";
    maxValueRow.style.marginBottom = "10px";
    
    const maxValueLabel = document.createElement("label");
    maxValueLabel.textContent = "Max Value:";
    maxValueLabel.style.width = "140px";
    maxValueLabel.style.marginRight = "10px";
    maxValueRow.appendChild(maxValueLabel);
    
    const maxValueInput = document.createElement("input");
maxValueInput.type = "text";
maxValueInput.placeholder = "#b# or numeric";
maxValueInput.value = container.numberLineData.maxValue;
    maxValueInput.style.marginRight = "10px";
    maxValueRow.appendChild(maxValueInput);
    
    dialogBox.appendChild(maxValueRow);
    
    // Tick Interval input
    const tickIntervalRow = document.createElement("div");
    tickIntervalRow.style.display = "flex";
    tickIntervalRow.style.alignItems = "center";
    tickIntervalRow.style.marginBottom = "10px";
    
    const tickIntervalLabel = document.createElement("label");
    tickIntervalLabel.textContent = "Tick Interval:";
    tickIntervalLabel.style.width = "140px";
    tickIntervalLabel.style.marginRight = "10px";
    tickIntervalRow.appendChild(tickIntervalLabel);
    
    const tickIntervalInput = document.createElement("input");
    tickIntervalInput.type = "text";
    tickIntervalInput.value = container.numberLineData.tickInterval;
    tickIntervalInput.placeholder = "Number or fraction (e.g. 1/3)";
    tickIntervalInput.style.marginRight = "10px";
    tickIntervalRow.appendChild(tickIntervalInput);
    
    dialogBox.appendChild(tickIntervalRow);
    
    // Label Interval input
    const labelIntervalRow = document.createElement("div");
    labelIntervalRow.style.display = "flex";
    labelIntervalRow.style.alignItems = "center";
    labelIntervalRow.style.marginBottom = "10px";
    
    const labelIntervalLabel = document.createElement("label");
    labelIntervalLabel.textContent = "Label Interval:";
    labelIntervalLabel.style.width = "140px";
    labelIntervalLabel.style.marginRight = "10px";
    labelIntervalRow.appendChild(labelIntervalLabel);
    
    const labelIntervalInput = document.createElement("input");
    labelIntervalInput.type = "text";
    labelIntervalInput.value = container.numberLineData.labelInterval;
    labelIntervalInput.placeholder = "Number or fraction (e.g. 1/3)";
    labelIntervalInput.style.marginRight = "10px";
    labelIntervalRow.appendChild(labelIntervalInput);
    
    dialogBox.appendChild(labelIntervalRow);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.padding = "8px 16px";
    applyButton.style.marginRight = "10px";
    applyButton.style.cursor = "pointer";
    applyButton.style.backgroundColor = "#4CAF50";
    applyButton.style.color = "white";
    applyButton.style.border = "none";
    applyButton.style.borderRadius = "4px";
    
    applyButton.addEventListener("click", function() {
        container.numberLineData.minValue = minValueInput.value;
        container.numberLineData.maxValue = maxValueInput.value;
      container.numberLineData.tickInterval = tickIntervalInput.value;
      container.numberLineData.labelInterval = labelIntervalInput.value;
      
      drawNumberLine();
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.padding = "8px 16px";
    cancelButton.style.cursor = "pointer";
    cancelButton.style.backgroundColor = "#f0f0f0";
    cancelButton.style.border = "1px solid #ccc";
    cancelButton.style.borderRadius = "4px";
    
    cancelButton.addEventListener("click", function() {
      // Close the dialog without saving changes
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Points dialog
  function showPointsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Points";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Points list
    const pointsListContainer = document.createElement("div");
    pointsListContainer.id = "pointsList";
    pointsListContainer.style.marginBottom = "20px";
    
    // Render existing points
    function renderPointsList() {
      pointsListContainer.innerHTML = "";
      
      if (container.numberLineData.points.length === 0) {
        const noPointsMsg = document.createElement("p");
        noPointsMsg.textContent = "No points added yet.";
        pointsListContainer.appendChild(noPointsMsg);
      } else {
        container.numberLineData.points.forEach((point, index) => {
          const item = document.createElement("div");
          item.className = "point-item";
          item.style.border = "1px solid #ddd";
          item.style.padding = "10px";
          item.style.marginBottom = "10px";
          item.style.backgroundColor = "#fff";
          item.style.borderRadius = "3px";
          
          const title = document.createElement("strong");
          title.textContent = escapeHtml(point.label) + ': ';
          item.appendChild(title);
          
          const desc = document.createTextNode(point.value);
          item.appendChild(desc);
          
          const actions = document.createElement("div");
          actions.className = "item-actions";
          actions.style.display = "flex";
          actions.style.alignItems = "center";
          actions.style.marginTop = "5px";
          
          const swatch = document.createElement("span");
          swatch.style.cssText = `display:inline-block;width:20px;height:10px;background-color:${point.color};margin-right:5px;`;
          actions.appendChild(swatch);
          
          const infoText = document.createTextNode(`Point Size: ${point.size || 4}px, Font Size: ${point.fontSize || 12}px, Position: ${point.position || 'up'}, Show Label: ${point.showLabel ? 'Yes' : 'No'} `);
          actions.appendChild(infoText);
          
          // Create edit button
          const btnEdit = document.createElement("button");
          btnEdit.type = "button";
          btnEdit.textContent = "Edit";
          btnEdit.style.marginLeft = "10px";
          btnEdit.addEventListener("click", function() { 
            editPoint(index); 
          });
          actions.appendChild(btnEdit);
          
          const del = document.createElement("button");
          del.type = "button";
          del.className = "delete-btn";
          del.textContent = "Delete";
          del.style.display = "inline-block";
          del.style.padding = "2px 6px";
          del.style.border = "1px solid #000";
          del.style.backgroundColor = "#fff";
          del.style.color = "#000";
          del.style.borderRadius = "3px";
          del.style.fontSize = "0.9em";
          del.style.cursor = "pointer";
          del.style.marginLeft = "10px";
          del.addEventListener("click", function() {
            deletePoint(index);
          });
          actions.appendChild(del);
          
          item.appendChild(actions);
          pointsListContainer.appendChild(item);
        });
      }
    }
    
    renderPointsList();
    dialogBox.appendChild(pointsListContainer);
    
    // Add new point form
    const addPointForm = document.createElement("div");
    addPointForm.style.backgroundColor = "#f9f9f9";
    addPointForm.style.padding = "15px";
    addPointForm.style.borderRadius = "5px";
    addPointForm.style.marginBottom = "20px";
    
    const formTitle = document.createElement("h4");
    formTitle.textContent = "Add Point";
    formTitle.style.marginTop = "0";
    formTitle.style.marginBottom = "15px";
    addPointForm.appendChild(formTitle);
    
    // Point value input
    const valueRow = document.createElement("div");
    valueRow.style.display = "flex";
    valueRow.style.alignItems = "center";
    valueRow.style.marginBottom = "10px";
    
    const valueLabel = document.createElement("label");
    valueLabel.textContent = "Point Value:";
    valueLabel.style.display = "inline-block";
    valueLabel.style.width = "140px";
    valueLabel.style.marginRight = "10px";
    valueRow.appendChild(valueLabel);
    
    const valueInput = document.createElement("input");
    valueInput.type = "text";
    valueInput.id = "newPointValue";
    valueInput.placeholder = "e.g. 5 or -3.5";
    valueInput.style.width = "150px";
    valueInput.style.marginRight = "20px";
    valueRow.appendChild(valueInput);
    
    const labelLabel = document.createElement("label");
    labelLabel.textContent = "Label:";
    labelLabel.style.width = "60px";
    labelLabel.style.marginRight = "10px";
    valueRow.appendChild(labelLabel);
    
    const labelInput = document.createElement("input");
    labelInput.type = "text";
    labelInput.id = "newPointLabel";
    labelInput.placeholder = "e.g. A or P1";
    labelInput.style.width = "80px";
    valueRow.appendChild(labelInput);
    
    addPointForm.appendChild(valueRow);
    
    // Point style
    const styleRow = document.createElement("div");
    styleRow.style.display = "flex";
    styleRow.style.alignItems = "center";
    styleRow.style.marginBottom = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Point Color:";
    colorLabel.style.display = "inline-block";
    colorLabel.style.width = "140px";
    colorLabel.style.marginRight = "10px";
    styleRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.id = "pointColor";
    colorInput.value = "#000000";
    colorInput.style.marginRight = "20px";
    styleRow.appendChild(colorInput);
    
    const sizeLabel = document.createElement("label");
    sizeLabel.textContent = "Point Size:";
    sizeLabel.style.marginRight = "10px";
    styleRow.appendChild(sizeLabel);
    
    const sizeInput = document.createElement("input");
    sizeInput.type = "number";
    sizeInput.id = "pointSize";
    sizeInput.min = "1";
    sizeInput.max = "20";
    sizeInput.value = "4";
    sizeInput.style.width = "50px";
    styleRow.appendChild(sizeInput);
    
    addPointForm.appendChild(styleRow);
    
    // Label style
    const labelStyleRow = document.createElement("div");
    labelStyleRow.style.display = "flex";
    labelStyleRow.style.alignItems = "center";
    labelStyleRow.style.marginBottom = "10px";
    
    const fontSizeLabel = document.createElement("label");
    fontSizeLabel.textContent = "Label Font Size:";
    fontSizeLabel.style.display = "inline-block";
    fontSizeLabel.style.width = "140px";
    fontSizeLabel.style.marginRight = "10px";
    labelStyleRow.appendChild(fontSizeLabel);
    
    const fontSizeInput = document.createElement("input");
    fontSizeInput.type = "number";
    fontSizeInput.id = "labelFontSize";
    fontSizeInput.min = "6";
    fontSizeInput.max = "48";
    fontSizeInput.value = "12";
    fontSizeInput.style.width = "50px";
    fontSizeInput.style.marginRight = "20px";
    labelStyleRow.appendChild(fontSizeInput);
    
    const showLabelLabel = document.createElement("label");
    showLabelLabel.textContent = "Show Label?";
    showLabelLabel.style.marginRight = "10px";
    labelStyleRow.appendChild(showLabelLabel);
    
    const showLabelSelect = document.createElement("select");
    showLabelSelect.id = "showLabel";
    
    const yesOption = document.createElement("option");
    yesOption.value = "yes";
    yesOption.textContent = "Yes";
    showLabelSelect.appendChild(yesOption);
    
    const noOption = document.createElement("option");
    noOption.value = "no";
    noOption.textContent = "No";
    showLabelSelect.appendChild(noOption);
    
    labelStyleRow.appendChild(showLabelSelect);
    
    addPointForm.appendChild(labelStyleRow);
    
    // Label position
    const positionRow = document.createElement("div");
    positionRow.style.display = "flex";
    positionRow.style.alignItems = "center";
    positionRow.style.marginBottom = "15px";
    
    const positionLabel = document.createElement("label");
    positionLabel.textContent = "Label Position:";
    positionLabel.style.display = "inline-block";
    positionLabel.style.width = "140px";
    positionLabel.style.marginRight = "10px";
    positionRow.appendChild(positionLabel);
    
    const positionSelect = document.createElement("select");
    positionSelect.id = "labelPosition";
    
    const positions = [
      { value: "up", text: "up" },
      { value: "down", text: "down" },
      { value: "left", text: "left" },
      { value: "right", text: "right" },
      { value: "upleft", text: "up/left" },
      { value: "upright", text: "up/right" },
      { value: "downleft", text: "down/left" },
      { value: "downright", text: "down/right" }
    ];
    
    positions.forEach(option => {
      const optionEl = document.createElement("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
      positionSelect.appendChild(optionEl);
    });
    
    positionRow.appendChild(positionSelect);
    addPointForm.appendChild(positionRow);
    
    // Add point button
    const addBtnRow = document.createElement("div");
    
    const addPointBtn = document.createElement("button");
    addPointBtn.textContent = "Add Point";
    addPointBtn.style.padding = "8px 16px";
    addPointBtn.style.cursor = "pointer";
    addPointBtn.style.backgroundColor = "#4CAF50";
    addPointBtn.style.color = "white";
    addPointBtn.style.border = "none";
    addPointBtn.style.borderRadius = "4px";
    
    // Hidden input for tracking editing state
    const editingIndexInput = document.createElement("input");
    editingIndexInput.type = "hidden";
    editingIndexInput.id = "editingPointIndex";
    editingIndexInput.value = "-1";
    addBtnRow.appendChild(editingIndexInput);
    
    addBtnRow.appendChild(addPointBtn);
    addPointForm.appendChild(addBtnRow);
    
    dialogBox.appendChild(addPointForm);
    
    // Function to edit a point
    function editPoint(index) {
      const point = container.numberLineData.points[index];
      
      // Set form fields to point values
      valueInput.value = point.value;
      labelInput.value = point.label;
      colorInput.value = point.color;
      sizeInput.value = point.size || 4;
      fontSizeInput.value = point.fontSize || 12;
      showLabelSelect.value = point.showLabel ? 'yes' : 'no';
      positionSelect.value = point.position || 'up';
      
      // Set editing state
      editingIndexInput.value = index;
      
      // Change button text
      addPointBtn.textContent = 'Update Point';
    }
    
    // Function to delete a point
    function deletePoint(index) {
      if (index < 0 || index >= container.numberLineData.points.length) {
        return;
      }
      
      container.numberLineData.points.splice(index, 1);
      
      // If we were editing this point, reset the form
      if (parseInt(editingIndexInput.value) === index) {
        valueInput.value = '';
        labelInput.value = '';
        editingIndexInput.value = "-1";
        addPointBtn.textContent = "Add Point";
      }
      
      // Update UI
      renderPointsList();
      drawNumberLine();
    }
    
    // Add point button handler
    addPointBtn.addEventListener("click", function() {
        const rawVal = valueInput.value.trim();
        const value  = rawVal.includes('#') ? rawVal : parseInput(rawVal);
      let label = labelInput.value.trim();
      const color = colorInput.value;
      const size = parseInt(sizeInput.value);
      const fontSize = parseInt(fontSizeInput.value);
      const showLabel = showLabelSelect.value === 'yes';
      const position = positionSelect.value;
      
      const editingIndex = parseInt(editingIndexInput.value);
      
      // Validate input
 // Only check numeric values if rawVal has no ‘#’
if (!rawVal.includes('#')) {
  if (isNaN(value)) {
    alert('Please enter a valid number for the point value');
    return;
  }
  const minValue = container.numberLineData.minValue;
  const maxValue = container.numberLineData.maxValue;
  if (value < minValue || value > maxValue) {
    alert(`Point value must be between ${minValue} and ${maxValue}`);
    return;
  }
}

      
      // Sanitize inputs
      const pointLabel = label || `P${container.numberLineData.points.length + 1}`;
      
      const point = {
        value: rawVal,
        label: pointLabel,
        color,
        size,
        fontSize,
        position,
        showLabel
      };
      
      if (editingIndex >= 0 && editingIndex < container.numberLineData.points.length) {
        // Update existing point
        container.numberLineData.points[editingIndex] = point;
        
        // Reset editing state
        editingIndexInput.value = "-1";
        addPointBtn.textContent = "Add Point";
      } else {
        // Add new point
        container.numberLineData.points.push(point);
      }
      
      // Reset inputs
      valueInput.value = '';
      labelInput.value = '';
      
      // Update UI
      renderPointsList();
      drawNumberLine();
    });
    
    // Dialog buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Inequalities dialog
  function showInequalitiesDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Inequalities";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Inequalities list
    const inequalitiesListContainer = document.createElement("div");
    inequalitiesListContainer.id = "inequalitiesList";
    inequalitiesListContainer.style.marginBottom = "20px";
    
    // Render existing inequalities
    function renderInequalitiesList() {
      inequalitiesListContainer.innerHTML = "";
      
      if (container.numberLineData.inequalities.length === 0) {
        const noInequalitiesMsg = document.createElement("p");
        noInequalitiesMsg.textContent = "No inequalities added yet.";
        inequalitiesListContainer.appendChild(noInequalitiesMsg);
      } else {
        container.numberLineData.inequalities.forEach((ineq, index) => {
          // Build description
          let description = '';

          if (ineq.type === 'simple') {
            // x < a, x ≤ a, x > a, x ≥ a
            const sym = ineq.operator === '<'  ? '<'
                      : ineq.operator === '<=' ? '≤'
                      : ineq.operator === '>'  ? '>'
                      :                           '≥';
            description = `x ${sym} ${ineq.value}`;
          } else if (ineq.type === 'and') {
            // a < x < b  (possibly ≤)
            // First operator is operator1 on the left of x, so we flip it
            const leftSym = ineq.operator1 === '>'  ? '<'
                          : ineq.operator1 === '>=' ? '≤'
                          : ineq.operator1 === '<'  ? '>'
                          :                             '≥';
            // Second operator is operator2 on the right of x
            const rightSym = ineq.operator2 === '<'  ? '<'
                           : ineq.operator2 === '<=' ? '≤'
                           : ineq.operator2 === '>'  ? '>'
                           :                             '≥';
            description = `${ineq.value1} ${leftSym} x ${rightSym} ${ineq.value2}`;
        } else { // or
           // x < a OR x > b  (possibly ≤ or ≥)
           const sym1 = ineq.operator1 === '<'  ? '<'
                      : ineq.operator1 === '<=' ? '≤'
                      : ineq.operator1 === '>'  ? '>'
                      :                             '≥';
           const sym2 = ineq.operator2 === '<'  ? '<'
                      : ineq.operator2 === '<=' ? '≤'
                      : ineq.operator2 === '>'  ? '>'
                      :                             '≥';
           description = `x ${sym1} ${ineq.value1} OR x ${sym2} ${ineq.value2}`;
         }

         // Container
         const item = document.createElement("div");
         item.className = "inequality-item";
         item.style.border = "1px solid #ddd";
         item.style.padding = "10px";
         item.style.marginBottom = "10px";
         item.style.backgroundColor = "#fff";
         item.style.borderRadius = "3px";

         // Title
         const title = document.createElement("strong");
         title.textContent = `Inequality ${index + 1}: `;
         item.appendChild(title);

         // Description
         item.appendChild(document.createTextNode(description));

         // Actions
         const actions = document.createElement("div");
         actions.className = "item-actions";
         actions.style.display = "flex";
         actions.style.alignItems = "center";
         actions.style.marginTop = "5px";

         // Color swatch
         const colorToUse = ineq.type === 'simple'
           ? ineq.color
           : (ineq.color || ineq.color1 || '#0000FF');
         const swatch = document.createElement("span");
         swatch.style.cssText = `display:inline-block;
                                 width:20px;
                                 height:10px;
                                 background-color:${colorToUse};
                                 margin-right:5px;`;
         actions.appendChild(swatch);

         // Edit
         const btnEdit = document.createElement("button");
         btnEdit.type = "button";
         btnEdit.textContent = "Edit";
         btnEdit.style.marginLeft = "10px";
         btnEdit.addEventListener("click", function() {
           editInequality(index);
         });
         actions.appendChild(btnEdit);

         // Delete
         const btnDelete = document.createElement("button");
         btnDelete.type = "button";
         btnDelete.className = "delete-btn";
         btnDelete.textContent = "Delete";
         btnDelete.style.display = "inline-block";
         btnDelete.style.padding = "2px 6px";
         btnDelete.style.border = "1px solid #000";
         btnDelete.style.backgroundColor = "#fff";
         btnDelete.style.color = "#000";
         btnDelete.style.borderRadius = "3px";
         btnDelete.style.fontSize = "0.9em";
         btnDelete.style.cursor = "pointer";
         btnDelete.style.marginLeft = "10px";
         btnDelete.addEventListener("click", function() {
           deleteInequality(index);
         });
         actions.appendChild(btnDelete);

         item.appendChild(actions);
         inequalitiesListContainer.appendChild(item);
       });
     }
   }
   
   renderInequalitiesList();
   dialogBox.appendChild(inequalitiesListContainer);
   
   // Add new inequality form
   const addInequalityForm = document.createElement("div");
   addInequalityForm.style.backgroundColor = "#f9f9f9";
   addInequalityForm.style.padding = "15px";
   addInequalityForm.style.borderRadius = "5px";
   addInequalityForm.style.marginBottom = "20px";
   
   const formTitle = document.createElement("h4");
   formTitle.textContent = "Add Inequality";
   formTitle.style.marginTop = "0";
   formTitle.style.marginBottom = "15px";
   addInequalityForm.appendChild(formTitle);
   
   // First inequality input container
   const inequality1Container = document.createElement("div");
   inequality1Container.className = "inequality-container";
   inequality1Container.style.border = "1px solid #ddd";
   inequality1Container.style.padding = "10px";
   inequality1Container.style.marginBottom = "10px";
   inequality1Container.style.backgroundColor = "#f9f9f9";
   inequality1Container.style.borderRadius = "5px";
   
   const inequality1Row = document.createElement("div");
   inequality1Row.className = "inequality-row";
   inequality1Row.style.display = "flex";
   inequality1Row.style.alignItems = "center";
   inequality1Row.style.marginBottom = "10px";
   
   const inequality1Label = document.createElement("label");
   inequality1Label.textContent = "Inequality:";
   inequality1Label.style.width = "140px";
   inequality1Label.style.marginRight = "10px";
   inequality1Row.appendChild(inequality1Label);
   
   const inequality1Operator = document.createElement("select");
   inequality1Operator.id = "inequality1Operator";
   inequality1Operator.className = "inequality-operator";
   inequality1Operator.style.marginRight = "10px";
   
   const ltOption = document.createElement("option");
   ltOption.value = "<";
   ltOption.textContent = "x < ";
   inequality1Operator.appendChild(ltOption);
   
   const leOption = document.createElement("option");
   leOption.value = "<=";
   leOption.textContent = "x ≤ ";
   inequality1Operator.appendChild(leOption);
   
   const gtOption = document.createElement("option");
   gtOption.value = ">";
   gtOption.textContent = "x > ";
   inequality1Operator.appendChild(gtOption);
   
   const geOption = document.createElement("option");
   geOption.value = ">=";
   geOption.textContent = "x ≥ ";
   inequality1Operator.appendChild(geOption);
   
   inequality1Row.appendChild(inequality1Operator);
   
   const inequality1Value = document.createElement("input");
   inequality1Value.id = "inequality1Value";
   inequality1Value.className = "inequality-value";
   inequality1Value.type = "text";
   inequality1Value.placeholder = "Enter a value";
   inequality1Value.style.width = "80px";
   inequality1Row.appendChild(inequality1Value);
   
   inequality1Container.appendChild(inequality1Row);
   
   const ineq1ColorRow = document.createElement("div");
   ineq1ColorRow.className = "control-row";
   ineq1ColorRow.style.display = "flex";
   ineq1ColorRow.style.alignItems = "center";
   ineq1ColorRow.style.marginBottom = "10px";
   
   const ineq1ColorLabel = document.createElement("label");
   ineq1ColorLabel.textContent = "Color:";
   ineq1ColorLabel.style.width = "140px";
   ineq1ColorLabel.style.marginRight = "10px";
   ineq1ColorRow.appendChild(ineq1ColorLabel);
   
   const ineq1ColorInput = document.createElement("input");
   ineq1ColorInput.id = "inequality1Color";
   ineq1ColorInput.type = "color";
   ineq1ColorInput.value = "#0000FF";
   ineq1ColorRow.appendChild(ineq1ColorInput);
   
   inequality1Container.appendChild(ineq1ColorRow);
   
   addInequalityForm.appendChild(inequality1Container);

   // ── thickness row ──
const thicknessRow = document.createElement("div");
thicknessRow.style.display = "flex";
thicknessRow.style.alignItems = "center";
thicknessRow.style.marginBottom = "10px";

const thicknessLabel = document.createElement("label");
thicknessLabel.textContent = "Line Thickness:";
thicknessLabel.style.width = "140px";
thicknessLabel.style.marginRight = "10px";
thicknessRow.appendChild(thicknessLabel);

const thicknessInput = document.createElement("input");
thicknessInput.type = "number";
thicknessInput.id = "inequalityThickness";
thicknessInput.min = "1";
thicknessInput.max = "20";
thicknessInput.value = "3";             // your default
thicknessInput.style.width = "50px";
thicknessRow.appendChild(thicknessInput);

addInequalityForm.appendChild(thicknessRow);

   
   // And/Or buttons
   const andOrContainer = document.createElement("div");
   andOrContainer.className = "and-or-container";
   andOrContainer.style.display = "flex";
   andOrContainer.style.margin = "10px 0";
   
   const andBtn = document.createElement("button");
   andBtn.id = "andBtn";
   andBtn.className = "and-or-btn";
   andBtn.type = "button";
   andBtn.textContent = "AND";
   andBtn.style.marginRight = "10px";
   andBtn.style.padding = "5px 10px";
   andOrContainer.appendChild(andBtn);
   
   const orBtn = document.createElement("button");
   orBtn.id = "orBtn";
   orBtn.className = "and-or-btn";
   orBtn.type = "button";
   orBtn.textContent = "OR";
   orBtn.style.marginRight = "10px";
   orBtn.style.padding = "5px 10px";
   andOrContainer.appendChild(orBtn);
   
   addInequalityForm.appendChild(andOrContainer);
   
   // Second inequality container (initially hidden)
   const inequality2Container = document.createElement("div");
   inequality2Container.id = "inequality2";
   inequality2Container.className = "inequality-container";
   inequality2Container.style.border = "1px solid #ddd";
   inequality2Container.style.padding = "10px";
   inequality2Container.style.marginBottom = "10px";
   inequality2Container.style.backgroundColor = "#f9f9f9";
   inequality2Container.style.borderRadius = "5px";
   inequality2Container.style.display = "none";
   
   const inequality2Row = document.createElement("div");
   inequality2Row.className = "inequality-row";
   inequality2Row.style.display = "flex";
   inequality2Row.style.alignItems = "center";
   inequality2Row.style.marginBottom = "10px";
   
   const inequality2Label = document.createElement("label");
   inequality2Label.textContent = "Inequality:";
   inequality2Label.style.width = "140px";
   inequality2Label.style.marginRight = "10px";
   inequality2Row.appendChild(inequality2Label);
   
   const inequality2Operator = document.createElement("select");
   inequality2Operator.id = "inequality2Operator";
   inequality2Operator.className = "inequality-operator";
   inequality2Operator.style.marginRight = "10px";
   
   const lt2Option = document.createElement("option");
   lt2Option.value = "<";
   lt2Option.textContent = "x < ";
   inequality2Operator.appendChild(lt2Option);
   
   const le2Option = document.createElement("option");
   le2Option.value = "<=";
   le2Option.textContent = "x ≤ ";
   inequality2Operator.appendChild(le2Option);
   
   const gt2Option = document.createElement("option");
   gt2Option.value = ">";
   gt2Option.textContent = "x > ";
   inequality2Operator.appendChild(gt2Option);
   
   const ge2Option = document.createElement("option");
   ge2Option.value = ">=";
   ge2Option.textContent = "x ≥ ";
   inequality2Operator.appendChild(ge2Option);
   
   inequality2Row.appendChild(inequality2Operator);
   
   const inequality2Value = document.createElement("input");
   inequality2Value.id = "inequality2Value";
   inequality2Value.className = "inequality-value";
   inequality2Value.type = "text";
   inequality2Value.placeholder = "Enter a value";
   inequality2Value.style.width = "80px";
   inequality2Row.appendChild(inequality2Value);
   
   inequality2Container.appendChild(inequality2Row);
   
   addInequalityForm.appendChild(inequality2Container);
   
   // Combined inequality display (for AND)
   const combinedInequality = document.createElement("div");
   combinedInequality.id = "combinedInequality";
   combinedInequality.className = "combined-inequality";
   combinedInequality.style.margin = "10px 0";
   combinedInequality.style.padding = "5px";
   combinedInequality.style.backgroundColor = "#f0f0f0";
   combinedInequality.style.borderRadius = "3px";
   combinedInequality.style.fontFamily = "monospace";
   combinedInequality.style.display = "none";
   
   combinedInequality.innerHTML = 'Combined inequality: <span id="combinedInequalityText"></span>';
   
   addInequalityForm.appendChild(combinedInequality);
   
   // Add inequality button
   const addBtnRow = document.createElement("div");
   addBtnRow.className = "control-row";
   addBtnRow.style.marginTop = "15px";
   
   const addInequalityBtn = document.createElement("button");
   addInequalityBtn.id = "addInequalityBtn";
   addInequalityBtn.textContent = "Add Inequality";
   addInequalityBtn.style.padding = "8px 16px";
   addInequalityBtn.style.cursor = "pointer";
   addInequalityBtn.style.backgroundColor = "#4CAF50";
   addInequalityBtn.style.color = "white";
   addInequalityBtn.style.border = "none";
   addInequalityBtn.style.borderRadius = "4px";
   
   // Hidden input for tracking editing state
   const editingIndexInput = document.createElement("input");
   editingIndexInput.type = "hidden";
   editingIndexInput.id = "editingInequalityIndex";
   editingIndexInput.value = "-1";
   addBtnRow.appendChild(editingIndexInput);
   
   addBtnRow.appendChild(addInequalityBtn);
   addInequalityForm.appendChild(addBtnRow);
   
   dialogBox.appendChild(addInequalityForm);
   
   // Track inequality combination type
   let inequalityCombinationType = null; // 'and', 'or', or null
   
   // Set inequality combination type (and/or)
   function setInequalityCombinationType(type) {
     inequalityCombinationType = type;
     andBtn.classList.toggle('primary', type === 'and');
     orBtn.classList.toggle('primary', type === 'or');
     
     inequality2Container.style.display = 'block';
     
     if (type === 'and') {
       combinedInequality.style.display = 'block';
     } else {
       combinedInequality.style.display = 'none';
     }
     
     updateCombinedInequality();
   }
   
   // Update the combined inequality display
   function updateCombinedInequality() {
     if (inequalityCombinationType !== 'and') return;
     
     const operator1 = document.getElementById('inequality1Operator').value;
     const value1 = document.getElementById('inequality1Value').value;
     const operator2 = document.getElementById('inequality2Operator').value;
     const value2 = document.getElementById('inequality2Value').value;
     
     // Get the proper symbols
     let op1Symbol = operator1 === '<' ? '<' : 
                    operator1 === '<=' ? '≤' : 
                    operator1 === '>' ? '>' : '≥';
     let op2Symbol = operator2 === '<' ? '<' : 
                    operator2 === '<=' ? '≤' : 
                    operator2 === '>' ? '>' : '≥';
     
     let combinedText = '';
     
     // Construct the proper format based on operator types
     if (value1 && value2) {
       if ((operator1 === '>' || operator1 === '>=') && (operator2 === '<' || operator2 === '<=')) {
         // Correct "AND" format: value1 < x < value2
         // Need to FLIP the first operator for display
         const flippedOp1Symbol = operator1 === '>' ? '<' : operator1 === '>=' ? '≤' : operator1 === '<' ? '>' : '≥';
         combinedText = `${value1} ${flippedOp1Symbol} x ${op2Symbol} ${value2}`;
       } else {
         // Handle invalid combination 
         combinedText = `x ${op1Symbol} ${value1} AND x ${op2Symbol} ${value2}`;
       }
     } else if (value1) {
       combinedText = `x ${op1Symbol} ${value1}`;
     } else if (value2) {
       combinedText = `x ${op2Symbol} ${value2}`;
     }
     
     document.getElementById('combinedInequalityText').textContent = combinedText;
   }
   
   // Reset inequality inputs
   function resetInequalityInputs() {
  inequality1Operator.value = '<';
  inequality1Value.value    = '';
  inequality2Operator.value = '<';
  inequality2Value.value    = '';
  ineq1ColorInput.value     = '#0000FF';
  thicknessInput.value      = '3';              // ← reset thickness here
  inequality2Container.style.display = 'none';
  combinedInequality.style.display   = 'none';
  inequalityCombinationType = null;
  andBtn.classList.remove('primary');
  orBtn.classList.remove('primary');
}

   
   // Function to edit an inequality
  function editInequality(index) {
  const inequality = container.numberLineData.inequalities[index];
  resetInequalityInputs();

  if (inequality.type === 'simple') {
    inequality1Operator.value = inequality.operator;
    inequality1Value.value    = inequality.value;
    ineq1ColorInput.value     = inequality.color;
    thicknessInput.value      = inequality.strokeWidth || 2;  // ← populate thickness
  }
  else if (inequality.type === 'and' || inequality.type === 'or') {
    inequality1Operator.value = inequality.operator1;
    inequality1Value.value    = inequality.value1;
    ineq1ColorInput.value     = inequality.color;
    inequality2Operator.value = inequality.operator2;
    inequality2Value.value    = inequality.value2;
    thicknessInput.value      = inequality.strokeWidth || 2;  // ← and here

    setInequalityCombinationType(inequality.type);
  }

  editingInequalityIndex.value = index;
  addInequalityBtn.textContent = 'Update Inequality';
}

   
   // Function to delete an inequality
   function deleteInequality(index) {
     if (index < 0 || index >= container.numberLineData.inequalities.length) {
       return;
     }
     
     container.numberLineData.inequalities.splice(index, 1);
     
     // If we were editing this inequality, reset the form
     if (parseInt(editingIndexInput.value) === index) {
       resetInequalityInputs();
       editingIndexInput.value = "-1";
       addInequalityBtn.textContent = "Add Inequality";
     }
     
     // Update UI
     renderInequalitiesList();
     drawNumberLine();
   }
   addInequalityBtn.addEventListener("click", function() {
  const op1  = inequality1Operator.value;
  const raw1 = inequality1Value.value.trim();
  const val1 = raw1.includes('#') ? raw1 : parseFloat(raw1);
  const color1      = ineq1ColorInput.value;
const strokeWidth = parseInt(thicknessInput.value, 10) || 2;

  // Only validate if it’s actually numeric
  if (!raw1.includes('#') && isNaN(val1)) {
    alert('Please enter a valid number for the first inequality');
    return;
  }

  let inequality;
  if (inequalityCombinationType === 'and') {
    const op2  = inequality2Operator.value;
    const raw2 = inequality2Value.value.trim();
    const val2 = raw2.includes('#') ? raw2 : parseFloat(raw2);

    if (!raw2.includes('#') && isNaN(val2)) {
      alert('Please enter a valid number for the second inequality');
      return;
    }

    // Only enforce bounds check if both are numeric
    if (
      !raw1.includes('#') &&
      !raw2.includes('#') &&
      (op1 === '>' || op1 === '>=') &&
      (op2 === '<' || op2 === '<=') &&
      val1 >= val2
    ) {
      alert('For AND inequalities the lower bound must be less than the upper bound');
      return;
    }

    inequality = {
      type:      'and',
      operator1: op1,
      value1:    val1,
      operator2: op2,
      value2:    val2,
      color:     color1,
      strokeWidth
    };

  } else if (inequalityCombinationType === 'or') {
    const op2  = inequality2Operator.value;
    const raw2 = inequality2Value.value.trim();
    const val2 = raw2.includes('#') ? raw2 : parseFloat(raw2);

    if (!raw2.includes('#') && isNaN(val2)) {
      alert('Please enter a valid number for the second inequality');
      return;
    }

    inequality = {
      type:      'or',
      operator1: op1,
      value1:    val1,
      operator2: op2,
      value2:    val2,
      color:     color1,
      strokeWidth
    };

  } else {
    // simple x < a  or  x > a
    inequality = {
      type:     'simple',
      operator: op1,
      value:    val1,
      color:    color1,
      strokeWidth
    };
  }

  // push or update
  const idx = parseInt(editingInequalityIndex.value, 10);
  if (idx >= 0 && idx < container.numberLineData.inequalities.length) {
    container.numberLineData.inequalities[idx] = inequality;
    editingInequalityIndex.value = "-1";
    addInequalityBtn.textContent = "Add Inequality";
  } else {
    container.numberLineData.inequalities.push(inequality);
  }

  resetInequalityInputs();
  renderInequalitiesList();
  drawNumberLine();
});

   
   // Add event listeners for and/or buttons
   andBtn.addEventListener("click", function() {
     setInequalityCombinationType('and');
   });
   
   orBtn.addEventListener("click", function() {
     setInequalityCombinationType('or');
   });
   
   // Update combined inequality text when inputs change
   inequality1Operator.addEventListener("change", updateCombinedInequality);
   inequality1Value.addEventListener("input", updateCombinedInequality);
   inequality2Operator.addEventListener("change", updateCombinedInequality);
   inequality2Value.addEventListener("input", updateCombinedInequality);
   
   // Dialog buttons
   const buttonsContainer = document.createElement("div");
   buttonsContainer.style.display = "flex";
   buttonsContainer.style.justifyContent = "flex-end";
   buttonsContainer.style.marginTop = "20px";
   
   const closeButton = document.createElement("button");
   closeButton.textContent = "Close";
   closeButton.style.padding = "8px 16px";
   closeButton.style.cursor = "pointer";
   
   closeButton.addEventListener("click", function() {
     document.body.removeChild(dialogBackdrop);
   });
   
   buttonsContainer.appendChild(closeButton);
   dialogBox.appendChild(buttonsContainer);
   
   dialogBackdrop.appendChild(dialogBox);
   document.body.appendChild(dialogBackdrop);
 }

 // Function to show Spans dialog
 function showSpansDialog() {
   const dialogBackdrop = document.createElement("div");
   dialogBackdrop.style.position = "fixed";
   dialogBackdrop.style.top = "0";
   dialogBackdrop.style.left = "0";
   dialogBackdrop.style.width = "100%";
   dialogBackdrop.style.height = "100%";
   dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
   dialogBackdrop.style.zIndex = "1000";
   dialogBackdrop.style.display = "flex";
   dialogBackdrop.style.justifyContent = "center";
   dialogBackdrop.style.alignItems = "center";
   
   const dialogBox = document.createElement("div");
   dialogBox.style.backgroundColor = "white";
   dialogBox.style.padding = "20px";
   dialogBox.style.borderRadius = "5px";
   dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
   dialogBox.style.width = "80%";
   dialogBox.style.maxWidth = "800px";
   dialogBox.style.maxHeight = "80vh";
   dialogBox.style.overflowY = "auto";
   
   const dialogTitle = document.createElement("h3");
   dialogTitle.textContent = "Spans";
   dialogTitle.style.marginTop = "0";
   dialogBox.appendChild(dialogTitle);
   
   // Spans list
   const spansListContainer = document.createElement("div");
   spansListContainer.id = "spansList";
   spansListContainer.style.marginBottom = "20px";
   
   // Render existing spans
   function renderSpansList() {
     spansListContainer.innerHTML = "";
     
     if (container.numberLineData.spans.length === 0) {
       const noSpansMsg = document.createElement("p");
       noSpansMsg.textContent = "No spans added yet.";
       spansListContainer.appendChild(noSpansMsg);
     } else {
       container.numberLineData.spans.forEach((span, index) => {
         const item = document.createElement("div");
         item.className = "point-item";
         item.style.border = "1px solid #ddd";
         item.style.padding = "10px";
         item.style.marginBottom = "10px";
         item.style.backgroundColor = "#fff";
         item.style.borderRadius = "3px";
         
         const title = document.createElement("strong");
         title.textContent = `Span ${index+1}: `;
         item.appendChild(title);
         
         let typeDesc = '';
         switch(span.type) {
           case 'line': typeDesc = 'Simple Span'; break;
           case 'arrow': typeDesc = 'Arrow'; break;
           case 'bouncy': typeDesc = 'Bouncy Arrow'; break;
         }
         
         const desc = document.createTextNode(`${span.startValue} to ${span.endValue} (${typeDesc})`);
         item.appendChild(desc);
         
         const actions = document.createElement("div");
         actions.className = "item-actions";
         actions.style.display = "flex";
         actions.style.alignItems = "center";
         actions.style.marginTop = "5px";
         
         const swatch = document.createElement("span");
         swatch.style.cssText = `display:inline-block;width:20px;height:10px;background-color:${span.color};margin-right:5px;`;
         actions.appendChild(swatch);
         
         const info = document.createTextNode(`Width: ${span.width}px `);
         actions.appendChild(info);
         
         // Create edit button
         const btnEdit = document.createElement("button");
         btnEdit.type = "button";
         btnEdit.textContent = "Edit";
         btnEdit.style.marginLeft = "10px";
         btnEdit.addEventListener("click", function() { 
           editSpan(index); 
         });
         actions.appendChild(btnEdit);
         
         const del = document.createElement("button");
         del.type = "button";
         del.className = "delete-btn";
         del.textContent = "Delete";
         del.style.display = "inline-block";
         del.style.padding = "2px 6px";
         del.style.border = "1px solid #000";
         del.style.backgroundColor = "#fff";
         del.style.color = "#000";
         del.style.borderRadius = "3px";
         del.style.fontSize = "0.9em";
         del.style.cursor = "pointer";
         del.style.marginLeft = "10px";
         del.addEventListener("click", function() {
           deleteSpan(index);
         });
         actions.appendChild(del);
         
         item.appendChild(actions);
         spansListContainer.appendChild(item);
       });
     }
   }
   
   renderSpansList();
   dialogBox.appendChild(spansListContainer);
   
   // Add new span form
   const addSpanForm = document.createElement("div");
   addSpanForm.style.backgroundColor = "#f9f9f9";
   addSpanForm.style.padding = "15px";
   addSpanForm.style.borderRadius = "5px";
   addSpanForm.style.marginBottom = "20px";
   
   const formTitle = document.createElement("h4");
   formTitle.textContent = "Add Span";
   formTitle.style.marginTop = "0";
   formTitle.style.marginBottom = "15px";
   addSpanForm.appendChild(formTitle);
   
   // Span start and end values
   const spanValuesRow = document.createElement("div");
   spanValuesRow.style.display = "flex";
   spanValuesRow.style.alignItems = "center";
   spanValuesRow.style.marginBottom = "10px";
   
   const startValueLabel = document.createElement("label");
   startValueLabel.textContent = "Start Value:";
   startValueLabel.style.display = "inline-block";
   startValueLabel.style.width = "140px";
   startValueLabel.style.marginRight = "10px";
   spanValuesRow.appendChild(startValueLabel);
   
   const startValueInput = document.createElement("input");
   startValueInput.id = "spanStartValue";
   startValueInput.type = "text";
   startValueInput.placeholder = "e.g. 2";
   startValueInput.style.width = "80px";
   startValueInput.style.marginRight = "20px";
   spanValuesRow.appendChild(startValueInput);
   
   const endValueLabel = document.createElement("label");
   endValueLabel.textContent = "End Value:";
   endValueLabel.style.marginRight = "10px";
   spanValuesRow.appendChild(endValueLabel);
   
   const endValueInput = document.createElement("input");
   endValueInput.id = "spanEndValue";
   endValueInput.type = "text";
   endValueInput.placeholder = "e.g. 5";
   endValueInput.style.width = "80px";
   spanValuesRow.appendChild(endValueInput);
   
   addSpanForm.appendChild(spanValuesRow);
   
   // Span type
   const spanTypeRow = document.createElement("div");
   spanTypeRow.style.display = "flex";
   spanTypeRow.style.alignItems = "center";
   spanTypeRow.style.marginBottom = "10px";
   
   const spanTypeLabel = document.createElement("label");
   spanTypeLabel.textContent = "Span Type:";
   spanTypeLabel.style.display = "inline-block";
   spanTypeLabel.style.width = "140px";
   spanTypeLabel.style.marginRight = "10px";
   spanTypeRow.appendChild(spanTypeLabel);
   
   const spanTypeSelect = document.createElement("select");
   spanTypeSelect.id = "spanType";
   
   const lineOption = document.createElement("option");
   lineOption.value = "line";
   lineOption.textContent = "Simple Span |-----|";
   spanTypeSelect.appendChild(lineOption);
   
   const arrowOption = document.createElement("option");
   arrowOption.value = "arrow";
   arrowOption.textContent = "Arrow →";
   spanTypeSelect.appendChild(arrowOption);
   
   const bouncyOption = document.createElement("option");
   bouncyOption.value = "bouncy";
   bouncyOption.textContent = "Bent Arrow";
   spanTypeSelect.appendChild(bouncyOption);
   
   spanTypeRow.appendChild(spanTypeSelect);
   addSpanForm.appendChild(spanTypeRow);
   
   // Span style
   const spanStyleRow = document.createElement("div");
   spanStyleRow.style.display = "flex";
   spanStyleRow.style.alignItems = "center";
   spanStyleRow.style.marginBottom = "10px";
   
   const spanColorLabel = document.createElement("label");
   spanColorLabel.textContent = "Color:";
   spanColorLabel.style.display = "inline-block";
   spanColorLabel.style.width = "140px";
   spanColorLabel.style.marginRight = "10px";
   spanStyleRow.appendChild(spanColorLabel);
   
   const spanColorInput = document.createElement("input");
   spanColorInput.id = "spanColor";
   spanColorInput.type = "color";
   spanColorInput.value = "#0000FF";
   spanColorInput.style.marginRight = "20px";
   spanStyleRow.appendChild(spanColorInput);
   
   const spanWidthLabel = document.createElement("label");
   spanWidthLabel.textContent = "Width:";
   spanWidthLabel.style.marginRight = "10px";
   spanStyleRow.appendChild(spanWidthLabel);
   
   const spanWidthInput = document.createElement("input");
   spanWidthInput.id = "spanWidth";
   spanWidthInput.type = "number";
   spanWidthInput.min = "1";
   spanWidthInput.max = "5";
   spanWidthInput.value = "3";
   spanWidthInput.style.width = "50px";
   spanStyleRow.appendChild(spanWidthInput);
   
   addSpanForm.appendChild(spanStyleRow);
   
   // Add span button
   const addBtnRow = document.createElement("div");
   
   const addSpanBtn = document.createElement("button");
   addSpanBtn.textContent = "Add Span";
   addSpanBtn.style.padding = "8px 16px";
   addSpanBtn.style.cursor = "pointer";
   addSpanBtn.style.backgroundColor = "#4CAF50";
   addSpanBtn.style.color = "white";
   addSpanBtn.style.border = "none";
   addSpanBtn.style.borderRadius = "4px";
   
   // Hidden input for tracking editing state
   const editingIndexInput = document.createElement("input");
   editingIndexInput.type = "hidden";
   editingIndexInput.id = "editingSpanIndex";
   editingIndexInput.value = "-1";
   addBtnRow.appendChild(editingIndexInput);
   
   addBtnRow.appendChild(addSpanBtn);
   addSpanForm.appendChild(addBtnRow);
   
   dialogBox.appendChild(addSpanForm);
   
   // Function to edit a span
   function editSpan(index) {
     if (index < 0 || index >= container.numberLineData.spans.length) {
       return;
     }
     
     const span = container.numberLineData.spans[index];
     
     startValueInput.value = span.startValue;
     endValueInput.value = span.endValue;
     spanTypeSelect.value = span.type;
     spanColorInput.value = span.color;
     spanWidthInput.value = span.width;
     
     editingIndexInput.value = index;
     addSpanBtn.textContent = 'Update Span';
   }
   
   // Function to delete a span
   function deleteSpan(index) {
     if (index < 0 || index >= container.numberLineData.spans.length) {
       return;
     }
     
     container.numberLineData.spans.splice(index, 1);
     
     // If we were editing this span, reset the form
     if (parseInt(editingIndexInput.value) === index) {
       startValueInput.value = '';
       endValueInput.value = '';
       editingIndexInput.value = "-1";
       addSpanBtn.textContent = "Add Span";
     }
     
     // Update UI
     renderSpansList();
     drawNumberLine();
   }
   addSpanBtn.addEventListener("click", function() {
  // Read & trim raw inputs
  const rawS = startValueInput.value.trim();
  const rawE = endValueInput.value.trim();
  
  // Parse (or keep literal if it contains “#”)
  const startValue = rawS.includes('#') ? rawS : parseFloat(rawS);
  const endValue   = rawE.includes('#') ? rawE : parseFloat(rawE);
  
  const type  = spanTypeSelect.value;
  const color = spanColorInput.value;
  const width = parseInt(spanWidthInput.value, 10);

  // Validate numeric-only cases
  if (!rawS.includes('#') && isNaN(startValue)) {
    alert('Please enter a valid number for the span start');
    return;
  }
  if (!rawE.includes('#') && isNaN(endValue)) {
    alert('Please enter a valid number for the span end');
    return;
  }

  // Check bounds if numeric
  const minValue = container.numberLineData.minValue;
  const maxValue = container.numberLineData.maxValue;
  if (
    (!rawS.includes('#') && (startValue < minValue || startValue > maxValue)) ||
    (!rawE.includes('#') && (endValue   < minValue || endValue   > maxValue))
  ) {
    alert(`Span values must be between ${minValue} and ${maxValue}`);
    return;
  }

  // Build span object
  const spanObj = { startValue, endValue, type, color, width };

  // Handle edit vs. add
  const editingIndex = parseInt(editingSpanIndex.value, 10);
  if (editingIndex >= 0 && editingIndex < container.numberLineData.spans.length) {
    container.numberLineData.spans[editingIndex] = spanObj;
    editingSpanIndex.value = "-1";
    addSpanBtn.textContent   = "Add Span";
  } else {
    container.numberLineData.spans.push(spanObj);
  }

  // Reset form and redraw
  startValueInput.value = '';
  endValueInput.value   = '';
  renderSpansList();
  drawNumberLine();
});

   
   // Dialog buttons
   const buttonsContainer = document.createElement("div");
   buttonsContainer.style.display = "flex";
   buttonsContainer.style.justifyContent = "flex-end";
   buttonsContainer.style.marginTop = "20px";
   
   const closeButton = document.createElement("button");
   closeButton.textContent = "Close";
   closeButton.style.padding = "8px 16px";
   closeButton.style.cursor = "pointer";
   
   closeButton.addEventListener("click", function() {
     document.body.removeChild(dialogBackdrop);
   });
   
   buttonsContainer.appendChild(closeButton);
   dialogBox.appendChild(buttonsContainer);
   
   dialogBackdrop.appendChild(dialogBox);
   document.body.appendChild(dialogBackdrop);
 }
 
 // Functions for element activation and deactivation
 function activateNumberLine() {
   // Deactivate the previously active element if any
   if (window.activeNumberLineElement && window.activeNumberLineElement !== container) {
     window.activeNumberLineElement.style.border = "none";
     
     const prevToolbar = window.activeNumberLineElement.querySelector(".number-line-toolbar");
     const prevResizeHandle = window.activeNumberLineElement.querySelector(".resize-handle");
     
     if (prevToolbar) prevToolbar.style.display = "none";
     if (prevResizeHandle) prevResizeHandle.style.display = "none";
   }
   
   window.activeNumberLineElement = container;
   
   container.style.border = "1px dashed #ccc";
   localToolbar.style.display = "flex";
   resizeHandle.style.display = "block";
   
   updateGlobalToolbar();
 }
 
 function deactivateNumberLine() {
   if (window.activeNumberLineElement === container) {
     container.style.border = "none";
     localToolbar.style.display = "none";
     resizeHandle.style.display = "none";
     window.activeNumberLineElement = null;
     
     const globalToolbar = document.getElementById("global-toolbar");
     if (globalToolbar) {
       globalToolbar.innerHTML = "";
     }
   }
 }
 
 function deleteNumberLine() {
   if (window.activeNumberLineElement === container) {
     window.activeNumberLineElement = null;
   }
   
   try {
     if (container.parentNode) {
       container.parentNode.removeChild(container);
     }
     
     const globalToolbar = document.getElementById("global-toolbar");
     if (globalToolbar) globalToolbar.innerHTML = "";
   } catch (err) {
     console.error("Error removing container:", err);
   }
 }
 
 // Event listeners
 container.addEventListener("mousedown", function(e) {
   if (e.target !== dragHandle && e.target !== resizeHandle) {
     activateNumberLine();
   }
 });
 
 deleteButton.addEventListener("mousedown", function(e) {
   e.preventDefault();
   e.stopPropagation();
   deleteNumberLine();
 });
 
 deleteButton.addEventListener("click", function(e) {
   e.preventDefault();
   e.stopPropagation();
   deleteNumberLine();
 });
 
 // Resize handle functionality
 resizeHandle.addEventListener("mousedown", function(e) {
   e.preventDefault();
   e.stopPropagation();
   
   const startX = e.clientX;
   const startY = e.clientY;
   const startWidth = container.offsetWidth;
   const startHeight = container.offsetHeight;
   
   function onMouseMove(e) {
     const newWidth = Math.max(300, startWidth + (e.clientX - startX));
     const newHeight = Math.max(100, startHeight + (e.clientY - startY));
     
     container.style.width = newWidth + "px";
     container.style.height = newHeight + "px";
     
     drawNumberLine();
   }
   
   function onMouseUp() {
     document.removeEventListener("mousemove", onMouseMove);
     document.removeEventListener("mouseup", onMouseUp);
   }
   
   document.addEventListener("mousemove", onMouseMove);
   document.addEventListener("mouseup", onMouseUp);
 });
 
 // Drag handle functionality
 dragHandle.addEventListener("mousedown", function(e) {
   e.preventDefault();
   e.stopPropagation();
   
   container.isDragging = false;
   const canvasRect = canvas.getBoundingClientRect();
   const rect = container.getBoundingClientRect();
   const startX = e.clientX;
   const startY = e.clientY;
   const shiftX = e.clientX - rect.left;
   const shiftY = e.clientY - rect.top;
   
   function onMouseMove(e) {
     const dx = e.clientX - startX;
     const dy = e.clientY - startY;
     
     if (Math.sqrt(dx * dx + dy * dy) > 5) {
       container.isDragging = true;
     }
     
     const newLeft = e.clientX - shiftX - canvasRect.left;
     const newTop = e.clientY - shiftY - canvasRect.top;
     
     container.style.left = newLeft + "px";
     container.style.top = newTop + "px";
   }
   
   function onMouseUp() {
     document.removeEventListener("mousemove", onMouseMove);
     document.removeEventListener("mouseup", onMouseUp);
   }
   
   document.addEventListener("mousemove", onMouseMove);
   document.addEventListener("mouseup", onMouseUp);
 });
 
 // Document click for deactivation
 document.addEventListener("click", function(e) {
   if (!container.contains(e.target) && window.activeNumberLineElement === container) {
     deactivateNumberLine();
   }
 });
 
 // Append to canvas and activate
 canvas.appendChild(container);
 
 // Store the draw function on the container so it can be called externally
 container.drawNumberLine = drawNumberLine;
 
 // Draw the initial number line
 drawNumberLine();
 
 // Activate the number line
 activateNumberLine();
 
 return container;
}



// Add Quadrant One Graph component to the canvas
function addQuadOneGraph() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeQuadOneGraphElement) {
    window.activeQuadOneGraphElement = null;
  }
  // Global counter for quadrant one graph IDs
  if (!window.globalQuadOneGraphCounter) {
    window.globalQuadOneGraphCounter = 1;
  } else {
    window.globalQuadOneGraphCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element quad-one-graph-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "600px";
  container.style.height = (toolbarHeight + 600) + "px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this graph
  container.quadOneGraphID = window.globalQuadOneGraphCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-quad-one-graph-id', container.quadOneGraphID);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "quad-one-graph-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);
  
  // Create content div
  const content = document.createElement("div");
  content.className = "quad-one-graph-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create canvas for the graph
  const graphCanvas = document.createElement("canvas");
  graphCanvas.id = "quadOneCanvas-" + container.quadOneGraphID;
  graphCanvas.width = 600;
  graphCanvas.height = 600;
  graphCanvas.style.width = "100%";
  graphCanvas.style.height = "100%";
  content.appendChild(graphCanvas);

  // Store the data needed for the graph
  container.graphData = {
    xmin: 0,
    xmax: 10,
    ymin: 0,
    ymax: 10,
    xscale: 1,
    yscale: 1,
    xlabelInterval: 1,
    ylabelInterval: 1,
    tickFontSize: 14,
    axisLabelFontSize: 20,
    xAxisLabel: "x",
    yAxisLabel: "y",
    tickFontFamily: "'Computer Modern Serif', serif",
    axisLabelFontFamily: "'Computer Modern Serif', serif",
    axisLabelItalic: true,
    axisLabelBold: false,
    equations: [],
    points: [],
    segments: []
  };

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Define helper functions
  function gcd(a, b) { 
    return b ? gcd(b, a % b) : a; 
  }
  
  function formatLabel(val) {
    // Handle variable cases
    if (typeof val === 'string' && val.includes('#')) {
      return val; // Return as is for later substitution
    }
    
    // Handle integer values
    if (Number.isInteger(val)) return val.toString();
    
    // Check if it's close to a multiple of pi
    const piVal = val / Math.PI;
    const eps = 1e-4; // More precise comparison
    
    // Check for common π fractions: π/6, π/4, π/3, π/2, 2π/3, 3π/4, 5π/6, π, etc.
    for (let den = 1; den <= 12; den++) {
      // Only check denominators that are common for π fractions (1, 2, 3, 4, 6)
      if (den > 6 && den !== 12) continue;
      
      const num = Math.round(piVal * den);
      if (Math.abs(piVal - num / den) < eps) {
        // Handle various special cases
        if (num === 0) return "0";
        
        // Full pi multiples
        if (den === 1) {
          if (num === 1) return "π";
          if (num === -1) return "-π";
          return `${num}π`;
        }
        
        // Simplified fractions of pi
        const g = gcd(Math.abs(num), den);
        const simplifiedNum = num / g;
        const simplifiedDen = den / g;
        
        if (simplifiedNum === 1) return `π/${simplifiedDen}`;
        if (simplifiedNum === -1) return `-π/${simplifiedDen}`;
        
        return `${simplifiedNum}π/${simplifiedDen}`;
      }
    }
    
    // Handle regular decimals
    return val.toFixed(2);
  }



  // ─── Safe-expression whitelist ────────────────────────────────────────────
  const safeExpr = new RegExp(
    '^\\s*' +
    '(?:' +
      '\\d+(?:\\.\\d+)?' +    // numbers
      '|x' +                  // the variable x
      '|#\\w+#' +             // placeholders like #a#
      '|abs|sin|cos|tan' +    // allowed functions
      '|[+\\-*/^(),\\s]+' +   // operators, commas, parentheses, spaces
    ')+' +
    '\\s*$'
  );


  
  // Updated safe expression validation to allow variable placeholders
  /**
   * Only numbers, x, #var#, abs/sin/cos/tan, + - * / ^ , ( ) and spaces allowed.
   */
   function isSafeMathExpression(str) {
    return safeExpr.test(str);
  }

  
  // The parseGraphInput function that handles variables
  function parseGraphInput(str) {
    const v = String(str).trim().toLowerCase();

    // Handle variable substitution
    if (v.includes('#')) {
      return str; // Return the raw string with #vars# for later substitution
    }

    // π-notation
    if (v.includes('π') || v.includes('pi')) {
      let norm = v
        .replace(/pi/g, 'π')                // pi → π
        .replace(/(\d)(π)/g, '$1*π')        // 2π → 2*π
        .replace(/π/g, 'Math.PI');         // π → Math.PI

      // whitelist: only allow Math.PI or digits and these symbols
      const whitelist = /^(?:(?:Math\.PI)|[0-9\.\+\-\*\/\(\)\s])+$/;
      if (!whitelist.test(norm)) {
        console.warn('Invalid input:', str);
        return NaN;
      }

      try {
        return eval(norm);
      } catch {
        return NaN;
      }
    }

    // fraction a/b
    if (v.includes('/')) {
      const [n, d] = v.split('/').map(Number);
      if (!isNaN(n) && !isNaN(d) && d !== 0) {
        return n / d;
      }
      return NaN;
    }

    // plain decimal
    const num = parseFloat(v);
    return isNaN(num) ? NaN : num;
  }
  
  // Function to draw the graph
  function drawGraph() {
    // Get the canvas element
    const canvas = graphCanvas;
    const ctx = canvas.getContext('2d');
    
    // --- Axis parameters ---
    let xmin = container.graphData.xmin,
        xmax = container.graphData.xmax,
        xscale = container.graphData.xscale,
        xi = container.graphData.xlabelInterval;
        
    let ymin = container.graphData.ymin,
        ymax = container.graphData.ymax,
        yscale = container.graphData.yscale,
        yi = container.graphData.ylabelInterval;
        
    const axMin = xmin - xscale, axMax = xmax + xscale;
    const ayMin = ymin - yscale, ayMax = ymax + yscale;
    
    // Define plot ranges that extend beyond visible area
    const plotXmin = Math.max(0, axMin);  // Ensure plotXmin is not negative
    const plotXmax = axMax;
    
    // --- Clamp grid density ---
    const maxGridLines = 200;
    // Compute how many would be drawn at this scale:
    const rawXLines = (xmax - xmin) / xscale;
    if (rawXLines > maxGridLines) {
      xscale = (xmax - xmin) / maxGridLines;
    }
    const rawYLines = (ymax - ymin) / yscale;
    if (rawYLines > maxGridLines) {
      yscale = (ymax - ymin) / maxGridLines;
    }
    
    // --- Time‑budget settings ---
    const tStart = performance.now();
    const maxDuration = 100; // ms
    let aborted = false;
    
    // --- Sampling cap for plotting ---
    const rawSteps = (plotXmax - plotXmin) / (xscale / 100);
    const maxSamples = 1000;
    const dx = (plotXmax - plotXmin) / Math.min(maxSamples, Math.max(1, Math.ceil(rawSteps)));
    
    // --- Style parameters ---
    const tickFontSize = container.graphData.tickFontSize;
    const axisLabelFontSize = container.graphData.axisLabelFontSize;
    const tickFontFamily = container.graphData.tickFontFamily;
    const axisLabelFontFamily = container.graphData.axisLabelFontFamily;
    const axisLabelItalic = container.graphData.axisLabelItalic;
    const axisLabelBold = container.graphData.axisLabelBold;
    const xAxisLabel = container.graphData.xAxisLabel;
    const yAxisLabel = container.graphData.yAxisLabel;
    
    // --- Canvas & transforms ---
// ─── Setup with left + bottom margins so labels never get clipped ─────────
const W = canvas.width;
const H = canvas.height;
ctx.clearRect(0, 0, W, H);

// pixel margin to the left (for Y-numbers & label)...
const marginLeftPx   = container.graphData.tickFontSize + 8;

// pixel margin at the bottom (for X-numbers + axis label)...
const marginBottomPx = 
    container.graphData.tickFontSize       // tick font
  + container.graphData.axisLabelFontSize  // axis-label font
  + 8;                                      // a little breathing room

// effective drawing width/height
const drawW = W  - marginLeftPx;
const drawH = H  - marginBottomPx;

// remap your coordinates into that “safe” box
const toPxX = x => marginLeftPx + (x - axMin) * (drawW / (axMax - axMin));
const toPxY = y => drawH        - (y - ayMin) * (drawH / (ayMax - ayMin));

// recalc origin in px
const x0 = toPxX(0);
const y0 = toPxY(0);


    // --- Grid lines ---
    ctx.setLineDash([]);
    ctx.strokeStyle = 'rgba(128,128,128,0.5)';
    ctx.lineWidth = 0.5;
    
    // Draw vertical grid lines (only from x-axis upward)
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath(); 
      ctx.moveTo(px, y0); // Start from x-axis 
      ctx.lineTo(px, 0);  // Draw up to top of canvas
      ctx.stroke();
    }
    
    // Draw horizontal grid lines (only from y-axis rightward)
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath(); 
      ctx.moveTo(x0, py);  // Start from y-axis
      ctx.lineTo(W, py);   // Draw to right edge of canvas
      ctx.stroke();
    }
    
    // --- Axes ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; 
    ctx.lineWidth = 2.5; // Thicker axes

    // Draw x-axis only from 0 to positive values
    ctx.beginPath(); 
    ctx.moveTo(x0, y0); // Start from origin (0,0)
    ctx.lineTo(toPxX(axMax), y0); // Draw only to positive x direction
    ctx.stroke();

    // Draw y-axis only from 0 to positive values
    ctx.beginPath(); 
    ctx.moveTo(x0, y0); // Start from origin (0,0)
    ctx.lineTo(x0, toPxY(ayMax)); // Draw only to positive y direction
    ctx.stroke();
    
    // --- Arrowheads ---
    ctx.fillStyle = '#000'; const head = 12;
    // +X
    ctx.beginPath(); ctx.moveTo(toPxX(axMax), y0);
    ctx.lineTo(toPxX(axMax) - head, y0 - head/2);
    ctx.lineTo(toPxX(axMax) - head, y0 + head/2);
    ctx.closePath(); ctx.fill();
    
    // +Y
    ctx.beginPath(); ctx.moveTo(x0, toPxY(ayMax));
    ctx.lineTo(x0 - head/2, toPxY(ayMax) + head);
    ctx.lineTo(x0 + head/2, toPxY(ayMax) + head);
    ctx.closePath(); ctx.fill();
    
    // --- Ticks & numeric labels ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.fillStyle = '#000';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.font = `${tickFontSize}px ${tickFontFamily}`;
    
    // X‑ticks
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath();
      ctx.moveTo(px, y0 - 5);
      ctx.lineTo(px, y0 + 5);
      ctx.stroke();
      
      // → robust label test instead of "x % xi === 0"
      const ratio = x / xi;
      if (x !== 0 && Math.abs(ratio - Math.round(ratio)) < 1e-6) {
        ctx.fillText(formatLabel(x), px, y0 + tickFontSize + 4);
      }
    }
    
    // Y‑ticks
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath(); ctx.moveTo(x0 - 5, py); ctx.lineTo(x0 + 5, py); ctx.stroke();
      if (y !== 0 && y % yi === 0) {
        ctx.fillText(formatLabel(y), x0 - tickFontSize - 4, py);
      }
    }
    
    // Origin "0"
    ctx.fillText('0', x0 - tickFontSize/2, y0 + tickFontSize/2+3);
    
    // --- Axis labels ---
    ctx.fillStyle = '#000';
    
    // Build font style string based on selected options
    let fontStyle = '';
    if (axisLabelItalic) fontStyle += 'italic ';
    if (axisLabelBold) fontStyle += 'bold ';
    ctx.font = `${fontStyle}${axisLabelFontSize}px ${axisLabelFontFamily}`;
    
 // X-axis label (just under the tick numbers)
 // X-axis label (clamped inside the bottom edge)
// ─── X-axis LABEL (always below the tick numbers) ─────────────────
ctx.textAlign    = 'center';
ctx.textBaseline = 'top'; 
// compute where your tick-labels are centered:
const tickCenterY = y0 + tickFontSize + 4;
// bottom of those tick-labels (baseline=middle, so + half a font):
const bottomTickY = tickCenterY + tickFontSize/2;
// add a little margin:
const desiredY    = bottomTickY + 6;
// never draw past the very bottom of the graph:
const xLabelY     = Math.min(desiredY, H - axisLabelFontSize); 
ctx.fillText(xAxisLabel, W/2+15, xLabelY);


    
    // Y-axis label (center left, rotated)
// Y-axis label (centered inside left margin)
ctx.save();
// half-margin keeps it away from tick-numbers
const leftPadding            = marginLeftPx / 2;
const yLabelVerticalPosition = H / 2 - 20;

ctx.translate(leftPadding, yLabelVerticalPosition);
ctx.rotate(-Math.PI / 2);
ctx.textAlign    = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(yAxisLabel, 0, 0);
ctx.restore();

    
    // --- Plot equations (with time‑check) ---
    for (let i = 0; i < container.graphData.equations.length; i++) {
      if (performance.now() - tStart > maxDuration) {
        aborted = true;
        break;
      }
      
     
       // … inside the for-loop over equations …
       const eq = container.graphData.equations[i], eqStr = eq.equation;
    
    if (!isSafeMathExpression(eqStr)) {
      alert(
        'Invalid equation. Only numbers, the variable x or placeholders #var#,\n' +
        'functions abs(), sin(), cos(), tan(), and operators + - * / ^ , ( ) are allowed.'
      );
      return;
    }
    
    // … then you do math.compile, etc. …

      
      try {
        const expr = math.compile(eqStr);
        ctx.strokeStyle = eq.color;
        ctx.lineWidth = eq.width;
        ctx.setLineDash(eq.style === 'dotted' ? [2,3]
                         : eq.style === 'dashed' ? [5,5]
                         : []);
        
        ctx.beginPath();
        let first = true;
        for (let x = Math.max(0, plotXmin); x <= plotXmax; x += dx) { // Ensure x is not negative
          // Check domain restrictions
          const skipDueToMinDomain = 
            (eq.domainMinOp === '<' && x <= parseFloat(eq.domainMin)) || 
            (eq.domainMinOp === '≤' && x < parseFloat(eq.domainMin));
          
          const skipDueToMaxDomain = 
            (eq.domainMaxOp === '<' && x >= parseFloat(eq.domainMax)) || 
            (eq.domainMaxOp === '≤' && x > parseFloat(eq.domainMax));
            
          // Skip this x value if it's outside the domain
          if ((eq.domainMinOp !== 'none' && eq.domainMin && skipDueToMinDomain) || 
              (eq.domainMaxOp !== 'none' && eq.domainMax && skipDueToMaxDomain)) {
            if (!first) { // End the current path segment
              ctx.stroke();
              ctx.beginPath();
              first = true;
            }
            continue;
          }
          
          // Handle special cases by equation type
          let y;
          
          if (eq.type === 'absoluteValue') {
            try {
              const exprStr = eqStr.includes('abs(') ? eqStr : `abs(${eqStr})`;
              y = math.evaluate(exprStr, { x });
            } catch (e) {
              console.error("Error evaluating absolute value:", e);
              continue;
            }
          } else {
            try {
              y = expr.evaluate({ x });
            } catch (e) {
              console.error("Error evaluating expression:", e);
              continue;
            }
          }
          
          // Only plot points where y is positive (Quadrant 1)
          if (!isNaN(y) && isFinite(y) && y >= 0) {
            const px = toPxX(x), py = toPxY(y);
            first ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
            first = false;
          }
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        if (aborted) break;
      } catch (e) {
        console.error("Error plotting:", e);
      }
    }
    
    // --- Draw segments ---
    container.graphData.segments.forEach(seg => {
      // Only draw segments with positive coordinates (Quadrant 1)
      if (seg.x1 >= 0 && seg.y1 >= 0 && seg.x2 >= 0 && seg.y2 >= 0) {
        ctx.strokeStyle = seg.color;
        ctx.lineWidth = seg.width;
        ctx.setLineDash(seg.style === 'dashed' ? [5,5] : []);
        const x1 = toPxX(seg.x1), y1 = toPxY(seg.y1);
        const x2 = toPxX(seg.x2), y2 = toPxY(seg.y2);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        ctx.setLineDash([]);
      }
    });
    
    // --- Draw points & labels ---
    container.graphData.points.forEach(pt => {
      // Only draw points with positive coordinates (Quadrant 1)
      if (pt.x >= 0 && pt.y >= 0) {
        const px = toPxX(pt.x), py = toPxY(pt.y);
        
        // Draw the point
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(px, py, pt.pointSize || 4, 0, 2*Math.PI); ctx.fill();
        
        // Draw the label
        ctx.fillStyle = pt.color;
        ctx.font = pt.fontSize + 'px ' + tickFontFamily;
        const m = ctx.measureText(pt.label), w = m.width, h = pt.fontSize;
        
        // Position the label based on the specified position
        let dxOff = 0, dyOff = 0;
        switch(pt.position) {
          case 'up':       dyOff = -h - 2; break;
          case 'down':     dyOff = 16;     break;
          case 'left':     dxOff = -w;     break;
          case 'right':    dxOff = 21;     break;
          case 'upleft':   dxOff = -w; dyOff = -h+3; break;
          case 'upright':  dxOff = 10; dyOff = -h-2; break;
          case 'downleft': dxOff = -w; dyOff = 10;   break;
          case 'downright':dxOff = 10; dyOff = 17;   break;
        }
        
        // Draw the label text
        ctx.fillText(pt.label, px + dxOff, py + dyOff);
      }
    });
    
    // Draw domain endpoints
    function drawDomainEndpoints() {
      container.graphData.equations.forEach(eq => {
        if ((eq.domainMinOp === '<' || eq.domainMinOp === '≤') && eq.domainMin) {
          const x = parseFloat(eq.domainMin);
          // Only draw if within visible range and positive (Quadrant 1)
          if (x >= xmin && x <= xmax && x >= 0) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              // Only draw if y is positive (Quadrant 1)
              if (!isNaN(y) && isFinite(y) && y >= 0) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMinOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating endpoint:", e);
            }
          }
        }

        if ((eq.domainMaxOp === '<' || eq.domainMaxOp === '≤') && eq.domainMax) {
          const x = parseFloat(eq.domainMax);
          // Only draw if within visible range and positive (Quadrant 1)
          if (x >= xmin && x <= xmax && x >= 0) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              // Only draw if y is positive (Quadrant 1)
              if (!isNaN(y) && isFinite(y) && y >= 0) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMaxOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating endpoint:", e);
            }
          }
        }
      });
    }
    
    // Call the function to draw domain endpoints
    drawDomainEndpoints();
    
    // --- Notify if aborted ---
    if (aborted) {
      alert("Plotting aborted: took too long.");
    }
  }
  
  // Function to update the global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    
    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Quadrant One Graph " + container.quadOneGraphID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Graph Settings button
    const graphSettingsBtn = document.createElement("button");
    graphSettingsBtn.textContent = "Graph Settings";
    graphSettingsBtn.style.marginRight = "10px";
    graphSettingsBtn.style.padding = "5px 10px";
    graphSettingsBtn.style.cursor = "pointer";
    graphSettingsBtn.addEventListener("click", function() {
      showGraphSettingsDialog();
    });
    controls.appendChild(graphSettingsBtn);
    
    // Equations button
    const equationsBtn = document.createElement("button");
    equationsBtn.textContent = "Equations";
    equationsBtn.style.marginRight = "10px";
    equationsBtn.style.padding = "5px 10px";
    equationsBtn.style.cursor = "pointer";
    equationsBtn.addEventListener("click", function() {
      showEquationsDialog();
    });
    controls.appendChild(equationsBtn);
    
    // Points button
    const pointsBtn = document.createElement("button");
    pointsBtn.textContent = "Points";
    pointsBtn.style.marginRight = "10px";
    pointsBtn.style.padding = "5px 10px";
    pointsBtn.style.cursor = "pointer";
    pointsBtn.addEventListener("click", function() {
      showPointsDialog();
    });
    controls.appendChild(pointsBtn);
    
    // Segments button
    const segmentsBtn = document.createElement("button");
    segmentsBtn.textContent = "Segments";
    segmentsBtn.style.marginRight = "10px";
    segmentsBtn.style.padding = "5px 10px";
    segmentsBtn.style.cursor = "pointer";
    segmentsBtn.addEventListener("click", function() {
      showSegmentsDialog();
    });
    controls.appendChild(segmentsBtn);
    
    globalToolbar.appendChild(controls);
  }

  // Function to store axis input with support for variables
  function storeAxisInput(field, raw) {
    raw = raw.trim();
    // if it contains a variable placeholder (#…#), store it un-parsed
    if (raw.includes('#')) return raw;
    // otherwise parse numbers, π, or fractions
    return parseGraphInput(raw);
  }

  // Function to show Graph Settings dialog
 // Function to show Graph Settings dialog
 function showGraphSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Graph Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // X-axis settings section
    const xAxisSection = document.createElement("div");
    xAxisSection.style.marginBottom = "20px";
    
    const xAxisTitle = document.createElement("h4");
    xAxisTitle.textContent = "X-Axis Settings";
    xAxisTitle.style.marginBottom = "10px";
    xAxisSection.appendChild(xAxisTitle);
    
    // X-min input
    const xMinRow = document.createElement("div");
    xMinRow.style.display = "flex";
    xMinRow.style.alignItems = "center";
    xMinRow.style.marginBottom = "10px";
    
    const xMinLabel = document.createElement("label");
    xMinLabel.textContent = "x-min:";
    xMinLabel.style.width = "140px";
    xMinLabel.style.marginRight = "10px";
    xMinRow.appendChild(xMinLabel);
    
    const xMinInput = document.createElement("input");
    xMinInput.type = "text";
    xMinInput.value = container.graphData.xmin;
    xMinInput.style.marginRight = "10px";
    xMinRow.appendChild(xMinInput);
    
    xAxisSection.appendChild(xMinRow);
    
    // X-max input
    const xMaxRow = document.createElement("div");
    xMaxRow.style.display = "flex";
    xMaxRow.style.alignItems = "center";
    xMaxRow.style.marginBottom = "10px";
    
    const xMaxLabel = document.createElement("label");
    xMaxLabel.textContent = "x-max:";
    xMaxLabel.style.width = "140px";
    xMaxLabel.style.marginRight = "10px";
    xMaxRow.appendChild(xMaxLabel);
    
    const xMaxInput = document.createElement("input");
    xMaxInput.type = "text";
    xMaxInput.value = container.graphData.xmax;
    xMaxInput.style.marginRight = "10px";
    xMaxRow.appendChild(xMaxInput);
    
    xAxisSection.appendChild(xMaxRow);
    
    // X-scale input
    const xScaleRow = document.createElement("div");
    xScaleRow.style.display = "flex";
    xScaleRow.style.alignItems = "center";
    xScaleRow.style.marginBottom = "10px";
    
    const xScaleLabel = document.createElement("label");
    xScaleLabel.textContent = "x-scale:";
    xScaleLabel.style.width = "140px";
    xScaleLabel.style.marginRight = "10px";
    xScaleRow.appendChild(xScaleLabel);
    
    const xScaleInput = document.createElement("input");
    xScaleInput.type = "text";
    xScaleInput.value = container.graphData.xscale;
    xScaleInput.style.marginRight = "10px";
    xScaleRow.appendChild(xScaleInput);
    
    xAxisSection.appendChild(xScaleRow);
    
    // X-label interval input
    const xLabelIntervalRow = document.createElement("div");
    xLabelIntervalRow.style.display = "flex";
    xLabelIntervalRow.style.alignItems = "center";
    xLabelIntervalRow.style.marginBottom = "10px";
    
    const xLabelIntervalLabel = document.createElement("label");
    xLabelIntervalLabel.textContent = "x-label interval:";
    xLabelIntervalLabel.style.width = "140px";
    xLabelIntervalLabel.style.marginRight = "10px";
    xLabelIntervalRow.appendChild(xLabelIntervalLabel);
    
    const xLabelIntervalInput = document.createElement("input");
    xLabelIntervalInput.type = "text";
    xLabelIntervalInput.value = container.graphData.xlabelInterval;
    xLabelIntervalInput.style.marginRight = "10px";
    xLabelIntervalRow.appendChild(xLabelIntervalInput);
    
    xAxisSection.appendChild(xLabelIntervalRow);
    
    // X-axis label input
    const xAxisLabelRow = document.createElement("div");
    xAxisLabelRow.style.display = "flex";
    xAxisLabelRow.style.alignItems = "center";
    xAxisLabelRow.style.marginBottom = "10px";
    
    const xAxisLabelRowLabel = document.createElement("label");
    xAxisLabelRowLabel.textContent = "x-axis label:";
    xAxisLabelRowLabel.style.width = "140px";
    xAxisLabelRowLabel.style.marginRight = "10px";
    xAxisLabelRow.appendChild(xAxisLabelRowLabel);
    
    const xAxisLabelInput = document.createElement("input");
    xAxisLabelInput.type = "text";
    xAxisLabelInput.value = container.graphData.xAxisLabel;
    xAxisLabelInput.style.marginRight = "10px";
    xAxisLabelRow.appendChild(xAxisLabelInput);
    
    xAxisSection.appendChild(xAxisLabelRow);
    
    dialogBox.appendChild(xAxisSection);
    
    // Y-axis settings section
    const yAxisSection = document.createElement("div");
    yAxisSection.style.marginBottom = "20px";
    
    const yAxisTitle = document.createElement("h4");
    yAxisTitle.textContent = "Y-Axis Settings";
    yAxisTitle.style.marginBottom = "10px";
    yAxisSection.appendChild(yAxisTitle);
    
    // Y-min input
    const yMinRow = document.createElement("div");
    yMinRow.style.display = "flex";
    yMinRow.style.alignItems = "center";
    yMinRow.style.marginBottom = "10px";
    
    const yMinLabel = document.createElement("label");
    yMinLabel.textContent = "y-min:";
    yMinLabel.style.width = "140px";
    yMinLabel.style.marginRight = "10px";
    yMinRow.appendChild(yMinLabel);
    
    const yMinInput = document.createElement("input");
    yMinInput.type = "text";
    yMinInput.value = container.graphData.ymin;
    yMinInput.style.marginRight = "10px";
    yMinRow.appendChild(yMinInput);
    
    yAxisSection.appendChild(yMinRow);
    
    // Y-max input
    const yMaxRow = document.createElement("div");
    yMaxRow.style.display = "flex";
    yMaxRow.style.alignItems = "center";
    yMaxRow.style.marginBottom = "10px";
    
    const yMaxLabel = document.createElement("label");
    yMaxLabel.textContent = "y-max:";
    yMaxLabel.style.width = "140px";
    yMaxLabel.style.marginRight = "10px";
    yMaxRow.appendChild(yMaxLabel);
    
    const yMaxInput = document.createElement("input");
    yMaxInput.type = "text";
    yMaxInput.value = container.graphData.ymax;
    yMaxInput.style.marginRight = "10px";
    yMaxRow.appendChild(yMaxInput);
    
    yAxisSection.appendChild(yMaxRow);
    
    // Y-scale input
    const yScaleRow = document.createElement("div");
    yScaleRow.style.display = "flex";
    yScaleRow.style.alignItems = "center";
    yScaleRow.style.marginBottom = "10px";
    
    const yScaleLabel = document.createElement("label");
    yScaleLabel.textContent = "y-scale:";
    yScaleLabel.style.width = "140px";
    yScaleLabel.style.marginRight = "10px";
    yScaleRow.appendChild(yScaleLabel);
    
    const yScaleInput = document.createElement("input");
    yScaleInput.type = "text";
    yScaleInput.value = container.graphData.yscale;
    yScaleInput.style.marginRight = "10px";
    yScaleRow.appendChild(yScaleInput);
    
    yAxisSection.appendChild(yScaleRow);
    
    // Y-label interval input
    const yLabelIntervalRow = document.createElement("div");
    yLabelIntervalRow.style.display = "flex";
    yLabelIntervalRow.style.alignItems = "center";
    yLabelIntervalRow.style.marginBottom = "10px";
    
    const yLabelIntervalLabel = document.createElement("label");
    yLabelIntervalLabel.textContent = "y-label interval:";
    yLabelIntervalLabel.style.width = "140px";
    yLabelIntervalLabel.style.marginRight = "10px";
    yLabelIntervalRow.appendChild(yLabelIntervalLabel);
    
    const yLabelIntervalInput = document.createElement("input");
    yLabelIntervalInput.type = "text";
    yLabelIntervalInput.value = container.graphData.ylabelInterval;
    yLabelIntervalInput.style.marginRight = "10px";
    yLabelIntervalRow.appendChild(yLabelIntervalInput);
    
    yAxisSection.appendChild(yLabelIntervalRow);
    
    // Y-axis label input
    const yAxisLabelRow = document.createElement("div");
    yAxisLabelRow.style.display = "flex";
    yAxisLabelRow.style.alignItems = "center";
    yAxisLabelRow.style.marginBottom = "10px";
    
    const yAxisLabelRowLabel = document.createElement("label");
    yAxisLabelRowLabel.textContent = "y-axis label:";
    yAxisLabelRowLabel.style.width = "140px";
    yAxisLabelRowLabel.style.marginRight = "10px";
    yAxisLabelRow.appendChild(yAxisLabelRowLabel);
    
    const yAxisLabelInput = document.createElement("input");
    yAxisLabelInput.type = "text";
    yAxisLabelInput.value = container.graphData.yAxisLabel;
    yAxisLabelInput.style.marginRight = "10px";
    yAxisLabelRow.appendChild(yAxisLabelInput);
    
    yAxisSection.appendChild(yAxisLabelRow);
    
    dialogBox.appendChild(yAxisSection);
    
    // Font settings section
    const fontSection = document.createElement("div");
    fontSection.style.marginBottom = "20px";
    
    const fontTitle = document.createElement("h4");
    fontTitle.textContent = "Font Settings";
    fontTitle.style.marginBottom = "10px";
    fontSection.appendChild(fontTitle);
    
    // Tick font size input
    const tickFontSizeRow = document.createElement("div");
    tickFontSizeRow.style.display = "flex";
    tickFontSizeRow.style.alignItems = "center";
    tickFontSizeRow.style.marginBottom = "10px";
    
    const tickFontSizeLabel = document.createElement("label");
    tickFontSizeLabel.textContent = "Tick Font Size:";
    tickFontSizeLabel.style.width = "140px";
    tickFontSizeLabel.style.marginRight = "10px";
    tickFontSizeRow.appendChild(tickFontSizeLabel);
    
    const tickFontSizeInput = document.createElement("input");
    tickFontSizeInput.type = "number";
    tickFontSizeInput.min = "6";
    tickFontSizeInput.max = "32";
    tickFontSizeInput.value = container.graphData.tickFontSize;
    tickFontSizeInput.style.marginRight = "10px";
    tickFontSizeRow.appendChild(tickFontSizeInput);
    
    fontSection.appendChild(tickFontSizeRow);
    
    // Tick font family
    const tickFontFamilyRow = document.createElement("div");
    tickFontFamilyRow.style.display = "flex";
    tickFontFamilyRow.style.alignItems = "center";
    tickFontFamilyRow.style.marginBottom = "10px";
    
    const tickFontFamilyLabel = document.createElement("label");
    tickFontFamilyLabel.textContent = "Tick Font:";
    tickFontFamilyLabel.style.width = "140px";
    tickFontFamilyLabel.style.marginRight = "10px";
    tickFontFamilyRow.appendChild(tickFontFamilyLabel);
    
    const tickFontFamilySelect = document.createElement("select");
    
    const fontOptions = [
      { value: "'Computer Modern Serif', serif", text: "Computer Modern" },
      { value: "Arial, sans-serif", text: "Arial" },
      { value: "'Times New Roman', serif", text: "Times New Roman" },
      { value: "'Courier New', monospace", text: "Courier New" },
      { value: "Georgia, serif", text: "Georgia" },
      { value: "Verdana, sans-serif", text: "Verdana" },
      { value: "'Trebuchet MS', sans-serif", text: "Trebuchet MS" }
    ];
    
    fontOptions.forEach(option => {
      const optEl = document.createElement("option");
      optEl.value = option.value;
      optEl.textContent = option.text;
      if (option.value === container.graphData.tickFontFamily) {
        optEl.selected = true;
      }
      tickFontFamilySelect.appendChild(optEl);
    });
    
    tickFontFamilyRow.appendChild(tickFontFamilySelect);
    fontSection.appendChild(tickFontFamilyRow);
    
    // Axis label font size input
    const axisLabelFontSizeRow = document.createElement("div");
    axisLabelFontSizeRow.style.display = "flex";
    axisLabelFontSizeRow.style.alignItems = "center";
    axisLabelFontSizeRow.style.marginBottom = "10px";
    
    const axisLabelFontSizeLabel = document.createElement("label");
    axisLabelFontSizeLabel.textContent = "Axis Label Font Size:";
    axisLabelFontSizeLabel.style.width = "140px";
    axisLabelFontSizeLabel.style.marginRight = "10px";
    axisLabelFontSizeRow.appendChild(axisLabelFontSizeLabel);
    
    const axisLabelFontSizeInput = document.createElement("input");
    axisLabelFontSizeInput.type = "number";
    axisLabelFontSizeInput.min = "6";
    axisLabelFontSizeInput.max = "48";
    axisLabelFontSizeInput.value = container.graphData.axisLabelFontSize;
    axisLabelFontSizeInput.style.marginRight = "10px";
    axisLabelFontSizeRow.appendChild(axisLabelFontSizeInput);
    
    fontSection.appendChild(axisLabelFontSizeRow);
    
    // Axis label font family
    const axisLabelFontFamilyRow = document.createElement("div");
    axisLabelFontFamilyRow.style.display = "flex";
    axisLabelFontFamilyRow.style.alignItems = "center";
    axisLabelFontFamilyRow.style.marginBottom = "10px";
    
    const axisLabelFontFamilyLabel = document.createElement("label");
    axisLabelFontFamilyLabel.textContent = "Axis Label Font:";
    axisLabelFontFamilyLabel.style.width = "140px";
    axisLabelFontFamilyLabel.style.marginRight = "10px";
    axisLabelFontFamilyRow.appendChild(axisLabelFontFamilyLabel);
    
    const axisLabelFontFamilySelect = document.createElement("select");
    
    fontOptions.forEach(option => {
      const optEl = document.createElement("option");
      optEl.value = option.value;
      optEl.textContent = option.text;
      if (option.value === container.graphData.axisLabelFontFamily) {
        optEl.selected = true;
      }
      axisLabelFontFamilySelect.appendChild(optEl);
    });
    
    axisLabelFontFamilyRow.appendChild(axisLabelFontFamilySelect);
    fontSection.appendChild(axisLabelFontFamilyRow);
    
    // Axis label style options
    const axisLabelStyleRow = document.createElement("div");
    axisLabelStyleRow.style.display = "flex";
    axisLabelStyleRow.style.alignItems = "center";
    axisLabelStyleRow.style.marginBottom = "10px";
    
    const axisLabelItalicLabel = document.createElement("label");
    axisLabelItalicLabel.textContent = "Axis Label Italic:";
    axisLabelItalicLabel.style.width = "140px";
    axisLabelItalicLabel.style.marginRight = "10px";
    axisLabelStyleRow.appendChild(axisLabelItalicLabel);
    
    const axisLabelItalicInput = document.createElement("input");
    axisLabelItalicInput.type = "checkbox";
    axisLabelItalicInput.checked = container.graphData.axisLabelItalic;
    axisLabelItalicInput.style.marginRight = "30px";
    axisLabelStyleRow.appendChild(axisLabelItalicInput);
    
    const axisLabelBoldLabel = document.createElement("label");
    axisLabelBoldLabel.textContent = "Axis Label Bold:";
    axisLabelBoldLabel.style.marginRight = "10px";
    axisLabelStyleRow.appendChild(axisLabelBoldLabel);
    
    const axisLabelBoldInput = document.createElement("input");
    axisLabelBoldInput.type = "checkbox";
    axisLabelBoldInput.checked = container.graphData.axisLabelBold;
    axisLabelStyleRow.appendChild(axisLabelBoldInput);
    
    fontSection.appendChild(axisLabelStyleRow);
    
    dialogBox.appendChild(fontSection);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.padding = "8px 16px";
    applyButton.style.marginRight = "10px";
    applyButton.style.cursor = "pointer";
    applyButton.style.backgroundColor = "#4CAF50";
    applyButton.style.color = "white";
    applyButton.style.border = "none";
    applyButton.style.borderRadius = "4px";
    
    applyButton.addEventListener("click", function() {
      container.graphData.xmin = storeAxisInput('xmin', xMinInput.value);
      container.graphData.xmax = storeAxisInput('xmax', xMaxInput.value);
      container.graphData.xscale = storeAxisInput('xscale', xScaleInput.value);
      container.graphData.xlabelInterval = storeAxisInput('xlabelInterval', xLabelIntervalInput.value);
      container.graphData.xAxisLabel = xAxisLabelInput.value;
      
      container.graphData.ymin = storeAxisInput('ymin', yMinInput.value);
      container.graphData.ymax = storeAxisInput('ymax', yMaxInput.value);
      container.graphData.yscale = storeAxisInput('yscale', yScaleInput.value);
      container.graphData.ylabelInterval = storeAxisInput('ylabelInterval', yLabelIntervalInput.value);
      container.graphData.yAxisLabel = yAxisLabelInput.value;
      
      // keep these parsed as ints
      container.graphData.tickFontSize = parseInt(tickFontSizeInput.value, 10);
      container.graphData.axisLabelFontSize = parseInt(axisLabelFontSizeInput.value, 10);
      
      // Font options
      container.graphData.tickFontFamily = tickFontFamilySelect.value;
      container.graphData.axisLabelFontFamily = axisLabelFontFamilySelect.value;
      container.graphData.axisLabelItalic = axisLabelItalicInput.checked;
      container.graphData.axisLabelBold = axisLabelBoldInput.checked;
      
      drawGraph();
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.padding = "8px 16px";
    cancelButton.style.cursor = "pointer";
    cancelButton.style.backgroundColor = "#f0f0f0";
    cancelButton.style.border = "1px solid #ccc";
    cancelButton.style.borderRadius = "4px";
    
    cancelButton.addEventListener("click", function() {
      // Close the dialog without saving changes
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Equations dialog
  function showEquationsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Equations";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Equations list
    const equationsListContainer = document.createElement("div");
    equationsListContainer.id = "equationsList";
    equationsListContainer.style.marginBottom = "20px";
    
    // Render existing equations
    function renderEquationsList() {
      equationsListContainer.innerHTML = "";
      
      if (container.graphData.equations.length === 0) {
        const noEquationsMsg = document.createElement("p");
        noEquationsMsg.textContent = "No equations added yet.";
        equationsListContainer.appendChild(noEquationsMsg);
      } else {
        container.graphData.equations.forEach((eq, index) => {
          const eqItem = document.createElement("div");
          eqItem.className = "equation-item";
          eqItem.style.border = "1px solid #ddd";
          eqItem.style.padding = "10px";
          eqItem.style.marginBottom = "10px";
          eqItem.style.backgroundColor = "#fff";
          eqItem.style.borderRadius = "3px";
          
          const eqTitle = document.createElement("strong");
          eqTitle.textContent = `Equation ${index+1}: `;
          eqItem.appendChild(eqTitle);
          
          const eqDesc = document.createTextNode(`${eq.type} – ${eq.equation}`);
          eqItem.appendChild(eqDesc);
          
          const actionsContainer = document.createElement("div");
          actionsContainer.style.display = "flex";
          actionsContainer.style.alignItems = "center";
          actionsContainer.style.marginTop = "5px";
          
          const colorSwatch = document.createElement("span");
          colorSwatch.style.display = "inline-block";
          colorSwatch.style.width = "20px";
          colorSwatch.style.height = "10px";
          colorSwatch.style.backgroundColor = eq.color;
          actionsContainer.appendChild(colorSwatch);
          
          const infoText = document.createTextNode(` Width: ${eq.width}, Style: ${eq.style || 'solid'} `);
          actionsContainer.appendChild(infoText);
          
          let domainText = '';
          if (eq.domainMinOp !== 'none' && eq.domainMin) {
            domainText += `${eq.domainMin} ${eq.domainMinOp} `;
          }
          domainText += 'x';
          if (eq.domainMaxOp !== 'none' && eq.domainMax) {
            domainText += ` ${eq.domainMaxOp} ${eq.domainMax}`;
          }
          
          if (domainText !== 'x') {
            const domain = document.createElement("div");
            domain.style.marginTop = "5px";
            domain.style.fontSize = "0.9em";
            domain.textContent = `Domain: ${domainText}`;
            eqItem.appendChild(domain);
          }
          
          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";
          editBtn.style.marginLeft = "10px";
          editBtn.addEventListener("click", function() {
            editEquation(index);
          });
          actionsContainer.appendChild(editBtn);
          
          const deleteBtn = document.createElement("span");
          deleteBtn.className = "delete-btn";
          deleteBtn.textContent = "Delete";
          deleteBtn.style.display = "inline-block";
          deleteBtn.style.padding = "2px 6px";
          deleteBtn.style.border = "1px solid #000";
          deleteBtn.style.backgroundColor = "#fff";
          deleteBtn.style.color = "#000";
          deleteBtn.style.borderRadius = "3px";
          deleteBtn.style.fontSize = "0.9em";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.marginLeft = "10px";
          deleteBtn.addEventListener("click", function() {
            container.graphData.equations.splice(index, 1);
            renderEquationsList();
            drawGraph();
          });
          actionsContainer.appendChild(deleteBtn);
          
          eqItem.appendChild(actionsContainer);
          equationsListContainer.appendChild(eqItem);
        });
      }
    }
    
    renderEquationsList();
    dialogBox.appendChild(equationsListContainer);
    
    // Add new equation form
    const addEquationForm = document.createElement("div");
    addEquationForm.style.backgroundColor = "#f9f9f9";
    addEquationForm.style.padding = "15px";
    addEquationForm.style.borderRadius = "5px";
    addEquationForm.style.marginBottom = "20px";
    
    const formTitle = document.createElement("h4");
    formTitle.textContent = "Add Equation";
    formTitle.style.marginTop = "0";
    formTitle.style.marginBottom = "15px";
    addEquationForm.appendChild(formTitle);
    
    // Equation type dropdown
    const eqTypeRow = document.createElement("div");
    eqTypeRow.style.marginBottom = "10px";
    
    const eqTypeLabel = document.createElement("label");
    eqTypeLabel.textContent = "Equation type:";
    eqTypeLabel.style.display = "inline-block";
    eqTypeLabel.style.width = "140px";
    eqTypeLabel.style.marginRight = "10px";
    eqTypeRow.appendChild(eqTypeLabel);
    
    const eqTypeSelect = document.createElement("select");
    eqTypeSelect.id = "newEqType";
    
    const eqTypeOptions = [
      { value: "linear", text: "Linear" },
      { value: "quadratic", text: "Quadratic" },
      { value: "exponential", text: "Exponential" },
      { value: "polynomial", text: "Polynomial" },
      { value: "rational", text: "Rational" },
      { value: "absoluteValue", text: "Absolute Value" }
    ];
    
    eqTypeOptions.forEach(option => {
      const optionEl = document.createElement("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
      eqTypeSelect.appendChild(optionEl);
    });
    
    eqTypeRow.appendChild(eqTypeSelect);
    addEquationForm.appendChild(eqTypeRow);
    
    // Equation input
    const eqInputRow = document.createElement("div");
    eqInputRow.style.marginBottom = "10px";
    
    const eqInputLabel = document.createElement("label");
    eqInputLabel.textContent = "Equation:";
    eqInputLabel.style.display = "inline-block";
    eqInputLabel.style.width = "140px";
    eqInputLabel.style.marginRight = "10px";
    eqInputRow.appendChild(eqInputLabel);
    
    const eqInput = document.createElement("input");
    eqInput.type = "text";
    eqInput.id = "newEquation";
    eqInput.style.width = "60%";
    eqInputRow.appendChild(eqInput);
    
    const eqHint = document.createElement("span");
    eqHint.id = "hint";
    eqHint.style.display = "block";
    eqHint.style.marginLeft = "150px";
    eqHint.style.fontStyle = "italic";
    eqHint.style.color = "#555";
    eqInputRow.appendChild(eqHint);
    
    addEquationForm.appendChild(eqInputRow);
    
    // Style options
    const styleRow = document.createElement("div");
    styleRow.style.marginBottom = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Line Color:";
    colorLabel.style.display = "inline-block";
    colorLabel.style.width = "140px";
    colorLabel.style.marginRight = "10px";
    styleRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.id = "newLineColor";
    colorInput.value = "#ff0000";
    colorInput.style.marginRight = "20px";
    styleRow.appendChild(colorInput);
    
    const widthLabel = document.createElement("label");
    widthLabel.textContent = "Line Width:";
    widthLabel.style.marginRight = "10px";
    styleRow.appendChild(widthLabel);
    
    const widthInput = document.createElement("input");
    widthInput.type = "number";
    widthInput.id = "newLineWidth";
    widthInput.min = "1";
    widthInput.max = "10";
    widthInput.value = "2";
    widthInput.style.width = "50px";
    widthInput.style.marginRight = "20px";
    styleRow.appendChild(widthInput);
    
    const styleLabel = document.createElement("label");
    styleLabel.textContent = "Line Style:";
    styleLabel.style.marginRight = "10px";
    styleRow.appendChild(styleLabel);
    
    const styleSelect = document.createElement("select");
    styleSelect.id = "newLineStyle";
    
    const solidOption = document.createElement("option");
    solidOption.value = "solid";
    solidOption.textContent = "Solid";
    styleSelect.appendChild(solidOption);
    
    const dottedOption = document.createElement("option");
    dottedOption.value = "dotted";
    dottedOption.textContent = "Dotted";
    styleSelect.appendChild(dottedOption);
    
    const dashedOption = document.createElement("option");
    dashedOption.value = "dashed";
    dashedOption.textContent = "Dashed";
    styleSelect.appendChild(dashedOption);
    
    styleRow.appendChild(styleSelect);
    
    addEquationForm.appendChild(styleRow);
    
    // Domain restriction
    const domainRow = document.createElement("div");
    domainRow.className = "domain-restriction";
    domainRow.style.display = "flex";
    domainRow.style.alignItems = "center";
    domainRow.style.marginTop = "10px";
    domainRow.style.marginBottom = "15px";
    
    const domainLabel = document.createElement("label");
    domainLabel.textContent = "Domain:";
    domainLabel.style.display = "inline-block";
    domainLabel.style.width = "140px";
    domainLabel.style.marginRight = "10px";
    domainRow.appendChild(domainLabel);
    
    const domainMinInput = document.createElement("input");
    domainMinInput.id = "newDomainMin";
    domainMinInput.type = "text";
    domainMinInput.placeholder = "min";
    domainMinInput.style.width = "60px";
    domainRow.appendChild(domainMinInput);
    
    const domainMinOpSelect = document.createElement("select");
    domainMinOpSelect.id = "newDomainMinOp";
    domainMinOpSelect.style.width = "60px";
    
    const minNoneOption = document.createElement("option");
    minNoneOption.value = "none";
    minNoneOption.textContent = "none";
    domainMinOpSelect.appendChild(minNoneOption);
    
    const minLessOption = document.createElement("option");
    minLessOption.value = "<";
    minLessOption.textContent = "<";
    domainMinOpSelect.appendChild(minLessOption);
    
    const minLessEqOption = document.createElement("option");
    minLessEqOption.value = "≤";
    minLessEqOption.textContent = "≤";
    domainMinOpSelect.appendChild(minLessEqOption);
    
    domainRow.appendChild(domainMinOpSelect);
    
    const xText = document.createElement("span");
    xText.textContent = "x";
    xText.style.margin = "0 5px";
    domainRow.appendChild(xText);
    
    const domainMaxOpSelect = document.createElement("select");
    domainMaxOpSelect.id = "newDomainMaxOp";
    domainMaxOpSelect.style.width = "60px";
    
    const maxNoneOption = document.createElement("option");
    maxNoneOption.value = "none";
    maxNoneOption.textContent = "none";
    domainMaxOpSelect.appendChild(maxNoneOption);
    
    const maxLessOption = document.createElement("option");
    maxLessOption.value = "<";
    maxLessOption.textContent = "<";
    domainMaxOpSelect.appendChild(maxLessOption);
    
    const maxLessEqOption = document.createElement("option");
    maxLessEqOption.value = "≤";
    maxLessEqOption.textContent = "≤";
    domainMaxOpSelect.appendChild(maxLessEqOption);
    
    domainRow.appendChild(domainMaxOpSelect);
    
    const domainMaxInput = document.createElement("input");
    domainMaxInput.id = "newDomainMax";
    domainMaxInput.type = "text";
    domainMaxInput.placeholder = "max";
    domainMaxInput.style.width = "60px";
    domainRow.appendChild(domainMaxInput);
    
    addEquationForm.appendChild(domainRow);
    
    // Add equation button
    const addBtnRow = document.createElement("div");
    
    const addEquationBtn = document.createElement("button");
    addEquationBtn.textContent = "Add Equation";
    addEquationBtn.style.padding = "8px 16px";
    addEquationBtn.style.cursor = "pointer";
    addEquationBtn.style.backgroundColor = "#4CAF50";
    addEquationBtn.style.color = "white";
    addEquationBtn.style.border = "none";
    addEquationBtn.style.borderRadius = "4px";
    
    // Hidden input for tracking editing state
    const editingIndexInput = document.createElement("input");
    editingIndexInput.type = "hidden";
    editingIndexInput.id = "editingEquationIndex";
    editingIndexInput.value = "-1";
    addBtnRow.appendChild(editingIndexInput);
    
    addBtnRow.appendChild(addEquationBtn);
    addEquationForm.appendChild(addBtnRow);
    
    dialogBox.appendChild(addEquationForm);
    
    // Function to edit an equation
    function editEquation(index) {
      const eq = container.graphData.equations[index];
      
      // Set form fields to equation values
      eqTypeSelect.value = eq.type;
      eqInput.value = eq.equation;
      colorInput.value = eq.color;
      widthInput.value = eq.width;
      styleSelect.value = eq.style || 'solid';
      
      domainMinInput.value = eq.domainMin || '';
      domainMinOpSelect.value = eq.domainMinOp || 'none';
      domainMaxInput.value = eq.domainMax || '';
      domainMaxOpSelect.value = eq.domainMaxOp || 'none';
      
      // Update the hint text
      updateEquationHint();
      
      // Set editing state
      editingIndexInput.value = index;
      
      // Change button text
      addEquationBtn.textContent = 'Update Equation';
    }
    
    // Add equation hints
    const hints = {
      linear: 'e.g. 2*x+1',
      quadratic: 'e.g. x^2 - 4*x + 3',
      exponential: 'e.g. 2^(x/2)',
      polynomial: 'e.g. x^3 - 2*x + 1',
      rational: '(x^2 - 1)/(x - 1)',
      absoluteValue: 'e.g. abs(x) or abs(x-2)+1'
    };
    
    // Function to update equation hint
    function updateEquationHint() {
      const t = eqTypeSelect.value;
      eqHint.textContent = hints[t] || '';
      eqInput.placeholder = hints[t] || '';
    }
    
    // Add event listener for equation type change
    eqTypeSelect.addEventListener("change", updateEquationHint);
    
    // Initialize hint
    updateEquationHint();
    
    // Add equation button handler
    addEquationBtn.addEventListener("click", function() {
      const eqType = eqTypeSelect.value;
      const eqStr = eqInput.value.trim();
      
      // Validate input
        // Enforce max length first
        if (eqStr.length > 60) {
        alert('Equation too long (max 60 characters).');
        return;
      }

      // Strict whitelist: numbers, x or #var#, abs/sin/cos/tan, + - * / ^ , ( )
      if (!isSafeMathExpression(eqStr)) {
        alert(
          'Invalid equation. Only numbers, the variable x or placeholders #var#, ' +
          'functions abs(), sin(), cos(), tan(), and operators + - * / ^ , ( ) are allowed.'
        );
        return;
      }

      
      const lineColor = colorInput.value;
      const lineWidth = parseFloat(widthInput.value);
      const lineStyle = styleSelect.value;
      const domainMin = domainMinInput.value.trim();
      const domainMinOp = domainMinOpSelect.value;
      const domainMax = domainMaxInput.value.trim();
      const domainMaxOp = domainMaxOpSelect.value;
      
      // Check if we're editing or adding
      const editingIndex = parseInt(editingIndexInput.value);
      
      if (eqStr) {
        const equation = {
          type: eqType,
          equation: eqStr,
          color: lineColor,
          width: lineWidth,
          style: lineStyle,
          domainMin: domainMin,
          domainMinOp: domainMinOp,
          domainMax: domainMax,
          domainMaxOp: domainMaxOp
        };
        
        if (editingIndex >= 0) {
          // Update existing equation
          container.graphData.equations[editingIndex] = equation;
          
          // Reset editing state
          editingIndexInput.value = "-1";
          addEquationBtn.textContent = "Add Equation";
        } else {
          // Add new equation
          container.graphData.equations.push(equation);
        }
        
        // Redraw equation list
        renderEquationsList();
        
        // Redraw graph
        drawGraph();
        
        // Clear form
        eqInput.value = '';
        domainMinInput.value = '';
        domainMaxInput.value = '';
        domainMinOpSelect.value = 'none';
        domainMaxOpSelect.value = 'none';
      } else {
        alert('Please enter an equation');
      }
    });
    
    // Dialog buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Points dialog
  function showPointsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Points";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Points list
    const pointsListContainer = document.createElement("div");
    pointsListContainer.id = "pointsList";
    pointsListContainer.style.marginBottom = "20px";
    
    // Render existing points
    function renderPointsList() {
      pointsListContainer.innerHTML = "";
      
      if (container.graphData.points.length === 0) {
        const noPointsMsg = document.createElement("p");
        noPointsMsg.textContent = "No points added yet.";
        pointsListContainer.appendChild(noPointsMsg);
      } else {
        container.graphData.points.forEach((pt, index) => {
          const ptItem = document.createElement("div");
          ptItem.className = "point-item";
          ptItem.style.border = "1px solid #ddd";
          ptItem.style.padding = "10px";
          ptItem.style.marginBottom = "10px";
          ptItem.style.backgroundColor = "#fff";
          ptItem.style.borderRadius = "3px";
          
          const ptTitle = document.createElement("strong");
          ptTitle.textContent = `${pt.label}: `;
          ptItem.appendChild(ptTitle);
          
          const ptDesc = document.createTextNode(`(${pt.x}, ${pt.y})`);
          ptItem.appendChild(ptDesc);
          
          const actionsContainer = document.createElement("div");
          actionsContainer.style.display = "flex";
          actionsContainer.style.alignItems = "center";
          actionsContainer.style.marginTop = "5px";
          
          const colorSwatch = document.createElement("span");
          colorSwatch.style.display = "inline-block";
          colorSwatch.style.width = "20px";
          colorSwatch.style.height = "10px";
          colorSwatch.style.backgroundColor = pt.color;
          colorSwatch.style.marginRight = "5px";
          actionsContainer.appendChild(colorSwatch);
          
          const infoText = document.createTextNode(`Point Size: ${pt.pointSize||4}px, Font Size: ${pt.fontSize}px, Position: ${pt.position} `);
          actionsContainer.appendChild(infoText);
          
          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";
          editBtn.style.marginLeft = "10px";
          editBtn.addEventListener("click", function() {
            editPoint(index);
          });
          actionsContainer.appendChild(editBtn);
          
          const deleteBtn = document.createElement("span");
          deleteBtn.className = "delete-btn";
          deleteBtn.textContent = "Delete";
          deleteBtn.style.display = "inline-block";
          deleteBtn.style.padding = "2px 6px";
          deleteBtn.style.border = "1px solid #000";
          deleteBtn.style.backgroundColor = "#fff";
          deleteBtn.style.color = "#000";
          deleteBtn.style.borderRadius = "3px";
          deleteBtn.style.fontSize = "0.9em";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.marginLeft = "10px";
          deleteBtn.addEventListener("click", function() {
            container.graphData.points.splice(index, 1);
            renderPointsList();
            drawGraph();
          });
          actionsContainer.appendChild(deleteBtn);
          
          ptItem.appendChild(actionsContainer);
          pointsListContainer.appendChild(ptItem);
        });
      }
    }
    
    renderPointsList();
    dialogBox.appendChild(pointsListContainer);
    
    // Add new point form
    const addPointForm = document.createElement("div");
    addPointForm.style.backgroundColor = "#f9f9f9";
    addPointForm.style.padding = "15px";
    addPointForm.style.borderRadius = "5px";
    addPointForm.style.marginBottom = "20px";
    
    const formTitle = document.createElement("h4");
    formTitle.textContent = "Add Point";
    formTitle.style.marginTop = "0";
    formTitle.style.marginBottom = "15px";
    addPointForm.appendChild(formTitle);
    
    // Point coordinates
    const coordRow = document.createElement("div");
    coordRow.style.marginBottom = "10px";
    
    const coordLabel = document.createElement("label");
    coordLabel.textContent = "Point (x,y):";
    coordLabel.style.display = "inline-block";
    coordLabel.style.width = "140px";
    coordLabel.style.marginRight = "10px";
    coordRow.appendChild(coordLabel);
    
    const coordInput = document.createElement("input");
    coordInput.type = "text";
    coordInput.id = "newPointCoord";
    coordInput.placeholder = "e.g. 1,2 or (1,2)";
    coordInput.style.width = "150px";
    coordInput.style.marginRight = "20px";
    coordRow.appendChild(coordInput);
    
    const labelLabel = document.createElement("label");
    labelLabel.textContent = "Label:";
    labelLabel.style.marginRight = "10px";
    coordRow.appendChild(labelLabel);
    
    const labelInput = document.createElement("input");
    labelInput.type = "text";
    labelInput.id = "newPointLabel";
    labelInput.placeholder = "A";
    labelInput.style.width = "80px";
    coordRow.appendChild(labelInput);
    
    addPointForm.appendChild(coordRow);
    
    // Point style
    const styleRow = document.createElement("div");
    styleRow.style.marginBottom = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Label Color:";
    colorLabel.style.display = "inline-block";
    colorLabel.style.width = "140px";
    colorLabel.style.marginRight = "10px";
    styleRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.id = "newPointColor";
    colorInput.value = "#000000";
    colorInput.style.marginRight = "20px";
    styleRow.appendChild(colorInput);
    
    const sizeLabel = document.createElement("label");
    sizeLabel.textContent = "Point Size:";
    sizeLabel.style.marginRight = "10px";
    styleRow.appendChild(sizeLabel);
    
    const sizeInput = document.createElement("input");
    sizeInput.type = "number";
    sizeInput.id = "newPointSize";
    sizeInput.min = "1";
    sizeInput.max = "20";
    sizeInput.value = "4";
    sizeInput.style.width = "50px";
    sizeInput.style.marginRight = "20px";
    styleRow.appendChild(sizeInput);
    
    const fontSizeLabel = document.createElement("label");
    fontSizeLabel.textContent = "Label Font Size:";
    fontSizeLabel.style.marginRight = "10px";
    styleRow.appendChild(fontSizeLabel);
    
    const fontSizeInput = document.createElement("input");
    fontSizeInput.type = "number";
    fontSizeInput.id = "newPointFontSize";
    fontSizeInput.min = "6";
    fontSizeInput.max = "48";
    fontSizeInput.value = "12";
    fontSizeInput.style.width = "50px";
    styleRow.appendChild(fontSizeInput);
    
    addPointForm.appendChild(styleRow);
    
    // Label position
    const positionRow = document.createElement("div");
    positionRow.style.marginBottom = "15px";
    
    const positionLabel = document.createElement("label");
    positionLabel.textContent = "Label Position:";
    positionLabel.style.display = "inline-block";
    positionLabel.style.width = "140px";
    positionLabel.style.marginRight = "10px";
    positionRow.appendChild(positionLabel);
    
    const positionSelect = document.createElement("select");
    positionSelect.id = "newLabelPosition";
    
    const positions = [
      { value: "up", text: "up" },
      { value: "down", text: "down" },
      { value: "left", text: "left" },
      { value: "right", text: "right" },
      { value: "upleft", text: "up/left" },
      { value: "upright", text: "up/right" },
      { value: "downleft", text: "down/left" },
      { value: "downright", text: "down/right" }
    ];
    
    positions.forEach(option => {
      const optionEl = document.createElement("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
      positionSelect.appendChild(optionEl);
    });
    
    positionRow.appendChild(positionSelect);
    addPointForm.appendChild(positionRow);
    
    // Add point button
    const addBtnRow = document.createElement("div");
    
    const addPointBtn = document.createElement("button");
    addPointBtn.textContent = "Add Point";
    addPointBtn.style.padding = "8px 16px";
    addPointBtn.style.cursor = "pointer";
    addPointBtn.style.backgroundColor = "#4CAF50";
    addPointBtn.style.color = "white";
    addPointBtn.style.border = "none";
    addPointBtn.style.borderRadius = "4px";
    
    // Hidden input for tracking editing state
    const editingIndexInput = document.createElement("input");
    editingIndexInput.type = "hidden";
    editingIndexInput.id = "editingPointIndex";
    editingIndexInput.value = "-1";
    addBtnRow.appendChild(editingIndexInput);
    
    addBtnRow.appendChild(addPointBtn);
    addPointForm.appendChild(addBtnRow);
    
    dialogBox.appendChild(addPointForm);
    
    // Function to edit a point
    function editPoint(index) {
      const pt = container.graphData.points[index];
      
      // Set form fields to point values
      coordInput.value = `${pt.x},${pt.y}`;
      labelInput.value = pt.label;
      colorInput.value = pt.color;
      sizeInput.value = pt.pointSize || 4;
      fontSizeInput.value = pt.fontSize;
      positionSelect.value = pt.position;
      
      // Set editing state
      editingIndexInput.value = index;
      
      // Change button text
      addPointBtn.textContent = 'Update Point';
    }
    
    // Add point button handler
    addPointBtn.addEventListener("click", function() {
  let coordInputValue = coordInput.value.trim();
  
  // Handle (a,b) format
  if (coordInputValue.startsWith('(') && coordInputValue.endsWith(')')) {
    coordInputValue = coordInputValue.substring(1, coordInputValue.length - 1);
  }
  
  const coords = coordInputValue.split(',');
  const label = labelInput.value.trim();
  const color = colorInput.value;
  const pointSize = parseFloat(sizeInput.value);
  const fontSize = parseFloat(fontSizeInput.value);
  const position = positionSelect.value;
  
  // Check if we're editing or adding
  const editingIndex = parseInt(editingIndexInput.value);
  
  // Handle both numeric values and variable placeholders (#a#)
  let x = coords[0].trim();
  let y = coords[1].trim();
  
  // If the value is not a variable placeholder, convert to number
  if (!x.includes('#')) {
    x = parseFloat(x);
    // For Quadrant 1, ensure x is not negative
    if (isNaN(x) || x < 0) {
      alert('X coordinate must be a positive number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!y.includes('#')) {
    y = parseFloat(y);
    // For Quadrant 1, ensure y is not negative
    if (isNaN(y) || y < 0) {
      alert('Y coordinate must be a positive number or a variable placeholder (#var#)');
      return;
    }
  }
  
  const point = {
    x,
    y,
    label: label || `P${container.graphData.points.length + 1}`,
    color,
    pointSize,
    fontSize,
    position
  };
  
  if (editingIndex >= 0) {
    // Update existing point
    container.graphData.points[editingIndex] = point;
    
    // Reset editing state
    editingIndexInput.value = "-1";
    addPointBtn.textContent = "Add Point";
  } else {
    // Add new point
    container.graphData.points.push(point);
  }
  
  // Redraw points list
  renderPointsList();
  
  // Redraw graph
  drawGraph();
  
  // Clear form
  coordInput.value = '';
  labelInput.value = '';
});
    
    
    // Dialog buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Segments dialog
  function showSegmentsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Segments";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Segments list
    const segmentsListContainer = document.createElement("div");
    segmentsListContainer.id = "segmentsList";
    segmentsListContainer.style.marginBottom = "20px";
    
    // Render existing segments
    function renderSegmentsList() {
      segmentsListContainer.innerHTML = "";
      
      if (container.graphData.segments.length === 0) {
        const noSegmentsMsg = document.createElement("p");
        noSegmentsMsg.textContent = "No segments added yet.";
        segmentsListContainer.appendChild(noSegmentsMsg);
      } else {
        container.graphData.segments.forEach((seg, index) => {
          const segItem = document.createElement("div");
          segItem.className = "equation-item";
          segItem.style.border = "1px solid #ddd";
          segItem.style.padding = "10px";
          segItem.style.marginBottom = "10px";
          segItem.style.backgroundColor = "#fff";
          segItem.style.borderRadius = "3px";
          
          const segTitle = document.createElement("strong");
          segTitle.textContent = `Segment ${index+1}: `;
          segItem.appendChild(segTitle);
          
          const segDesc = document.createTextNode(`(${seg.x1}, ${seg.y1}) to (${seg.x2}, ${seg.y2})`);
          segItem.appendChild(segDesc);
          
          const actionsContainer = document.createElement("div");
          actionsContainer.style.display = "flex";
          actionsContainer.style.alignItems = "center";
          actionsContainer.style.marginTop = "5px";
          
          const colorSwatch = document.createElement("span");
          colorSwatch.style.display = "inline-block";
          colorSwatch.style.width = "20px";
          colorSwatch.style.height = "10px";
          colorSwatch.style.backgroundColor = seg.color;
          actionsContainer.appendChild(colorSwatch);
          
          const infoText = document.createTextNode(` Width: ${seg.width}, Style: ${seg.style} `);
          actionsContainer.appendChild(infoText);
          
          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";
          editBtn.style.marginLeft = "10px";
          editBtn.addEventListener("click", function() {
            editSegment(index);
          });
          actionsContainer.appendChild(editBtn);
          
          const deleteBtn = document.createElement("span");
          deleteBtn.className = "delete-btn";
          deleteBtn.textContent = "Delete";
          deleteBtn.style.display = "inline-block";
          deleteBtn.style.padding = "2px 6px";
          deleteBtn.style.border = "1px solid #000";
          deleteBtn.style.backgroundColor = "#fff";
          deleteBtn.style.color = "#000";
          deleteBtn.style.borderRadius = "3px";
          deleteBtn.style.fontSize = "0.9em";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.marginLeft = "10px";
          deleteBtn.addEventListener("click", function() {
            container.graphData.segments.splice(index, 1);
            renderSegmentsList();
            drawGraph();
          });
          actionsContainer.appendChild(deleteBtn);
          
          segItem.appendChild(actionsContainer);
          segmentsListContainer.appendChild(segItem);
        });
      }
    }
    
    renderSegmentsList();
    dialogBox.appendChild(segmentsListContainer);
    
    // Add new segment form
    const addSegmentForm = document.createElement("div");
    addSegmentForm.style.backgroundColor = "#f9f9f9";
    addSegmentForm.style.padding = "15px";
    addSegmentForm.style.borderRadius = "5px";
    addSegmentForm.style.marginBottom = "20px";
    
    const formTitle = document.createElement("h4");
    formTitle.textContent = "Add Segment";
    formTitle.style.marginTop = "0";
    formTitle.style.marginBottom = "15px";
    addSegmentForm.appendChild(formTitle);
    
    // Segment start point
    const startRow = document.createElement("div");
    startRow.style.marginBottom = "10px";
    
    const startLabel = document.createElement("label");
    startLabel.textContent = "Start (x,y):";
    startLabel.style.display = "inline-block";
    startLabel.style.width = "140px";
    startLabel.style.marginRight = "10px";
    startRow.appendChild(startLabel);
    
    const startInput = document.createElement("input");
    startInput.type = "text";
    startInput.id = "newSegmentStart";
    startInput.placeholder = "e.g. 1,2 or (1,2)";
    startInput.style.width = "150px";
    startRow.appendChild(startInput);
    
    addSegmentForm.appendChild(startRow);
    
    // Segment end point
    const endRow = document.createElement("div");
    endRow.style.marginBottom = "10px";
    
    const endLabel = document.createElement("label");
    endLabel.textContent = "End (x,y):";
    endLabel.style.display = "inline-block";
    endLabel.style.width = "140px";
    endLabel.style.marginRight = "10px";
    endRow.appendChild(endLabel);
    
    const endInput = document.createElement("input");
    endInput.type = "text";
    endInput.id = "newSegmentEnd";
    endInput.placeholder = "e.g. 3,4 or (3,4)";
    endInput.style.width = "150px";
    endRow.appendChild(endInput);
    
    addSegmentForm.appendChild(endRow);
    
    // Segment style
    const styleRow = document.createElement("div");
    styleRow.style.marginBottom = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Line Color:";
    colorLabel.style.display = "inline-block";
    colorLabel.style.width = "140px";
    colorLabel.style.marginRight = "10px";
    styleRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.id = "newSegmentColor";
    colorInput.value = "#0000ff";
    colorInput.style.marginRight = "20px";
    styleRow.appendChild(colorInput);
    
    const widthLabel = document.createElement("label");
    widthLabel.textContent = "Line Width:";
    widthLabel.style.marginRight = "10px";
    styleRow.appendChild(widthLabel);
    
    const widthInput = document.createElement("input");
    widthInput.type = "number";
    widthInput.id = "newSegmentWidth";
    widthInput.min = "1";
    widthInput.max = "10";
    widthInput.value = "2";
    widthInput.style.width = "50px";
    styleRow.appendChild(widthInput);
    
    addSegmentForm.appendChild(styleRow);
    
    // Line style
    const lineStyleRow = document.createElement("div");
    lineStyleRow.style.marginBottom = "15px";
    
    const lineStyleLabel = document.createElement("label");
    lineStyleLabel.textContent = "Line Style:";
    lineStyleLabel.style.display = "inline-block";
    lineStyleLabel.style.width = "140px";
    lineStyleLabel.style.marginRight = "10px";
    lineStyleRow.appendChild(lineStyleLabel);
    
    const lineStyleSelect = document.createElement("select");
    lineStyleSelect.id = "newSegmentStyle";
    
    const solidOption = document.createElement("option");
    solidOption.value = "solid";
    solidOption.textContent = "Solid";
    lineStyleSelect.appendChild(solidOption);
    
    const dashedOption = document.createElement("option");
    dashedOption.value = "dashed";
    dashedOption.textContent = "Dashed";
    lineStyleSelect.appendChild(dashedOption);
    
    lineStyleRow.appendChild(lineStyleSelect);
    addSegmentForm.appendChild(lineStyleRow);
    
    // Add segment button
    const addBtnRow = document.createElement("div");
    
    const addSegmentBtn = document.createElement("button");
    addSegmentBtn.textContent = "Add Segment";
    addSegmentBtn.style.padding = "8px 16px";
    addSegmentBtn.style.cursor = "pointer";
    addSegmentBtn.style.backgroundColor = "#4CAF50";
    addSegmentBtn.style.color = "white";
    addSegmentBtn.style.border = "none";
    addSegmentBtn.style.borderRadius = "4px";
    
    // Hidden input for tracking editing state
    const editingIndexInput = document.createElement("input");
    editingIndexInput.type = "hidden";
    editingIndexInput.id = "editingSegmentIndex";
    editingIndexInput.value = "-1";
    addBtnRow.appendChild(editingIndexInput);
    
    addBtnRow.appendChild(addSegmentBtn);
    addSegmentForm.appendChild(addBtnRow);
    
    dialogBox.appendChild(addSegmentForm);
    
    // Function to edit a segment
    function editSegment(index) {
      const seg = container.graphData.segments[index];
      
      // Set form fields to segment values
      startInput.value = `${seg.x1},${seg.y1}`;
      endInput.value = `${seg.x2},${seg.y2}`;
      colorInput.value = seg.color;
      widthInput.value = seg.width;
      lineStyleSelect.value = seg.style;
      
      // Set editing state
      editingIndexInput.value = index;
      
      // Change button text
      addSegmentBtn.textContent = 'Update Segment';
    }
    
    // Add segment button handler
    addSegmentBtn.addEventListener("click", function() {
  let startInputValue = startInput.value.trim();
  let endInputValue = endInput.value.trim();
  
  // Handle (a,b) format for start point
  if (startInputValue.startsWith('(') && startInputValue.endsWith(')')) {
    startInputValue = startInputValue.substring(1, startInputValue.length - 1);
  }
  
  // Handle (a,b) format for end point
  if (endInputValue.startsWith('(') && endInputValue.endsWith(')')) {
    endInputValue = endInputValue.substring(1, endInputValue.length - 1);
  }
  
  const startCoords = startInputValue.split(',');
  const endCoords = endInputValue.split(',');
  const color = colorInput.value;
  const width = parseFloat(widthInput.value);
  const style = lineStyleSelect.value;
  
  // Check if we're editing or adding
  const editingIndex = parseInt(editingIndexInput.value);
  
  // Handle both numeric values and variable placeholders (#a#)
  let x1 = startCoords[0].trim();
  let y1 = startCoords[1].trim();
  let x2 = endCoords[0].trim();
  let y2 = endCoords[1].trim();
  
  // If the values are not variable placeholders, convert to numbers
  if (!x1.includes('#')) {
    x1 = parseFloat(x1);
    if (isNaN(x1) || x1 < 0) {
      alert('Start X coordinate must be a positive number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!y1.includes('#')) {
    y1 = parseFloat(y1);
    if (isNaN(y1) || y1 < 0) {
      alert('Start Y coordinate must be a positive number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!x2.includes('#')) {
    x2 = parseFloat(x2);
    if (isNaN(x2) || x2 < 0) {
      alert('End X coordinate must be a positive number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!y2.includes('#')) {
    y2 = parseFloat(y2);
    if (isNaN(y2) || y2 < 0) {
      alert('End Y coordinate must be a positive number or a variable placeholder (#var#)');
      return;
    }
  }
  
  const segment = {
    x1,
    y1,
    x2,
    y2,
    color,
    width,
    style
  };
  
  if (editingIndex >= 0) {
    // Update existing segment
    container.graphData.segments[editingIndex] = segment;
    
    // Reset editing state
    editingIndexInput.value = "-1";
    addSegmentBtn.textContent = "Add Segment";
  } else {
    // Add new segment
    container.graphData.segments.push(segment);
  }
  
  // Redraw segments list
  renderSegmentsList();
  
  // Redraw graph
  drawGraph();
  
  // Clear form
  startInput.value = '';
  endInput.value = '';
});
    
    // Dialog buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }
  
  // Functions for element activation and deactivation
  function activateQuadOneGraph() {
    // Deactivate the previously active element if any
    if (window.activeQuadOneGraphElement && window.activeQuadOneGraphElement !== container) {
      window.activeQuadOneGraphElement.style.border = "none";
      
      const prevToolbar = window.activeQuadOneGraphElement.querySelector(".quad-one-graph-toolbar");
      const prevResizeHandle = window.activeQuadOneGraphElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeQuadOneGraphElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }
  
  function deactivateQuadOneGraph() {
    if (window.activeQuadOneGraphElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeQuadOneGraphElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }
  
  function deleteQuadOneGraph() {
    if (window.activeQuadOneGraphElement === container) {
      window.activeQuadOneGraphElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }
  
  // Event listeners
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateQuadOneGraph();
    }
  });
  
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteQuadOneGraph();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteQuadOneGraph();
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      const newHeight = Math.max(300, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      
      graphCanvas.width = newWidth;
      graphCanvas.height = newHeight - toolbarHeight;
      
      drawGraph();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activeQuadOneGraphElement === container) {
      deactivateQuadOneGraph();
    }
  });
  
  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Store the draw function on the container so it can be called externally
  container.drawGraph = drawGraph;
  
  // Draw the initial graph
  drawGraph();
  
  // Activate the graph
  activateQuadOneGraph();
  
  return container;
}


// Add Four Quadrant Graph component to the canvas
function addFourQuadrantGraph() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeFourQuadrantGraphElement) {
    window.activeFourQuadrantGraphElement = null;
  }
  // Global counter for four quadrant graph IDs
  if (!window.globalFourQuadrantGraphCounter) {
    window.globalFourQuadrantGraphCounter = 1;
  } else {
    window.globalFourQuadrantGraphCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element four-quadrant-graph-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "600px";
  container.style.height = (toolbarHeight + 600) + "px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this graph
  container.fourQuadrantGraphID = window.globalFourQuadrantGraphCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-four-quadrant-graph-id', container.fourQuadrantGraphID);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "four-quadrant-graph-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);
  
  // Create content div
  const content = document.createElement("div");
  content.className = "four-quadrant-graph-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create canvas for the graph
  const graphCanvas = document.createElement("canvas");
  graphCanvas.id = "fourQuadrantCanvas-" + container.fourQuadrantGraphID;
  graphCanvas.width = 600;
  graphCanvas.height = 600;
  graphCanvas.style.width = "100%";
  graphCanvas.style.height = "100%";
  content.appendChild(graphCanvas);

  // Store the data needed for the graph
  container.graphData = {
    xmin: -10,
    xmax: 10,
    ymin: -10,
    ymax: 10,
    xscale: 1,
    yscale: 1,
    xlabelInterval: 1,
    ylabelInterval: 1,
    tickFontSize: 14,
    axisLabelFontSize: 20,
    equations: [],
    points: [],
    segments: []
  };

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Define helper functions
  function gcd(a, b) { 
    return b ? gcd(b, a % b) : a; 
  }
  
  function formatLabel(val) {
    // Handle integer values
    if (Number.isInteger(val)) return val.toString();
    
    // Check if it's close to a multiple of pi
    const piVal = val / Math.PI;
    const eps = 1e-4; // More precise comparison
    
    // Check for common π fractions: π/6, π/4, π/3, π/2, 2π/3, 3π/4, 5π/6, π, etc.
    for (let den = 1; den <= 12; den++) {
      // Only check denominators that are common for π fractions (1, 2, 3, 4, 6)
      if (den > 6 && den !== 12) continue;
      
      const num = Math.round(piVal * den);
      if (Math.abs(piVal - num / den) < eps) {
        // Handle various special cases
        if (num === 0) return "0";
        
        // Full pi multiples
        if (den === 1) {
          if (num === 1) return "π";
          if (num === -1) return "-π";
          return `${num}π`;
        }
        
        // Simplified fractions of pi
        const g = gcd(Math.abs(num), den);
        const simplifiedNum = num / g;
        const simplifiedDen = den / g;
        
        if (simplifiedNum === 1) return `π/${simplifiedDen}`;
        if (simplifiedNum === -1) return `-π/${simplifiedDen}`;
        
        return `${simplifiedNum}π/${simplifiedDen}`;
      }
    }
    
    // Handle regular decimals
    return val.toFixed(2);
  }

  // Malicious input validation
  const maliciousInputs = [
    '<script>',
    'onerror=',
    'onclick=',
    'javascript:',
    'import(',
    'require(',
    'document.',
    'window.',
    'eval(',
    'Function(',
    'alert('
  ];

  function validateInput(str) {
    const lower = str.toLowerCase();
    for (const bad of maliciousInputs) {
      if (lower.includes(bad)) {
        return false;
      }
    }
    return true;
  }
  
  function isSafeMathExpression(str) {
    return /^[0-9x+\-*/^().,\s\pi]+$|abs\(.*\)|sin\(.*\)|cos\(.*\)|tan\(.*\)/.test(str);
  }
  
  function parseValue(id) {
    const v = document.getElementById(id).value.trim();
    
    // Handle pi notation (both π symbol and text)
    if (v.includes('π') || v.toLowerCase().includes('pi')) {
      // Normalize the input: convert "pi" to "π" for easier processing
      let normalized = v.toLowerCase().replace(/pi/g, 'π');
      
      // Process based on different patterns
      // Case 1: 2π - add multiplication
      normalized = normalized.replace(/(\d)([π])/g, '$1 * Math.PI');
      
      // Case 2: 2*π or 2 * π - just replace π
      normalized = normalized.replace(/[π]/g, 'Math.PI');
      
      try {
        return eval(normalized);
      } catch (e) {
        console.error("Error parsing pi value:", e, normalized);
      }
    }
    
    // Handle fractions
    if (v.includes('/')) {
      const [n, d] = v.split('/').map(Number);
      if (!isNaN(n) && !isNaN(d) && d !== 0) return n / d;
    }
    
    return parseFloat(v);
  }
  
  // Function to draw the graph
  function drawGraph() {
    // Get the canvas element
    const canvas = graphCanvas;
    const ctx = canvas.getContext('2d');
    
    // --- Axis parameters ---
    let xmin = container.graphData.xmin,
        xmax = container.graphData.xmax,
        xscale = container.graphData.xscale,
        xi = container.graphData.xlabelInterval;
        
    let ymin = container.graphData.ymin,
        ymax = container.graphData.ymax,
        yscale = container.graphData.yscale,
        yi = container.graphData.ylabelInterval;
        
    const axMin = xmin - xscale, axMax = xmax + xscale;
    const ayMin = ymin - yscale, ayMax = ymax + yscale;
    
    // Define plot ranges that extend beyond visible area
    const plotXmin = axMin;
    const plotXmax = axMax;
    
    // --- Clamp grid density ---
    const maxGridLines = 200;
    // Compute how many would be drawn at this scale:
    const rawXLines = (xmax - xmin) / xscale;
    if (rawXLines > maxGridLines) {
      xscale = (xmax - xmin) / maxGridLines;
    }
    const rawYLines = (ymax - ymin) / yscale;
    if (rawYLines > maxGridLines) {
      yscale = (ymax - ymin) / maxGridLines;
    }
    
    // --- Time‑budget settings ---
    const tStart = performance.now();
    const maxDuration = 100; // ms
    let aborted = false;
    
    // --- Sampling cap for plotting ---
    const rawSteps = (plotXmax - plotXmin) / (xscale / 100);
    const maxSamples = 1000;
    const dx = (plotXmax - plotXmin) / Math.min(maxSamples, Math.max(1, Math.ceil(rawSteps)));
    
    // --- Style parameters ---
    const tickFontSize = container.graphData.tickFontSize;
    const axisLabelFontSize = container.graphData.axisLabelFontSize;
    
    // --- Canvas & transforms ---
    const W = canvas.width,
          H = canvas.height;
    ctx.clearRect(0, 0, W, H);
    const toPxX = x => (x - axMin) * (W / (axMax - axMin));
    const toPxY = y => H - (y - ayMin) * (H / (ayMax - ayMin));

    // --- Grid lines ---
    ctx.setLineDash([]);
    ctx.strokeStyle = 'rgba(128,128,128,0.5)';
    ctx.lineWidth = 0.5;
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, H); ctx.stroke();
    }
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(W, py); ctx.stroke();
    }
    
    // --- Axes ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
    const x0 = toPxX(0), y0 = toPxY(0);
    ctx.beginPath(); ctx.moveTo(toPxX(axMin), y0); ctx.lineTo(toPxX(axMax), y0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x0, toPxY(ayMin)); ctx.lineTo(x0, toPxY(ayMax)); ctx.stroke();
    
    // --- Arrowheads ---
    ctx.fillStyle = '#000'; const head = 12;
    // +X
    ctx.beginPath(); ctx.moveTo(toPxX(axMax), y0);
    ctx.lineTo(toPxX(axMax) - head, y0 - head/2);
    ctx.lineTo(toPxX(axMax) - head, y0 + head/2);
    ctx.closePath(); ctx.fill();
    // –X
    ctx.beginPath(); ctx.moveTo(toPxX(axMin), y0);
    ctx.lineTo(toPxX(axMin) + head, y0 - head/2);
    ctx.lineTo(toPxX(axMin) + head, y0 + head/2);
    ctx.closePath(); ctx.fill();
    // +Y
    ctx.beginPath(); ctx.moveTo(x0, toPxY(ayMax));
    ctx.lineTo(x0 - head/2, toPxY(ayMax) + head);
    ctx.lineTo(x0 + head/2, toPxY(ayMax) + head);
    ctx.closePath(); ctx.fill();
    // –Y
    ctx.beginPath(); ctx.moveTo(x0, toPxY(ayMin));
    ctx.lineTo(x0 - head/2, toPxY(ayMin) - head);
    ctx.lineTo(x0 + head/2, toPxY(ayMin) - head);
    ctx.closePath(); ctx.fill();
    
    // --- Ticks & numeric labels ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.fillStyle = '#000';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.font = tickFontSize + 'px Computer Modern Serif';
    
    // X‑ticks
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath();
      ctx.moveTo(px, y0 - 5);
      ctx.lineTo(px, y0 + 5);
      ctx.stroke();
      
      // → robust label test instead of "x % xi === 0"
      const ratio = x / xi;
      if (x !== 0 && Math.abs(ratio - Math.round(ratio)) < 1e-6) {
        ctx.fillText(formatLabel(x), px, y0 + tickFontSize + 4);
      }
    }
    
    // Y‑ticks
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath(); ctx.moveTo(x0 - 5, py); ctx.lineTo(x0 + 5, py); ctx.stroke();
      if (y !== 0 && y % yi === 0) {
        ctx.fillText(formatLabel(y), x0 - tickFontSize - 4, py);
      }
    }
    
    // Origin "0"
    ctx.fillText('0', x0 - tickFontSize/2, y0 + tickFontSize/2+3);
    
    // --- Axis labels ---
    ctx.fillStyle = '#000';
    ctx.font = 'italic ' + axisLabelFontSize + 'px Computer Modern Serif';
    ctx.fillText('x',
      toPxX(axMax) - axisLabelFontSize/1.5,
      y0 - axisLabelFontSize - 1
    );
    ctx.fillText('y',
      x0 + axisLabelFontSize,
      toPxY(ayMax) + axisLabelFontSize/1.5
    );
    
    // --- Plot equations (with time‑check) ---
    for (let i = 0; i < container.graphData.equations.length; i++) {
      if (performance.now() - tStart > maxDuration) {
        aborted = true;
        break;
      }
      
      const eq = container.graphData.equations[i], eqStr = eq.equation;
      if (!validateInput(eqStr)) {
        alert('Invalid input.');
        return;
      }
      
      if (!isSafeMathExpression(eqStr)) continue;
      
      try {
        const expr = math.compile(eqStr);
        ctx.strokeStyle = eq.color;
        ctx.lineWidth = eq.width;
        ctx.setLineDash(eq.style === 'dotted' ? [2,3]
                         : eq.style === 'dashed' ? [5,5]
                         : []);
        
        ctx.beginPath();
        let first = true;
        for (let x = plotXmin; x <= plotXmax; x += dx) {
          // Check domain restrictions
          const skipDueToMinDomain = 
            (eq.domainMinOp === '<' && x <= parseFloat(eq.domainMin)) || 
            (eq.domainMinOp === '≤' && x < parseFloat(eq.domainMin));
          
          const skipDueToMaxDomain = 
            (eq.domainMaxOp === '<' && x >= parseFloat(eq.domainMax)) || 
            (eq.domainMaxOp === '≤' && x > parseFloat(eq.domainMax));
            
          // Skip this x value if it's outside the domain
          if ((eq.domainMinOp !== 'none' && eq.domainMin && skipDueToMinDomain) || 
              (eq.domainMaxOp !== 'none' && eq.domainMax && skipDueToMaxDomain)) {
            if (!first) { // End the current path segment
              ctx.stroke();
              ctx.beginPath();
              first = true;
            }
            continue;
          }

          // Handle special cases by equation type
          let y;
          
          if (eq.type === 'absoluteValue') {
            try {
              const exprStr = eqStr.includes('abs(') ? eqStr : `abs(${eqStr})`;
              y = math.evaluate(exprStr, { x });
            } catch (e) {
              console.error("Error evaluating absolute value:", e);
              continue;
            }
          } else if (eq.type === 'sine') {
            try {
              const xArg = eq.useDegrees ? x * Math.PI/180 : x;
              if (eqStr.includes('sin(')) {
                y = math.evaluate(eqStr, { x: xArg });
              } else {
                y = Math.sin(xArg);
              }
            } catch (e) {
              console.error("Error evaluating sine:", e);
              continue;
            }
          } else if (eq.type === 'cosine') {
            try {
              const xArg = eq.useDegrees ? x * Math.PI/180 : x;
              if (eqStr.includes('cos(')) {
                y = math.evaluate(eqStr, { x: xArg });
              } else {
                y = Math.cos(xArg);
              }
            } catch (e) {
              console.error("Error evaluating cosine:", e);
              continue;
            }
          } else if (eq.type === 'tangent') {
            try {
              const xArg = eq.useDegrees ? x * Math.PI/180 : x;
              if (eqStr.includes('tan(')) {
                y = math.evaluate(eqStr, { x: xArg });
              } else {
                y = Math.tan(xArg);
              }
            } catch (e) {
              console.error("Error evaluating tangent:", e);
              continue;
            }
          } else {
            try {
              y = expr.evaluate({ x });
            } catch (e) {
              console.error("Error evaluating expression:", e);
              continue;
            }
          }
          
          if (!isNaN(y) && isFinite(y)) {
            const px = toPxX(x), py = toPxY(y);
            first ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
            first = false;
          }
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        if (aborted) break;
      } catch (e) {
        console.error("Error plotting:", e);
      }
    }
    
    // --- Draw segments ---
    container.graphData.segments.forEach(seg => {
      ctx.strokeStyle = seg.color;
      ctx.lineWidth = seg.width;
      ctx.setLineDash(seg.style === 'dashed' ? [5,5] : []);
      const x1 = toPxX(seg.x1), y1 = toPxY(seg.y1);
      const x2 = toPxX(seg.x2), y2 = toPxY(seg.y2);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.setLineDash([]);
    });
    
    // --- Draw points & labels ---
    container.graphData.points.forEach(pt => {
      const px = toPxX(pt.x), py = toPxY(pt.y);
      
      // Draw the point
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(px, py, pt.pointSize || 4, 0, 2*Math.PI); ctx.fill();
      
      // Draw the label
      ctx.fillStyle = pt.color;
      ctx.font = pt.fontSize + 'px Computer Modern Serif';
      const m = ctx.measureText(pt.label), w = m.width, h = pt.fontSize;
      
      // Position the label based on the specified position
      let dxOff = 0, dyOff = 0;
      switch(pt.position) {
        case 'up':       dyOff = -h - 2; break;
        case 'down':     dyOff = 16;     break;
        case 'left':     dxOff = -w;     break;
        case 'right':    dxOff = 21;     break;
        case 'upleft':   dxOff = -w; dyOff = -h+3; break;
        case 'upright':  dxOff = 10; dyOff = -h-2; break;
        case 'downleft': dxOff = -w; dyOff = 10;   break;
        case 'downright':dxOff = 10; dyOff = 17;   break;
      }
      
      // Draw the label text
      ctx.fillText(pt.label, px + dxOff, py + dyOff);
    });
    
    // Draw domain endpoints
    function drawDomainEndpoints() {
      container.graphData.equations.forEach(eq => {
        if ((eq.domainMinOp === '<' || eq.domainMinOp === '≤') && eq.domainMin) {
          const x = parseFloat(eq.domainMin);
          // Only draw if within visible range
          if (x >= xmin && x <= xmax) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              if (!isNaN(y) && isFinite(y)) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMinOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating endpoint:", e);
            }
          }
        }

        if ((eq.domainMaxOp === '<' || eq.domainMaxOp === '≤') && eq.domainMax) {
          const x = parseFloat(eq.domainMax);
          // Only draw if within visible range
          if (x >= xmin && x <= xmax) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              if (!isNaN(y) && isFinite(y)) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMaxOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating endpoint:", e);
            }
          }
        }
      });
    }
    
    // Call the function to draw domain endpoints
    drawDomainEndpoints();
    
    // --- Notify if aborted ---
    if (aborted) {
      alert("Plotting aborted: took too long.");
    }
  }
  
  // Function to update the global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    
    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Four Quadrant Graph " + container.fourQuadrantGraphID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Graph Settings button
    const graphSettingsBtn = document.createElement("button");
    graphSettingsBtn.textContent = "Graph Settings";
    graphSettingsBtn.style.marginRight = "10px";
    graphSettingsBtn.style.padding = "5px 10px";
    graphSettingsBtn.style.cursor = "pointer";
    graphSettingsBtn.addEventListener("click", function() {
      showGraphSettingsDialog();
    });
    controls.appendChild(graphSettingsBtn);
    
    // Equations button
    const equationsBtn = document.createElement("button");
    equationsBtn.textContent = "Equations";
    equationsBtn.style.marginRight = "10px";
    equationsBtn.style.padding = "5px 10px";
    equationsBtn.style.cursor = "pointer";
    equationsBtn.addEventListener("click", function() {
      showEquationsDialog();
    });
    controls.appendChild(equationsBtn);
    
    // Points button
    const pointsBtn = document.createElement("button");
    pointsBtn.textContent = "Points";
    pointsBtn.style.marginRight = "10px";
    pointsBtn.style.padding = "5px 10px";
    pointsBtn.style.cursor = "pointer";
    pointsBtn.addEventListener("click", function() {
      showPointsDialog();
    });
    controls.appendChild(pointsBtn);
    
    // Segments button
    const segmentsBtn = document.createElement("button");
    segmentsBtn.textContent = "Segments";
    segmentsBtn.style.marginRight = "10px";
    segmentsBtn.style.padding = "5px 10px";
    segmentsBtn.style.cursor = "pointer";
    segmentsBtn.addEventListener("click", function() {
      showSegmentsDialog();
    });
    controls.appendChild(segmentsBtn);
    
    globalToolbar.appendChild(controls);
  }
  

  /**
 * Turn strings like "π/3", "2pi", "pi", "3/4", or "5.2" into a Number.
 * Falls back to NaN if it really can’t parse.
 */



  // Function to show Graph Settings dialog
  function showGraphSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    dialogBox.style.maxWidth = "80%";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Graph Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // X-axis settings section
    const xAxisSection = document.createElement("div");
    xAxisSection.style.marginBottom = "20px";
    
    const xAxisTitle = document.createElement("h4");
    xAxisTitle.textContent = "X-Axis Settings";
    xAxisTitle.style.marginBottom = "10px";
    xAxisSection.appendChild(xAxisTitle);
    
    // X-min input
    const xMinRow = document.createElement("div");
    xMinRow.style.display = "flex";
    xMinRow.style.alignItems = "center";
    xMinRow.style.marginBottom = "10px";
    
    const xMinLabel = document.createElement("label");
    xMinLabel.textContent = "x-min:";
    xMinLabel.style.width = "140px";
    xMinLabel.style.marginRight = "10px";
    xMinRow.appendChild(xMinLabel);
    
    const xMinInput = document.createElement("input");
    xMinInput.type = "text";
    xMinInput.value = container.graphData.xmin;
    xMinInput.style.marginRight = "10px";
    xMinRow.appendChild(xMinInput);
    
    xAxisSection.appendChild(xMinRow);
    
    // X-max input
    const xMaxRow = document.createElement("div");
    xMaxRow.style.display = "flex";
    xMaxRow.style.alignItems = "center";
    xMaxRow.style.marginBottom = "10px";
    
    const xMaxLabel = document.createElement("label");
    xMaxLabel.textContent = "x-max:";
    xMaxLabel.style.width = "140px";
    xMaxLabel.style.marginRight = "10px";
    xMaxRow.appendChild(xMaxLabel);
    
    const xMaxInput = document.createElement("input");
    xMaxInput.type = "text";
    xMaxInput.value = container.graphData.xmax;
    xMaxInput.style.marginRight = "10px";
    xMaxRow.appendChild(xMaxInput);
    
    xAxisSection.appendChild(xMaxRow);
    
    // X-scale input
    const xScaleRow = document.createElement("div");
    xScaleRow.style.display = "flex";
    xScaleRow.style.alignItems = "center";
    xScaleRow.style.marginBottom = "10px";
    
    const xScaleLabel = document.createElement("label");
    xScaleLabel.textContent = "x-scale:";
    xScaleLabel.style.width = "140px";
    xScaleLabel.style.marginRight = "10px";
    xScaleRow.appendChild(xScaleLabel);
    
    const xScaleInput = document.createElement("input");
    xScaleInput.type = "text";
    xScaleInput.value = container.graphData.xscale;
    xScaleInput.style.marginRight = "10px";
    xScaleRow.appendChild(xScaleInput);
    
    xAxisSection.appendChild(xScaleRow);
    
    // X-label interval input
    const xLabelIntervalRow = document.createElement("div");
    xLabelIntervalRow.style.display = "flex";
    xLabelIntervalRow.style.alignItems = "center";
    xLabelIntervalRow.style.marginBottom = "10px";
    
    const xLabelIntervalLabel = document.createElement("label");
    xLabelIntervalLabel.textContent = "x-label interval:";
    xLabelIntervalLabel.style.width = "140px";
    xLabelIntervalLabel.style.marginRight = "10px";
    xLabelIntervalRow.appendChild(xLabelIntervalLabel);
    
    const xLabelIntervalInput = document.createElement("input");
    xLabelIntervalInput.type = "text";
    xLabelIntervalInput.value = container.graphData.xlabelInterval;
    xLabelIntervalInput.style.marginRight = "10px";
    xLabelIntervalRow.appendChild(xLabelIntervalInput);
    
    xAxisSection.appendChild(xLabelIntervalRow);
    
    dialogBox.appendChild(xAxisSection);
    
    // Y-axis settings section
    const yAxisSection = document.createElement("div");
    yAxisSection.style.marginBottom = "20px";
    
    const yAxisTitle = document.createElement("h4");
    yAxisTitle.textContent = "Y-Axis Settings";
    yAxisTitle.style.marginBottom = "10px";
    yAxisSection.appendChild(yAxisTitle);
    
    // Y-min input
    const yMinRow = document.createElement("div");
    yMinRow.style.display = "flex";
    yMinRow.style.alignItems = "center";
    yMinRow.style.marginBottom = "10px";
    
    const yMinLabel = document.createElement("label");
    yMinLabel.textContent = "y-min:";
    yMinLabel.style.width = "140px";
    yMinLabel.style.marginRight = "10px";
    yMinRow.appendChild(yMinLabel);
    
    const yMinInput = document.createElement("input");
    yMinInput.type = "text";
    yMinInput.value = container.graphData.ymin;
    yMinInput.style.marginRight = "10px";
    yMinRow.appendChild(yMinInput);
    
    yAxisSection.appendChild(yMinRow);
    
    // Y-max input
    const yMaxRow = document.createElement("div");
    yMaxRow.style.display = "flex";
    yMaxRow.style.alignItems = "center";
    yMaxRow.style.marginBottom = "10px";
    
    const yMaxLabel = document.createElement("label");
    yMaxLabel.textContent = "y-max:";
    yMaxLabel.style.width = "140px";
    yMaxLabel.style.marginRight = "10px";
    yMaxRow.appendChild(yMaxLabel);
    
    const yMaxInput = document.createElement("input");
    yMaxInput.type = "text";
    yMaxInput.value = container.graphData.ymax;
    yMaxInput.style.marginRight = "10px";
    yMaxRow.appendChild(yMaxInput);
    
    yAxisSection.appendChild(yMaxRow);
    
    // Y-scale input
    const yScaleRow = document.createElement("div");
    yScaleRow.style.display = "flex";
    yScaleRow.style.alignItems = "center";
    yScaleRow.style.marginBottom = "10px";
    
    const yScaleLabel = document.createElement("label");
    yScaleLabel.textContent = "y-scale:";
    yScaleLabel.style.width = "140px";
    yScaleLabel.style.marginRight = "10px";
    yScaleRow.appendChild(yScaleLabel);
    
    const yScaleInput = document.createElement("input");
    yScaleInput.type = "text";
    yScaleInput.value = container.graphData.yscale;
    yScaleInput.style.marginRight = "10px";
    yScaleRow.appendChild(yScaleInput);
    
    yAxisSection.appendChild(yScaleRow);
    
    // Y-label interval input
    const yLabelIntervalRow = document.createElement("div");
    yLabelIntervalRow.style.display = "flex";
    yLabelIntervalRow.style.alignItems = "center";
    yLabelIntervalRow.style.marginBottom = "10px";
    
    const yLabelIntervalLabel = document.createElement("label");
    yLabelIntervalLabel.textContent = "y-label interval:";
    yLabelIntervalLabel.style.width = "140px";
    yLabelIntervalLabel.style.marginRight = "10px";
    yLabelIntervalRow.appendChild(yLabelIntervalLabel);
    
    const yLabelIntervalInput = document.createElement("input");
    yLabelIntervalInput.type = "text";
    yLabelIntervalInput.value = container.graphData.ylabelInterval;
    yLabelIntervalInput.style.marginRight = "10px";
    yLabelIntervalRow.appendChild(yLabelIntervalInput);
    
    yAxisSection.appendChild(yLabelIntervalRow);
    
    dialogBox.appendChild(yAxisSection);
    
    // Font settings section
    const fontSection = document.createElement("div");
    fontSection.style.marginBottom = "20px";
    
    const fontTitle = document.createElement("h4");
    fontTitle.textContent = "Font Settings";
    fontTitle.style.marginBottom = "10px";
    fontSection.appendChild(fontTitle);
    
    // Tick font size input
    const tickFontSizeRow = document.createElement("div");
    tickFontSizeRow.style.display = "flex";
    tickFontSizeRow.style.alignItems = "center";
    tickFontSizeRow.style.marginBottom = "10px";
    
    const tickFontSizeLabel = document.createElement("label");
    tickFontSizeLabel.textContent = "Tick Font Size:";
    tickFontSizeLabel.style.width = "140px";
    tickFontSizeLabel.style.marginRight = "10px";
    tickFontSizeRow.appendChild(tickFontSizeLabel);
    
    const tickFontSizeInput = document.createElement("input");
    tickFontSizeInput.type = "number";
    tickFontSizeInput.min = "6";
    tickFontSizeInput.max = "32";
    tickFontSizeInput.value = container.graphData.tickFontSize;
    tickFontSizeInput.style.marginRight = "10px";
    tickFontSizeRow.appendChild(tickFontSizeInput);
    
    fontSection.appendChild(tickFontSizeRow);
    
    // Axis label font size input
    const axisLabelFontSizeRow = document.createElement("div");
    axisLabelFontSizeRow.style.display = "flex";
    axisLabelFontSizeRow.style.alignItems = "center";
    axisLabelFontSizeRow.style.marginBottom = "10px";
    
    const axisLabelFontSizeLabel = document.createElement("label");
    axisLabelFontSizeLabel.textContent = "Axis Label Font Size:";
    axisLabelFontSizeLabel.style.width = "140px";
    axisLabelFontSizeLabel.style.marginRight = "10px";
    axisLabelFontSizeRow.appendChild(axisLabelFontSizeLabel);
    
    const axisLabelFontSizeInput = document.createElement("input");
    axisLabelFontSizeInput.type = "number";
    axisLabelFontSizeInput.min = "6";
    axisLabelFontSizeInput.max = "48";
    axisLabelFontSizeInput.value = container.graphData.axisLabelFontSize;
    axisLabelFontSizeInput.style.marginRight = "10px";
    axisLabelFontSizeRow.appendChild(axisLabelFontSizeInput);
    
    fontSection.appendChild(axisLabelFontSizeRow);
    
    dialogBox.appendChild(fontSection);
    
    // Buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.padding = "8px 16px";
    applyButton.style.marginRight = "10px";
    applyButton.style.cursor = "pointer";
    applyButton.style.backgroundColor = "#4CAF50";
    applyButton.style.color = "white";
    applyButton.style.border = "none";
    applyButton.style.borderRadius = "4px";
    

    function storeAxisInput(field, raw) {
  raw = raw.trim();
  // if it contains a variable placeholder (#…#), store it un-parsed
  if (raw.includes('#')) return raw;
  // otherwise parse numbers, π, or fractions
  return parseGraphInput(raw);
}

applyButton.addEventListener("click", function() {
  container.graphData.xmin           = storeAxisInput('xmin',           xMinInput.value);
  container.graphData.xmax           = storeAxisInput('xmax',           xMaxInput.value);
  container.graphData.xscale         = storeAxisInput('xscale',         xScaleInput.value);
  container.graphData.xlabelInterval = storeAxisInput('xlabelInterval', xLabelIntervalInput.value);

  container.graphData.ymin           = storeAxisInput('ymin',           yMinInput.value);
  container.graphData.ymax           = storeAxisInput('ymax',           yMaxInput.value);
  container.graphData.yscale         = storeAxisInput('yscale',         yScaleInput.value);
  container.graphData.ylabelInterval = storeAxisInput('ylabelInterval', yLabelIntervalInput.value);

  // keep these parsed as ints
  container.graphData.tickFontSize      = parseInt(tickFontSizeInput.value,      10);
  container.graphData.axisLabelFontSize = parseInt(axisLabelFontSizeInput.value, 10);

  drawGraph();
  document.body.removeChild(dialogBackdrop);
});
    
    buttonsContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.padding = "8px 16px";
    cancelButton.style.cursor = "pointer";
    cancelButton.style.backgroundColor = "#f0f0f0";
    cancelButton.style.border = "1px solid #ccc";
    cancelButton.style.borderRadius = "4px";
    
    cancelButton.addEventListener("click", function() {
      // Close the dialog without saving changes
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Equations dialog
  function showEquationsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Equations";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Equations list
    const equationsListContainer = document.createElement("div");
    equationsListContainer.id = "equationsList";
    equationsListContainer.style.marginBottom = "20px";
    
    // Render existing equations
    function renderEquationsList() {
      equationsListContainer.innerHTML = "";
      
      if (container.graphData.equations.length === 0) {
        const noEquationsMsg = document.createElement("p");
        noEquationsMsg.textContent = "No equations added yet.";
        equationsListContainer.appendChild(noEquationsMsg);
      } else {
        container.graphData.equations.forEach((eq, index) => {
          const eqItem = document.createElement("div");
          eqItem.className = "equation-item";
          eqItem.style.border = "1px solid #ddd";
          eqItem.style.padding = "10px";
          eqItem.style.marginBottom = "10px";
          eqItem.style.backgroundColor = "#fff";
          eqItem.style.borderRadius = "3px";
          
          const eqTitle = document.createElement("strong");
          eqTitle.textContent = `Equation ${index+1}: `;
          eqItem.appendChild(eqTitle);
          
          const eqDesc = document.createTextNode(`${eq.type} – ${eq.equation}`);
          eqItem.appendChild(eqDesc);
          
          const actionsContainer = document.createElement("div");
          actionsContainer.style.display = "flex";
          actionsContainer.style.alignItems = "center";
          actionsContainer.style.marginTop = "5px";
          
          const colorSwatch = document.createElement("span");
          colorSwatch.style.display = "inline-block";
          colorSwatch.style.width = "20px";
          colorSwatch.style.height = "10px";
          colorSwatch.style.backgroundColor = eq.color;
          actionsContainer.appendChild(colorSwatch);
          
          const infoText = document.createTextNode(` Width: ${eq.width}, Style: ${eq.style || 'solid'} `);
          actionsContainer.appendChild(infoText);
          
          let domainText = '';
          if (eq.domainMinOp !== 'none' && eq.domainMin) {
            domainText += `${eq.domainMin} ${eq.domainMinOp} `;
          }
          domainText += 'x';
          if (eq.domainMaxOp !== 'none' && eq.domainMax) {
            domainText += ` ${eq.domainMaxOp} ${eq.domainMax}`;
          }
          
          if (domainText !== 'x') {
            const domain = document.createElement("div");
            domain.style.marginTop = "5px";
            domain.style.fontSize = "0.9em";
            domain.textContent = `Domain: ${domainText}`;
            eqItem.appendChild(domain);
          }
          
          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";
          editBtn.style.marginLeft = "10px";
          editBtn.addEventListener("click", function() {
            editEquation(index);
          });
          actionsContainer.appendChild(editBtn);
          
          const deleteBtn = document.createElement("span");
          deleteBtn.className = "delete-btn";
          deleteBtn.textContent = "Delete";
          deleteBtn.style.display = "inline-block";
          deleteBtn.style.padding = "2px 6px";
          deleteBtn.style.border = "1px solid #000";
          deleteBtn.style.backgroundColor = "#fff";
          deleteBtn.style.color = "#000";
          deleteBtn.style.borderRadius = "3px";
          deleteBtn.style.fontSize = "0.9em";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.marginLeft = "10px";
          deleteBtn.addEventListener("click", function() {
            container.graphData.equations.splice(index, 1);
            renderEquationsList();
          });
          actionsContainer.appendChild(deleteBtn);
          
          eqItem.appendChild(actionsContainer);
          equationsListContainer.appendChild(eqItem);
        });
      }
    }
    
    renderEquationsList();
    dialogBox.appendChild(equationsListContainer);
    
    // Add new equation form
    const addEquationForm = document.createElement("div");
    addEquationForm.style.backgroundColor = "#f9f9f9";
    addEquationForm.style.padding = "15px";
    addEquationForm.style.borderRadius = "5px";
    addEquationForm.style.marginBottom = "20px";
    
    const formTitle = document.createElement("h4");
    formTitle.textContent = "Add Equation";
    formTitle.style.marginTop = "0";
    formTitle.style.marginBottom = "15px";
    addEquationForm.appendChild(formTitle);
    
    // Equation type dropdown
    const eqTypeRow = document.createElement("div");
    eqTypeRow.style.marginBottom = "10px";
    
    const eqTypeLabel = document.createElement("label");
    eqTypeLabel.textContent = "Equation type:";
    eqTypeLabel.style.display = "inline-block";
    eqTypeLabel.style.width = "140px";
    eqTypeLabel.style.marginRight = "10px";
    eqTypeRow.appendChild(eqTypeLabel);
    
    const eqTypeSelect = document.createElement("select");
    eqTypeSelect.id = "newEqType";
    
    const eqTypeOptions = [
      { value: "linear", text: "Linear" },
      { value: "quadratic", text: "Quadratic" },
      { value: "exponential", text: "Exponential" },
      { value: "polynomial", text: "Polynomial" },
      { value: "rational", text: "Rational" },
      { value: "absoluteValue", text: "Absolute Value" },
      { value: "sine", text: "Sine (sin)" },
      { value: "cosine", text: "Cosine (cos)" },
      { value: "tangent", text: "Tangent (tan)" },
      { value: "circle", text: "Circle" },
      { value: "semicircle", text: "Semicircle" },
      { value: "ellipse", text: "Ellipse" },
      { value: "hyperbola", text: "Hyperbola" }
    ];
    
    eqTypeOptions.forEach(option => {
      const optionEl = document.createElement("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
      eqTypeSelect.appendChild(optionEl);
    });
    
    eqTypeRow.appendChild(eqTypeSelect);
    addEquationForm.appendChild(eqTypeRow);
    
    // Trig unit toggle (initially hidden)
    const trigUnitToggle = document.createElement("div");
    trigUnitToggle.id = "trigUnitToggle";
    trigUnitToggle.style.display = "none";
    trigUnitToggle.style.marginBottom = "10px";
    
    const useDegLabel = document.createElement("label");
    useDegLabel.textContent = "Use Degrees:";
    useDegLabel.style.display = "inline-block";
    useDegLabel.style.width = "140px";
    useDegLabel.style.marginRight = "10px";
    trigUnitToggle.appendChild(useDegLabel);
    
    const useDegCheckbox = document.createElement("input");
    useDegCheckbox.type = "checkbox";
    useDegCheckbox.id = "useDegrees";
    trigUnitToggle.appendChild(useDegCheckbox);
    
    const useDegNote = document.createElement("span");
    useDegNote.textContent = " (default is radians)";
    trigUnitToggle.appendChild(useDegNote);
    
    addEquationForm.appendChild(trigUnitToggle);
    
    // Equation input
    const eqInputRow = document.createElement("div");
    eqInputRow.style.marginBottom = "10px";
    
    const eqInputLabel = document.createElement("label");
    eqInputLabel.textContent = "Equation:";
    eqInputLabel.style.display = "inline-block";
    eqInputLabel.style.width = "140px";
    eqInputLabel.style.marginRight = "10px";
    eqInputRow.appendChild(eqInputLabel);
    
    const eqInput = document.createElement("input");
    eqInput.type = "text";
    eqInput.id = "newEquation";
    eqInput.style.width = "60%";
    eqInputRow.appendChild(eqInput);
    
    const eqHint = document.createElement("span");
    eqHint.id = "hint";
    eqHint.style.display = "block";
    eqHint.style.marginLeft = "150px";
    eqHint.style.fontStyle = "italic";
    eqHint.style.color = "#555";
    eqInputRow.appendChild(eqHint);
    
    addEquationForm.appendChild(eqInputRow);
    
    // Style options
    const styleRow = document.createElement("div");
    styleRow.style.marginBottom = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Line Color:";
    colorLabel.style.display = "inline-block";
    colorLabel.style.width = "140px";
    colorLabel.style.marginRight = "10px";
    styleRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.id = "newLineColor";
    colorInput.value = "#ff0000";
    colorInput.style.marginRight = "20px";
    styleRow.appendChild(colorInput);
    
    const widthLabel = document.createElement("label");
    widthLabel.textContent = "Line Width:";
    widthLabel.style.marginRight = "10px";
    styleRow.appendChild(widthLabel);
    
    const widthInput = document.createElement("input");
    widthInput.type = "number";
    widthInput.id = "newLineWidth";
    widthInput.min = "1";
    widthInput.max = "10";
    widthInput.value = "2";
    widthInput.style.width = "50px";
    widthInput.style.marginRight = "20px";
    styleRow.appendChild(widthInput);
    
    const styleLabel = document.createElement("label");
    styleLabel.textContent = "Line Style:";
    styleLabel.style.marginRight = "10px";
    styleRow.appendChild(styleLabel);
    
    const styleSelect = document.createElement("select");
    styleSelect.id = "newLineStyle";
    
    const solidOption = document.createElement("option");
    solidOption.value = "solid";
    solidOption.textContent = "Solid";
    styleSelect.appendChild(solidOption);
    
    const dottedOption = document.createElement("option");
    dottedOption.value = "dotted";
    dottedOption.textContent = "Dotted";
    styleSelect.appendChild(dottedOption);
    
    const dashedOption = document.createElement("option");
    dashedOption.value = "dashed";
    dashedOption.textContent = "Dashed";
    styleSelect.appendChild(dashedOption);
    
    styleRow.appendChild(styleSelect);
    
    addEquationForm.appendChild(styleRow);


    
    // Domain restriction
    const domainRow = document.createElement("div");
    domainRow.className = "domain-restriction";
    domainRow.style.display = "flex";
    domainRow.style.alignItems = "center";
    domainRow.style.marginTop = "10px";
    domainRow.style.marginBottom = "15px";
    
    const domainLabel = document.createElement("label");
domainLabel.textContent = "Domain:";
domainLabel.style.display = "inline-block";
domainLabel.style.width = "140px";
domainLabel.style.marginRight = "10px";
domainRow.appendChild(domainLabel);

    const domainMinInput = document.createElement("input");
    domainMinInput.id = "newDomainMin";
    domainMinInput.type = "text";
    domainMinInput.placeholder = "min";
    domainMinInput.style.width = "60px";
    domainRow.appendChild(domainMinInput);
    
    const domainMinOpSelect = document.createElement("select");
    domainMinOpSelect.id = "newDomainMinOp";
    domainMinOpSelect.style.width = "60px";
    
    const minNoneOption = document.createElement("option");
    minNoneOption.value = "none";
    minNoneOption.textContent = "none";
    domainMinOpSelect.appendChild(minNoneOption);
    
    const minLessOption = document.createElement("option");
    minLessOption.value = "<";
    minLessOption.textContent = "<";
    domainMinOpSelect.appendChild(minLessOption);
    
    const minLessEqOption = document.createElement("option");
    minLessEqOption.value = "≤";
    minLessEqOption.textContent = "≤";
    domainMinOpSelect.appendChild(minLessEqOption);
    
    domainRow.appendChild(domainMinOpSelect);
    
    const xText = document.createElement("span");
    xText.textContent = "x";
    xText.style.margin = "0 5px";
    domainRow.appendChild(xText);
    
    const domainMaxOpSelect = document.createElement("select");
    domainMaxOpSelect.id = "newDomainMaxOp";
    domainMaxOpSelect.style.width = "60px";
    
    const maxNoneOption = document.createElement("option");
    maxNoneOption.value = "none";
    maxNoneOption.textContent = "none";
    domainMaxOpSelect.appendChild(maxNoneOption);
    
    const maxLessOption = document.createElement("option");
    maxLessOption.value = "<";
    maxLessOption.textContent = "<";
    domainMaxOpSelect.appendChild(maxLessOption);
    
    const maxLessEqOption = document.createElement("option");
    maxLessEqOption.value = "≤";
    maxLessEqOption.textContent = "≤";
    domainMaxOpSelect.appendChild(maxLessEqOption);
    
    domainRow.appendChild(domainMaxOpSelect);
    
    const domainMaxInput = document.createElement("input");
    domainMaxInput.id = "newDomainMax";
    domainMaxInput.type = "text";
    domainMaxInput.placeholder = "max";
    domainMaxInput.style.width = "60px";
    domainRow.appendChild(domainMaxInput);
    
    addEquationForm.appendChild(domainRow);
    
    // Add equation button
    const addBtnRow = document.createElement("div");
    
    const addEquationBtn = document.createElement("button");
    addEquationBtn.textContent = "Add Equation";
    addEquationBtn.style.padding = "8px 16px";
    addEquationBtn.style.cursor = "pointer";
    addEquationBtn.style.backgroundColor = "#4CAF50";
    addEquationBtn.style.color = "white";
    addEquationBtn.style.border = "none";
    addEquationBtn.style.borderRadius = "4px";
    
    // Hidden input for tracking editing state
    const editingIndexInput = document.createElement("input");
    editingIndexInput.type = "hidden";
    editingIndexInput.id = "editingEquationIndex";
    editingIndexInput.value = "-1";
    addBtnRow.appendChild(editingIndexInput);
    
    addBtnRow.appendChild(addEquationBtn);
    addEquationForm.appendChild(addBtnRow);
    
    dialogBox.appendChild(addEquationForm);
    
    // Function to edit an equation
    function editEquation(index) {
      const eq = container.graphData.equations[index];
      
      // Set form fields to equation values
      eqTypeSelect.value = eq.type;
      eqInput.value = eq.equation;
      colorInput.value = eq.color;
      widthInput.value = eq.width;
      styleSelect.value = eq.style || 'solid';
      
      domainMinInput.value = eq.domainMin || '';
      domainMinOpSelect.value = eq.domainMinOp || 'none';
      domainMaxInput.value = eq.domainMax || '';
      domainMaxOpSelect.value = eq.domainMaxOp || 'none';
      
      // Handle trigonometric functions
      if (['sine', 'cosine', 'tangent'].includes(eq.type)) {
        trigUnitToggle.style.display = 'block';
        useDegCheckbox.checked = eq.useDegrees || false;
      } else {
        trigUnitToggle.style.display = 'none';
      }
      
      // Update the hint text
      updateEquationHint();
      
      // Set editing state
      editingIndexInput.value = index;
      
      // Change button text
      addEquationBtn.textContent = 'Update Equation';
    }
    
    // Add equation hints
    const hints = {
      linear: 'e.g. 2*x+1',
      quadratic: 'e.g. x^2 - 4*x + 3',
      exponential: 'e.g. 2^(x/2)',
      polynomial: 'e.g. x^3 - 2*x + 1',
      rational: '(x^2 - 1)/(x - 1)',
      absoluteValue: 'e.g. abs(x) or abs(x-2)+1',
      sine: 'e.g. sin(x) or 2*sin(3*x)',
      cosine: 'e.g. cos(x) or 3*cos(x/2)',
      tangent: 'e.g. tan(x) or 0.5*tan(2*x)',
      circle: 'center x,center y,r (e.g. 0,0,5)',
      semicircle: 'center x,center y,r,top/left,bottom/right (e.g. 0,0,5,top)',
      ellipse: 'center x,center y,a,b (e.g. 0,0,6,3)',
      hyperbola: 'center x,center y,a,b (e.g. 0,0,4,2)'
    };
    
    // Function to update equation hint
    function updateEquationHint() {
      const t = eqTypeSelect.value;
      eqHint.textContent = hints[t] || '';
      eqInput.placeholder = hints[t] || '';
      
      // Show/hide the degrees toggle based on trig functions
      if (['sine', 'cosine', 'tangent'].includes(t)) {
        trigUnitToggle.style.display = 'block';
      } else {
        trigUnitToggle.style.display = 'none';
      }
    }
    
    // Add event listener for equation type change
    eqTypeSelect.addEventListener("change", updateEquationHint);
    
    // Initialize hint
    updateEquationHint();
    
    // Add equation button handler
    addEquationBtn.addEventListener("click", function() {
      const eqType = eqTypeSelect.value;
      const eqStr = eqInput.value.trim();
      
      // Validate input
      if (!validateInput(eqStr)) {
        alert('Invalid input.');
        return;
      }
      
      if (eqStr.length > 60) {
        alert('Equation too long (max 60 characters).');
        return;
      }
      
      if (!isSafeMathExpression(eqStr)) {
        alert('Invalid equation: only numbers, x, mathematical operators, and supported functions (abs, sin, cos, tan) are allowed.');
        return;
      }
      
      const lineColor = colorInput.value;
      const lineWidth = parseFloat(widthInput.value);
      const lineStyle = styleSelect.value;
      const domainMin = domainMinInput.value.trim();
      const domainMinOp = domainMinOpSelect.value;
      const domainMax = domainMaxInput.value.trim();
      const domainMaxOp = domainMaxOpSelect.value;
      const useDegrees = ['sine', 'cosine', 'tangent'].includes(eqType) ? 
        useDegCheckbox.checked : false;
      
      // Check if we're editing or adding
      const editingIndex = parseInt(editingIndexInput.value);
      
      if (eqStr) {
        const equation = {
          type: eqType,
          equation: eqStr,
          color: lineColor,
          width: lineWidth,
          style: lineStyle,
          domainMin: domainMin,
          domainMinOp: domainMinOp,
          domainMax: domainMax,
          domainMaxOp: domainMaxOp,
          useDegrees: useDegrees
        };
        
        if (editingIndex >= 0) {
          // Update existing equation
          container.graphData.equations[editingIndex] = equation;
          
          // Reset editing state
          editingIndexInput.value = "-1";
          addEquationBtn.textContent = "Add Equation";
        } else {
          // Add new equation
          container.graphData.equations.push(equation);
        }
        
        // Redraw equation list
        renderEquationsList();
        
        // Redraw graph
        drawGraph();
        
        // Clear form
        eqInput.value = '';
        domainMinInput.value = '';
        domainMaxInput.value = '';
        domainMinOpSelect.value = 'none';
        domainMaxOpSelect.value = 'none';
      } else {
        alert('Please enter an equation');
      }
    });
    
    // Dialog buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Points dialog
  function showPointsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Points";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Points list
    const pointsListContainer = document.createElement("div");
    pointsListContainer.id = "pointsList";
    pointsListContainer.style.marginBottom = "20px";
    
    // Render existing points
    function renderPointsList() {
      pointsListContainer.innerHTML = "";
      
      if (container.graphData.points.length === 0) {
        const noPointsMsg = document.createElement("p");
        noPointsMsg.textContent = "No points added yet.";
        pointsListContainer.appendChild(noPointsMsg);
      } else {
        container.graphData.points.forEach((pt, index) => {
          const ptItem = document.createElement("div");
          ptItem.className = "point-item";
          ptItem.style.border = "1px solid #ddd";
          ptItem.style.padding = "10px";
          ptItem.style.marginBottom = "10px";
          ptItem.style.backgroundColor = "#fff";
          ptItem.style.borderRadius = "3px";
          
          const ptTitle = document.createElement("strong");
          ptTitle.textContent = `${pt.label}: `;
          ptItem.appendChild(ptTitle);
          
          const ptDesc = document.createTextNode(`(${pt.x}, ${pt.y})`);
          ptItem.appendChild(ptDesc);
          
          const actionsContainer = document.createElement("div");
          actionsContainer.style.display = "flex";
          actionsContainer.style.alignItems = "center";
          actionsContainer.style.marginTop = "5px";
          
          const colorSwatch = document.createElement("span");
          colorSwatch.style.display = "inline-block";
          colorSwatch.style.width = "20px";
          colorSwatch.style.height = "10px";
          colorSwatch.style.backgroundColor = pt.color;
          colorSwatch.style.marginRight = "5px";
          actionsContainer.appendChild(colorSwatch);
          
          const infoText = document.createTextNode(`Point Size: ${pt.pointSize || 4}px, Font Size: ${pt.fontSize}px, Position: ${pt.position} `);
          actionsContainer.appendChild(infoText);
          
          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";
          editBtn.style.marginLeft = "10px";
          editBtn.addEventListener("click", function() {
            editPoint(index);
          });
          actionsContainer.appendChild(editBtn);
          
          const deleteBtn = document.createElement("span");
          deleteBtn.className = "delete-btn";
          deleteBtn.textContent = "Delete";
          deleteBtn.style.display = "inline-block";
          deleteBtn.style.padding = "2px 6px";
          deleteBtn.style.border = "1px solid #000";
          deleteBtn.style.backgroundColor = "#fff";
          deleteBtn.style.color = "#000";
          deleteBtn.style.borderRadius = "3px";
          deleteBtn.style.fontSize = "0.9em";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.marginLeft = "10px";
          deleteBtn.addEventListener("click", function() {
            container.graphData.points.splice(index, 1);
            renderPointsList();
            drawGraph();
          });
          actionsContainer.appendChild(deleteBtn);
          
          ptItem.appendChild(actionsContainer);
          pointsListContainer.appendChild(ptItem);
        });
      }
    }
    
    renderPointsList();
    dialogBox.appendChild(pointsListContainer);
    
    // Add new point form
    const addPointForm = document.createElement("div");
    addPointForm.style.backgroundColor = "#f9f9f9";
    addPointForm.style.padding = "15px";
    addPointForm.style.borderRadius = "5px";
    addPointForm.style.marginBottom = "20px";
    
    const formTitle = document.createElement("h4");
    formTitle.textContent = "Add Point";
    formTitle.style.marginTop = "0";
    formTitle.style.marginBottom = "15px";
    addPointForm.appendChild(formTitle);
    
    // Point coordinates
    const coordRow = document.createElement("div");
    coordRow.style.marginBottom = "10px";
    
    const coordLabel = document.createElement("label");
    coordLabel.textContent = "Point (x,y):";
    coordLabel.style.display = "inline-block";
    coordLabel.style.width = "140px";
    coordLabel.style.marginRight = "10px";
    coordRow.appendChild(coordLabel);
    
    const coordInput = document.createElement("input");
    coordInput.type = "text";
    coordInput.id = "newPointCoord";
    coordInput.placeholder = "e.g. 1,2 or (1,2)";
    coordInput.style.width = "150px";
    coordInput.style.marginRight = "20px";
    coordRow.appendChild(coordInput);
    
    const labelLabel = document.createElement("label");
    labelLabel.textContent = "Label:";
    labelLabel.style.marginRight = "10px";
    coordRow.appendChild(labelLabel);
    
    const labelInput = document.createElement("input");
    labelInput.type = "text";
    labelInput.id = "newPointLabel";
    labelInput.placeholder = "A";
    labelInput.style.width = "80px";
    coordRow.appendChild(labelInput);
    
    addPointForm.appendChild(coordRow);
    
    // Point style
    const styleRow = document.createElement("div");
    styleRow.style.marginBottom = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Label Color:";
    colorLabel.style.display = "inline-block";
    colorLabel.style.width = "140px";
    colorLabel.style.marginRight = "10px";
    styleRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.id = "newPointColor";
    colorInput.value = "#000000";
    colorInput.style.marginRight = "20px";
    styleRow.appendChild(colorInput);
    
    const sizeLabel = document.createElement("label");
    sizeLabel.textContent = "Point Size:";
    sizeLabel.style.marginRight = "10px";
    styleRow.appendChild(sizeLabel);
    
    const sizeInput = document.createElement("input");
    sizeInput.type = "number";
    sizeInput.id = "newPointSize";
    sizeInput.min = "1";
    sizeInput.max = "20";
    sizeInput.value = "4";
    sizeInput.style.width = "50px";
    sizeInput.style.marginRight = "20px";
    styleRow.appendChild(sizeInput);
    
    const fontSizeLabel = document.createElement("label");
    fontSizeLabel.textContent = "Label Font Size:";
    fontSizeLabel.style.marginRight = "10px";
    styleRow.appendChild(fontSizeLabel);
    
    const fontSizeInput = document.createElement("input");
    fontSizeInput.type = "number";
    fontSizeInput.id = "newPointFontSize";
    fontSizeInput.min = "6";
    fontSizeInput.max = "48";
    fontSizeInput.value = "12";
    fontSizeInput.style.width = "50px";
    styleRow.appendChild(fontSizeInput);
    
    addPointForm.appendChild(styleRow);
    
    // Label position
    const positionRow = document.createElement("div");
    positionRow.style.marginBottom = "15px";
    
    const positionLabel = document.createElement("label");
    positionLabel.textContent = "Label Position:";
    positionLabel.style.display = "inline-block";
    positionLabel.style.width = "140px";
    positionLabel.style.marginRight = "10px";
    positionRow.appendChild(positionLabel);
    
    const positionSelect = document.createElement("select");
    positionSelect.id = "newLabelPosition";
    
    const positions = [
      { value: "up", text: "up" },
      { value: "down", text: "down" },
      { value: "left", text: "left" },
      { value: "right", text: "right" },
      { value: "upleft", text: "up/left" },
      { value: "upright", text: "up/right" },
      { value: "downleft", text: "down/left" },
      { value: "downright", text: "down/right" }
    ];
    
    positions.forEach(option => {
      const optionEl = document.createElement("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
      positionSelect.appendChild(optionEl);
    });
    
    positionRow.appendChild(positionSelect);
    addPointForm.appendChild(positionRow);
    
    // Add point button
    const addBtnRow = document.createElement("div");
    
    const addPointBtn = document.createElement("button");
    addPointBtn.textContent = "Add Point";
    addPointBtn.style.padding = "8px 16px";
    addPointBtn.style.cursor = "pointer";
    addPointBtn.style.backgroundColor = "#4CAF50";
    addPointBtn.style.color = "white";
    addPointBtn.style.border = "none";
    addPointBtn.style.borderRadius = "4px";
    
    // Hidden input for tracking editing state
    const editingIndexInput = document.createElement("input");
    editingIndexInput.type = "hidden";
    editingIndexInput.id = "editingPointIndex";
    editingIndexInput.value = "-1";
    addBtnRow.appendChild(editingIndexInput);
    
    addBtnRow.appendChild(addPointBtn);
    addPointForm.appendChild(addBtnRow);
    
    dialogBox.appendChild(addPointForm);
    
    // Function to edit a point
    function editPoint(index) {
      const pt = container.graphData.points[index];
      
      // Set form fields to point values
      coordInput.value = `${pt.x},${pt.y}`;
      labelInput.value = pt.label;
      colorInput.value = pt.color;
      sizeInput.value = pt.pointSize || 4;
      fontSizeInput.value = pt.fontSize;
      positionSelect.value = pt.position;
      
      // Set editing state
      editingIndexInput.value = index;
      
      // Change button text
      addPointBtn.textContent = 'Update Point';
    }
    
    // Add point button handler
 // Add point button handler - modified version with variable support
addPointBtn.addEventListener("click", function() {
  let coordInputValue = coordInput.value.trim();
  
  // Handle (a,b) format
  if (coordInputValue.startsWith('(') && coordInputValue.endsWith(')')) {
    coordInputValue = coordInputValue.substring(1, coordInputValue.length - 1);
  }
  
  const coords = coordInputValue.split(',');
  const label = labelInput.value.trim();
  const color = colorInput.value;
  const pointSize = parseFloat(sizeInput.value);
  const fontSize = parseFloat(fontSizeInput.value);
  const position = positionSelect.value;
  
  // Check if we're editing or adding
  const editingIndex = parseInt(editingIndexInput.value);
  
  // Handle both numeric values and variable placeholders (#a#)
  let x = coords[0].trim();
  let y = coords[1].trim();
  
  // If the value is not a variable placeholder, convert to number
  if (!x.includes('#')) {
    x = parseFloat(x);
    if (isNaN(x)) {
      alert('X coordinate must be a number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!y.includes('#')) {
    y = parseFloat(y);
    if (isNaN(y)) {
      alert('Y coordinate must be a number or a variable placeholder (#var#)');
      return;
    }
  }
  
  const point = {
    x,
    y,
    label: label || `P${container.graphData.points.length + 1}`,
    color,
    pointSize,
    fontSize,
    position
  };
  
  if (editingIndex >= 0) {
    // Update existing point
    container.graphData.points[editingIndex] = point;
    
    // Reset editing state
    editingIndexInput.value = "-1";
    addPointBtn.textContent = "Add Point";
  } else {
    // Add new point
    container.graphData.points.push(point);
  }
  
  // Redraw points list
  renderPointsList();
  
  // Redraw graph
  drawGraph();
  
  // Clear form
  coordInput.value = '';
  labelInput.value = '';
});
    // Dialog buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Function to show Segments dialog
  function showSegmentsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "80%";
    dialogBox.style.maxWidth = "800px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Segments";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Segments list
    const segmentsListContainer = document.createElement("div");
    segmentsListContainer.id = "segmentsList";
    segmentsListContainer.style.marginBottom = "20px";
    
    // Render existing segments
    function renderSegmentsList() {
      segmentsListContainer.innerHTML = "";
      
      if (container.graphData.segments.length === 0) {
        const noSegmentsMsg = document.createElement("p");
        noSegmentsMsg.textContent = "No segments added yet.";
        segmentsListContainer.appendChild(noSegmentsMsg);
      } else {
        container.graphData.segments.forEach((seg, index) => {
          const segItem = document.createElement("div");
          segItem.className = "equation-item";
          segItem.style.border = "1px solid #ddd";
          segItem.style.padding = "10px";
          segItem.style.marginBottom = "10px";
          segItem.style.backgroundColor = "#fff";
          segItem.style.borderRadius = "3px";
          
          const segTitle = document.createElement("strong");
          segTitle.textContent = `Segment ${index+1}: `;
          segItem.appendChild(segTitle);
          
          const segDesc = document.createTextNode(`(${seg.x1}, ${seg.y1}) to (${seg.x2}, ${seg.y2})`);
          segItem.appendChild(segDesc);
          
          const actionsContainer = document.createElement("div");
          actionsContainer.style.display = "flex";
          actionsContainer.style.alignItems = "center";
          actionsContainer.style.marginTop = "5px";
          
          const colorSwatch = document.createElement("span");
          colorSwatch.style.display = "inline-block";
          colorSwatch.style.width = "20px";
          colorSwatch.style.height = "10px";
          colorSwatch.style.backgroundColor = seg.color;
          actionsContainer.appendChild(colorSwatch);
          
          const infoText = document.createTextNode(` Width: ${seg.width}, Style: ${seg.style} `);
          actionsContainer.appendChild(infoText);
          
          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";
          editBtn.style.marginLeft = "10px";
          editBtn.addEventListener("click", function() {
            editSegment(index);
          });
          actionsContainer.appendChild(editBtn);
          
          const deleteBtn = document.createElement("span");
          deleteBtn.className = "delete-btn";
          deleteBtn.textContent = "Delete";
          deleteBtn.style.display = "inline-block";
          deleteBtn.style.padding = "2px 6px";
          deleteBtn.style.border = "1px solid #000";
          deleteBtn.style.backgroundColor = "#fff";
          deleteBtn.style.color = "#000";
          deleteBtn.style.borderRadius = "3px";
          deleteBtn.style.fontSize = "0.9em";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.marginLeft = "10px";
          deleteBtn.addEventListener("click", function() {
            container.graphData.segments.splice(index, 1);
            renderSegmentsList();
            drawGraph();
          });
          actionsContainer.appendChild(deleteBtn);
          
          segItem.appendChild(actionsContainer);
          segmentsListContainer.appendChild(segItem);
        });
      }
    }
    
    renderSegmentsList();
    dialogBox.appendChild(segmentsListContainer);
    
    // Add new segment form
    const addSegmentForm = document.createElement("div");
    addSegmentForm.style.backgroundColor = "#f9f9f9";
    addSegmentForm.style.padding = "15px";
    addSegmentForm.style.borderRadius = "5px";
    addSegmentForm.style.marginBottom = "20px";
    
    const formTitle = document.createElement("h4");
    formTitle.textContent = "Add Segment";
    formTitle.style.marginTop = "0";
    formTitle.style.marginBottom = "15px";
    addSegmentForm.appendChild(formTitle);
    
    // Segment start point
    const startRow = document.createElement("div");
    startRow.style.marginBottom = "10px";
    
    const startLabel = document.createElement("label");
    startLabel.textContent = "Start (x,y):";
    startLabel.style.display = "inline-block";
    startLabel.style.width = "140px";
    startLabel.style.marginRight = "10px";
    startRow.appendChild(startLabel);
    
    const startInput = document.createElement("input");
    startInput.type = "text";
    startInput.id = "newSegmentStart";
    startInput.placeholder = "e.g. 1,2 or (1,2)";
    startInput.style.width = "150px";
    startRow.appendChild(startInput);
    
    addSegmentForm.appendChild(startRow);
    
    // Segment end point
    const endRow = document.createElement("div");
    endRow.style.marginBottom = "10px";
    
    const endLabel = document.createElement("label");
    endLabel.textContent = "End (x,y):";
    endLabel.style.display = "inline-block";
    endLabel.style.width = "140px";
    endLabel.style.marginRight = "10px";
    endRow.appendChild(endLabel);
    
    const endInput = document.createElement("input");
    endInput.type = "text";
    endInput.id = "newSegmentEnd";
    endInput.placeholder = "e.g. 3,4 or (3,4)";
    endInput.style.width = "150px";
    endRow.appendChild(endInput);
    
    addSegmentForm.appendChild(endRow);
    
    // Segment style
    const styleRow = document.createElement("div");
    styleRow.style.marginBottom = "10px";
    
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Line Color:";
    colorLabel.style.display = "inline-block";
    colorLabel.style.width = "140px";
    colorLabel.style.marginRight = "10px";
    styleRow.appendChild(colorLabel);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.id = "newSegmentColor";
    colorInput.value = "#0000ff";
    colorInput.style.marginRight = "20px";
    styleRow.appendChild(colorInput);
    
    const widthLabel = document.createElement("label");
    widthLabel.textContent = "Line Width:";
    widthLabel.style.marginRight = "10px";
    styleRow.appendChild(widthLabel);
    
    const widthInput = document.createElement("input");
    widthInput.type = "number";
    widthInput.id = "newSegmentWidth";
    widthInput.min = "1";
    widthInput.max = "10";
    widthInput.value = "2";
    widthInput.style.width = "50px";
    styleRow.appendChild(widthInput);
    
    addSegmentForm.appendChild(styleRow);
    
    // Line style
    const lineStyleRow = document.createElement("div");
    lineStyleRow.style.marginBottom = "15px";
    
    const lineStyleLabel = document.createElement("label");
    lineStyleLabel.textContent = "Line Style:";
    lineStyleLabel.style.display = "inline-block";
    lineStyleLabel.style.width = "140px";
    lineStyleLabel.style.marginRight = "10px";
    lineStyleRow.appendChild(lineStyleLabel);
    
    const lineStyleSelect = document.createElement("select");
    lineStyleSelect.id = "newSegmentStyle";
    
    const solidOption = document.createElement("option");
    solidOption.value = "solid";
    solidOption.textContent = "Solid";
    lineStyleSelect.appendChild(solidOption);
    
    const dashedOption = document.createElement("option");
    dashedOption.value = "dashed";
    dashedOption.textContent = "Dashed";
    lineStyleSelect.appendChild(dashedOption);
    
    lineStyleRow.appendChild(lineStyleSelect);
    addSegmentForm.appendChild(lineStyleRow);
    
    // Add segment button
    const addBtnRow = document.createElement("div");
    
    const addSegmentBtn = document.createElement("button");
    addSegmentBtn.textContent = "Add Segment";
    addSegmentBtn.style.padding = "8px 16px";
    addSegmentBtn.style.cursor = "pointer";
    addSegmentBtn.style.backgroundColor = "#4CAF50";
    addSegmentBtn.style.color = "white";
    addSegmentBtn.style.border = "none";
    addSegmentBtn.style.borderRadius = "4px";
    
    // Hidden input for tracking editing state
   // Hidden input for tracking editing state
   const editingIndexInput = document.createElement("input");
    editingIndexInput.type = "hidden";
    editingIndexInput.id = "editingSegmentIndex";
    editingIndexInput.value = "-1";
    addBtnRow.appendChild(editingIndexInput);
    
    addBtnRow.appendChild(addSegmentBtn);
    addSegmentForm.appendChild(addBtnRow);
    
    dialogBox.appendChild(addSegmentForm);
    
    // Function to edit a segment
    function editSegment(index) {
      const seg = container.graphData.segments[index];
      
      // Set form fields to segment values
      startInput.value = `${seg.x1},${seg.y1}`;
      endInput.value = `${seg.x2},${seg.y2}`;
      colorInput.value = seg.color;
      widthInput.value = seg.width;
      lineStyleSelect.value = seg.style;
      
      // Set editing state
      editingIndexInput.value = index;
      
      // Change button text
      addSegmentBtn.textContent = 'Update Segment';
    }
    
    // Add segment button handler
  // Add segment button handler - modified version with variable support
addSegmentBtn.addEventListener("click", function() {
  let startInputValue = startInput.value.trim();
  let endInputValue = endInput.value.trim();
  
  // Handle (a,b) format for start point
  if (startInputValue.startsWith('(') && startInputValue.endsWith(')')) {
    startInputValue = startInputValue.substring(1, startInputValue.length - 1);
  }
  
  // Handle (a,b) format for end point
  if (endInputValue.startsWith('(') && endInputValue.endsWith(')')) {
    endInputValue = endInputValue.substring(1, endInputValue.length - 1);
  }
  
  const startCoords = startInputValue.split(',');
  const endCoords = endInputValue.split(',');
  const color = colorInput.value;
  const width = parseFloat(widthInput.value);
  const style = lineStyleSelect.value;
  
  // Check if we're editing or adding
  const editingIndex = parseInt(editingIndexInput.value);
  
  // Handle both numeric values and variable placeholders (#a#)
  let x1 = startCoords[0].trim();
  let y1 = startCoords[1].trim();
  let x2 = endCoords[0].trim();
  let y2 = endCoords[1].trim();
  
  // If the values are not variable placeholders, convert to numbers
  if (!x1.includes('#')) {
    x1 = parseFloat(x1);
    if (isNaN(x1)) {
      alert('Start X coordinate must be a number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!y1.includes('#')) {
    y1 = parseFloat(y1);
    if (isNaN(y1)) {
      alert('Start Y coordinate must be a number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!x2.includes('#')) {
    x2 = parseFloat(x2);
    if (isNaN(x2)) {
      alert('End X coordinate must be a number or a variable placeholder (#var#)');
      return;
    }
  }
  
  if (!y2.includes('#')) {
    y2 = parseFloat(y2);
    if (isNaN(y2)) {
      alert('End Y coordinate must be a number or a variable placeholder (#var#)');
      return;
    }
  }
  
  const segment = {
    x1,
    y1,
    x2,
    y2,
    color,
    width,
    style
  };
  
  if (editingIndex >= 0) {
    // Update existing segment
    container.graphData.segments[editingIndex] = segment;
    
    // Reset editing state
    editingIndexInput.value = "-1";
    addSegmentBtn.textContent = "Add Segment";
  } else {
    // Add new segment
    container.graphData.segments.push(segment);
  }
  
  // Redraw segments list
  renderSegmentsList();
  
  // Redraw graph
  drawGraph();
  
  // Clear form
  startInput.value = '';
  endInput.value = '';
});
    
    // Dialog buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    
    const closeButton = document.createElement("button");
    closeButton.textContent = "Close";
    closeButton.style.padding = "8px 16px";
    closeButton.style.cursor = "pointer";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    dialogBox.appendChild(buttonsContainer);
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Functions for element activation and deactivation
  function activateFourQuadrantGraph() {
    // Deactivate the previously active element if any
    if (window.activeFourQuadrantGraphElement && window.activeFourQuadrantGraphElement !== container) {
      window.activeFourQuadrantGraphElement.style.border = "none";
      
      const prevToolbar = window.activeFourQuadrantGraphElement.querySelector(".four-quadrant-graph-toolbar");
      const prevResizeHandle = window.activeFourQuadrantGraphElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeFourQuadrantGraphElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }
  
  function deactivateFourQuadrantGraph() {
    if (window.activeFourQuadrantGraphElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeFourQuadrantGraphElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }
  
  // Function to delete the graph
  function deleteFourQuadrantGraph() {
    if (window.activeFourQuadrantGraphElement === container) {
      window.activeFourQuadrantGraphElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }
  
  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateFourQuadrantGraph();
    }
  });
  
  // Deletion: add both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteFourQuadrantGraph();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteFourQuadrantGraph();
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      // Calculate new dimensions based on mouse position
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      const newHeight = Math.max(300, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      
      // Update canvas dimensions and ensure content scales properly
      graphCanvas.width = newWidth;
      graphCanvas.height = newHeight - toolbarHeight;
      
      // Redraw the graph with the new dimensions
      drawGraph();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activeFourQuadrantGraphElement === container) {
      deactivateFourQuadrantGraph();
    }
  });
  
  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Store the draw function on the container so it can be called externally
  container.drawGraph = drawGraph;
  
  // Draw the initial graph
  drawGraph();
  
  // Activate the graph
  activateFourQuadrantGraph();
  
  return container;
}

// Add Line Graph component to the canvas
function addLineGraph() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeLineGraphElement) {
    window.activeLineGraphElement = null;
  }
  // Global counter for line graph IDs
  if (!window.globalLineGraphCounter) {
    window.globalLineGraphCounter = 1;
  } else {
    window.globalLineGraphCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element line-graph-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "600px";
  container.style.height = (toolbarHeight + 400) + "px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this line graph
  container.lineGraphID = window.globalLineGraphCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-line-graph-id', container.lineGraphID);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "line-graph-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);
  // Create content div
  const content = document.createElement("div");
  content.className = "line-graph-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG for line graph
  const graphSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  graphSVG.setAttribute("width", "600");
  graphSVG.setAttribute("height", "400");
  graphSVG.style.width = "100%";
  graphSVG.style.height = "100%";
  content.appendChild(graphSVG);

  // Store the data needed for the line graph
  container.lineGraphData = {
    title: "Line Graph #title#",
    xAxisLabel: "Category",
    yAxisLabel: "Value",
    titleFontSize: 18,
    labelFontSize: 14,
    showValues: true,
    showLegend: true,
    useCategories: true,
    xMin: 0,
    xMax: 10,
    xInterval: 1,
    yMin: 0,
    yMax: 25,
    yInterval: 5,
    lines: [
      {
        id: 1,
        name: "Line 1",
        color: "#4688c7",
        style: "solid",
        dataPoints: [
          { x: "A", y: 12, label: "Category A" },
          { x: "B", y: 19, label: "Category B" },
          { x: "C", y: 3, label: "Category C" },
          { x: "D", y: 5, label: "Category D" }
        ]
      }
    ],
    selectedLineId: 1
  };

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Function to draw the line graph
  function drawLineGraph() {
    const svg = graphSVG;
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }

    // Get the container dimensions
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight - toolbarHeight; // Adjust for toolbar

    // Update SVG dimensions to match container
    svg.setAttribute("width", containerWidth);
    svg.setAttribute("height", containerHeight);

    const data = container.lineGraphData;
    const w = containerWidth;
    const h = containerHeight;
    const padding = { 
      top: Math.max(30, h * 0.12), 
      right: Math.max(30, w * 0.08), 
      bottom: Math.max(40, h * 0.15), 
      left: Math.max(40, w * 0.1) 
    };
    
    // Handle variable substitution for y-axis values
    const rawYMin = data.yMin;
    const rawYMax = data.yMax;
    const rawInterval = data.yInterval;

    const yMin = (typeof rawYMin === "string")
      ? (parseFloat(rawYMin) || 0)    // if "#a#" → NaN → fallback 0
      : rawYMin;

    const yMax = (typeof rawYMax === "string")
      ? (parseFloat(rawYMax) || 25)   // if "#a#" → NaN → fallback 25
      : rawYMax;

    const interval = (typeof rawInterval === "string")
      ? (parseFloat(rawInterval) || 5) // if "#a#" → NaN → fallback 5
      : rawInterval;

      // Handle variable substitution for x-axis values
const rawXMin      = data.xMin;
const rawXMax      = data.xMax;
const rawXInterval = data.xInterval;

const xMin = (typeof rawXMin === "string")
  ? (parseFloat(rawXMin) || 0)
  : rawXMin;
const xMax = (typeof rawXMax === "string")
  ? (parseFloat(rawXMax) || xMin + 1)   // fallback if parse fails
  : rawXMax;
const xInterval = (typeof rawXInterval === "string")
  ? (parseFloat(rawXInterval) || 1)
  : rawXInterval;


      const fs = data.labelFontSize;
    const titleFs = data.titleFontSize;

    const titleText = data.title;
    const xLabel = data.xAxisLabel;
    const yLabel = data.yAxisLabel;
    const showVals = data.showValues;
    const showLegend = data.showLegend;
    const useCategories = data.useCategories;

    const chartW = w - padding.left - padding.right;
    const chartH = h - padding.top - padding.bottom;

    // Helper function to get unique categories
    function getUniqueCategories() {
      const allCategories = [];
      data.lines.forEach(line => {
        line.dataPoints.forEach(point => {
          if (!allCategories.includes(point.x)) {
            allCategories.push(point.x);
          }
        });
      });
      return allCategories;
    }

    // Scaling functions
    function scaleX(x) {
      if (useCategories) {
        const categories = getUniqueCategories();
        const idx = categories.indexOf(x);
        const count = categories.length;
        if (count <= 1) return padding.left + (chartW / 2);
        return padding.left + ((idx + 0.5) / count) * chartW;
      }   else {
    // coerce point.x into a number, then scale
    const xv = (typeof x === "string")
      ? (parseFloat(x) || xMin)
      : x;
    return padding.left +
      ((xv - xMin)/(xMax - xMin || 1)) * chartW;
  }

    }

    function scaleY(y) {
      return h - padding.bottom - ((y - yMin) / (yMax - yMin || 1)) * chartH;
    }

    // Calculate ticks for y-axis
    const yTicks = [];
    for (let v = yMin; v <= yMax; v += interval) {
      yTicks.push(v);
      if (yTicks.length > 1000) break; // Safety limit
    }

    // Calculate ticks/categories for x-axis
    const xTicks = [];
if (useCategories) {
  xTicks.push(...getUniqueCategories());
} else {
  for (let v = xMin; v <= xMax; v += xInterval) {
    xTicks.push(v);
    if (xTicks.length > 1000) break;
  }
}
    // Draw grid lines for y-axis
    yTicks.forEach(t => {
      const yPos = scaleY(t);
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", padding.left);
      line.setAttribute("y1", yPos);
      line.setAttribute("x2", padding.left + chartW);
      line.setAttribute("y2", yPos);
      line.setAttribute("stroke", "#ddd");
      line.setAttribute("stroke-width", "1");
      line.setAttribute("stroke-dasharray", "3,3");
      svg.appendChild(line);
    });

    // Draw grid lines for x-axis
    xTicks.forEach(t => {
      const xPos = scaleX(t);
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", xPos);
      line.setAttribute("y1", padding.top);
      line.setAttribute("x2", xPos);
      line.setAttribute("y2", h - padding.bottom);
      line.setAttribute("stroke", "#ddd");
      line.setAttribute("stroke-width", "1");
      line.setAttribute("stroke-dasharray", "3,3");
      svg.appendChild(line);
    });

    // Axes
    const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    xAxis.setAttribute("x1", padding.left);
    xAxis.setAttribute("y1", h - padding.bottom);
    xAxis.setAttribute("x2", padding.left + chartW);
    xAxis.setAttribute("y2", h - padding.bottom);
    xAxis.setAttribute("stroke", "black");
    xAxis.setAttribute("stroke-width", "2");
    svg.appendChild(xAxis);

    const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    yAxis.setAttribute("x1", padding.left);
    yAxis.setAttribute("y1", padding.top);
    yAxis.setAttribute("x2", padding.left);
    yAxis.setAttribute("y2", h - padding.bottom);
    yAxis.setAttribute("stroke", "black");
    yAxis.setAttribute("stroke-width", "2");
    svg.appendChild(yAxis);

    // Y ticks & labels
    yTicks.forEach(t => {
      const yPos = scaleY(t);
      
      const tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
      tick.setAttribute("x1", padding.left - 5);
      tick.setAttribute("y1", yPos);
      tick.setAttribute("x2", padding.left);
      tick.setAttribute("y2", yPos);
      tick.setAttribute("stroke", "black");
      tick.setAttribute("stroke-width", "1");
      svg.appendChild(tick);
      
      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", padding.left - 10);
      label.setAttribute("y", yPos);
      label.setAttribute("text-anchor", "end");
      label.setAttribute("dominant-baseline", "middle");
      label.setAttribute("font-size", fs);
      label.textContent = t;
      svg.appendChild(label);
    });

    // X ticks & labels
    xTicks.forEach(t => {
      const xPos = scaleX(t);
      
      const tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
      tick.setAttribute("x1", xPos);
      tick.setAttribute("y1", h - padding.bottom);
      tick.setAttribute("x2", xPos);
      tick.setAttribute("y2", h - padding.bottom + 5);
      tick.setAttribute("stroke", "black");
      tick.setAttribute("stroke-width", "1");
      svg.appendChild(tick);
      
      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", xPos);
      label.setAttribute("y", h - padding.bottom + 20);
      label.setAttribute("text-anchor", "middle");
      label.setAttribute("font-size", fs);
      label.textContent = t;
      svg.appendChild(label);
    });

    // Draw lines & points
    data.lines.forEach(line => {
      // Filter valid points
      const validPoints = line.dataPoints.filter(point => {
        const y = typeof point.y === 'string' ? parseFloat(point.y) : point.y;
        return !isNaN(y) && y >= yMin && y <= yMax;
      });

      if (validPoints.length < 2) return; // Need at least 2 points to draw a line

      // Sort points by x-value if not using categories
      if (!useCategories) {
        validPoints.sort((a, b) => {
          const aX = typeof a.x === 'string' ? parseFloat(a.x) : a.x;
          const bX = typeof b.x === 'string' ? parseFloat(b.x) : b.x;
          return aX - bX;
        });
      } else {
        // Sort by category order
        const categories = getUniqueCategories();
        validPoints.sort((a, b) => categories.indexOf(a.x) - categories.indexOf(b.x));
      }

      // Create line path
      let pathData = '';
      validPoints.forEach((point, i) => {
        const x = scaleX(point.x);
        const y = scaleY(typeof point.y === 'string' ? parseFloat(point.y) : point.y);
        if (i === 0) {
          pathData += `M ${x},${y}`;
        } else {
          pathData += ` L ${x},${y}`;
        }
      });

      // Line shadow
      const shadowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      shadowPath.setAttribute("d", pathData);
      shadowPath.setAttribute("fill", "none");
      shadowPath.setAttribute("stroke", "rgba(0,0,0,0.1)");
      shadowPath.setAttribute("stroke-width", "4");
      shadowPath.setAttribute("transform", "translate(2,2)");
      svg.appendChild(shadowPath);

      // Actual line
      const linePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      linePath.setAttribute("d", pathData);
      linePath.setAttribute("fill", "none");
      linePath.setAttribute("stroke", line.color);
      linePath.setAttribute("stroke-width", "3");
      linePath.setAttribute("stroke-linejoin", "round");
      
      if (line.style === "dashed") {
        linePath.setAttribute("stroke-dasharray", "5,5");
      }
      
      svg.appendChild(linePath);

      // Draw points
      validPoints.forEach(point => {
        const x = scaleX(point.x);
        const y = scaleY(typeof point.y === 'string' ? parseFloat(point.y) : point.y);
        
        // Point shadow
        const shadowCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        shadowCircle.setAttribute("cx", x + 1);
        shadowCircle.setAttribute("cy", y + 1);
        shadowCircle.setAttribute("r", "5");
        shadowCircle.setAttribute("fill", "rgba(0,0,0,0.2)");
        svg.appendChild(shadowCircle);
        
        // Point circle
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", "5");
        circle.setAttribute("fill", line.color);
        circle.setAttribute("stroke", "#fff");
        circle.setAttribute("stroke-width", "1");
        svg.appendChild(circle);
        
        // Value label
        if (showVals) {
          const valueLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
          valueLabel.setAttribute("x", x);
          valueLabel.setAttribute("y", y - 12);
          valueLabel.setAttribute("text-anchor", "middle");
          valueLabel.setAttribute("font-size", fs);
          valueLabel.textContent = point.y;
          svg.appendChild(valueLabel);
        }
      });
    });

    // Title
    if (titleText) {
      const title = document.createElementNS("http://www.w3.org/2000/svg", "text");
      title.setAttribute("x", w / 2);
      title.setAttribute("y", padding.top / 2);
      title.setAttribute("text-anchor", "middle");
      title.setAttribute("dominant-baseline", "middle");
      title.setAttribute("font-size", titleFs);
      title.setAttribute("font-weight", "bold");
      title.textContent = titleText;
      svg.appendChild(title);
    }

    // Axis titles
    if (xLabel) {
      const xAxisTitle = document.createElementNS("http://www.w3.org/2000/svg", "text");
      xAxisTitle.setAttribute("x", padding.left + chartW / 2);
      xAxisTitle.setAttribute("y", h - 5);
      xAxisTitle.setAttribute("text-anchor", "middle");
      xAxisTitle.setAttribute("font-size", fs);
      xAxisTitle.textContent = xLabel;
      svg.appendChild(xAxisTitle);
    }

    if (yLabel) {
      const yAxisTitle = document.createElementNS("http://www.w3.org/2000/svg", "text");
      yAxisTitle.setAttribute("transform", `rotate(-90,${padding.left/3},${padding.top+chartH/2})`);
      yAxisTitle.setAttribute("x", padding.left / 3);
      yAxisTitle.setAttribute("y", padding.top + chartH / 2);
      yAxisTitle.setAttribute("text-anchor", "middle");
      yAxisTitle.setAttribute("font-size", fs);
      yAxisTitle.textContent = yLabel;
      svg.appendChild(yAxisTitle);
    }

    // Legend
    if (showLegend && data.lines.length > 0) {
      const legendX = w - padding.right - 100;
      const legendY = padding.top + 10;
      const lineHeight = 20;
      const legendWidth = 120;
      const legendHeight = data.lines.length * lineHeight + 10;
      
      // Legend background
      const legendBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      legendBg.setAttribute("x", legendX - 10);
      legendBg.setAttribute("y", legendY - 5);
      legendBg.setAttribute("width", legendWidth);
      legendBg.setAttribute("height", legendHeight);
      legendBg.setAttribute("fill", "white");
      legendBg.setAttribute("stroke", "#ddd");
      legendBg.setAttribute("stroke-width", "1");
      legendBg.setAttribute("rx", "3");
      svg.appendChild(legendBg);
      
      // Legend items
      data.lines.forEach((line, i) => {
        const itemY = legendY + i * lineHeight;
        
        // Line sample
        const lineSample = document.createElementNS("http://www.w3.org/2000/svg", "line");
        lineSample.setAttribute("x1", legendX);
        lineSample.setAttribute("y1", itemY + 10);
        lineSample.setAttribute("x2", legendX + 15);
        lineSample.setAttribute("y2", itemY + 10);
        lineSample.setAttribute("stroke", line.color);
        lineSample.setAttribute("stroke-width", "2");
        
        if (line.style === "dashed") {
          lineSample.setAttribute("stroke-dasharray", "3,3");
        }
        
        svg.appendChild(lineSample);
        
        // Point sample
        const pointSample = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        pointSample.setAttribute("cx", legendX + 7.5);
        pointSample.setAttribute("cy", itemY + 10);
        pointSample.setAttribute("r", "3");
        pointSample.setAttribute("fill", line.color);
        pointSample.setAttribute("stroke", "#fff");
        pointSample.setAttribute("stroke-width", "0.5");
        svg.appendChild(pointSample);
        
        // Line name
        const lineName = document.createElementNS("http://www.w3.org/2000/svg", "text");
        lineName.setAttribute("x", legendX + 20);
        lineName.setAttribute("y", itemY + 14);
        lineName.setAttribute("font-size", "12px");
        lineName.textContent = line.name;
        svg.appendChild(lineName);
      });
    }
  }
  
  // Update global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;

    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Line Graph " + container.lineGraphID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Graph Properties button
    const graphPropsBtn = document.createElement("button");
    graphPropsBtn.textContent = "Graph Properties";
    graphPropsBtn.style.marginRight = "10px";
    graphPropsBtn.style.padding = "5px 10px";
    graphPropsBtn.style.cursor = "pointer";
    graphPropsBtn.addEventListener("click", function() {
      showGraphPropertiesDialog();
    });
    controls.appendChild(graphPropsBtn);
    
    // X-Axis Settings button
    const xAxisSettingsBtn = document.createElement("button");
    xAxisSettingsBtn.textContent = "X-Axis Settings";
    xAxisSettingsBtn.style.marginRight = "10px";
    xAxisSettingsBtn.style.padding = "5px 10px";
    xAxisSettingsBtn.style.cursor = "pointer";
    xAxisSettingsBtn.addEventListener("click", function() {
      showXAxisSettingsDialog();
    });
    controls.appendChild(xAxisSettingsBtn);
    
    // Y-Axis Settings button
    const yAxisSettingsBtn = document.createElement("button");
    yAxisSettingsBtn.textContent = "Y-Axis Settings";
    yAxisSettingsBtn.style.marginRight = "10px";
    yAxisSettingsBtn.style.padding = "5px 10px";
    yAxisSettingsBtn.style.cursor = "pointer";
    yAxisSettingsBtn.addEventListener("click", function() {
      showYAxisSettingsDialog();
    });
    controls.appendChild(yAxisSettingsBtn);
    
    // Line Properties button
    const linePropsBtn = document.createElement("button");
    linePropsBtn.textContent = "Line Properties";
    linePropsBtn.style.marginRight = "10px";
    linePropsBtn.style.padding = "5px 10px";
    linePropsBtn.style.cursor = "pointer";
    linePropsBtn.addEventListener("click", function() {
      showLinePropertiesDialog();
    });
    controls.appendChild(linePropsBtn);
    
    // Edit Data button
    const editDataBtn = document.createElement("button");
    editDataBtn.textContent = "Edit Data";
    editDataBtn.style.marginRight = "10px";
    editDataBtn.style.padding = "5px 10px";
    editDataBtn.style.cursor = "pointer";
    editDataBtn.addEventListener("click", function() {
      showEditDataDialog();
    });
    controls.appendChild(editDataBtn);
    
    globalToolbar.appendChild(controls);
  }
  
  // Graph Properties Dialog
  function showGraphPropertiesDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Graph Properties";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Title input
    const titleLabel = document.createElement("label");
    titleLabel.style.display = "flex";
    titleLabel.style.justifyContent = "space-between";
    titleLabel.style.alignItems = "center";
    titleLabel.style.marginBottom = "10px";
    titleLabel.innerHTML = "Title:";
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.value = container.lineGraphData.title;
    titleInput.style.width = "300px";
    titleInput.style.marginLeft = "10px";
    titleLabel.appendChild(titleInput);
    dialogBox.appendChild(titleLabel);
    
    // Title Font Size input
    const titleFontLabel = document.createElement("label");
    titleFontLabel.style.display = "flex";
    titleFontLabel.style.justifyContent = "space-between";
    titleFontLabel.style.alignItems = "center";
    titleFontLabel.style.marginBottom = "10px";
    titleFontLabel.innerHTML = "Title Font Size:";
    const titleFontInput = document.createElement("input");
    titleFontInput.type = "number";
    titleFontInput.min = "12";
    titleFontInput.max = "36";
    titleFontInput.value = container.lineGraphData.titleFontSize;
    titleFontInput.style.width = "70px";
    titleFontInput.style.marginLeft = "10px";
    titleFontLabel.appendChild(titleFontInput);
    dialogBox.appendChild(titleFontLabel);
    
    // Label Font Size input
    const labelFontLabel = document.createElement("label");
    labelFontLabel.style.display = "flex";
    labelFontLabel.style.justifyContent = "space-between";
    labelFontLabel.style.alignItems = "center";
    labelFontLabel.style.marginBottom = "10px";
    labelFontLabel.innerHTML = "Label Font Size:";
    const labelFontInput = document.createElement("input");
    labelFontInput.type = "number";
    labelFontInput.min = "10";
    labelFontInput.max = "24";
    labelFontInput.value = container.lineGraphData.labelFontSize;
    labelFontInput.style.width = "70px";
    labelFontInput.style.marginLeft = "10px";
    labelFontLabel.appendChild(labelFontInput);
    dialogBox.appendChild(labelFontLabel);
    
    // Show Values checkbox
    const showValuesLabel = document.createElement("label");
    showValuesLabel.style.display = "flex";
    showValuesLabel.style.justifyContent = "space-between";
    showValuesLabel.style.alignItems = "center";
    showValuesLabel.style.marginBottom = "10px";
    showValuesLabel.innerHTML = "Show Values:";
    const showValuesCheckbox = document.createElement("input");
    showValuesCheckbox.type = "checkbox";
    showValuesCheckbox.checked = container.lineGraphData.showValues;
    showValuesCheckbox.style.marginLeft = "10px";
    showValuesLabel.appendChild(showValuesCheckbox);
    dialogBox.appendChild(showValuesLabel);
    
    // Show Legend checkbox
    const showLegendLabel = document.createElement("label");
    showLegendLabel.style.display = "flex";
    showLegendLabel.style.justifyContent = "space-between";
    showLegendLabel.style.alignItems = "center";
    showLegendLabel.style.marginBottom = "15px";
    showLegendLabel.innerHTML = "Show Legend:";
    const showLegendCheckbox = document.createElement("input");
    showLegendCheckbox.type = "checkbox";
    showLegendCheckbox.checked = container.lineGraphData.showLegend;
    showLegendCheckbox.style.marginLeft = "10px";
    showLegendLabel.appendChild(showLegendCheckbox);
    dialogBox.appendChild(showLegendLabel);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the line graph data
      container.lineGraphData.title = titleInput.value;
      container.lineGraphData.titleFontSize = parseInt(titleFontInput.value);
      container.lineGraphData.labelFontSize = parseInt(labelFontInput.value);
      container.lineGraphData.showValues = showValuesCheckbox.checked;
      container.lineGraphData.showLegend = showLegendCheckbox.checked;
      
      // Redraw the line graph
      drawLineGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // X-Axis Settings Dialog
  function showXAxisSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "X-Axis Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // X-Axis Label input
    const xAxisLabel = document.createElement("label");
    xAxisLabel.style.display = "flex";
    xAxisLabel.style.justifyContent = "space-between";
    xAxisLabel.style.alignItems = "center";
    xAxisLabel.style.marginBottom = "10px";
    xAxisLabel.innerHTML = "X-Axis Label:";
    const xAxisInput = document.createElement("input");
    xAxisInput.type = "text";
    xAxisInput.value = container.lineGraphData.xAxisLabel;
    xAxisInput.style.width = "300px";
    xAxisInput.style.marginLeft = "10px";
    xAxisLabel.appendChild(xAxisInput);
    dialogBox.appendChild(xAxisLabel);
    
    // Use Categories checkbox
    const useCategoriesLabel = document.createElement("label");
    useCategoriesLabel.style.display = "flex";
    useCategoriesLabel.style.justifyContent = "space-between";
    useCategoriesLabel.style.alignItems = "center";
    useCategoriesLabel.style.marginBottom = "15px";
    useCategoriesLabel.innerHTML = "Use Categories:";
    const useCategoriesCheckbox = document.createElement("input");
    useCategoriesCheckbox.type = "checkbox";
    useCategoriesCheckbox.checked = container.lineGraphData.useCategories;
    useCategoriesCheckbox.style.marginLeft = "10px";
    
    // Event listener to show/hide numeric settings based on categories
    useCategoriesCheckbox.addEventListener("change", function() {
      const isChecked = useCategoriesCheckbox.checked;
      numericSettingsDiv.style.display = isChecked ? "none" : "block";
    });
    
    useCategoriesLabel.appendChild(useCategoriesCheckbox);
    dialogBox.appendChild(useCategoriesLabel);
    
    // Numeric X-Axis settings (shown only when not using categories)
    const numericSettingsDiv = document.createElement("div");
    numericSettingsDiv.style.display = container.lineGraphData.useCategories ? "none" : "block";
    numericSettingsDiv.style.marginBottom = "15px";
    
    // Min Value input
    const minLabel = document.createElement("label");
    minLabel.style.display = "flex";
    minLabel.style.justifyContent = "space-between";
    minLabel.style.alignItems = "center";
    minLabel.style.marginBottom = "10px";
    minLabel.innerHTML = "Min Value:";
    const minInput = document.createElement("input");
    minInput.type = "text"; // Using text to allow variables
    minInput.value = container.lineGraphData.xMin;
    minInput.style.width = "100px";
    minInput.style.marginLeft = "10px";
    minLabel.appendChild(minInput);
    numericSettingsDiv.appendChild(minLabel);
    
    // Max Value input
    const maxLabel = document.createElement("label");
    maxLabel.style.display = "flex";
    maxLabel.style.justifyContent = "space-between";
    maxLabel.style.alignItems = "center";
    maxLabel.style.marginBottom = "10px";
    maxLabel.innerHTML = "Max Value:";
    const maxInput = document.createElement("input");
    maxInput.type = "text"; // Using text to allow variables
    maxInput.value = container.lineGraphData.xMax;
    maxInput.style.width = "100px";
    maxInput.style.marginLeft = "10px";
    maxLabel.appendChild(maxInput);
    numericSettingsDiv.appendChild(maxLabel);
    
    // Interval input
    const intervalLabel = document.createElement("label");
    intervalLabel.style.display = "flex";
    intervalLabel.style.justifyContent = "space-between";
    intervalLabel.style.alignItems = "center";
    intervalLabel.style.marginBottom = "10px";
    intervalLabel.innerHTML = "Interval:";
    const intervalInput = document.createElement("input");
    intervalInput.type = "text"; // Using text to allow variables
    intervalInput.value = container.lineGraphData.xInterval;
    intervalInput.style.width = "100px";
    intervalInput.style.marginLeft = "10px";
    intervalLabel.appendChild(intervalInput);
    numericSettingsDiv.appendChild(intervalLabel);
    
    dialogBox.appendChild(numericSettingsDiv);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the line graph data
      container.lineGraphData.xAxisLabel = xAxisInput.value;
      container.lineGraphData.useCategories = useCategoriesCheckbox.checked;
      
      if (!useCategoriesCheckbox.checked) {
        container.lineGraphData.xMin = minInput.value;
        container.lineGraphData.xMax = maxInput.value;
        container.lineGraphData.xInterval = intervalInput.value;
        
        // Convert category data points to numeric if switching
        if (container.lineGraphData.useCategories) {
          container.lineGraphData.lines.forEach(line => {
            line.dataPoints.forEach((point, i) => {
              if (typeof point.x !== 'number') {
                point.x = i + 1;
              }
            });
          });
        }
      } else {
        // Convert numeric data points to categories if switching
        if (!container.lineGraphData.useCategories) {
          container.lineGraphData.lines.forEach(line => {
            line.dataPoints.forEach((point, i) => {
              if (typeof point.x === 'number') {
                point.x = point.label || `Category ${i+1}`;
              }
            });
          });
        }
      }
      
      // Redraw the line graph
      drawLineGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }
  
  // Y-Axis Settings Dialog
  function showYAxisSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Y-Axis Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Y-Axis Label input
    const yAxisLabel = document.createElement("label");
    yAxisLabel.style.display = "flex";
    yAxisLabel.style.justifyContent = "space-between";
    yAxisLabel.style.alignItems = "center";
    yAxisLabel.style.marginBottom = "10px";
    yAxisLabel.innerHTML = "Y-Axis Label:";
    const yAxisInput = document.createElement("input");
    yAxisInput.type = "text";
    yAxisInput.value = container.lineGraphData.yAxisLabel;
    yAxisInput.style.width = "300px";
    yAxisInput.style.marginLeft = "10px";
    yAxisLabel.appendChild(yAxisInput);
    dialogBox.appendChild(yAxisLabel);
    
    // Min Value input
    const minLabel = document.createElement("label");
    minLabel.style.display = "flex";
    minLabel.style.justifyContent = "space-between";
    minLabel.style.alignItems = "center";
    minLabel.style.marginBottom = "10px";
    minLabel.innerHTML = "Min Value:";
    const minInput = document.createElement("input");
    minInput.type = "text"; // Text type to allow variables
    minInput.value = container.lineGraphData.yMin;
    minInput.style.width = "100px";
    minInput.style.marginLeft = "10px";
    minLabel.appendChild(minInput);
    dialogBox.appendChild(minLabel);
    
    // Max Value input
    const maxLabel = document.createElement("label");
    maxLabel.style.display = "flex";
    maxLabel.style.justifyContent = "space-between";
    maxLabel.style.alignItems = "center";
    maxLabel.style.marginBottom = "10px";
    maxLabel.innerHTML = "Max Value:";
    const maxInput = document.createElement("input");
    maxInput.type = "text"; // Text type to allow variables
    maxInput.value = container.lineGraphData.yMax;
    maxInput.style.width = "100px";
    maxInput.style.marginLeft = "10px";
    maxLabel.appendChild(maxInput);
    dialogBox.appendChild(maxLabel);
    
    // Interval input
    const intervalLabel = document.createElement("label");
    intervalLabel.style.display = "flex";
    intervalLabel.style.justifyContent = "space-between";
    intervalLabel.style.alignItems = "center";
    intervalLabel.style.marginBottom = "15px";
    intervalLabel.innerHTML = "Interval:";
    const intervalInput = document.createElement("input");
    intervalInput.type = "text"; // Text type to allow variables
    intervalInput.value = container.lineGraphData.yInterval;
    intervalInput.style.width = "100px";
    intervalInput.style.marginLeft = "10px";
    intervalLabel.appendChild(intervalInput);
    dialogBox.appendChild(intervalLabel);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the line graph data
      container.lineGraphData.yAxisLabel = yAxisInput.value;
      container.lineGraphData.yMin = minInput.value;
      container.lineGraphData.yMax = maxInput.value;
      container.lineGraphData.yInterval = intervalInput.value;
      
      // Redraw the line graph
      drawLineGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Line Properties Dialog
  function showLinePropertiesDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Line Properties";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Line selector
    const lineSelectorLabel = document.createElement("label");
    lineSelectorLabel.style.display = "flex";
    lineSelectorLabel.style.justifyContent = "space-between";
    lineSelectorLabel.style.alignItems = "center";
    lineSelectorLabel.style.marginBottom = "15px";
    lineSelectorLabel.innerHTML = "Select Line:";
    
    const lineSelector = document.createElement("select");
    container.lineGraphData.lines.forEach(line => {
      const option = document.createElement("option");
      option.value = line.id;
      option.textContent = line.name;
      if (line.id === container.lineGraphData.selectedLineId) {
        option.selected = true;
      }
      lineSelector.appendChild(option);
    });
    
    lineSelector.style.width = "200px";
    lineSelector.style.marginLeft = "10px";
    lineSelector.addEventListener("change", function() {
      const selectedId = parseInt(lineSelector.value);
      container.lineGraphData.selectedLineId = selectedId;
      updateLinePropertiesForm(selectedId);
    });
    
    lineSelectorLabel.appendChild(lineSelector);
    dialogBox.appendChild(lineSelectorLabel);
    
    // Line properties form
    const linePropertiesForm = document.createElement("div");
    linePropertiesForm.id = "line-properties-form";
    dialogBox.appendChild(linePropertiesForm);
    
    // Add/Remove Line buttons
    const lineButtonsContainer = document.createElement("div");
    lineButtonsContainer.style.display = "flex";
    lineButtonsContainer.style.justifyContent = "space-between";
    lineButtonsContainer.style.marginBottom = "15px";
    
    const addLineButton = document.createElement("button");
    addLineButton.textContent = "Add New Line";
    addLineButton.style.padding = "5px 10px";
    addLineButton.style.cursor = "pointer";
    addLineButton.style.backgroundColor = "#4688c7";
    addLineButton.style.color = "white";
    addLineButton.style.border = "none";
    addLineButton.style.borderRadius = "3px";
    addLineButton.addEventListener("click", function() {
      // Create a new line with a unique ID
      const newId = Math.max(...container.lineGraphData.lines.map(l => l.id), 0) + 1;
      const colors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b"];
      const colorIndex = (newId - 1) % colors.length;
      
      // Get data points structure based on existing lines
      let dataPoints = [];
      if (container.lineGraphData.lines.length > 0) {
        const firstLine = container.lineGraphData.lines[0];
        
        if (container.lineGraphData.useCategories) {
          // For categories, use existing categories with random values
          dataPoints = firstLine.dataPoints.map(point => ({
            x: point.x,
            y: Math.floor(Math.random() * (container.lineGraphData.yMax - container.lineGraphData.yMin)) + container.lineGraphData.yMin,
            label: point.label
          }));
        } else {
          // For numeric x-values, copy x-values with random y-values
          dataPoints = firstLine.dataPoints.map(point => ({
            x: point.x,
            y: Math.floor(Math.random() * (container.lineGraphData.yMax - container.lineGraphData.yMin)) + container.lineGraphData.yMin,
            label: point.label
          }));
        }
      } else {
        // Default data points if no existing lines
        dataPoints = [
          { x: container.lineGraphData.useCategories ? "A" : 1, y: 5, label: "Point 1" },
          { x: container.lineGraphData.useCategories ? "B" : 2, y: 10, label: "Point 2" },
          { x: container.lineGraphData.useCategories ? "C" : 3, y: 15, label: "Point 3" },
          { x: container.lineGraphData.useCategories ? "D" : 4, y: 7, label: "Point 4" }
        ];
      }
      
      const newLine = {
        id: newId,
        name: `Line ${newId}`,
        color: colors[colorIndex],
        style: "solid",
        dataPoints: dataPoints
      };
      
      container.lineGraphData.lines.push(newLine);
      container.lineGraphData.selectedLineId = newId;
      
      // Refresh the line selector and properties form
      const option = document.createElement("option");
      option.value = newId;
      option.textContent = newLine.name;
      option.selected = true;
      lineSelector.appendChild(option);
      
      updateLinePropertiesForm(newId);
      toggleRemoveButton();
    });
    lineButtonsContainer.appendChild(addLineButton);
    
    const removeLineButton = document.createElement("button");
    removeLineButton.textContent = "Remove Selected Line";
    removeLineButton.style.padding = "5px 10px";
    removeLineButton.style.cursor = "pointer";
    removeLineButton.style.backgroundColor = "#e74c3c";
    removeLineButton.style.color = "white";
    removeLineButton.style.border = "none";
    removeLineButton.style.borderRadius = "3px";
    removeLineButton.addEventListener("click", function() {
      if (container.lineGraphData.lines.length <= 1) {
        alert("Cannot remove the last line. At least one line is required.");
        return;
      }
      
      const selectedId = parseInt(lineSelector.value);
      
      // Remove the line from data
      // Remove the line from data
      container.lineGraphData.lines = container.lineGraphData.lines.filter(line => line.id !== selectedId);
      
      // Select the first line after removal
      container.lineGraphData.selectedLineId = container.lineGraphData.lines[0].id;
      
      // Update the line selector
      // Remove the option from the dropdown
      for (let i = 0; i < lineSelector.options.length; i++) {
        if (parseInt(lineSelector.options[i].value) === selectedId) {
          lineSelector.remove(i);
          break;
        }
      }
      
      // Select the first option
      lineSelector.value = container.lineGraphData.selectedLineId;
      
      // Update the properties form
      updateLinePropertiesForm(container.lineGraphData.selectedLineId);
      toggleRemoveButton();
    });
    lineButtonsContainer.appendChild(removeLineButton);
    
    dialogBox.appendChild(lineButtonsContainer);
    
    // Function to toggle remove button based on line count
    function toggleRemoveButton() {
      removeLineButton.disabled = container.lineGraphData.lines.length <= 1;
      removeLineButton.style.opacity = container.lineGraphData.lines.length <= 1 ? "0.5" : "1";
    }
    
    // Function to update line properties form based on selected line
    function updateLinePropertiesForm(lineId) {
  // look _inside_ our dialogBox, not the whole document
  const formDiv = dialogBox.querySelector("#line-properties-form");
  formDiv.innerHTML = "";
      
      const selectedLine = container.lineGraphData.lines.find(line => line.id === lineId);
      if (!selectedLine) return;
      
      // Line Name input
      const nameLabel = document.createElement("label");
      nameLabel.style.display = "flex";
      nameLabel.style.justifyContent = "space-between";
      nameLabel.style.alignItems = "center";
      nameLabel.style.marginBottom = "10px";
      nameLabel.innerHTML = "Line Name:";
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = selectedLine.name;
      nameInput.style.width = "300px";
      nameInput.style.marginLeft = "10px";
      nameLabel.appendChild(nameInput);
      formDiv.appendChild(nameLabel);
      
      // Line Color input
      const colorLabel = document.createElement("label");
      colorLabel.style.display = "flex";
      colorLabel.style.justifyContent = "space-between";
      colorLabel.style.alignItems = "center";
      colorLabel.style.marginBottom = "10px";
      colorLabel.innerHTML = "Line Color:";
      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.value = selectedLine.color;
      colorInput.style.width = "100px";
      colorInput.style.marginLeft = "10px";
      colorLabel.appendChild(colorInput);
      formDiv.appendChild(colorLabel);
      
      // Line Style select
      const styleLabel = document.createElement("label");
      styleLabel.style.display = "flex";
      styleLabel.style.justifyContent = "space-between";
      styleLabel.style.alignItems = "center";
      styleLabel.style.marginBottom = "15px";
      styleLabel.innerHTML = "Line Style:";
      const styleSelect = document.createElement("select");
      styleSelect.style.width = "100px";
      styleSelect.style.marginLeft = "10px";
      
      const solidOption = document.createElement("option");
      solidOption.value = "solid";
      solidOption.textContent = "Solid";
      if (selectedLine.style === "solid") solidOption.selected = true;
      styleSelect.appendChild(solidOption);
      
      const dashedOption = document.createElement("option");
      dashedOption.value = "dashed";
      dashedOption.textContent = "Dashed";
      if (selectedLine.style === "dashed") dashedOption.selected = true;
      styleSelect.appendChild(dashedOption);
      
      styleLabel.appendChild(styleSelect);
      formDiv.appendChild(styleLabel);
    }
    
    // Initialize line properties form
    updateLinePropertiesForm(container.lineGraphData.selectedLineId);
    
    // Initialize remove button state
    toggleRemoveButton();
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update line properties
      const selectedId = parseInt(lineSelector.value);
      const selectedLine = container.lineGraphData.lines.find(line => line.id === selectedId);
      if (selectedLine) {
        const nameInput = document.querySelector("#line-properties-form label:nth-child(1) input");
        const colorInput = document.querySelector("#line-properties-form label:nth-child(2) input");
        const styleSelect = document.querySelector("#line-properties-form label:nth-child(3) select");
        
        selectedLine.name = nameInput.value;
        selectedLine.color = colorInput.value;
        selectedLine.style = styleSelect.value;
      }
      
      // Redraw the line graph
      drawLineGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }
  
  // Edit Data Dialog
  function showEditDataDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "600px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Edit Line Data";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Line selector 
    const lineSelectorDiv = document.createElement("div");
    lineSelectorDiv.style.marginBottom = "20px";
    
    const lineSelectorLabel = document.createElement("label");
    lineSelectorLabel.style.display = "inline-block";
    lineSelectorLabel.style.marginRight = "10px";
    lineSelectorLabel.style.fontWeight = "bold";
    lineSelectorLabel.textContent = "Select Line:";
    lineSelectorDiv.appendChild(lineSelectorLabel);
    
    const lineSelector = document.createElement("select");
    lineSelector.style.width = "200px";
    lineSelector.style.padding = "5px";
    
    container.lineGraphData.lines.forEach(line => {
      const option = document.createElement("option");
      option.value = line.id;
      option.textContent = line.name;
      if (line.id === container.lineGraphData.selectedLineId) {
        option.selected = true;
      }
      lineSelector.appendChild(option);
    });
    
    lineSelector.addEventListener("change", function() {
      container.lineGraphData.selectedLineId = parseInt(lineSelector.value);
      updateDataPointsTable();
    });
    
    lineSelectorDiv.appendChild(lineSelector);
    dialogBox.appendChild(lineSelectorDiv);
    
    // Data points table
    const tableDiv = document.createElement("div");
    tableDiv.id = "data-points-table-container";
    dialogBox.appendChild(tableDiv);
    
    // Update function for data points table
    function updateDataPointsTable() {
        const tableContainer = dialogBox.querySelector("#data-points-table-container");
      tableContainer.innerHTML = "";
      
      const selectedLine = container.lineGraphData.lines.find(line => line.id === container.lineGraphData.selectedLineId);
      if (!selectedLine) return;
      
      // Create table
      const table = document.createElement("table");
      table.style.width = "100%";
      table.style.borderCollapse = "collapse";
      table.style.marginBottom = "15px";
      
      // Table header
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      headerRow.style.backgroundColor = "#f0f0f0";
      
      const xHeader = document.createElement("th");
      xHeader.textContent = container.lineGraphData.useCategories ? "Category" : "X Value";
      xHeader.style.padding = "8px";
      xHeader.style.textAlign = "left";
      xHeader.style.borderBottom = "1px solid #ddd";
      headerRow.appendChild(xHeader);
      
      const yHeader = document.createElement("th");
      yHeader.textContent = "Y Value";
      yHeader.style.padding = "8px";
      yHeader.style.textAlign = "left";
      yHeader.style.borderBottom = "1px solid #ddd";
      headerRow.appendChild(yHeader);
      
      const labelHeader = document.createElement("th");
      labelHeader.textContent = "Label";
      labelHeader.style.padding = "8px";
      labelHeader.style.textAlign = "left";
      labelHeader.style.borderBottom = "1px solid #ddd";
      headerRow.appendChild(labelHeader);
      
      const actionsHeader = document.createElement("th");
      actionsHeader.textContent = "Actions";
      actionsHeader.style.padding = "8px";
      actionsHeader.style.textAlign = "left";
      actionsHeader.style.borderBottom = "1px solid #ddd";
      headerRow.appendChild(actionsHeader);
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Table body
      const tbody = document.createElement("tbody");
      
      selectedLine.dataPoints.forEach((point, index) => {
        const row = document.createElement("tr");
        row.style.backgroundColor = index % 2 === 0 ? "#f9f9f9" : "white";
        
        // X value/category cell
        const xCell = document.createElement("td");
        xCell.style.padding = "8px";
        xCell.style.borderBottom = "1px solid #ddd";
        
        const xInput = document.createElement("input");
        xInput.type = container.lineGraphData.useCategories ? "text" : "text"; // Text for both to allow variables
        xInput.value = point.x;
        xInput.style.width = "100%";
        xInput.style.padding = "5px";
        xInput.style.boxSizing = "border-box";
        xInput.dataset.index = index;
        xInput.dataset.field = "x";
        xCell.appendChild(xInput);
        row.appendChild(xCell);
        
        // Y value cell
        const yCell = document.createElement("td");
        yCell.style.padding = "8px";
        yCell.style.borderBottom = "1px solid #ddd";
        
        const yInput = document.createElement("input");
        yInput.type = "text"; // Text type to allow variables
        yInput.value = point.y;
        yInput.style.width = "100%";
        yInput.style.padding = "5px";
        yInput.style.boxSizing = "border-box";
        yInput.dataset.index = index;
        yInput.dataset.field = "y";
        yCell.appendChild(yInput);
        row.appendChild(yCell);
        
        // Label cell
        const labelCell = document.createElement("td");
        labelCell.style.padding = "8px";
        labelCell.style.borderBottom = "1px solid #ddd";
        
        const labelInput = document.createElement("input");
        labelInput.type = "text";
        labelInput.value = point.label || "";
        labelInput.style.width = "100%";
        labelInput.style.padding = "5px";
        labelInput.style.boxSizing = "border-box";
        labelInput.dataset.index = index;
        labelInput.dataset.field = "label";
        labelCell.appendChild(labelInput);
        row.appendChild(labelCell);
        
        // Actions cell
        const actionsCell = document.createElement("td");
        actionsCell.style.padding = "8px";
        actionsCell.style.borderBottom = "1px solid #ddd";
        
        const deleteButton = document.createElement("button");
        deleteButton.textContent = "Remove";
        deleteButton.style.padding = "3px 8px";
        deleteButton.style.backgroundColor = "#e74c3c";
        deleteButton.style.color = "white";
        deleteButton.style.border = "none";
        deleteButton.style.borderRadius = "3px";
        deleteButton.style.cursor = "pointer";
        deleteButton.dataset.index = index;
        actionsCell.appendChild(deleteButton);
        row.appendChild(actionsCell);
        
        tbody.appendChild(row);
      });
      
      table.appendChild(tbody);
      tableContainer.appendChild(table);
      
      // Add data point button
      const addPointButton = document.createElement("button");
      addPointButton.textContent = "Add Data Point";
      addPointButton.style.padding = "5px 15px";
      addPointButton.style.backgroundColor = "#4688c7";
      addPointButton.style.color = "white";
      addPointButton.style.border = "none";
      addPointButton.style.borderRadius = "3px";
      addPointButton.style.cursor = "pointer";
      addPointButton.style.marginRight = "10px";
      
      addPointButton.addEventListener("click", function() {
        const selectedLine = container.lineGraphData.lines.find(line => line.id === container.lineGraphData.selectedLineId);
        if (!selectedLine) return;
        
        // Create a new data point
        let newX;
        if (container.lineGraphData.useCategories) {
          newX = `Category ${selectedLine.dataPoints.length + 1}`;
        } else {
          // Find max X and add 1 (or use 1 if no points)
          const maxX = selectedLine.dataPoints.length > 0 
            ? Math.max(...selectedLine.dataPoints.map(p => typeof p.x === 'number' ? p.x : 0)) 
            : 0;
          newX = maxX + 1;
        }
        
        selectedLine.dataPoints.push({
          x: newX,
          y: 0,
          label: `Point ${selectedLine.dataPoints.length + 1}`
        });
        
        // Update the table
        updateDataPointsTable();
      });
      
      tableContainer.appendChild(addPointButton);
      
      // Event listeners for delete buttons
      const deleteButtons = table.querySelectorAll("button");
      deleteButtons.forEach(button => {
        if (button.textContent === "Remove") {
          button.addEventListener("click", function() {
            const selectedLine = container.lineGraphData.lines.find(line => line.id === container.lineGraphData.selectedLineId);
            if (!selectedLine) return;
            
            const index = parseInt(button.dataset.index);
            
            // Don't allow deleting if only 2 points remain
            if (selectedLine.dataPoints.length <= 2) {
              alert("Cannot remove data point. At least 2 points are required for a line.");
              return;
            }
            
            // Remove the data point
            selectedLine.dataPoints.splice(index, 1);
            
            // Update the table
            updateDataPointsTable();
          });
        }
      });
      
      // Event listeners for input fields
      const inputFields = table.querySelectorAll("input");
      inputFields.forEach(input => {
        input.addEventListener("change", function() {
          const selectedLine = container.lineGraphData.lines.find(line => line.id === container.lineGraphData.selectedLineId);
          if (!selectedLine) return;
          
          const index = parseInt(input.dataset.index);
          const field = input.dataset.field;
          
          // Update the data point
          selectedLine.dataPoints[index][field] = input.value;
        });
      });
    }
    
    // Initialize data points table
    updateDataPointsTable();
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // All changes are already applied to the data through event listeners
      
      // Redraw the line graph
      drawLineGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Key functions for activation
  function activateLineGraph() {
    // Deactivate the previously active element if any
    if (window.activeLineGraphElement && window.activeLineGraphElement !== container) {
      window.activeLineGraphElement.style.border = "none";
      
      const prevToolbar = window.activeLineGraphElement.querySelector(".line-graph-toolbar");
      const prevResizeHandle = window.activeLineGraphElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeLineGraphElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivateLineGraph() {
    if (window.activeLineGraphElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeLineGraphElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteLineGraph() {
    if (window.activeLineGraphElement === container) {
      window.activeLineGraphElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateLineGraph();
    }
  });

  // Deletion: add both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteLineGraph();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteLineGraph();
  });

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    const aspectRatio = startWidth / startHeight;
    
    function onMouseMove(e) {
      // Calculate new width based on mouse position
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      // Maintain aspect ratio for height
      const newHeight = newWidth / aspectRatio;
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      
      // Update SVG dimensions and ensure content scales properly
      graphSVG.setAttribute("width", newWidth);
      graphSVG.setAttribute("height", newHeight - toolbarHeight);
      graphSVG.style.width = "100%";
      graphSVG.style.height = "100%";
      
      // Redraw the graph with the new dimensions
      drawLineGraph();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activeLineGraphElement === container) {
      deactivateLineGraph();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Store the draw function on the container so it can be called externally
  container.drawLineGraph = drawLineGraph;
  
  // Draw the initial line graph
  drawLineGraph();
  
  // Activate the line graph
  activateLineGraph();
}



// Add Bar Graph component to the canvas
function addBarGraph() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeBarGraphElement) {
    window.activeBarGraphElement = null;
  }
  // Global counter for bar graph IDs
  if (!window.globalBarGraphCounter) {
    window.globalBarGraphCounter = 1;
  } else {
    window.globalBarGraphCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element bar-graph-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "600px";
  container.style.height = (toolbarHeight + 400) + "px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this bar graph
  container.barGraphID = window.globalBarGraphCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-bar-graph-id', container.barGraphID);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "bar-graph-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "bar-graph-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG for bar graph
  const graphSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  graphSVG.setAttribute("width", "600");
  graphSVG.setAttribute("height", "400");
  graphSVG.style.width = "100%";
  graphSVG.style.height = "100%";
  content.appendChild(graphSVG);

  // Store the data needed for the bar graph
  container.barGraphData = {
    title: "Bar Graph #title#",
    xAxisLabel: "Category",
    yAxisLabel: "Value",
    titleFontSize: 18,
    labelFontSize: 14,
    barWidthPercent: 50,
    showValues: true,
    yMin: 0,
    yMax: 25,
    yInterval: 5,
    bars: [
      { name: "A ", value: 12, color: "#4688c7" },
      { name: "B ", value: 19, color: "#e74c3c" },
      { name: "C", value: 3, color: "#2ecc71" },
      { name: "D", value: 5, color: "#f39c12" }
    ]
  };

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Function to draw the bar graph
  function drawBarGraph() {
    const svg = graphSVG;
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }

    // Get the container dimensions
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight - toolbarHeight; // Adjust for toolbar

    // Update SVG dimensions to match container
    svg.setAttribute("width", containerWidth);
    svg.setAttribute("height", containerHeight);

    const data = container.barGraphData;
    const w = containerWidth;
    const h = containerHeight;
    const padding = { 
      top: Math.max(30, h * 0.12), 
      right: Math.max(20, w * 0.05), 
      bottom: Math.max(40, h * 0.15), 
      left: Math.max(40, w * 0.1) 
    };
    const rawYMin     = data.yMin;
const rawYMax     = data.yMax;
const rawInterval = data.yInterval;

const yMin = (typeof rawYMin === "string")
  ? (parseFloat(rawYMin) || 0)    // if "#a#" → NaN → fallback 0
  : rawYMin;

const yMax = (typeof rawYMax === "string")
  ? (parseFloat(rawYMax) || 25)   // if "#a#" → NaN → fallback 25
  : rawYMax;

const interval = (typeof rawInterval === "string")
  ? (parseFloat(rawInterval) || 5) // if "#a#" → NaN → fallback 5
  : rawInterval;

    const fs = data.labelFontSize;
    const titleFs = data.titleFontSize;
    const bwPct = data.barWidthPercent / 100;

    const titleText = data.title;
    const xLabel = data.xAxisLabel;
    const yLabel = data.yAxisLabel;
    const showVals = data.showValues;

    const chartW = w - padding.left - padding.right;
    const chartH = h - padding.top - padding.bottom;

    // Calculate ticks
    const ticks = [];
    for (let v = yMin; v <= yMax; v += interval) {
      ticks.push(v);
      if (ticks.length > 1000) break;
    }

    // Grid lines
    ticks.forEach(t => {
      const yPos = h - padding.bottom - ((t - yMin)/(yMax-yMin))*chartH;
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", padding.left);
      line.setAttribute("y1", yPos);
      line.setAttribute("x2", padding.left + chartW);
      line.setAttribute("y2", yPos);
      line.setAttribute("stroke", "#ddd");
      line.setAttribute("stroke-width", "1");
      line.setAttribute("stroke-dasharray", "3,3");
      svg.appendChild(line);
    });

    // Axes
    const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    xAxis.setAttribute("x1", padding.left);
    xAxis.setAttribute("y1", h - padding.bottom);
    xAxis.setAttribute("x2", padding.left + chartW);
    xAxis.setAttribute("y2", h - padding.bottom);
    xAxis.setAttribute("stroke", "black");
    xAxis.setAttribute("stroke-width", "2");
    svg.appendChild(xAxis);

    const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    yAxis.setAttribute("x1", padding.left);
    yAxis.setAttribute("y1", padding.top);
    yAxis.setAttribute("x2", padding.left);
    yAxis.setAttribute("y2", h - padding.bottom);
    yAxis.setAttribute("stroke", "black");
    yAxis.setAttribute("stroke-width", "2");
    svg.appendChild(yAxis);

    // Y ticks & labels
    ticks.forEach(t => {
      const yPos = h - padding.bottom - ((t - yMin)/(yMax-yMin))*chartH;
      
      const tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
      tick.setAttribute("x1", padding.left - 5);
      tick.setAttribute("y1", yPos);
      tick.setAttribute("x2", padding.left);
      tick.setAttribute("y2", yPos);
      tick.setAttribute("stroke", "black");
      tick.setAttribute("stroke-width", "1");
      svg.appendChild(tick);
      
      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", padding.left - 10);
      label.setAttribute("y", yPos);
      label.setAttribute("text-anchor", "end");
      label.setAttribute("dominant-baseline", "middle");
      label.setAttribute("font-size", fs);
      label.textContent = t;
      svg.appendChild(label);
    });

    // Bars & x labels
    const barW = (chartW / data.bars.length) * bwPct;
    data.bars.forEach((bar, i) => {
      const xSlot = padding.left + (i + 0.5) * (chartW / data.bars.length);
      const barH = ((bar.value - yMin) / (yMax - yMin)) * chartH;
      const yPos = h - padding.bottom - barH;

      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("x", xSlot - barW / 2);
      rect.setAttribute("y", yPos);
      rect.setAttribute("width", barW);
      rect.setAttribute("height", barH);
      rect.setAttribute("fill", bar.color);
      svg.appendChild(rect);

      if (showVals) {
        const valueLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
        valueLabel.setAttribute("x", xSlot);
        valueLabel.setAttribute("y", yPos - 8);
        valueLabel.setAttribute("text-anchor", "middle");
        valueLabel.setAttribute("font-size", fs);
        valueLabel.textContent = bar.value;
        svg.appendChild(valueLabel);
      }

      const categoryLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
      categoryLabel.setAttribute("x", xSlot);
      categoryLabel.setAttribute("y", h - padding.bottom + 20);
      categoryLabel.setAttribute("text-anchor", "middle");
      categoryLabel.setAttribute("font-size", fs);
      categoryLabel.textContent = bar.name;
      svg.appendChild(categoryLabel);
    });

    // Title
    if (titleText) {
      const title = document.createElementNS("http://www.w3.org/2000/svg", "text");
      title.setAttribute("x", w / 2);
      title.setAttribute("y", padding.top / 2);
      title.setAttribute("text-anchor", "middle");
      title.setAttribute("dominant-baseline", "middle");
      title.setAttribute("font-size", titleFs);
      title.setAttribute("font-weight", "bold");
      title.textContent = titleText;
      svg.appendChild(title);
    }

    // Axis titles
    if (xLabel) {
      const xAxisTitle = document.createElementNS("http://www.w3.org/2000/svg", "text");
      xAxisTitle.setAttribute("x", padding.left + chartW / 2);
      xAxisTitle.setAttribute("y", h - 5);
      xAxisTitle.setAttribute("text-anchor", "middle");
      xAxisTitle.setAttribute("font-size", fs);
      xAxisTitle.textContent = xLabel;
      svg.appendChild(xAxisTitle);
    }

    if (yLabel) {
      const yAxisTitle = document.createElementNS("http://www.w3.org/2000/svg", "text");
      yAxisTitle.setAttribute("transform", `rotate(-90,${padding.left/3},${padding.top+chartH/2})`);
      yAxisTitle.setAttribute("x", padding.left / 3);
      yAxisTitle.setAttribute("y", padding.top + chartH / 2);
      yAxisTitle.setAttribute("text-anchor", "middle");
      yAxisTitle.setAttribute("font-size", fs);
      yAxisTitle.textContent = yLabel;
      svg.appendChild(yAxisTitle);
    }
  }
  
  // Update global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;

    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Bar Graph " + container.barGraphID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Chart Settings button
    const chartSettingsBtn = document.createElement("button");
    chartSettingsBtn.textContent = "Chart Settings";
    chartSettingsBtn.style.marginRight = "10px";
    chartSettingsBtn.style.padding = "5px 10px";
    chartSettingsBtn.style.cursor = "pointer";
    chartSettingsBtn.addEventListener("click", function() {
      showChartSettingsDialog();
    });
    controls.appendChild(chartSettingsBtn);
    
    // Y-Axis Settings button
    const yAxisSettingsBtn = document.createElement("button");
    yAxisSettingsBtn.textContent = "Y-Axis Settings";
    yAxisSettingsBtn.style.marginRight = "10px";
    yAxisSettingsBtn.style.padding = "5px 10px";
    yAxisSettingsBtn.style.cursor = "pointer";
    yAxisSettingsBtn.addEventListener("click", function() {
      showYAxisSettingsDialog();
    });
    controls.appendChild(yAxisSettingsBtn);
    
    // Edit Data button
    const editDataBtn = document.createElement("button");
    editDataBtn.textContent = "Edit Data";
    editDataBtn.style.marginRight = "10px";
    editDataBtn.style.padding = "5px 10px";
    editDataBtn.style.cursor = "pointer";
    editDataBtn.addEventListener("click", function() {
      showEditDataDialog();
    });
    controls.appendChild(editDataBtn);
    
    globalToolbar.appendChild(controls);
  }
  
  // Chart Settings Dialog
  function showChartSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "400px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Chart Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Title input
    const titleLabel = document.createElement("label");
    titleLabel.style.display = "flex";
    titleLabel.style.justifyContent = "space-between";
    titleLabel.style.alignItems = "center";
    titleLabel.style.marginBottom = "10px";
    titleLabel.innerHTML = "Title:";
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.value = container.barGraphData.title;
    titleInput.style.width = "300px";
    titleInput.style.marginLeft = "10px";
    titleLabel.appendChild(titleInput);
    dialogBox.appendChild(titleLabel);
    
    // X-Axis Label input
    const xAxisLabel = document.createElement("label");
    xAxisLabel.style.display = "flex";
    xAxisLabel.style.justifyContent = "space-between";
    xAxisLabel.style.alignItems = "center";
    xAxisLabel.style.marginBottom = "10px";
    xAxisLabel.innerHTML = "X-Axis Label:";
    const xAxisInput = document.createElement("input");
    xAxisInput.type = "text";
    xAxisInput.value = container.barGraphData.xAxisLabel;
    xAxisInput.style.width = "300px";
    xAxisInput.style.marginLeft = "10px";
    xAxisLabel.appendChild(xAxisInput);
    dialogBox.appendChild(xAxisLabel);
    
    // Y-Axis Label input
    const yAxisLabel = document.createElement("label");
    yAxisLabel.style.display = "flex";
    yAxisLabel.style.justifyContent = "space-between";
    yAxisLabel.style.alignItems = "center";
    yAxisLabel.style.marginBottom = "10px";
    yAxisLabel.innerHTML = "Y-Axis Label:";
    const yAxisInput = document.createElement("input");
    yAxisInput.type = "text";
    yAxisInput.value = container.barGraphData.yAxisLabel;
    yAxisInput.style.width = "300px";
    yAxisInput.style.marginLeft = "10px";
    yAxisLabel.appendChild(yAxisInput);
    dialogBox.appendChild(yAxisLabel);
    
    // Title Font Size input
    const titleFontLabel = document.createElement("label");
    titleFontLabel.style.display = "flex";
    titleFontLabel.style.justifyContent = "space-between";
    titleFontLabel.style.alignItems = "center";
    titleFontLabel.style.marginBottom = "10px";
    titleFontLabel.innerHTML = "Title Font Size:";
    const titleFontInput = document.createElement("input");
    titleFontInput.type = "number";
    titleFontInput.min = "12";
    titleFontInput.max = "36";
    titleFontInput.value = container.barGraphData.titleFontSize;
    titleFontInput.style.width = "70px";
    titleFontInput.style.marginLeft = "10px";
    titleFontLabel.appendChild(titleFontInput);
    dialogBox.appendChild(titleFontLabel);
    
    // Label Font Size input
    const labelFontLabel = document.createElement("label");
    labelFontLabel.style.display = "flex";
    labelFontLabel.style.justifyContent = "space-between";
    labelFontLabel.style.alignItems = "center";
    labelFontLabel.style.marginBottom = "10px";
    labelFontLabel.innerHTML = "Label Font Size:";
    const labelFontInput = document.createElement("input");
    labelFontInput.type = "number";
    labelFontInput.min = "10";
    labelFontInput.max = "24";
    labelFontInput.value = container.barGraphData.labelFontSize;
    labelFontInput.style.width = "70px";
    labelFontInput.style.marginLeft = "10px";
    labelFontLabel.appendChild(labelFontInput);
    dialogBox.appendChild(labelFontLabel);
    
    // Bar Width Percent input
    const barWidthLabel = document.createElement("label");
    barWidthLabel.style.display = "flex";
    barWidthLabel.style.justifyContent = "space-between";
    barWidthLabel.style.alignItems = "center";
    barWidthLabel.style.marginBottom = "10px";
    barWidthLabel.innerHTML = "Bar Width %:";
    const barWidthSlider = document.createElement("input");
    barWidthSlider.type = "range";
    barWidthSlider.min = "10";
    barWidthSlider.max = "80";
    barWidthSlider.value = container.barGraphData.barWidthPercent;
    barWidthSlider.style.width = "200px";
    barWidthSlider.style.marginLeft = "10px";
    barWidthLabel.appendChild(barWidthSlider);
    dialogBox.appendChild(barWidthLabel);
    
    // Show Values checkbox
    const showValuesLabel = document.createElement("label");
    showValuesLabel.style.display = "flex";
    showValuesLabel.style.justifyContent = "space-between";
    showValuesLabel.style.alignItems = "center";
    showValuesLabel.style.marginBottom = "15px";
    showValuesLabel.innerHTML = "Show Values:";
    const showValuesCheckbox = document.createElement("input");
    showValuesCheckbox.type = "checkbox";
    showValuesCheckbox.checked = container.barGraphData.showValues;
    showValuesCheckbox.style.marginLeft = "10px";
    showValuesLabel.appendChild(showValuesCheckbox);
    dialogBox.appendChild(showValuesLabel);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the bar graph data
      container.barGraphData.title = titleInput.value;
      container.barGraphData.xAxisLabel = xAxisInput.value;
      container.barGraphData.yAxisLabel = yAxisInput.value;
      container.barGraphData.titleFontSize = parseInt(titleFontInput.value);
      container.barGraphData.labelFontSize = parseInt(labelFontInput.value);
      container.barGraphData.barWidthPercent = parseInt(barWidthSlider.value);
      container.barGraphData.showValues = showValuesCheckbox.checked;
      
      // Redraw the bar graph
      drawBarGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }
  
  // Y-Axis Settings Dialog
  function showYAxisSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "300px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Y-Axis Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Min Value input
    const minLabel = document.createElement("label");
    minLabel.style.display = "flex";
    minLabel.style.justifyContent = "space-between";
    minLabel.style.alignItems = "center";
    minLabel.style.marginBottom = "10px";
    minLabel.innerHTML = "Min Value:";
    const minInput = document.createElement("input");
    minInput.type = "text"; // Changed to text to allow variables
    minInput.value = container.barGraphData.yMin;
    minInput.style.width = "100px";
    minInput.style.marginLeft = "10px";
    minLabel.appendChild(minInput);
    dialogBox.appendChild(minLabel);
    
    // Max Value input
    const maxLabel = document.createElement("label");
    maxLabel.style.display = "flex";
    maxLabel.style.justifyContent = "space-between";
    maxLabel.style.alignItems = "center";
    maxLabel.style.marginBottom = "10px";
    maxLabel.innerHTML = "Max Value:";
    const maxInput = document.createElement("input");
    maxInput.type = "text"; // Changed to text to allow variables
    maxInput.value = container.barGraphData.yMax;
    maxInput.style.width = "100px";
    maxInput.style.marginLeft = "10px";
    maxLabel.appendChild(maxInput);
    dialogBox.appendChild(maxLabel);
    
    // Interval input
    const intervalLabel = document.createElement("label");
    intervalLabel.style.display = "flex";
    intervalLabel.style.justifyContent = "space-between";
    intervalLabel.style.alignItems = "center";
    intervalLabel.style.marginBottom = "15px";
    intervalLabel.innerHTML = "Interval:";
    const intervalInput = document.createElement("input");
    intervalInput.type = "text"; // Changed to text to allow variables
    intervalInput.value = container.barGraphData.yInterval;
    intervalInput.style.width = "100px";
    intervalInput.style.marginLeft = "10px";
    intervalLabel.appendChild(intervalInput);
    dialogBox.appendChild(intervalLabel);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the bar graph data
      container.barGraphData.yMin = minInput.value; // Store as-is to preserve variables
      container.barGraphData.yMax = maxInput.value; // Store as-is to preserve variables
      container.barGraphData.yInterval = intervalInput.value; // Store as-is to preserve variables
      
      // Redraw the bar graph
      drawBarGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }
  
  // Edit Data Dialog (combining Add Bar and Manage Bars)
  function showEditDataDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "500px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Edit Bar Data";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Add New Bar section
    const addBarSection = document.createElement("div");
    addBarSection.style.marginBottom = "20px";
    addBarSection.style.padding = "15px";
    addBarSection.style.border = "1px solid #ddd";
    addBarSection.style.borderRadius = "5px";
    
    const addBarTitle = document.createElement("h4");
    addBarTitle.textContent = "Add New Bar";
    addBarTitle.style.marginTop = "0";
    addBarTitle.style.marginBottom = "15px";
    addBarSection.appendChild(addBarTitle);
    
    // Add bar form
    const addBarForm = document.createElement("div");
    addBarForm.style.display = "grid";
    addBarForm.style.gridTemplateColumns = "1fr 1fr 1fr";
    addBarForm.style.gap = "10px";
    
    // Bar Name input
    const nameContainer = document.createElement("div");
    const nameLabel = document.createElement("label");
    nameLabel.textContent = "Bar Name:";
    nameLabel.style.display = "block";
    nameLabel.style.marginBottom = "5px";
    
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.placeholder = "Enter bar name";
    nameInput.style.width = "100%";
    nameInput.style.padding = "5px";
    nameInput.style.boxSizing = "border-box";
    
    nameContainer.appendChild(nameLabel);
    nameContainer.appendChild(nameInput);
    addBarForm.appendChild(nameContainer);
    
    // Bar Value input
    const valueContainer = document.createElement("div");
    const valueLabel = document.createElement("label");
    valueLabel.textContent = "Bar Value:";
    valueLabel.style.display = "block";
    valueLabel.style.marginBottom = "5px";
    
    const valueInput = document.createElement("input");
    valueInput.type = "text"; // Changed from "number" to "text" to allow #a# format
    valueInput.placeholder = "Enter value or #var#";
    valueInput.style.width = "100%";
    valueInput.style.padding = "5px";
    valueInput.style.boxSizing = "border-box";
    
    valueContainer.appendChild(valueLabel);
    valueContainer.appendChild(valueInput);
    addBarForm.appendChild(valueContainer);
    
    // Bar Color input
    const colorContainer = document.createElement("div");
    const colorLabel = document.createElement("label");
    colorLabel.textContent = "Bar Color:";
    colorLabel.style.display = "block";
    colorLabel.style.marginBottom = "5px";
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = "#4688c7";
    colorInput.style.width = "100%";
    colorInput.style.padding = "0";
    colorInput.style.height = "30px";
    colorInput.style.boxSizing = "border-box";
    
    colorContainer.appendChild(colorLabel);
    colorContainer.appendChild(colorInput);
    addBarForm.appendChild(colorContainer);
    
    addBarSection.appendChild(addBarForm);
    
    // Add Bar button
    const addBarButtonContainer = document.createElement("div");
    addBarButtonContainer.style.textAlign = "right";
    addBarButtonContainer.style.marginTop = "10px";
    
    const addBarButton = document.createElement("button");
    addBarButton.textContent = "Add Bar";
    addBarButton.style.padding = "5px 15px";
    addBarButton.style.cursor = "pointer";
    addBarButton.style.backgroundColor = "#4688c7";
    addBarButton.style.color = "white";
    addBarButton.style.border = "none";
    addBarButton.style.borderRadius = "4px";
    
    addBarButtonContainer.appendChild(addBarButton);
    addBarSection.appendChild(addBarButtonContainer);
    
    dialogBox.appendChild(addBarSection);
    
    // Manage Bars section
    const manageBarsSection = document.createElement("div");
    manageBarsSection.style.marginTop = "20px";
    
    const manageBarsTitle = document.createElement("h4");
    manageBarsTitle.textContent = "Manage Bars";
    manageBarsTitle.style.marginTop = "0";
    manageBarsTitle.style.marginBottom = "15px";
    manageBarsSection.appendChild(manageBarsTitle);
    
    // Bars table
    const barsTable = document.createElement("table");
    barsTable.style.width = "100%";
    barsTable.style.borderCollapse = "collapse";
    
    // Table header
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    
    const nameHeader = document.createElement("th");
    nameHeader.textContent = "Name";
    nameHeader.style.padding = "8px";
    nameHeader.style.textAlign = "left";
    nameHeader.style.backgroundColor = "#f2f2f2";
    nameHeader.style.width = "30%";
    headerRow.appendChild(nameHeader);
    
    const valueHeader = document.createElement("th");
    valueHeader.textContent = "Value";
    valueHeader.style.padding = "8px";
    valueHeader.style.textAlign = "left";
    valueHeader.style.backgroundColor = "#f2f2f2";
    valueHeader.style.width = "25%";
    headerRow.appendChild(valueHeader);
    
    const colorHeader = document.createElement("th");
    colorHeader.textContent = "Color";
    colorHeader.style.padding = "8px";
    colorHeader.style.textAlign = "left";
    colorHeader.style.backgroundColor = "#f2f2f2";
    colorHeader.style.width = "25%";
    headerRow.appendChild(colorHeader);
    
    const actionsHeader = document.createElement("th");
    actionsHeader.textContent = "Actions";
    actionsHeader.style.padding = "8px";
    actionsHeader.style.textAlign = "left";
    actionsHeader.style.backgroundColor = "#f2f2f2";
    actionsHeader.style.width = "20%";
    headerRow.appendChild(actionsHeader);
    
    thead.appendChild(headerRow);
    barsTable.appendChild(thead);
    
    // Table body
    const tbody = document.createElement("tbody");
    
    // Create a row for each bar
    container.barGraphData.bars.forEach((bar, index) => {
      const row = document.createElement("tr");
      
      // Name cell
      const nameCell = document.createElement("td");
      nameCell.style.padding = "8px";
      nameCell.style.borderBottom = "1px solid #ddd";
      
      const nameField = document.createElement("input");
      nameField.type = "text";
      nameField.value = bar.name;
      nameField.style.width = "100%";
      nameField.style.padding = "5px";
      nameField.style.boxSizing = "border-box";
      nameField.dataset.index = index;
      nameField.dataset.property = "name";
      
      nameCell.appendChild(nameField);
      row.appendChild(nameCell);
      
      // Value cell
      const valueCell = document.createElement("td");
      valueCell.style.padding = "8px";
      valueCell.style.borderBottom = "1px solid #ddd";
      
      const valueField = document.createElement("input");
      valueField.type = "text"; // Changed from "number" to "text" to allow #a# format
      valueField.value = bar.value;
      valueField.style.width = "100%";
      valueField.style.padding = "5px";
      valueField.style.boxSizing = "border-box";
      valueField.dataset.index = index;
      valueField.dataset.property = "value";
      
      valueCell.appendChild(valueField);
      row.appendChild(valueCell);
      
      // Color cell
      const colorCell = document.createElement("td");
      colorCell.style.padding = "8px";
      colorCell.style.borderBottom = "1px solid #ddd";
      
      const colorField = document.createElement("input");
      colorField.type = "color";
      colorField.value = bar.color;
      colorField.style.width = "100%";
      colorField.style.padding = "0";
      colorField.style.height = "30px";
      colorField.dataset.index = index;
      colorField.dataset.property = "color";
      
      colorCell.appendChild(colorField);
      row.appendChild(colorCell);
      
      // Actions cell
      const actionsCell = document.createElement("td");
      actionsCell.style.padding = "8px";
      actionsCell.style.borderBottom = "1px solid #ddd";
      
      const deleteButton = document.createElement("button");
      deleteButton.textContent = "Remove";
      deleteButton.style.padding = "5px";
      deleteButton.style.backgroundColor = "#e74c3c";
      deleteButton.style.color = "white";
      deleteButton.style.border = "none";
      deleteButton.style.borderRadius = "4px";
      deleteButton.style.cursor = "pointer";
      deleteButton.style.width = "100%";
      deleteButton.dataset.index = index;
      
      actionsCell.appendChild(deleteButton);
      row.appendChild(actionsCell);
      
      tbody.appendChild(row);
    });
    
    barsTable.appendChild(tbody);
    manageBarsSection.appendChild(barsTable);
    dialogBox.appendChild(manageBarsSection);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the bar data from the table
      const nameInputs = tbody.querySelectorAll('input[data-property="name"]');
      const valueInputs = tbody.querySelectorAll('input[data-property="value"]');
      const colorInputs = tbody.querySelectorAll('input[data-property="color"]');
      
      nameInputs.forEach((input, i) => {
        const index = parseInt(input.dataset.index);
        container.barGraphData.bars[index].name = input.value;
      });
      
      valueInputs.forEach((input, i) => {
        const index = parseInt(input.dataset.index);
        // Store the value as-is, whether it's a number or a variable string like "#a#"
        container.barGraphData.bars[index].value = input.value;
      });
      
      colorInputs.forEach((input, i) => {
        const index = parseInt(input.dataset.index);
        container.barGraphData.bars[index].color = input.value;
      });
      
      // Redraw the bar graph
      drawBarGraph();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    
    // Event listeners
    
    // Add bar button
    addBarButton.addEventListener("click", function() {
      const name = nameInput.value.trim();
      const value = valueInput.value.trim(); // Keep as string to support variables
      const color = colorInput.value;
      
      if (name && value !== "") {
        // Add the new bar to the data
        container.barGraphData.bars.push({
          name: name,
          value: value,
          color: color
        });
        
        // Clear the inputs
        nameInput.value = "";
        valueInput.value = "";
        
        // Recreate the table
        showEditDataDialog();
        
        // Close the current dialog
        document.body.removeChild(dialogBackdrop);
      } else {
        alert("Please enter a name and valid value for the bar");
      }
    });
    
    // Remove bar buttons
    tbody.addEventListener("click", function(e) {
      if (e.target.tagName === "BUTTON" && e.target.textContent === "Remove") {
        const index = parseInt(e.target.dataset.index);
        
        // Remove the bar from the data
        container.barGraphData.bars.splice(index, 1);
        
        // Recreate the table
        showEditDataDialog();
        
        // Close the current dialog
        document.body.removeChild(dialogBackdrop);
      }
    });
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Key functions for activation
  function activateBarGraph() {
    // Deactivate the previously active element if any
    if (window.activeBarGraphElement && window.activeBarGraphElement !== container) {
      window.activeBarGraphElement.style.border = "none";
      
      const prevToolbar = window.activeBarGraphElement.querySelector(".bar-graph-toolbar");
      const prevResizeHandle = window.activeBarGraphElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeBarGraphElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivateBarGraph() {
    if (window.activeBarGraphElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeBarGraphElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteBarGraph() {
    if (window.activeBarGraphElement === container) {
      window.activeBarGraphElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateBarGraph();
    }
  });

  // Deletion: add both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteBarGraph();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteBarGraph();
  });

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    const aspectRatio = startWidth / startHeight;
    
    function onMouseMove(e) {
      // Calculate new width based on mouse position
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      // Maintain aspect ratio for height
      const newHeight = newWidth / aspectRatio;
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      
      // Update SVG dimensions and ensure content scales properly
      graphSVG.setAttribute("width", newWidth);
      graphSVG.setAttribute("height", newHeight - toolbarHeight);
      graphSVG.style.width = "100%";
      graphSVG.style.height = "100%";
      
      // Redraw the graph with the new dimensions
      drawBarGraph();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activeBarGraphElement === container) {
      deactivateBarGraph();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Store the draw function on the container so it can be called externally
  container.drawBarGraph = drawBarGraph;
  
  // Draw the initial bar graph
  drawBarGraph();
  
  // Activate the bar graph
  activateBarGraph();
}


function addStemLeaf() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeStemLeafElement) {
    window.activeStemLeafElement = null;
  }
  // Global counter for stem-and-leaf IDs
  if (!window.globalStemLeafCounter) {
    window.globalStemLeafCounter = 1;
  } else {
    window.globalStemLeafCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element stem-leaf-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "600px";
  container.style.height = (toolbarHeight + 300) + "px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this stem-and-leaf
  container.stemLeafID = window.globalStemLeafCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-stem-leaf-id', container.stemLeafID);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "stem-leaf-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "stem-leaf-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create canvas for stem and leaf plot
  const plotCanvas = document.createElement("canvas");
  plotCanvas.width = 600;
  plotCanvas.height = 300;
  plotCanvas.style.width = "100%";
  plotCanvas.style.height = "100%";
  content.appendChild(plotCanvas);

  // Store the data needed for the stem-and-leaf plot
  container.stemLeafData = {
    title: "Stem-and-Leaf Plot",
    titleFontSize: 18,
    fontFamily: "monospace",
    keyNote: "1|2 represents 12",
    stems: [
      { stem: "0", leaves: "2,5,7,9" },
      { stem: "1", leaves: "0,3,5,5,7,8" },
      { stem: "2", leaves: "0,2,4,6,8" },
      { stem: "3", leaves: "1,2,5" }
    ]
  };

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Function to draw the stem-and-leaf plot
  function drawStemLeaf() {
    const ctx = plotCanvas.getContext('2d');
    ctx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

    const data = container.stemLeafData;
    const fontSize = data.titleFontSize;
    const fontFamily = data.fontFamily || 'monospace';
    
    // Title (if present)
    if (data.title) {
      ctx.font = `bold ${fontSize}px ${fontFamily}`;
      ctx.textAlign = 'center';
      ctx.fillText(data.title, 220, fontSize + 5);
    }

    // Calculate dimensions
    const padding = 40; 
    const startY = data.title ? fontSize + 30 : 20;
    const lineHeight = fontSize + 10;
    
    // T-shape stem-and-leaf structure with table headers
    const tableStartY = startY + lineHeight;
    
    // HARDCODED VALUES FOR T-STRUCTURE
    // You can adjust these to your preference
    const verticalLineX = 200;             // X position of vertical line (change this to move the divider)
    const horizontalLineStart = 120;        // Left endpoint of horizontal line
    const horizontalLineEnd = 400;         // Right endpoint of horizontal line
    const stemHeaderX = verticalLineX - 40; // Position of "stem" header
    const leafHeaderX = verticalLineX + 40; // Position of "leaf" header
    
    // Draw the horizontal line for the top of the T (with custom endpoints)
    ctx.beginPath();
    ctx.moveTo(horizontalLineStart, tableStartY);
    ctx.lineTo(horizontalLineEnd, tableStartY);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Draw "stem" on the left side above the horizontal line
    ctx.font = `${fontSize}px ${fontFamily}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText("stem", stemHeaderX, tableStartY - 5);
    
    // Draw "leaf" on the right side above the horizontal line
    ctx.textAlign = 'center';
    ctx.fillText("leaf", leafHeaderX, tableStartY -5);
    
    // Reset text baseline
    ctx.textBaseline = 'alphabetic';
    
    // Draw vertical line at the specified X position
    ctx.beginPath();
    ctx.moveTo(verticalLineX, tableStartY - lineHeight);
    ctx.lineTo(verticalLineX, tableStartY + data.stems.length * lineHeight + 5);
    ctx.stroke();
    
    // Draw stems and leaves
    const dataStartY = tableStartY + lineHeight;
    
    data.stems.forEach((item, index) => {
      const y = dataStartY + index * lineHeight;
      
      // Draw stem
      ctx.textAlign = 'right';
      ctx.fillText(item.stem, verticalLineX - 10, y);
      
      // Draw leaves
      ctx.textAlign = 'left';
      const leaves = Array.isArray(item.leaves) ? item.leaves.join(' ') : 
                    typeof item.leaves === 'string' ? item.leaves.split(',').join(' ') : '';
      ctx.fillText(leaves, verticalLineX + 10, y);
    });
    
    // Draw key note below the table if present
    if (data.keyNote) {
      const keyNoteY = dataStartY + (data.stems.length * lineHeight) + lineHeight;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.textAlign = 'left';
      ctx.fillText("Key: " + data.keyNote, 140, keyNoteY);
    }
  }
  
  // Update global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;

    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Stem-and-Leaf " + container.stemLeafID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Table Properties button
    const tablePropsBtn = document.createElement("button");
    tablePropsBtn.textContent = "Table Properties";
    tablePropsBtn.style.marginRight = "10px";
    tablePropsBtn.style.padding = "5px 10px";
    tablePropsBtn.style.cursor = "pointer";
    tablePropsBtn.addEventListener("click", function() {
      showTablePropertiesDialog();
    });
    controls.appendChild(tablePropsBtn);
    
    // Edit Data button
    const editDataBtn = document.createElement("button");
    editDataBtn.textContent = "Edit Data";
    editDataBtn.style.marginRight = "10px";
    editDataBtn.style.padding = "5px 10px";
    editDataBtn.style.cursor = "pointer";
    editDataBtn.addEventListener("click", function() {
      showEditDataDialog();
    });
    controls.appendChild(editDataBtn);
    
    globalToolbar.appendChild(controls);
  }
  
  // Table Properties Dialog
  function showTablePropertiesDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "300px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Table Properties";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Plot title input
    const titleLabel = document.createElement("label");
    titleLabel.style.display = "flex";
    titleLabel.style.justifyContent = "space-between";
    titleLabel.style.alignItems = "center";
    titleLabel.style.marginBottom = "10px";
    titleLabel.innerHTML = "Title:";
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.value = container.stemLeafData.title;
    titleInput.style.width = "200px";
    titleInput.style.marginLeft = "10px";
    titleLabel.appendChild(titleInput);
    dialogBox.appendChild(titleLabel);
    
    // Font size input
    const fontLabel = document.createElement("label");
    fontLabel.style.display = "flex";
    fontLabel.style.justifyContent = "space-between";
    fontLabel.style.alignItems = "center";
    fontLabel.style.marginBottom = "10px";
    fontLabel.innerHTML = "Font Size:";
    const fontInput = document.createElement("input");
    fontInput.type = "number";
    fontInput.min = "10";
    fontInput.max = "36";
    fontInput.value = container.stemLeafData.titleFontSize;
    fontInput.style.width = "60px";
    fontInput.style.marginLeft = "10px";
    fontLabel.appendChild(fontInput);
    dialogBox.appendChild(fontLabel);
    
    // Font family selection
    const fontFamilyLabel = document.createElement("label");
    fontFamilyLabel.style.display = "flex";
    fontFamilyLabel.style.justifyContent = "space-between";
    fontFamilyLabel.style.alignItems = "center";
    fontFamilyLabel.style.marginBottom = "10px";
    fontFamilyLabel.innerHTML = "Font Family:";
    
    const fontFamilySelect = document.createElement("select");
    fontFamilySelect.style.width = "200px";
    fontFamilySelect.style.marginLeft = "10px";
    
    const fontFamilies = [
      { value: "monospace", text: "Monospace" },
      { value: "sans-serif", text: "Sans Serif" },
      { value: "serif", text: "Serif" },
      { value: "Arial", text: "Arial" },
      { value: "Helvetica", text: "Helvetica" },
      { value: "Times New Roman", text: "Times New Roman" },
      { value: "Courier New", text: "Courier New" }
    ];
    
    fontFamilies.forEach(font => {
      const option = document.createElement("option");
      option.value = font.value;
      option.textContent = font.text;
      if (container.stemLeafData.fontFamily === font.value) {
        option.selected = true;
      }
      fontFamilySelect.appendChild(option);
    });
    
    fontFamilyLabel.appendChild(fontFamilySelect);
    dialogBox.appendChild(fontFamilyLabel);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the stem-and-leaf data
      container.stemLeafData.title = titleInput.value;
      container.stemLeafData.titleFontSize = parseInt(fontInput.value);
      container.stemLeafData.fontFamily = fontFamilySelect.value;
      
      // Redraw the stem-and-leaf plot
      drawStemLeaf();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Edit Data Dialog
  function showEditDataDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "400px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Edit Data";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Key Note input
    const keyNoteLabel = document.createElement("label");
    keyNoteLabel.style.display = "flex";
    keyNoteLabel.style.justifyContent = "space-between";
    keyNoteLabel.style.alignItems = "center";
    keyNoteLabel.style.marginBottom = "15px";
    keyNoteLabel.innerHTML = "Key Note:";
    const keyNoteInput = document.createElement("input");
    keyNoteInput.type = "text";
    keyNoteInput.value = container.stemLeafData.keyNote || "";
    keyNoteInput.style.width = "270px";
    keyNoteInput.style.marginLeft = "10px";
    keyNoteInput.placeholder = "e.g., 1|2 represents 12";
    keyNoteLabel.appendChild(keyNoteInput);
    dialogBox.appendChild(keyNoteLabel);
    
    // Create container for stem and leaf forms
    const dataFormsContainer = document.createElement("div");
    dataFormsContainer.style.maxHeight = "50vh";
    dataFormsContainer.style.overflowY = "auto";
    dataFormsContainer.style.marginBottom = "15px";
    
    // Function to create a form for a stem and its leaves
    function createStemLeafForm(stemData, index) {
      const stemForm = document.createElement("div");
      stemForm.style.border = "1px solid #ddd";
      stemForm.style.padding = "10px";
      stemForm.style.marginBottom = "10px";
      stemForm.style.borderRadius = "4px";
      stemForm.style.position = "relative";
      
      const stemTitle = document.createElement("div");
      stemTitle.style.fontWeight = "bold";
      stemTitle.style.marginBottom = "8px";
      stemTitle.textContent = `Row ${index + 1}`;
      stemForm.appendChild(stemTitle);
      
      // Delete stem button
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.style.position = "absolute";
      deleteBtn.style.top = "8px";
      deleteBtn.style.right = "8px";
      deleteBtn.style.padding = "2px 5px";
      deleteBtn.style.fontSize = "12px";
      deleteBtn.style.backgroundColor = "#e74c3c";
      deleteBtn.style.color = "white";
      deleteBtn.style.border = "none";
      deleteBtn.style.borderRadius = "3px";
      deleteBtn.style.cursor = "pointer";
      deleteBtn.dataset.stemIndex = index;
      stemForm.appendChild(deleteBtn);
      
      // Create inputs
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.marginBottom = "5px";
      
      // Stem input
      const stemLabel = document.createElement("label");
      stemLabel.textContent = "Stem:";
      stemLabel.style.width = "60px";
      
      const stemInput = document.createElement("input");
      stemInput.type = "text";
      stemInput.value = stemData.stem;
      stemInput.style.width = "60px";
      stemInput.dataset.property = "stem";
      stemInput.dataset.stemIndex = index;
      
      // Leaves input
      const leavesLabel = document.createElement("label");
      leavesLabel.textContent = "Leaves:";
      leavesLabel.style.width = "70px";
      leavesLabel.style.marginLeft = "10px";
      
      const leavesInput = document.createElement("input");
      leavesInput.type = "text";
      leavesInput.value = Array.isArray(stemData.leaves) ? stemData.leaves.join(",") : stemData.leaves;
      leavesInput.style.flexGrow = "1";
      leavesInput.dataset.property = "leaves";
      leavesInput.dataset.stemIndex = index;
      
      row.appendChild(stemLabel);
      row.appendChild(stemInput);
      row.appendChild(leavesLabel);
      row.appendChild(leavesInput);
      stemForm.appendChild(row);
      
      return stemForm;
    }
    
    // Create and add forms for each stem and leaf row
    container.stemLeafData.stems.forEach((stem, index) => {
      const stemForm = createStemLeafForm(stem, index);
      dataFormsContainer.appendChild(stemForm);
    });
    
    dialogBox.appendChild(dataFormsContainer);
    
    // Add Row button
    const addRowBtn = document.createElement("button");
    addRowBtn.textContent = "Add Row";
    addRowBtn.style.padding = "5px 10px";
    addRowBtn.style.marginBottom = "15px";
    addRowBtn.style.cursor = "pointer";
    dialogBox.appendChild(addRowBtn);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the key note
      container.stemLeafData.keyNote = keyNoteInput.value;
      
      // Create a new array for the stems
      const newStems = [];
      
      // Get all inputs by their data attributes
      const inputs = dataFormsContainer.querySelectorAll("input");
      let currentStemData = {};
      let currentStemIndex = -1;
      
      inputs.forEach(input => {
        const stemIndex = parseInt(input.dataset.stemIndex);
        const property = input.dataset.property;
        
        if (stemIndex !== currentStemIndex) {
          // Save previous stem data if any
          if (currentStemIndex !== -1) {
            newStems.push(currentStemData);
          }
          
          // Start a new stem
          currentStemIndex = stemIndex;
          currentStemData = {
            stem: "",
            leaves: ""
          };
        }
        
        // Set property for current stem
        if (property) {
          currentStemData[property] = input.value;
        }
      });
      
      // Add the last stem
      if (currentStemIndex !== -1) {
        newStems.push(currentStemData);
      }
      
      // Update the stem-and-leaf data
      container.stemLeafData.stems = newStems;
      
      // Redraw the stem-and-leaf plot
      drawStemLeaf();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    
    // Event listeners
    
    // Delete stem button
    dataFormsContainer.addEventListener("click", function(e) {
      if (e.target.tagName === "BUTTON" && e.target.textContent === "Delete") {
        const stemIndex = parseInt(e.target.dataset.stemIndex);
        const stemForm = e.target.closest("div");
        
        // Remove the form
        dataFormsContainer.removeChild(stemForm);
        
        // Update indices for remaining forms
        const remainingForms = dataFormsContainer.querySelectorAll("div > div");
        let index = 0;
        
        remainingForms.forEach(form => {
          // Skip forms that are not stem forms
          if (!form.querySelector("input[data-property]")) return;
          
          // Update title
          const titleElem = form.querySelector("div");
          if (titleElem) titleElem.textContent = `Row ${index + 1}`;
          
          // Update delete button index
          const deleteBtn = form.querySelector("button");
          if (deleteBtn) deleteBtn.dataset.stemIndex = index;
          
          // Update input indices
          const inputs = form.querySelectorAll("input");
          inputs.forEach(input => {
            if (input.dataset.stemIndex) {
              input.dataset.stemIndex = index;
            }
          });
          
          index++;
        });
      }
    });
    
    // Add row button
    addRowBtn.addEventListener("click", function() {
      const stemCount = container.stemLeafData.stems.length;
      const newStem = {
        stem: stemCount.toString(),
        leaves: "0,0"
      };
      
      const stemForm = createStemLeafForm(newStem, stemCount);
      dataFormsContainer.appendChild(stemForm);
      
      // Scroll to the new row
      dataFormsContainer.scrollTop = dataFormsContainer.scrollHeight;
    });
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Key functions for activation
  function activateStemLeaf() {
    // Deactivate the previously active element if any
    if (window.activeStemLeafElement && window.activeStemLeafElement !== container) {
      window.activeStemLeafElement.style.border = "none";
      
      const prevToolbar = window.activeStemLeafElement.querySelector(".stem-leaf-toolbar");
      const prevResizeHandle = window.activeStemLeafElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeStemLeafElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivateStemLeaf() {
    if (window.activeStemLeafElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeStemLeafElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteStemLeaf() {
    if (window.activeStemLeafElement === container) {
      window.activeStemLeafElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateStemLeaf();
    }
  });

  // Deletion: add both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteStemLeaf();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteStemLeaf();
  });

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    const aspectRatio = startWidth / startHeight;
    
    function onMouseMove(e) {
      // Calculate new width based on mouse position
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      // Maintain aspect ratio for height
      const newHeight = newWidth / aspectRatio;
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      drawStemLeaf();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activeStemLeafElement === container) {
      deactivateStemLeaf();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Store the draw function on the container so it can be called externally
  container.drawStemLeaf = drawStemLeaf;
  
  // Draw the initial stem-and-leaf plot
  drawStemLeaf();
  
  // Activate the stem-and-leaf plot
  activateStemLeaf();
}

function addBoxAndWhisker() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeBoxWhiskerElement) {
    window.activeBoxWhiskerElement = null;
  }
  // Global counter for box-and-whisker IDs
  if (!window.globalBoxWhiskerCounter) {
    window.globalBoxWhiskerCounter = 1;
  } else {
    window.globalBoxWhiskerCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element box-whisker-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "700px";
  container.style.height = (toolbarHeight + 300) + "px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this box-and-whisker
  container.boxWhiskerID = window.globalBoxWhiskerCounter;
// Also store it as a data-attribute so cloneNode will copy it:
container.setAttribute('data-box-whisker-id', container.boxWhiskerID);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "box-whisker-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "box-whisker-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create canvas for box and whisker plot
  const plotCanvas = document.createElement("canvas");
  plotCanvas.width = 700;
  plotCanvas.height = 300;
  plotCanvas.style.width = "100%";
  plotCanvas.style.height = "100%";
  content.appendChild(plotCanvas);

  // Store the data needed for the box-and-whisker plot
  container.boxWhiskerData = {
    title: "Box-and-Whisker Plot",
    titleFontSize: 18,
    numberLine: {
      min: 0,
      max: 10,
      tickInterval: 1,
      labelInterval: 1,
      axisLabel: "Value"
    },
    boxThickness: 2,
    boxes: [
      {
        id: 1,
        name: "Box 1",
        min: "2",
        q1: "3",
        med: "5",
        q3: "7",
        max: "9"
      }
    ]
  };

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Function to draw the box-and-whisker plot
  function drawBoxAndWhisker() {
    const ctx = plotCanvas.getContext('2d');
    ctx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

    const data = container.boxWhiskerData;
    const fontSize = data.titleFontSize;
    // Title
    ctx.font = `bold ${fontSize}px sans-serif`;
ctx.textAlign = 'center';
ctx.fillText(data.title, plotCanvas.width/2, fontSize + 5);

ctx.textAlign = 'start';

    const nlMin = parseFloat(data.numberLine.min);
    const nlMax = parseFloat(data.numberLine.max);
    const nlInt = parseFloat(data.numberLine.tickInterval);
    const labelInt = parseFloat(data.numberLine.labelInterval);
    const boxThk = parseFloat(data.boxThickness);
    const axisLabel = data.numberLine.axisLabel;

    const padding = 60;
    const axisY = plotCanvas.height - 60;
    const plotWidth = plotCanvas.width - 2*padding;
    const scale = plotWidth / (nlMax - nlMin);
    const xOf = v => padding + (v - nlMin)*scale;
    // Axis line
    ctx.beginPath();
    ctx.strokeStyle = '#000'; 
    ctx.lineWidth = 2;
    ctx.moveTo(xOf(nlMin), axisY);
    ctx.lineTo(xOf(nlMax), axisY);
    ctx.stroke();

    // Ticks & labels
    ctx.font = `bold ${fontSize}px sans-serif`;
ctx.fillStyle = '#000';
ctx.lineWidth = 1;
for (let v = nlMin; v <= nlMax; v += nlInt) {
  const x = xOf(v);
  ctx.beginPath();
    ctx.moveTo(x, axisY - 5);
    ctx.lineTo(x, axisY + 5);
  ctx.stroke();
  if (labelInt > 0 && ((v - nlMin) % labelInt) === 0) {
    ctx.fillText(
      v,
      x - ctx.measureText(v).width/2,
      axisY + fontSize + 5
    );
  }
}

    // Axis label
    ctx.font = `bold ${fontSize}px sans-serif`;
ctx.fillStyle = '#000';
ctx.textAlign = 'center';
ctx.textBaseline = 'top';
ctx.fillText(
  axisLabel,
  plotCanvas.width/2,
  axisY + fontSize + 10
);

    // Plot boxes
    const whiskerYBase = axisY - 30;
    const boxYBase = axisY - 50;
    const boxHeight = 30;

    data.boxes.forEach((box, i) => {
      const mn = parseFloat(box.min), q1 = parseFloat(box.q1);
      const md = parseFloat(box.med), q3 = parseFloat(box.q3);
      const mx = parseFloat(box.max);

      ctx.strokeStyle = '#000'; 
      ctx.lineWidth = boxThk;
      
      // Whiskers
      ctx.beginPath();
      ctx.moveTo(xOf(mn), whiskerYBase - i*(boxHeight+10));
      ctx.lineTo(xOf(q1), whiskerYBase - i*(boxHeight+10));
      ctx.moveTo(xOf(q3), whiskerYBase - i*(boxHeight+10));
      ctx.lineTo(xOf(mx), whiskerYBase - i*(boxHeight+10));
      ctx.stroke();
      
      // Caps
      [mn, mx].forEach(val => {
        const x = xOf(val);
        ctx.beginPath();
        ctx.moveTo(x, whiskerYBase - 10 - i*(boxHeight+10));
        ctx.lineTo(x, whiskerYBase + 10 - i*(boxHeight+10));
        ctx.stroke();
      });

      // Box
      const top = boxYBase - i*(boxHeight+10);
      ctx.strokeRect(xOf(q1), top, xOf(q3) - xOf(q1), boxHeight);
      
      // Median
      ctx.beginPath();
      const xm = xOf(md);
      ctx.moveTo(xm, top);
      ctx.lineTo(xm, top+boxHeight);
      ctx.stroke();

      // Box label
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.textBaseline = 'alphabetic';
      ctx.fillText(box.name, 40, top - 5);
    });
  }

  // Update global toolbar
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;

    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Box-and-Whisker " + container.boxWhiskerID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    controls.appendChild(identityLabel);
    
    // Plot Properties button
    const plotPropsBtn = document.createElement("button");
    plotPropsBtn.textContent = "Plot Properties";
    plotPropsBtn.style.marginRight = "10px";
    plotPropsBtn.style.padding = "5px 10px";
    plotPropsBtn.style.cursor = "pointer";
    plotPropsBtn.addEventListener("click", function() {
      showPlotPropertiesDialog();
    });
    controls.appendChild(plotPropsBtn);
    
    // Number Line Settings button
    const numberLineBtn = document.createElement("button");
    numberLineBtn.textContent = "Number Line Settings";
    numberLineBtn.style.marginRight = "10px";
    numberLineBtn.style.padding = "5px 10px";
    numberLineBtn.style.cursor = "pointer";
    numberLineBtn.addEventListener("click", function() {
      showNumberLineDialog();
    });
    controls.appendChild(numberLineBtn);
    
    // Box Properties button
    const boxPropsBtn = document.createElement("button");
    boxPropsBtn.textContent = "Box Properties";
    boxPropsBtn.style.marginRight = "10px";
    boxPropsBtn.style.padding = "5px 10px";
    boxPropsBtn.style.cursor = "pointer";
    boxPropsBtn.addEventListener("click", function() {
      showBoxPropertiesDialog();
    });
    controls.appendChild(boxPropsBtn);
    
    globalToolbar.appendChild(controls);
  }
  
  // Plot Properties Dialog
  function showPlotPropertiesDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "300px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Plot Properties";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    // Plot title input
    const titleLabel = document.createElement("label");
    titleLabel.style.display = "flex";
    titleLabel.style.justifyContent = "space-between";
    titleLabel.style.alignItems = "center";
    titleLabel.style.marginBottom = "10px";
    titleLabel.innerHTML = "Title:";
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.value = container.boxWhiskerData.title;
    titleInput.style.width = "200px";
    titleInput.style.marginLeft = "10px";
    titleLabel.appendChild(titleInput);
    dialogBox.appendChild(titleLabel);
    
    // Font size input
    const fontLabel = document.createElement("label");
    fontLabel.style.display = "flex";
    fontLabel.style.justifyContent = "space-between";
    fontLabel.style.alignItems = "center";
    fontLabel.style.marginBottom = "10px";
    fontLabel.innerHTML = "Font Size:";
    const fontInput = document.createElement("input");
    fontInput.type = "number";
    fontInput.min = "10";
    fontInput.max = "36";
    fontInput.value = container.boxWhiskerData.titleFontSize;
    fontInput.style.width = "60px";
    fontInput.style.marginLeft = "10px";
    fontLabel.appendChild(fontInput);
    dialogBox.appendChild(fontLabel);
    
    // Box thickness input
    const thicknessLabel = document.createElement("label");
    thicknessLabel.style.display = "flex";
    thicknessLabel.style.justifyContent = "space-between";
    thicknessLabel.style.alignItems = "center";
    thicknessLabel.style.marginBottom = "10px";
    thicknessLabel.innerHTML = "Box Thickness:";
    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = container.boxWhiskerData.boxThickness;
    thicknessInput.style.width = "60px";
    thicknessInput.style.marginLeft = "10px";
    thicknessLabel.appendChild(thicknessInput);
    dialogBox.appendChild(thicknessLabel);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the box-and-whisker data
      container.boxWhiskerData.title = titleInput.value;
      container.boxWhiskerData.titleFontSize = parseInt(fontInput.value);
      container.boxWhiskerData.boxThickness = parseInt(thicknessInput.value);
      
      // Redraw the box-and-whisker plot
      drawBoxAndWhisker();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }
  
  // Number Line Settings Dialog
  function showNumberLineDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.minWidth = "300px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Number Line Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Min input
    const minLabel = document.createElement("label");
    minLabel.style.display = "flex";
    minLabel.style.justifyContent = "space-between";
    minLabel.style.alignItems = "center";
    minLabel.style.marginBottom = "10px";
    minLabel.innerHTML = "Min:";
    const minInput = document.createElement("input");
    minInput.type = "text";
    minInput.value = container.boxWhiskerData.numberLine.min;
    minInput.style.width = "100px";
    minInput.style.marginLeft = "10px";
    minLabel.appendChild(minInput);
    dialogBox.appendChild(minLabel);
    
    // Max input
    const maxLabel = document.createElement("label");
    maxLabel.style.display = "flex";
    maxLabel.style.justifyContent = "space-between";
    maxLabel.style.alignItems = "center";
    maxLabel.style.marginBottom = "10px";
    maxLabel.innerHTML = "Max:";
    const maxInput = document.createElement("input");
    maxInput.type = "text";
    maxInput.value = container.boxWhiskerData.numberLine.max;
    maxInput.style.width = "100px";
    maxInput.style.marginLeft = "10px";
    maxLabel.appendChild(maxInput);
    dialogBox.appendChild(maxLabel);
    
    // Tick interval input
    const tickLabel = document.createElement("label");
    tickLabel.style.display = "flex";
    tickLabel.style.justifyContent = "space-between";
    tickLabel.style.alignItems = "center";
    tickLabel.style.marginBottom = "10px";
    tickLabel.innerHTML = "Tick Interval:";
    const tickInput = document.createElement("input");
    tickInput.type = "text";
    tickInput.value = container.boxWhiskerData.numberLine.tickInterval;
    tickInput.style.width = "100px";
    tickInput.style.marginLeft = "10px";
    tickLabel.appendChild(tickInput);
    dialogBox.appendChild(tickLabel);
    
    // Label interval input
    const labelIntervalLabel = document.createElement("label");
    labelIntervalLabel.style.display = "flex";
    labelIntervalLabel.style.justifyContent = "space-between";
    labelIntervalLabel.style.alignItems = "center";
    labelIntervalLabel.style.marginBottom = "10px";
    labelIntervalLabel.innerHTML = "Label Interval:";
    const labelIntervalInput = document.createElement("input");
    labelIntervalInput.type = "text";
    labelIntervalInput.value = container.boxWhiskerData.numberLine.labelInterval;
    labelIntervalInput.style.width = "100px";
    labelIntervalInput.style.marginLeft = "10px";
    labelIntervalLabel.appendChild(labelIntervalInput);
    dialogBox.appendChild(labelIntervalLabel);
    
    // Axis label input
    const axisLabelLabel = document.createElement("label");
    axisLabelLabel.style.display = "flex";
    axisLabelLabel.style.justifyContent = "space-between";
    axisLabelLabel.style.alignItems = "center";
    axisLabelLabel.style.marginBottom = "10px";
    axisLabelLabel.innerHTML = "Axis Label:";
    const axisLabelInput = document.createElement("input");
    axisLabelInput.type = "text";
    axisLabelInput.value = container.boxWhiskerData.numberLine.axisLabel;
    axisLabelInput.style.width = "150px";
    axisLabelInput.style.marginLeft = "10px";
    axisLabelLabel.appendChild(axisLabelInput);
    dialogBox.appendChild(axisLabelLabel);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "15px";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Update the box-and-whisker data
      container.boxWhiskerData.numberLine.min = minInput.value;
      container.boxWhiskerData.numberLine.max = maxInput.value;
      container.boxWhiskerData.numberLine.tickInterval = tickInput.value;
      container.boxWhiskerData.numberLine.labelInterval = labelIntervalInput.value;
      container.boxWhiskerData.numberLine.axisLabel = axisLabelInput.value;
      
      // Redraw the box-and-whisker plot
      drawBoxAndWhisker();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      // Close the dialog without applying changes
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }
  
  // Box Properties Dialog
  function showBoxPropertiesDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "400px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Box Properties";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Create container for box forms
    const boxFormsContainer = document.createElement("div");
    boxFormsContainer.style.maxHeight = "60vh";
    boxFormsContainer.style.overflowY = "auto";
    boxFormsContainer.style.marginBottom = "15px";
    
    // Function to create a form for a box
    function createBoxForm(box, index) {
      const boxForm = document.createElement("div");
      boxForm.style.border = "1px solid #ddd";
      boxForm.style.padding = "10px";
      boxForm.style.marginBottom = "10px";
      boxForm.style.borderRadius = "4px";
      boxForm.style.position = "relative";
      
      const boxTitle = document.createElement("div");
      boxTitle.style.fontWeight = "bold";
      boxTitle.style.marginBottom = "8px";
      boxTitle.textContent = `Box ${index + 1}`;
      boxForm.appendChild(boxTitle);
      
      // Delete box button
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.style.position = "absolute";
      deleteBtn.style.top = "8px";
      deleteBtn.style.right = "8px";
      deleteBtn.style.padding = "2px 5px";
      deleteBtn.style.fontSize = "12px";
      deleteBtn.style.backgroundColor = "#e74c3c";
      deleteBtn.style.color = "white";
      deleteBtn.style.border = "none";
      deleteBtn.style.borderRadius = "3px";
      deleteBtn.style.cursor = "pointer";
      deleteBtn.dataset.boxIndex = index;
      boxForm.appendChild(deleteBtn);
      
      // Create inputs
      const fields = [
        { label: "Name", property: "name", value: box.name },
        { label: "Min", property: "min", value: box.min },
        { label: "Q1", property: "q1", value: box.q1 },
        { label: "Median", property: "med", value: box.med },
        { label: "Q3", property: "q3", value: box.q3 },
        { label: "Max", property: "max", value: box.max }
      ];
      
      fields.forEach(field => {
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.marginBottom = "5px";
        
        const label = document.createElement("label");
        label.textContent = field.label + ":";
        label.style.width = "80px";
        
        const input = document.createElement("input");
        input.type = "text";
        input.value = field.value;
        input.style.flexGrow = "1";
        input.dataset.property = field.property;
        input.dataset.boxIndex = index;
        
        row.appendChild(label);
        row.appendChild(input);
        boxForm.appendChild(row);
      });
      
      return boxForm;
    }
    
    // Create and add forms for each box
    container.boxWhiskerData.boxes.forEach((box, index) => {
      const boxForm = createBoxForm(box, index);
      boxFormsContainer.appendChild(boxForm);
    });
    
    dialogBox.appendChild(boxFormsContainer);
    
    // Add Box button
    const addBoxBtn = document.createElement("button");
    addBoxBtn.textContent = "Add Box";
    addBoxBtn.style.padding = "5px 10px";
    addBoxBtn.style.marginBottom = "15px";
    addBoxBtn.style.cursor = "pointer";
    dialogBox.appendChild(addBoxBtn);
    
    // Button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    
    // Apply button
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.marginLeft = "10px";
    applyButton.style.padding = "5px 15px";
    applyButton.style.cursor = "pointer";
    applyButton.addEventListener("click", function() {
      // Create a new array for the boxes
      const newBoxes = [];
      
      // Get all inputs by their data attributes
      const inputs = boxFormsContainer.querySelectorAll("input");
      let currentBoxData = {};
      let currentBoxIndex = -1;
      
      inputs.forEach(input => {
        const boxIndex = parseInt(input.dataset.boxIndex);
        const property = input.dataset.property;
        
        if (boxIndex !== currentBoxIndex) {
          // Save previous box data if any
          if (currentBoxIndex !== -1) {
            newBoxes.push(currentBoxData);
          }
          
          // Start a new box
          currentBoxIndex = boxIndex;
          currentBoxData = {
            id: boxIndex + 1,
            name: "",
            min: "",
            q1: "",
            med: "",
            q3: "",
            max: ""
          };
        }
        
        // Set property for current box
        if (property) {
          currentBoxData[property] = input.value;
        }
      });
      
      // Add the last box
      if (currentBoxIndex !== -1) {
        newBoxes.push(currentBoxData);
      }
      
      // Update the box-and-whisker data
      container.boxWhiskerData.boxes = newBoxes;
      
      // Redraw the box-and-whisker plot
      drawBoxAndWhisker();
      
      // Close the dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(applyButton);
    
    // Cancel button
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.marginLeft = "10px";
    cancelButton.style.padding = "5px 15px";
    cancelButton.style.cursor = "pointer";
    cancelButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    buttonContainer.appendChild(cancelButton);
    
    dialogBox.appendChild(buttonContainer);
    
    // Event listeners
    
    // Delete box button
    boxFormsContainer.addEventListener("click", function(e) {
      if (e.target.tagName === "BUTTON" && e.target.textContent === "Delete") {
        const boxIndex = parseInt(e.target.dataset.boxIndex);
        const boxForm = e.target.closest("div");
        
        // Remove the form
        boxFormsContainer.removeChild(boxForm);
        
        // Update indices for remaining forms
        const remainingForms = boxFormsContainer.querySelectorAll("div > div");
        let index = 0;
        
        remainingForms.forEach(form => {
          // Skip forms that are not box forms
          if (!form.querySelector("input[data-property]")) return;
          
          // Update title
          const titleElem = form.querySelector("div");
          if (titleElem) titleElem.textContent = `Box ${index + 1}`;
          
          // Update delete button index
          const deleteBtn = form.querySelector("button");
          if (deleteBtn) deleteBtn.dataset.boxIndex = index;
          
          // Update input indices
          const inputs = form.querySelectorAll("input");
          inputs.forEach(input => {
            if (input.dataset.boxIndex) {
              input.dataset.boxIndex = index;
            }
          });
          
          index++;
        });
      }
    });
    
    // Add box button
    addBoxBtn.addEventListener("click", function() {
      const boxCount = container.boxWhiskerData.boxes.length;
      const newBox = {
        id: boxCount + 1,
        name: `Box ${boxCount + 1}`,
        min: "2",
        q1: "3",
        med: "5",
        q3: "7",
        max: "9"
      };
      
      const boxForm = createBoxForm(newBox, boxCount);
      boxFormsContainer.appendChild(boxForm);
      
      // Scroll to the new box
      boxFormsContainer.scrollTop = boxFormsContainer.scrollHeight;
    });
    
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  // Key functions for activation
  function activateBoxWhisker() {
    // Deactivate the previously active element if any
    if (window.activeBoxWhiskerElement && window.activeBoxWhiskerElement !== container) {
      window.activeBoxWhiskerElement.style.border = "none";
      
      const prevToolbar = window.activeBoxWhiskerElement.querySelector(".box-whisker-toolbar");
      const prevResizeHandle = window.activeBoxWhiskerElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeBoxWhiskerElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivateBoxWhisker() {
    if (window.activeBoxWhiskerElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeBoxWhiskerElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteBoxWhisker() {
    if (window.activeBoxWhiskerElement === container) {
      window.activeBoxWhiskerElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateBoxWhisker();
    }
  });

  // Deletion: add both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteBoxWhisker();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteBoxWhisker();
  });

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    const aspectRatio = startWidth / startHeight;
    
    function onMouseMove(e) {
      // Calculate new width based on mouse position
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      // Maintain aspect ratio for height
      const newHeight = newWidth / aspectRatio;
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      drawBoxAndWhisker();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activeBoxWhiskerElement === container) {
      deactivateBoxWhisker();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Draw the initial box-and-whisker plot
  drawBoxAndWhisker();
  
  // Activate the box-and-whisker plot
  activateBoxWhisker();
}

function addLine() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 28;
  let nextElementOffset = 10;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + 
          (element.className.includes("line") ? "Line " : 
           element.className.includes("parallelogram") ? "Parallelogram " : 
           element.className.includes("polygon") ? "Polygon " : "Triangle ") + 
          element.lineID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeLineElement) {
    window.activeLineElement = null;
  }
  
  // Global counter for line IDs
  if (!window.globalLineCounter) {
    window.globalLineCounter = 1;
  } else {
    window.globalLineCounter++;
  }

  // Create the outer container for the line
  const container = document.createElement("div");
  container.className = "draggable-element line-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "300px";
  container.style.height = (toolbarHeight + 50) + "px"; // toolbar + content area
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  // Assign an ID for this line
  container.lineID = window.globalLineCounter;
  
  // Initialize state properties
  container.lineThickness = 2;
  container.lineColor = "#000000";
  container.lineStyle = "line";
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;

  // Create the local toolbar (visible by default)
  const localToolbar = document.createElement("div");
  localToolbar.className = "line-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div for the SVG
  const content = document.createElement("div");
  content.className = "line-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create the SVG element
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  const svgWidth = parseInt(container.style.width);
  const svgHeight = parseInt(container.style.height) - toolbarHeight;
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  
  // Create marker definitions
  function createLocalSVGMarkerDefs(svg, color) {
    color = color || "#000000";
    const svgNS = "http://www.w3.org/2000/svg";
    const defs = document.createElementNS(svgNS, "defs");
    
    // Arrow Marker End
    const arrowMarkerEnd = document.createElementNS(svgNS, "marker");
    arrowMarkerEnd.setAttribute("id", "arrowMarkerEnd");
    arrowMarkerEnd.setAttribute("markerWidth", "10");
    arrowMarkerEnd.setAttribute("markerHeight", "7");
    arrowMarkerEnd.setAttribute("refX", "10");
    arrowMarkerEnd.setAttribute("refY", "3.5");
    arrowMarkerEnd.setAttribute("orient", "auto");
    
    const arrowEndPath = document.createElementNS(svgNS, "path");
    arrowEndPath.setAttribute("d", "M0,0 L0,7 L10,3.5 Z");
    arrowEndPath.setAttribute("fill", color);
    arrowMarkerEnd.appendChild(arrowEndPath);
    defs.appendChild(arrowMarkerEnd);
    
    // Arrow Marker Start
    const arrowMarkerStart = document.createElementNS(svgNS, "marker");
    arrowMarkerStart.setAttribute("id", "arrowMarkerStart");
    arrowMarkerStart.setAttribute("markerWidth", "10");
    arrowMarkerStart.setAttribute("markerHeight", "7");
    arrowMarkerStart.setAttribute("refX", "0");
    arrowMarkerStart.setAttribute("refY", "3.5");
    arrowMarkerStart.setAttribute("orient", "auto");
    
    const arrowStartPath = document.createElementNS(svgNS, "path");
    arrowStartPath.setAttribute("d", "M10,0 L10,7 L0,3.5 Z");
    arrowStartPath.setAttribute("fill", color);
    arrowMarkerStart.appendChild(arrowStartPath);
    defs.appendChild(arrowMarkerStart);
    
    // Closed Circle Marker
    const closedCircleMarker = document.createElementNS(svgNS, "marker");
    closedCircleMarker.setAttribute("id", "closedCircleMarker");
    closedCircleMarker.setAttribute("markerWidth", "7");
    closedCircleMarker.setAttribute("markerHeight", "7");
    closedCircleMarker.setAttribute("refX", "3.5");
    closedCircleMarker.setAttribute("refY", "3.5");
    
    const closedCircle = document.createElementNS(svgNS, "circle");
    closedCircle.setAttribute("cx", "3.5");
    closedCircle.setAttribute("cy", "3.5");
    closedCircle.setAttribute("r", "3");
    closedCircle.setAttribute("fill", color);
    closedCircleMarker.appendChild(closedCircle);
    defs.appendChild(closedCircleMarker);
    
    // Open Circle Marker
    const openCircleMarker = document.createElementNS(svgNS, "marker");
    openCircleMarker.setAttribute("id", "openCircleMarker");
    openCircleMarker.setAttribute("markerWidth", "7");
    openCircleMarker.setAttribute("markerHeight", "7");
    openCircleMarker.setAttribute("refX", "3.5");
    openCircleMarker.setAttribute("refY", "3.5");
    
    const openCircle = document.createElementNS(svgNS, "circle");
    openCircle.setAttribute("cx", "3.5");
    openCircle.setAttribute("cy", "3.5");
    openCircle.setAttribute("r", "3");
    openCircle.setAttribute("fill", "white");
    openCircle.setAttribute("stroke", color);
    openCircle.setAttribute("stroke-width", "1");
    openCircleMarker.appendChild(openCircle);
    defs.appendChild(openCircleMarker);
    
    // Span Marker End
    const spanMarkerEnd = document.createElementNS(svgNS, "marker");
    spanMarkerEnd.setAttribute("id", "spanMarkerEnd");
    spanMarkerEnd.setAttribute("markerWidth", "5");
    spanMarkerEnd.setAttribute("markerHeight", "10");
    spanMarkerEnd.setAttribute("refX", "0");
    spanMarkerEnd.setAttribute("refY", "5");
    spanMarkerEnd.setAttribute("orient", "auto");
    
    const spanEndLine = document.createElementNS(svgNS, "line");
    spanEndLine.setAttribute("x1", "0");
    spanEndLine.setAttribute("y1", "0");
    spanEndLine.setAttribute("x2", "0");
    spanEndLine.setAttribute("y2", "10");
    spanEndLine.setAttribute("stroke", color);
    spanEndLine.setAttribute("stroke-width", "2");
    spanMarkerEnd.appendChild(spanEndLine);
    defs.appendChild(spanMarkerEnd);
    
    // Span Marker Start
    const spanMarkerStart = document.createElementNS(svgNS, "marker");
    spanMarkerStart.setAttribute("id", "spanMarkerStart");
    spanMarkerStart.setAttribute("markerWidth", "5");
    spanMarkerStart.setAttribute("markerHeight", "10");
    spanMarkerStart.setAttribute("refX", "5");
    spanMarkerStart.setAttribute("refY", "5");
    spanMarkerStart.setAttribute("orient", "auto");
    
    const spanStartLine = document.createElementNS(svgNS, "line");
    spanStartLine.setAttribute("x1", "5");
    spanStartLine.setAttribute("y1", "0");
    spanStartLine.setAttribute("x2", "5");
    spanStartLine.setAttribute("y2", "10");
    spanStartLine.setAttribute("stroke", color);
    spanStartLine.setAttribute("stroke-width", "2");
    spanMarkerStart.appendChild(spanStartLine);
    defs.appendChild(spanMarkerStart);
    
    svg.appendChild(defs);
  }
  
  createLocalSVGMarkerDefs(svg, container.lineColor);

  content.appendChild(svg);

  // Create the line element with default endpoints
  const line = document.createElementNS(svgNS, "line");
  line.setAttribute("x1", 10);
  line.setAttribute("y1", svgHeight / 2);
  line.setAttribute("x2", svgWidth - 10);
  line.setAttribute("y2", svgHeight / 2);
  line.setAttribute("stroke", container.lineColor);
  line.setAttribute("stroke-width", container.lineThickness);
  
  // Store initial relative coordinates for endpoints
  line.relX1 = 10 / svgWidth;
  line.relY1 = 0.5; // y1 is at 50% height
  line.relX2 = (svgWidth - 10) / svgWidth;
  line.relY2 = 0.5; // y2 is at 50% height
  
  svg.appendChild(line);

  // Save a reference to the line on the SVG element
  svg.currentLine = line;

  // Make the endpoints draggable
  if (typeof createDraggableEndpoints === 'function') {
    createDraggableEndpoints(svg);
  } else {
    makeEndpointsDraggable(svg);
  }

  // Helper function to convert hex to RGB
  function hexToRgb(hex) {
    hex = hex.replace(/^#/, '');
    const bigint = parseInt(hex, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r, g, b];
  }

  // Helper function to update marker colors
  function updateMarkerColors(color) {
    const defs = svg.querySelector("defs");
    if (!defs) return;
    
    // Remove old defs and create new ones with updated color
    svg.removeChild(defs);
    createLocalSVGMarkerDefs(svg, color);
    
    // Need to reapply the markers since IDs are now referring to new elements
    updateLineStyle();
  }

  // Function to update line style based on the selected style
  function updateLineStyle() {
    const style = container.lineStyle;
    line.removeAttribute("marker-start");
    line.removeAttribute("marker-end");
    line.removeAttribute("stroke-dasharray");

    switch(style) {
      case "line":
        break;
      case "line-dashed":
        line.setAttribute("stroke-dasharray", "5,3");
        break;
      case "line-arrow-both":
        line.setAttribute("marker-start", "url(#arrowMarkerStart)");
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "ray":
        line.setAttribute("marker-start", "url(#closedCircleMarker)");
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "ray-no-endpoint":
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "ray-circle-open":
        line.setAttribute("marker-start", "url(#openCircleMarker)");
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "segment":
        break;
      case "segment-points":
        line.setAttribute("marker-start", "url(#closedCircleMarker)");
        line.setAttribute("marker-end", "url(#closedCircleMarker)");
        break;
      case "segment-open-circles":
        line.setAttribute("marker-start", "url(#openCircleMarker)");
        line.setAttribute("marker-end", "url(#openCircleMarker)");
        break;
      case "segment-mixed-circles":
        line.setAttribute("marker-start", "url(#openCircleMarker)");
        line.setAttribute("marker-end", "url(#closedCircleMarker)");
        break;
      case "span-segment":
        // For span segment, add a marker only at the ends (vertical bar)
        line.setAttribute("marker-start", "url(#spanMarkerEnd)");
        line.setAttribute("marker-end", "url(#spanMarkerEnd)");
        break;
      case "span-segment-dashed":
        line.setAttribute("marker-start", "url(#spanMarkerStart)");
        line.setAttribute("marker-end", "url(#spanMarkerEnd)");
        line.setAttribute("stroke-dasharray", "5,3");
        break;
    }
  }

  // Helper functions to get current values
  function getLineColor() {
    return container.lineColor;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }
  
  function getLineStyle() {
    return container.lineStyle;
  }

  // Create resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  // Update global toolbar with line controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Line " + container.lineID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Color:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getLineColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      const newColor = this.value;
      container.lineColor = newColor;
      line.setAttribute("stroke", newColor);
      updateMarkerColors(newColor);
      if (svg.endpoint1) {
        svg.endpoint1.setAttribute("stroke", newColor);
        svg.endpoint1.setAttribute("fill", "rgba(" + hexToRgb(newColor).join(",") + ",0.5)");
      }
      if (svg.endpoint2) {
        svg.endpoint2.setAttribute("stroke", newColor);
        svg.endpoint2.setAttribute("fill", "rgba(" + hexToRgb(newColor).join(",") + ",0.5)");
      }
    });
    row1.appendChild(lineColorInput);

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Width:";
    thicknessLabel.style.fontSize = "12px";
    row1.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "10px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.lineThickness = parseInt(this.value);
      line.setAttribute("stroke-width", this.value);
    });
    row1.appendChild(thicknessInput);

    // Line style dropdown
    const styleLabel = document.createElement("span");
    styleLabel.textContent = "Style:";
    styleLabel.style.fontSize = "12px";
    row1.appendChild(styleLabel);

    const lineStyleSelect = document.createElement("select");
    lineStyleSelect.style.marginLeft = "5px";
    lineStyleSelect.style.marginRight = "10px";
    lineStyleSelect.style.width = "150px"; // Adjust width for longer text

    // Line styles
    const lineStyles = [
      { value: "line", text: "Line" },
      { value: "line-arrow-both", text: "Line with arrows" },
      { value: "line-dashed", text: "Dashed Line" },
      { value: "ray", text: "Ray with endpoint" },
      { value: "ray-no-endpoint", text: "Ray no endpoint" },
      { value: "ray-circle-open", text: "Ray with open circle" },
      { value: "segment", text: "Segment" },
      { value: "segment-points", text: "Segment with endpoints" },
      { value: "segment-open-circles", text: "Segment with open circle endpoints" },
      { value: "segment-mixed-circles", text: "Segment with mixed circle endpoints" },
      { value: "span-segment", text: "Span segment" },
      { value: "span-segment-dashed", text: "Dashed Span segment" }
    ];

    lineStyles.forEach(style => {
      const option = document.createElement("option");
      option.value = style.value;
      option.textContent = style.text;
      lineStyleSelect.appendChild(option);
    });
    
    lineStyleSelect.value = getLineStyle();
    lineStyleSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineStyleSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    lineStyleSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.lineStyle = this.value;
      updateLineStyle();
    });
    row1.appendChild(lineStyleSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Add some spacing
    const spacer = document.createElement("div");
    spacer.style.width = "20px";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.marginLeft = "10px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  function activateLine() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Store reference to the previously active element if it exists
    if (typeof activeElement !== 'undefined' && activeElement && activeElement !== container) {
      // If using the temporary raise function from the original code
      if (typeof restoreElementZIndex === 'function' && activeElement.dataset.tempRaised) {
        restoreElementZIndex(activeElement);
      }
      
      // Handle toolbar of the previous element
      if (activeElement.querySelector(".element-controls")) {
        activeElement.querySelector(".element-controls").style.display = "none";
      }
    }
    
    if (window.activeLineElement && window.activeLineElement !== container) {
      // Reset previous element's appearance
      window.activeLineElement.style.border = "none";
      const prevToolbar = window.activeLineElement.querySelector(".line-toolbar");
      const prevResizeHandle = window.activeLineElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
      
      // Hide endpoints of previous active line
      const prevSvg = window.activeLineElement.querySelector("svg");
      if (prevSvg && prevSvg.endpoint1) prevSvg.endpoint1.style.display = "none";
      if (prevSvg && prevSvg.endpoint2) prevSvg.endpoint2.style.display = "none";
    }
    
    window.activeLineElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    
    // Show line endpoints
    if (svg.endpoint1) svg.endpoint1.style.display = "block";
    if (svg.endpoint2) svg.endpoint2.style.display = "block";
    
    // Use the raise function from the original code if available
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  function deactivateLine() {
    // Don't deactivate if this element has focus lock
    if (window.activeLineElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      
      // Hide endpoints
      if (svg.endpoint1) svg.endpoint1.style.display = "none";
      if (svg.endpoint2) svg.endpoint2.style.display = "none";
      
      window.activeLineElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteLine() {
    if (window.activeLineElement === container) {
      window.activeLineElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Function to update line position based on relative coordinates
  function updateLinePosition() {
    const currentWidth = parseInt(svg.getAttribute("width"));
    const currentHeight = parseInt(svg.getAttribute("height"));
    
    // Calculate actual positions based on relative positions
    const x1 = Math.round(line.relX1 * currentWidth);
    const y1 = Math.round(line.relY1 * currentHeight);
    const x2 = Math.round(line.relX2 * currentWidth);
    const y2 = Math.round(line.relY2 * currentHeight);
    
    // Update the line
    line.setAttribute("x1", x1);
    line.setAttribute("y1", y1);
    line.setAttribute("x2", x2);
    line.setAttribute("y2", y2);
    
    // Update the endpoints if they exist
    if (svg.endpoint1) {
      svg.endpoint1.setAttribute("cx", x1);
      svg.endpoint1.setAttribute("cy", y1);
    }
    
    if (svg.endpoint2) {
      svg.endpoint2.setAttribute("cx", x2);
      svg.endpoint2.setAttribute("cy", y2);
    }
  }
  
  // Update endpoint position and relative coordinates
  function updateEndpointPosition(endpoint, newX, newY) {
    const currentWidth = parseInt(svg.getAttribute("width"));
    const currentHeight = parseInt(svg.getAttribute("height"));
    
    if (endpoint === svg.endpoint1) {
      line.setAttribute("x1", newX);
      line.setAttribute("y1", newY);
      
      // Update the relative positions
      line.relX1 = newX / currentWidth;
      line.relY1 = newY / currentHeight;
    } else if (endpoint === svg.endpoint2) {
      line.setAttribute("x2", newX);
      line.setAttribute("y2", newY);
      
      // Update the relative positions
      line.relX2 = newX / currentWidth;
      line.relY2 = newY / currentHeight;
    }
  }

  // Function to create draggable endpoints
  function makeEndpointsDraggable(svg) {
    const svgNS = "http://www.w3.org/2000/svg";
    const line = svg.currentLine;
    
    // Create endpoint 1
    const endpoint1 = document.createElementNS(svgNS, "circle");
    endpoint1.setAttribute("cx", line.getAttribute("x1"));
    endpoint1.setAttribute("cy", line.getAttribute("y1"));
    endpoint1.setAttribute("r", "6");
    endpoint1.setAttribute("stroke", container.lineColor);
    endpoint1.setAttribute("fill", "rgba(" + hexToRgb(container.lineColor).join(",") + ",0.5)");
    endpoint1.style.cursor = "move";
    endpoint1.style.display = "block";
    svg.appendChild(endpoint1);
    
    // Create endpoint 2
    const endpoint2 = document.createElementNS(svgNS, "circle");
    endpoint2.setAttribute("cx", line.getAttribute("x2"));
    endpoint2.setAttribute("cy", line.getAttribute("y2"));
    endpoint2.setAttribute("r", "6");
    endpoint2.setAttribute("stroke", container.lineColor);
    endpoint2.setAttribute("fill", "rgba(" + hexToRgb(container.lineColor).join(",") + ",0.5)");
    endpoint2.style.cursor = "move";
    endpoint2.style.display = "block";
    svg.appendChild(endpoint2);
    
    // Store references
    svg.endpoint1 = endpoint1;
    svg.endpoint2 = endpoint2;
    
    // Make endpoints draggable
    [endpoint1, endpoint2].forEach(endpoint => {
      endpoint.addEventListener("mousedown", function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const svgRect = svg.getBoundingClientRect();
        const startX = e.clientX;
        const startY = e.clientY;
        
        const initialCX = parseFloat(endpoint.getAttribute("cx"));
        const initialCY = parseFloat(endpoint.getAttribute("cy"));
        
        function onMouseMove(e) {
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          
          const newX = Math.max(0, Math.min(parseInt(svg.getAttribute("width")), initialCX + dx));
          const newY = Math.max(0, Math.min(parseInt(svg.getAttribute("height")), initialCY + dy));
          
          endpoint.setAttribute("cx", newX);
          endpoint.setAttribute("cy", newY);
          
          // Update line endpoint and relative positions
          updateEndpointPosition(endpoint, newX, newY);
        }
        
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    });
  }

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const newWidth = Math.max(150, startWidth + dx);
      const newHeight = Math.max(100, startHeight + dy);
      const newContentHeight = newHeight - toolbarHeight;
      
      // Update container dimensions
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      content.style.height = newContentHeight + "px";
      
      // Update SVG dimensions
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newContentHeight);
      svg.setAttribute("viewBox", `0 0 ${newWidth} ${newContentHeight}`);
      
      // Update line position using relative coordinates
      updateLinePosition();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Get canvas and container dimensions
    const canvasRect = canvas.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    // Calculate the offset of the mouse cursor relative to the container
    const offsetX = e.clientX - containerRect.left;
    const offsetY = e.clientY - containerRect.top;
    
    let isDragging = false;
    
    function onMouseMove(e) {
      isDragging = true;
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - offsetX - canvasRect.left;
      let newTop = e.clientY - offsetY - canvasRect.top;
      
      // Apply boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - containerRect.width;
      const minTop = -10; // Allow small overlap at top
      const maxTop = canvasRect.height - containerRect.height;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      // Apply the new position directly
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      
      if (isDragging && typeof ignoreNextClick !== 'undefined') {
        ignoreNextClick = true;
      }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Delete button events
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteLine();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteLine();
  });

  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateLine();
    }
  });
  
  // Handle hiding of controls globally if this was in the original code
  if (typeof hideAllControls === 'function') {
    document.addEventListener("click", function(e) {
      if (!container.contains(e.target)) {
        hideAllControls();
      }
    });
  }
  
  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeLineElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivateLine();
    }
  });

  // Initial update and activation
  updateLineStyle();
  activateLine();
  
  // Store original z-index if using z-index management from original code
  if (container.style.zIndex) {
    container.dataset.originalZ = container.style.zIndex;
  }
  
  // Append container to the canvas
  canvas.appendChild(container);
}


// --- Helper function: Create local marker definitions inside a given SVG ---
function createLocalSVGMarkerDefs(svg) {
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");

  // arrowMarkerEnd
  const arrowMarkerEnd = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  arrowMarkerEnd.setAttribute("id", "arrowMarkerEnd");
  arrowMarkerEnd.setAttribute("markerWidth", "10");
  arrowMarkerEnd.setAttribute("markerHeight", "7");
  arrowMarkerEnd.setAttribute("refX", "9");
  arrowMarkerEnd.setAttribute("refY", "3.5");
  arrowMarkerEnd.setAttribute("orient", "auto");
  arrowMarkerEnd.setAttribute("markerUnits", "strokeWidth");
  const arrowPathEnd = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  arrowPathEnd.setAttribute("points", "0 0, 10 3.5, 0 7");
  arrowPathEnd.setAttribute("fill", "#000000");
  arrowMarkerEnd.appendChild(arrowPathEnd);
  defs.appendChild(arrowMarkerEnd);

  // arrowMarkerStart
  const arrowMarkerStart = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  arrowMarkerStart.setAttribute("id", "arrowMarkerStart");
  arrowMarkerStart.setAttribute("markerWidth", "10");
  arrowMarkerStart.setAttribute("markerHeight", "7");
  arrowMarkerStart.setAttribute("refX", "1");
  arrowMarkerStart.setAttribute("refY", "3.5");
  arrowMarkerStart.setAttribute("orient", "auto");
  arrowMarkerStart.setAttribute("markerUnits", "strokeWidth");
  const arrowPathStart = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  arrowPathStart.setAttribute("points", "10 0, 0 3.5, 10 7");
  arrowPathStart.setAttribute("fill", "#000000");
  arrowMarkerStart.appendChild(arrowPathStart);
  defs.appendChild(arrowMarkerStart);

  // closedCircleMarker
  const closedCircleMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  closedCircleMarker.setAttribute("id", "closedCircleMarker");
  closedCircleMarker.setAttribute("markerWidth", "8");
  closedCircleMarker.setAttribute("markerHeight", "8");
  closedCircleMarker.setAttribute("refX", "4");
  closedCircleMarker.setAttribute("refY", "4");
  closedCircleMarker.setAttribute("orient", "auto");
  closedCircleMarker.setAttribute("markerUnits", "strokeWidth");
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", "4");
  circle.setAttribute("cy", "4");
  circle.setAttribute("r", "3");
  circle.setAttribute("fill", "#000000");
  closedCircleMarker.appendChild(circle);
  defs.appendChild(closedCircleMarker);

  // openCircleMarker
  const openCircleMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  openCircleMarker.setAttribute("id", "openCircleMarker");
  openCircleMarker.setAttribute("markerWidth", "8");
  openCircleMarker.setAttribute("markerHeight", "8");
  openCircleMarker.setAttribute("refX", "4");
  openCircleMarker.setAttribute("refY", "4");
  openCircleMarker.setAttribute("orient", "auto");
  openCircleMarker.setAttribute("markerUnits", "strokeWidth");
  const openCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  openCircle.setAttribute("cx", "4");
  openCircle.setAttribute("cy", "4");
  openCircle.setAttribute("r", "3");
  openCircle.setAttribute("fill", "white");
  openCircle.setAttribute("stroke", "#000000");
  openCircle.setAttribute("stroke-width", "1");
  openCircleMarker.appendChild(openCircle);
  defs.appendChild(openCircleMarker);

  // squareMarker
  const squareMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  squareMarker.setAttribute("id", "squareMarker");
  squareMarker.setAttribute("markerWidth", "8");
  squareMarker.setAttribute("markerHeight", "8");
  squareMarker.setAttribute("refX", "4");
  squareMarker.setAttribute("refY", "4");
  squareMarker.setAttribute("orient", "auto");
  squareMarker.setAttribute("markerUnits", "strokeWidth");
  const square = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  square.setAttribute("x", "1");
  square.setAttribute("y", "1");
  square.setAttribute("width", "6");
  square.setAttribute("height", "6");
  square.setAttribute("fill", "#000000");
  squareMarker.appendChild(square);
  defs.appendChild(squareMarker);

  // spanMarkerStart
  const spanMarkerStart = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  spanMarkerStart.setAttribute("id", "spanMarkerStart");
  spanMarkerStart.setAttribute("markerWidth", "4");
  spanMarkerStart.setAttribute("markerHeight", "10");
  spanMarkerStart.setAttribute("refX", "2");
  spanMarkerStart.setAttribute("refY", "5");
  spanMarkerStart.setAttribute("orient", "auto");
  spanMarkerStart.setAttribute("markerUnits", "strokeWidth");
  const spanLineStart = document.createElementNS("http://www.w3.org/2000/svg", "line");
  spanLineStart.setAttribute("x1", "2");
  spanLineStart.setAttribute("y1", "0");
  spanLineStart.setAttribute("x2", "2");
  spanLineStart.setAttribute("y2", "10");
  spanLineStart.setAttribute("stroke", "#000000");
  spanLineStart.setAttribute("stroke-width", "2");
  spanMarkerStart.appendChild(spanLineStart);
  defs.appendChild(spanMarkerStart);

  // spanMarkerEnd
  const spanMarkerEnd = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  spanMarkerEnd.setAttribute("id", "spanMarkerEnd");
  spanMarkerEnd.setAttribute("markerWidth", "4");
  spanMarkerEnd.setAttribute("markerHeight", "10");
  spanMarkerEnd.setAttribute("refX", "2");
  spanMarkerEnd.setAttribute("refY", "5");
  spanMarkerEnd.setAttribute("orient", "auto");
  spanMarkerEnd.setAttribute("markerUnits", "strokeWidth");
  const spanLineEnd = document.createElementNS("http://www.w3.org/2000/svg", "line");
  spanLineEnd.setAttribute("x1", "2");
  spanLineEnd.setAttribute("y1", "0");
  spanLineEnd.setAttribute("x2", "2");
  spanLineEnd.setAttribute("y2", "10");
  spanLineEnd.setAttribute("stroke", "#000000");
  spanLineEnd.setAttribute("stroke-width", "2");
  spanMarkerEnd.appendChild(spanLineEnd);
  defs.appendChild(spanMarkerEnd);

  svg.appendChild(defs);
}


// Helper function to convert hex color to RGB array
function hexToRgb(hex) {
  // Remove # if present
  hex = hex.replace(/^#/, '');
  
  // Parse the hex values
  let r, g, b;
  if (hex.length === 3) {
    // 3-digit hex
    r = parseInt(hex.charAt(0) + hex.charAt(0), 16);
    g = parseInt(hex.charAt(1) + hex.charAt(1), 16);
    b = parseInt(hex.charAt(2) + hex.charAt(2), 16);
  } else {
    // 6-digit hex
    r = parseInt(hex.substring(0, 2), 16);
    g = parseInt(hex.substring(2, 4), 16);
    b = parseInt(hex.substring(4, 6), 16);
  }
  
  return [r, g, b];
}

function updateMarkerColors(color) {
  const markerIds = ["arrowMarkerEnd", "arrowMarkerStart", "squareMarker", "closedCircleMarker"];
  
  markerIds.forEach(id => {
    const marker = document.getElementById(id);
    if (marker) {
      const elements = marker.querySelectorAll("*");
      elements.forEach(el => {
        if (el.hasAttribute("fill") && el.getAttribute("fill") !== "white") {
          el.setAttribute("fill", color);
        }
      });
    }
  });
  
  // For open circle marker, we only change the stroke
  const openCircleMarker = document.getElementById("openCircleMarker");
  if (openCircleMarker) {
    const circle = openCircleMarker.querySelector("circle");
    if (circle) {
      circle.setAttribute("stroke", color);
    }
  }
  
  // For span markers, update the stroke color
  const spanMarkerIds = ["spanMarkerStart", "spanMarkerEnd"];
  spanMarkerIds.forEach(id => {
    const marker = document.getElementById(id);
    if (marker) {
      const lines = marker.querySelectorAll("line");
      lines.forEach(line => {
        line.setAttribute("stroke", color);
      });
    }
  });
}


// --- Function to add image via file input ---
// Function to show a modal drop-zone / upload area for images.
function showImageUploadModal(callback) {
  // Create the overlay.
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  overlay.style.zIndex = "10000";

  // Create the modal container.
  const modal = document.createElement("div");
  modal.style.backgroundColor = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "5px";
  modal.style.textAlign = "center";
  modal.style.width = "300px";
  modal.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
  
  // Create the drop zone.
  const dropZone = document.createElement("div");
  dropZone.style.border = "2px dashed #ccc";
  dropZone.style.borderRadius = "5px";
  dropZone.style.padding = "20px";
  dropZone.style.marginBottom = "10px";
  dropZone.style.cursor = "pointer";
  dropZone.innerHTML = "Drag & drop your image here";
  
  // Create the upload button.
  const uploadBtn = document.createElement("button");
  uploadBtn.innerText = "Upload Image";
  uploadBtn.style.marginRight = "10px";
  
  // Create the cancel button.
  const cancelBtn = document.createElement("button");
  cancelBtn.innerText = "Cancel";
  
  // Assemble the modal.
  modal.appendChild(dropZone);
  modal.appendChild(uploadBtn);
  modal.appendChild(cancelBtn);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // Create a hidden file input.
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = "image/*";
  fileInput.style.display = "none";
  document.body.appendChild(fileInput);

  // Helper to process the image file.
  function handleFile(file) {
    if (file && file.type.startsWith("image/")) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const dataURL = e.target.result;
        callback(dataURL);
        cleanup();
      };
      reader.readAsDataURL(file);
    } else {
      alert("Please upload a valid image file.");
    }
  }
  
  // File input change event.
  fileInput.addEventListener("change", function(e) {
    const file = e.target.files[0];
    handleFile(file);
  });
  
  // When the upload button is clicked, trigger the file input.
  uploadBtn.addEventListener("click", function(e) {
    fileInput.click();
  });
  
  // Cancel button removes the modal.
  cancelBtn.addEventListener("click", function(e) {
    cleanup();
  });
  
  // Drag and drop events on the drop zone.
  dropZone.addEventListener("dragover", function(e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "#f0f0f0";
  });
  
  dropZone.addEventListener("dragleave", function(e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "";
  });
  
  dropZone.addEventListener("drop", function(e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "";
    const dt = e.dataTransfer;
    if (dt && dt.files && dt.files.length > 0) {
      const file = dt.files[0];
      handleFile(file);
    }
  });
  
  // Cleanup function to remove the modal and file input.
  function cleanup() {
    if (overlay.parentNode) {
      overlay.parentNode.removeChild(overlay);
    }
    if (fileInput.parentNode) {
      fileInput.parentNode.removeChild(fileInput);
    }
  }
}

// --- Function to integrate the uploaded image into the canvas ---

function insertUploadedImage(dataURL) {
  const imgObj = new Image();
  imgObj.onload = function() {
    // Get the original dimensions.
    let origWidth = imgObj.naturalWidth;
    let origHeight = imgObj.naturalHeight;
    
    // Determine maximum allowed dimensions from your problem image settings.
    const problemWidthInput = document.getElementById("problem-width");
    const problemHeightInput = document.getElementById("problem-height");
    const maxWidth = problemWidthInput ? parseInt(problemWidthInput.value) : 600;
    const maxHeight = problemHeightInput ? parseInt(problemHeightInput.value) : 300;
    
    // If the uploaded image is larger than the problem canvas, scale it down.
    let scale = 1;
    if (origWidth > maxWidth || origHeight > maxHeight) {
      scale = Math.min(maxWidth / origWidth, maxHeight / origHeight);
      origWidth = origWidth * scale;
      origHeight = origHeight * scale;
    }
    
    // Create an <img> tag that fills its container and disables pointer events.
    const imgHTML = `<img src="${dataURL}" style="width:100%; height:100%; object-fit: contain; pointer-events: none;">`;
    
    // Create the container using your helper function.
    const container = createDraggableElement(imgHTML, false);
    container.style.width = origWidth + "px";
    container.style.height = origHeight + "px";
    // Ensure overflow is visible so the resize handle is not clipped.
    container.style.overflow = "visible";
    
    // Remove any default toolbar from the container.
    const defaultToolbar = container.querySelector('.element-controls');
    if (defaultToolbar) {
      defaultToolbar.remove();
    }
    
    // Append the container to the problem canvas.
    const canvas = document.getElementById("problem-canvas");
    canvas.appendChild(container);
    
    // Create a custom toolbar for the image.
    const toolbar = document.createElement("div");
    toolbar.className = "image-toolbar element-controls";
    toolbar.style.position = "absolute";
    toolbar.style.top = "0";
    toolbar.style.left = "0";
    toolbar.style.width = "100%";
    toolbar.style.zIndex = "10001"; // High z-index so it stays above the image.
    toolbar.style.display = "none"; // Hidden by default.
    toolbar.style.flexDirection = "row";
    toolbar.style.alignItems = "center";
    toolbar.style.justifyContent = "flex-start";
    toolbar.style.background = "rgba(240,240,240,0.8)";
    toolbar.style.pointerEvents = "auto";
    
    // Create a move (drag) handle.
    const moveHandle = document.createElement("span");
    moveHandle.className = "drag-handle";
    moveHandle.style.cursor = "move";
    moveHandle.style.padding = "2px 4px";
    moveHandle.style.background = "#ccc";
    moveHandle.textContent = "☰";
    toolbar.appendChild(moveHandle);
    makeDraggable(moveHandle, container);
    
    // Append the custom toolbar to the container.
    container.appendChild(toolbar);
    
    // Create a resize handle (blue box) that will always stay at the bottom-right.
    const resizeHandle = document.createElement("div");
    resizeHandle.className = "resize-handle";
    resizeHandle.style.position = "absolute";
    resizeHandle.style.width = "10px";
    resizeHandle.style.height = "10px";
    resizeHandle.style.backgroundColor = "blue";
    resizeHandle.style.right = "0";
    resizeHandle.style.bottom = "0";
    resizeHandle.style.cursor = "se-resize";
    resizeHandle.style.zIndex = "10002"; // Above the toolbar.
    // Prevent text selection on the resize handle.
    resizeHandle.style.userSelect = "none";
    container.appendChild(resizeHandle);
    
    resizeHandle.addEventListener("mousedown", function(e) {
      e.preventDefault();
      e.stopPropagation();
      const startX = e.clientX, startY = e.clientY;
      const startWidth = container.offsetWidth;
      const startHeight = container.offsetHeight;
      function onMouseMove(e) {
        let newWidth = startWidth + (e.clientX - startX);
        let newHeight = startHeight + (e.clientY - startY);
        if (newWidth > 10) container.style.width = newWidth + "px";
        if (newHeight > 10) container.style.height = newHeight + "px";
        // The resize handle remains pinned at bottom-right due to its CSS.
      }
      function onMouseUp(e) {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
    
    // Make the container focusable.
    container.setAttribute("tabindex", "0");
    
    // Container click event: mimic addTriangle behavior.
    container.addEventListener("click", function(e) {
      e.stopPropagation();
      // Hide toolbars from all other draggable elements.
      document.querySelectorAll('.element-controls').forEach(ctrl => ctrl.style.display = "none");
      // Show this container's toolbar.
      toolbar.style.display = "flex";
      activeElement = container;
      raiseElementTemporarily(container);
      // Apply a blue outline as a highlight.
      container.style.outline = "2px solid #00aaff";
      container.focus();
    });
    
    // Reapply highlight on focus.
    container.addEventListener("focus", function(e) {
      container.style.outline = "2px solid #00aaff";
    });
  };
  imgObj.src = dataURL;
}



// --- New "Add Image" function to be called from the toolbar ---
function addImageViaModal() {
  showImageUploadModal(insertUploadedImage);
}

document.addEventListener("keydown", function(e) {
  if (e.key === "Backspace" && activeElement && activeElement.classList.contains('draggable-element')) {
    // Check if the active element is not a text box in edit mode
    const textBox = activeElement.querySelector('.text-box[contenteditable="true"]:focus');
    if (!textBox) { // Only delete if not editing text
      e.preventDefault(); // Prevent default Backspace behavior (e.g., browser navigation)
      activeElement.remove();
      activeElement = null; // Clear the active element
    }
  }
});

// Function to add an image element from code.
function addImageWithCode() {
  showImageCodeModal(
    // Default template
    "<svg id='dynamicImage' width='300' height='300' viewBox='-50 -50 100 100' xmlns='http://www.w3.org/2000/svg'>\n" +
    "  <line x1='-50' y1='0' x2='50' y2='0' stroke='black' stroke-width='0.5'/>\n" +
    "  <line x1='0' y1='-50' x2='0' y2='50' stroke='black' stroke-width='0.5'/>\n" +
    "  <circle id='point' cx='0' cy='{a:plain}' r='5' fill='red'/>\n" +
    "  <text id='pointLabel' x='0' y='{a:plain}' dy='-10' font-size='10' text-anchor='middle'>(0, {a:plain})</text>\n" +
    "</svg>",
    function(code) {
      if (!code) return; // Do nothing if canceled
      
const canvas = document.getElementById("problem-canvas");
const container = createDraggableElement(code, false);
container.dataset.imageCode = code;
container.dataset.originalImageCode = code;

// Instead of reading the values from inputs, set them explicitly to 200px.
container.style.width = "300px";
container.style.height = "300px";

canvas.appendChild(container);

// Update immediately using the fresh template
updateImageCodeElement(container);


    }
  );
}

// Make sure the function is available globally:
window.addImageWithCode = addImageWithCode;

// Attach addImageWithCode to the global window so it’s available in onclick attributes.
window.addImageWithCode = addImageWithCode;

function addImageWithCodeToAnswerOption(parent) {
  showImageCodeModal(
    "<svg id='dynamicImage' width='300' height='300' viewBox='-50 -50 100 100' xmlns='http://www.w3.org/2000/svg'>\n" +
    "  <line x1='-50' y1='0' x2='50' y2='0' stroke='black' stroke-width='0.5'/>\n" +
    "  <line x1='0' y1='-50' x2='0' y2='50' stroke='black' stroke-width='0.5'/>\n" +
    "  <circle id='point' cx='0' cy='{a:plain}' r='5' fill='red'/>\n" +
    "  <text id='pointLabel' x='0' y='{a:plain}' dy='-10' font-size='10' text-anchor='middle'>(0, {a:plain})</text>\n" +
    "</svg>",
    function(code) {
      if (!code) return;
      
      // Ensure the answer option container is relatively positioned.
      parent.style.position = "relative";
      
      // Create the container for the image.
      let container = document.createElement("div");
      container.className = "draggable-answer-image";
      container.setAttribute("contentEditable", "false");
      container.style.display = "inline-block";
      container.style.position = "relative";
      container.style.width = "300px";
      container.style.height = "300px";
      container.dataset.imageCode = code;
      container.dataset.originalImageCode = code;
      
      // Create inner content to hold the SVG.
      let contentDiv = document.createElement("div");
      contentDiv.className = "element-content";
      contentDiv.innerHTML = code;
      contentDiv.setAttribute("contentEditable", "false");
      container.appendChild(contentDiv);
      
      // Create a drag handle.
      let dragHandle = document.createElement("div");
      dragHandle.className = "drag-handle";
      dragHandle.innerHTML = "&#9776;";
      dragHandle.style.position = "absolute";
      dragHandle.style.top = "0";
      dragHandle.style.left = "0";
      dragHandle.style.cursor = "move";
      container.appendChild(dragHandle);
      
      // Drag event handler (updates margins so it stays in flow).
      dragHandle.addEventListener("mousedown", function(e) {
        e.preventDefault();
        let startX = e.clientX, startY = e.clientY;
        let origMarginLeft = parseInt(window.getComputedStyle(container).marginLeft) || 0;
        let origMarginTop = parseInt(window.getComputedStyle(container).marginTop) || 0;
        function onMouseMove(e) {
          let dx = e.clientX - startX, dy = e.clientY - startY;
          container.style.marginLeft = (origMarginLeft + dx) + "px";
          container.style.marginTop = (origMarginTop + dy) + "px";
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
      
      // Create a resize handle.
      let resizeHandle = document.createElement("div");
      resizeHandle.className = "resize-handle";
      resizeHandle.style.position = "absolute";
      resizeHandle.style.right = "0";
      resizeHandle.style.bottom = "0";
      container.appendChild(resizeHandle);
      
      resizeHandle.addEventListener("mousedown", function(e) {
        e.preventDefault();
        let startX = e.clientX, startY = e.clientY;
        let startWidth = container.offsetWidth, startHeight = container.offsetHeight;
        function onMouseMove(e) {
          let newWidth = startWidth + (e.clientX - startX);
          let newHeight = startHeight + (e.clientY - startY);
          if (newWidth > 10) container.style.width = newWidth + "px";
          if (newHeight > 10) container.style.height = newHeight + "px";
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });

      // Add a delete button.
      let deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete Image";
      deleteBtn.className = "delete-image"; // Unique class for targeting
      deleteBtn.style.fontSize = "10px";
      deleteBtn.style.position = "absolute";
      deleteBtn.style.top = "0";
      deleteBtn.style.right = "0";
      deleteBtn.style.pointerEvents = "auto";
      deleteBtn.onclick = function(e) {
        e.stopPropagation();
        container.remove();
      };
      container.appendChild(deleteBtn);
      
      // Update the SVG content.
      updateImageCodeElement(container);
      
      // Append the container to the answer option.
      parent.appendChild(container);
    }
  );
}



// (Optional) Function to edit image code later.
function editImageCode(container) {
  const currentCode = container.dataset.imageCode || container.querySelector('.element-content').innerHTML;
  showImageCodeModal(currentCode, function(newCode) {
    if (!newCode) return;
    container.dataset.imageCode = newCode;
    container.dataset.originalImageCode = newCode; // Update the original code too
    container.querySelector('.element-content').innerHTML = newCode;
  });
}

// Helper function to shuffle an array (Fisher–Yates shuffle)
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
// Returns the current variable mode ("ui" or "code")
function getVariableMode() {
  let modeRadio = document.querySelector('input[name="variable-mode"]:checked');
  return modeRadio ? modeRadio.value : "ui";
}

// Updates the variable section display based on the selected mode
function updateVariableModeUI() {
  let mode = getVariableMode();
  if (mode === "code") {
    document.getElementById("variable-ui-container").style.display = "none";
    document.getElementById("variable-code-container").style.display = "block";
  } else {
    document.getElementById("variable-ui-container").style.display = "block";
    document.getElementById("variable-code-container").style.display = "none";
  }
  updateVariables();
}

// Attach change listeners to the mode radio buttons
document.querySelectorAll('input[name="variable-mode"]').forEach(radio => {
  radio.addEventListener("change", updateVariableModeUI);
});

function computeAnswerOptions(computedVars) {
  let options = [];
  const correctContainer = document.getElementById("mc-correct");
  const incorrectContainer = document.getElementById("mc-incorrect");

  function processOption(optionNode, isCorrect) {
    // Clone the option so we don’t affect the editor.
    let cloneOption = optionNode.cloneNode(true);

    // Remove editing controls (toolbar, graph/table buttons, etc.).
    let editors = cloneOption.querySelectorAll(".mc-option-toolbar, .edit-graph, .delete-graph, .edit-table, .delete-table");
    editors.forEach(el => el.remove());

    // Remove the required checkbox container.
    let reqContainers = cloneOption.querySelectorAll(".option-required-edit");
    reqContainers.forEach(el => el.remove());

    // Handle text boxes: remove toolbar and outline.
    let textBoxes = cloneOption.querySelectorAll(".draggable-text-box");
    textBoxes.forEach(textBox => {
      let toolbar = textBox.querySelector(".answer-text-toolbar");
      if (toolbar) toolbar.remove();
      let resizeHandle = textBox.querySelector(".resize-handle");
      if (resizeHandle) resizeHandle.remove();
      let textArea = textBox.querySelector(".text-box");
      if (textArea) {
        textArea.style.border = "none";
        textArea.style.outline = "none";
        textArea.contentEditable = false;
      }
      textBox.style.border = "none";
      textBox.style.background = "transparent";
      textBox.style.marginLeft = "0";
    });

    // Handle images with code: remove drag handle, resize handle, and delete button.
    let imageContainers = cloneOption.querySelectorAll(".draggable-answer-image");
    imageContainers.forEach(imageContainer => {
      // Remove drag handle.
      let dragHandle = imageContainer.querySelector(".drag-handle");
      if (dragHandle) dragHandle.remove();

      // Remove resize handle.
      let resizeHandle = imageContainer.querySelector(".resize-handle");
      if (resizeHandle) resizeHandle.remove();

      // Remove delete button.
      let deleteBtn = imageContainer.querySelector(".delete-image");
      if (deleteBtn) deleteBtn.remove();

      // Update the SVG with computed variables and clean up styling.
      updateImageCodeElement(imageContainer, computedVars);
      imageContainer.style.border = "none";
      imageContainer.style.background = "transparent";
      imageContainer.contentEditable = false;
    });

    // Process rich content if present.
    let graphElem = cloneOption.querySelector(".answer-graph");
    if (graphElem) {
      updateGraphInAnswerOption(graphElem, computedVars);
      let graphBtns = graphElem.querySelectorAll("button.edit-graph, button.delete-graph");
      graphBtns.forEach(btn => btn.remove());
      options.push({ 
        html: graphElem.outerHTML, 
        correct: isCorrect, 
        required: optionNode.getAttribute("data-required") === "true" 
      });
    } else {
      let contentHTML = substituteValue(cloneOption.innerHTML, computedVars);
      options.push({ 
        html: contentHTML, 
        correct: isCorrect, 
        required: optionNode.getAttribute("data-required") === "true" 
      });
    }
  }

  // Process all answer options.
  correctContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, true));
  incorrectContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, false));

  // Get global settings.
  let totalOptions = parseInt(document.getElementById("mc-total-options").value) || options.length;
  let correctMin = parseInt(document.getElementById("mc-correct-min").value) || 0;
  let correctMax = parseInt(document.getElementById("mc-correct-max").value) || 0;

  // Separate options into groups.
  let reqCorrect = options.filter(opt => opt.correct && opt.required);
  let optCorrect = options.filter(opt => opt.correct && !opt.required);
  let reqIncorrect = options.filter(opt => !opt.correct && opt.required);
  let optIncorrect = options.filter(opt => !opt.correct && !opt.required);

  // Randomly choose a number of correct options within the given range.
  let numCorrectDesired = correctMin;
  if (correctMax > correctMin) {
    numCorrectDesired = Math.floor(Math.random() * (correctMax - correctMin + 1)) + correctMin;
  }

  // Build final correct options.
  let selectedCorrect = reqCorrect.slice();
  let additionalCorrectNeeded = numCorrectDesired - selectedCorrect.length;
  if (additionalCorrectNeeded > 0) {
    let shuffledOptCorrect = shuffleArray(optCorrect.slice());
    selectedCorrect = selectedCorrect.concat(shuffledOptCorrect.slice(0, additionalCorrectNeeded));
  }

  // Determine number of incorrect options needed.
  let numIncorrectDesired = totalOptions - selectedCorrect.length;
  let selectedIncorrect = reqIncorrect.slice();
  let additionalIncorrectNeeded = numIncorrectDesired - selectedIncorrect.length;
  if (additionalIncorrectNeeded > 0) {
    let shuffledOptIncorrect = shuffleArray(optIncorrect.slice());
    selectedIncorrect = selectedIncorrect.concat(shuffledOptIncorrect.slice(0, additionalIncorrectNeeded));
  }

  // Combine and shuffle final options.
  let finalOptions = selectedCorrect.concat(selectedIncorrect);
  finalOptions = shuffleArray(finalOptions);
  window.currentAnswerOptions = finalOptions;
  return finalOptions;
}

function exitOnArrowRight(e) {
  if (e.key === "ArrowRight") {
    // Get the current selection and range
    const sel = window.getSelection();
    if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    const target = e.target;
    
    // Check if the caret is at the end of the element's text content
    if (range.endOffset >= target.textContent.length) {
      // Insert a space (or empty text node) after the current element
      let space = document.createTextNode(" ");
      target.parentNode.insertBefore(space, target.nextSibling);
      
      // Move the caret after the space
      range.setStartAfter(space);
      range.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range);
      e.preventDefault();
    }
  }
}
// Generates an interactive quiz (as HTML) based on the current answer configuration.
function generateAnswerQuiz(computedVars) {
  const answerType = document.getElementById("answer-type").value;
  let container = document.createElement("div");
  container.className = "answer-quiz";
  container.style.marginTop = "10px";

  if (answerType === "box") {
    // For answer boxes, do not display the correct answer in the preview.
    // (We compute it for possible use elsewhere but do not show it here.)
    let correctAns = substituteValue(document.getElementById("correct-answer").value, computedVars);
    let labelText = substituteValue(document.getElementById("label-text").value, computedVars);
    let labelPosition = document.getElementById("label-position").value;

    let inputBox = document.createElement("input");
    inputBox.type = "text";
    inputBox.style.width = "300px";
    // Instead of setting the placeholder to the correct answer, leave it empty or use a generic prompt.
    inputBox.placeholder = ""; // or you can use "Your Answer" if you prefer

    if (labelText && labelPosition === "before") {
      let label = document.createElement("span");
      label.textContent = labelText + " ";
      container.appendChild(label);
      container.appendChild(inputBox);
    } else if (labelText && labelPosition === "after") {
      container.appendChild(inputBox);
      let label = document.createElement("span");
      label.textContent = " " + labelText;
      container.appendChild(label);
    } else {
      container.appendChild(inputBox);
    }
  } else if (answerType === "multiple" || answerType === "multi-select") {
    // For multiple choice / multi-select, render each option on its own line.
    let options = window.currentAnswerOptions || computeAnswerOptions(computedVars);
    let form = document.createElement("form");
    let inputType = (answerType === "multiple") ? "radio" : "checkbox";
    let letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    options.forEach((option, index) => {
      let wrapper = document.createElement("div");
      // Each option appears on its own line.
      wrapper.style.display = "block";
      wrapper.style.marginBottom = "5px";

      let input = document.createElement("input");
      input.type = inputType;
      input.name = "quizOption";
      input.value = index;

      let optionLabel = document.createElement("label");
      // Build the label with the answer letter and the option content on the same line.
      optionLabel.innerHTML = "<span style='display:inline-block; vertical-align:middle;'>" + letters[index] + ". </span>" +
                              "<span style='display:inline-block; vertical-align:middle;'>" + option.html + "</span>";
      optionLabel.style.marginLeft = "5px";
      optionLabel.style.display = "inline-block";
      optionLabel.style.verticalAlign = "middle";

      wrapper.appendChild(input);
      wrapper.appendChild(optionLabel);
      form.appendChild(wrapper);
    });
    container.appendChild(form);
  }

  return container;
}

// Helper for "choose from list" (words)
function chooseFromWordList() {
  var args = Array.prototype.slice.call(arguments);
  if (args.length === 0) return "";
  return args[Math.floor(Math.random() * args.length)];
}

// Helper for "choose from list" (numbers)
function chooseFromNumberList() {
  var args = Array.prototype.slice.call(arguments);
  if (args.length === 0) return "";
  return args[Math.floor(Math.random() * args.length)];
}
// Helper for computing the greatest common divisor (already in your code)
function gcd(a, b) { return b ? gcd(b, a % b) : a; }

// ------------------ Fraction Helpers ------------------

// Returns an unreduced fraction string.
function unreducedfraction(num, denom) {
  return num + "/" + denom;
}

// Returns a reduced fraction string (improper fraction) by dividing numerator and denominator by their gcd.
function reduceFraction(num, denom) {
  let g = gcd(num, denom);
  return (num / g) + "/" + (denom / g);
}

// Returns a mixed fraction string.
// If the fraction is proper, it returns "whole remainder/denom" (with the fractional part reduced).
function mixedFraction(num, denom) {
  let whole = Math.floor(num / denom);
  let remainder = num % denom;
  if (remainder === 0) {
    return whole.toString();
  }
  let g = gcd(remainder, denom);
  return whole + " " + (remainder / g) + "/" + (denom / g);
}

// ------------------ Arranging Helpers ------------------

// Takes a comma-separated string (e.g., "1, 4, 2") and returns a comma-separated string arranged in ascending order.
function arrangeAscending(list) {
  let arr = list.split(",").map(item => item.trim());
  // If all elements can be converted to numbers, sort numerically.
  if (arr.every(x => !isNaN(x) && x !== "")) {
    arr = arr.map(Number).sort((a, b) => a - b);
  } else {
    arr.sort();
  }
  return arr.join(", ");
}

// Takes a comma-separated string and returns it arranged in descending order.
function arrangeDescending(list) {
  let arr = list.split(",").map(item => item.trim());
  if (arr.every(x => !isNaN(x) && x !== "")) {
    arr = arr.map(Number).sort((a, b) => b - a);
  } else {
    arr.sort().reverse();
  }
  return arr.join(", ");
}
/******** Utility Functions ********/
// Formats fractions if the string is in "num/den" format.
function formatFraction(fracStr) {
  let match = fracStr.match(/^(\d+(?:\.\d+)?)\/(\d+(?:\.\d+)?)$/);
  if (match) {
    // If the denominator is 1, just return the numerator.
    if (parseFloat(match[2]) === 1) {
      return match[1];
    }
    return `<span class="fraction"><span class="num">${match[1]}</span><span class="den">${match[2]}</span></span>`;
  }
  return fracStr;
}
function formatUsingFractionJS(fracStr) {
  try {
    let f = new Fraction(fracStr);
    // If the denominator is 1, return just the numerator.
    if (f.d === 1) {
      return f.n.toString();
    }
    return f.toFraction();
  } catch (e) {
    console.error("Invalid fraction", fracStr);
    return fracStr;
  }
}


// Substitutes {variable} placeholders using values from computed object.
function substituteValue(original, computedVars) {
  if (!original || typeof original !== 'string') return original;
  
  // Replace #variable# patterns with their computed values
  let result = original.replace(/#([^#\s]+)#/g, (match, variableName) => {
    // Look up the variable directly by name without the # symbols
    if (computedVars[variableName] !== undefined) {
      return computedVars[variableName];
    }
    return match; // Keep original if no value found
  });
  
  // For backward compatibility, also replace {variable} patterns
  result = result.replace(/\{([^}]+)\}/g, (match, variableName) => {
    const normalizedName = normalizeVariable(variableName.trim());
    if (computedVars[normalizedName] !== undefined) {
      return computedVars[normalizedName];
    }
    return match;
  });
  
  return result;
}

function updateImageCodeElement(container, computedVars) {
  // Use the stored original template code (with placeholders)
  var rawCode = container.dataset.originalImageCode;
  if (!rawCode) return;
  
  if (!computedVars) {
    computedVars = computeAllVariables();
  }
  
  var substitutedCode = substituteValue(rawCode, computedVars);
  
  var parser = new DOMParser();
  var doc = parser.parseFromString(substitutedCode, "image/svg+xml");
  var newSVG = doc.documentElement;
  
  var contentDiv = container.querySelector(".element-content");
  if (contentDiv) {
    contentDiv.innerHTML = "";
    contentDiv.appendChild(newSVG);
  }
}

// Parses a graph equation string into a function f(x)
function parseEquation(eqStr) {
  eqStr = eqStr.trim();
  if (eqStr.toLowerCase().startsWith("y=")) { eqStr = eqStr.substring(2); }
  eqStr = eqStr.replace(/(\d)([a-zA-Z\(])/g, '$1*$2');
  eqStr = eqStr.replace(/\)([a-zA-Z])/g, ')*$1');
  eqStr = eqStr.replace(/([a-zA-Z0-9\.\)\]])\^([a-zA-Z0-9\.\(])/g, 'Math.pow($1,$2)');
  eqStr = eqStr.replace(/sqrt\(/gi, 'Math.sqrt(');
  try {
    let f = new Function('x', 'return ' + eqStr + ';');
    f(1);
    return f;
  } catch(e) { return null; }
}
/******** Hide/Show Controls ********/
// Hides all element controls and line endpoints.
// Hide all element controls and SVG endpoints.
function hideAllControls() {
  document.querySelectorAll(".element-controls").forEach(ctrl => {
    ctrl.style.display = "none";
  });
  // Hide endpoints in all SVGs inside line containers.
  document.querySelectorAll(".line-container svg").forEach(svg => {
    if (svg.currentLine) {
      if (svg.endpoint1) svg.endpoint1.style.display = "none";
      if (svg.endpoint2) svg.endpoint2.style.display = "none";
    }
  });
}

// Immediately highlight the active element using an outline.
function highlightActiveElement() {
  // Remove previous outlines.
  document.querySelectorAll("#problem-canvas .draggable-element").forEach(el => {
    el.style.outline = "";
  });
  // Apply a visible outline to the active element.
  if (activeElement) {
    activeElement.style.outline = "2px solid #00aaff";
  }
}


document.addEventListener('click', () => hideAllControls());

function raiseElementTemporarily(element) {
  if (!element) return;
  
  // If not already stored, save the original z-index
  if (!element.dataset.originalZ) {
    element.dataset.originalZ = element.style.zIndex || "1";
  }
  
  // Mark as temporarily raised
  element.dataset.tempRaised = "true";
  
  // Set a very high z-index to ensure it's on top
  const highZIndex = (1000000 + Date.now() % 1000).toString();
  element.style.zIndex = highZIndex;
  
  // IMPORTANT: Make the toolbar's z-index even higher
  const toolbar = element.querySelector('.element-controls');
  if (toolbar) {
    // Store the toolbar's original z-index if not already saved
    if (!toolbar.dataset.originalZ) {
      toolbar.dataset.originalZ = toolbar.style.zIndex || "auto";
    }
    
    // Ensure the toolbar has a higher z-index than the element
    toolbar.style.zIndex = (parseInt(highZIndex) + 1000).toString();
    
    // Also ensure the toolbar is displayed
    toolbar.style.display = "flex";
  }
}

function restoreElementZIndex(element) {
  if (!element || !element.dataset.tempRaised) return;
  
  // Restore original z-index
  if (element.dataset.originalZ) {
    element.style.zIndex = element.dataset.originalZ;
  }
  
  // Also restore the toolbar's z-index
  const toolbar = element.querySelector('.element-controls');
  if (toolbar && toolbar.dataset.originalZ) {
    toolbar.style.zIndex = toolbar.dataset.originalZ;
  }
  
  // Remove temporary raise marker
  delete element.dataset.tempRaised;
}

/******** Element Deletion ********/
function deleteElement(button) {
  let container = button.closest('.draggable-element');
  if (container) container.remove();
}
function deleteActiveElement() {
  if (activeElement) { activeElement.remove(); activeElement = null; activeTextBox = null; }
}

function deleteVariable(varName) {
  // Remove the variable's DOM element.
  const elem = document.getElementById("var-item-" + varName);
  if (elem) {
    elem.remove();
  }
  // Optionally, remove the variable definition from your objects.
  if (varDefinitions.hasOwnProperty(varName)) {
    delete varDefinitions[varName];
  }
  if (computedValues.hasOwnProperty(varName)) {
    delete computedValues[varName];
  }
  // Re-run updateVariables to re-compute any substitutions.
  updateVariables();
}


/******** Draggable Functionality ********/
function makeDraggable(handle, container) {
  handle.addEventListener("mousedown", function(e) {
    // If this container isn't already active, hide controls on others.
    if (activeElement !== container) {
      hideAllControls();
    }
    
    // Set this as the active element
    activeElement = container;
    
    // Raise it to the top
    raiseElementTemporarily(container);
    
    let startX = e.clientX,
        startY = e.clientY;
    let origX = parseInt(container.style.left) || 0,
        origY = parseInt(container.style.top) || 0;
    
    // Reset the dragging flag.
    isDragging = false;
    
    function onMouseMove(e) {
      let dx = e.clientX - startX,
          dy = e.clientY - startY;
      // If movement exceeds threshold, mark as dragging.
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
        isDragging = true;
      }
      container.style.left = (origX + dx) + "px";
      container.style.top = (origY + dy) + "px";
    }
    
    function onMouseUp(e) {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      
      if (isDragging) {
        // If we dragged, prevent the next click from selecting a different element
        ignoreNextClick = true;
        
        // Important: Add this to keep focus on the dragged element
        e.stopPropagation();
        
        // Add a small delay before resetting isDragging
        setTimeout(() => {
          isDragging = false;
        }, 200);
      }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    e.stopPropagation();
  });
}


/******** Create Draggable Element ********/
// Modified dragEndpoint that calls our expand helper on every mouse move.

  
// Modified dragEndpoint that calls our expand helper on every mouse move.
 // Global flag

function dragEndpoint(e, endpoint, line, whichEnd, svgContainer) {
  e.stopPropagation();
  e.preventDefault();
  
  let hasDragged = false;  // Track if the endpoint was actually moved
  
  // Get initial positions and calculate offsets…
  const svgRect = svgContainer.getBoundingClientRect();
  const initialCX = parseFloat(endpoint.getAttribute("cx"));
  const initialCY = parseFloat(endpoint.getAttribute("cy"));
  
  let viewBox = svgContainer.getAttribute("viewBox");
  let [vbX, vbY, vbWidth, vbHeight] = viewBox.split(" ").map(Number);
  const scaleX = vbWidth / svgContainer.clientWidth;
  const scaleY = vbHeight / svgContainer.clientHeight;
  
  const startMouseSVGX = (e.clientX - svgRect.left) * scaleX + vbX;
  const startMouseSVGY = (e.clientY - svgRect.top) * scaleY + vbY;
  const offsetX = initialCX - startMouseSVGX;
  const offsetY = initialCY - startMouseSVGY;
  
  function onMouseMove(e) {
    hasDragged = true;  // Mark that a drag occurred
    const mouseSVGX = (e.clientX - svgRect.left) * scaleX + vbX;
    const mouseSVGY = (e.clientY - svgRect.top) * scaleY + vbY;
    const newCX = mouseSVGX + offsetX;
    const newCY = mouseSVGY + offsetY;
    
    // Update the endpoint and the corresponding end of the line.
    endpoint.setAttribute("cx", newCX);
    endpoint.setAttribute("cy", newCY);
    if (whichEnd === "start") {
      line.setAttribute("x1", newCX);
      line.setAttribute("y1", newCY);
    } else {
      line.setAttribute("x2", newCX);
      line.setAttribute("y2", newCY);
    }
    
    updateLineContainer(svgContainer);
  }
  
  function onMouseUp(e) {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    
    // If a drag occurred, set the flag to ignore the next click.
    if (hasDragged) {
      ignoreNextClick = true;
    }
    
    // Ensure the active element remains focused.
    if (activeElement) {
      activeElement.focus();
    }
    
    e.stopPropagation();
    e.preventDefault();
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
}


function updateLineContainer(svgContainer) {
  const line = svgContainer.currentLine;
  if (!line) return;

  // Get current endpoint coordinates.
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));

  // Calculate bounding box with fixed padding.
  const padding = 20;
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);

  const newWidth = (maxX - minX) + 2 * padding;
  const newHeight = (maxY - minY) + 2 * padding;

  // Update the SVG element.
  svgContainer.setAttribute("width", newWidth);
  svgContainer.setAttribute("height", newHeight);
  svgContainer.setAttribute("viewBox", `${minX - padding} ${minY - padding} ${newWidth} ${newHeight}`);

  // Update the outer container.
  const outerContainer = svgContainer.closest('.line-container');
  if (outerContainer) {
    outerContainer.style.left = (minX - padding) + "px";
    outerContainer.style.top  = (minY - padding) + "px";
    outerContainer.style.width = newWidth + "px";
    const toolbarHeight = 20; // Fixed toolbar height.
    outerContainer.style.height = (toolbarHeight + newHeight) + "px";

    // Force the toolbar inside the container to have a fixed width.
    const toolbar = outerContainer.querySelector('.line-toolbar');
    if (toolbar) {
      toolbar.style.width = "400px"; // Set to your fixed width.
    }
  }
}


// Helper: expand the SVG viewBox (and outer container) if the line’s endpoints are too close
// to or beyond the current boundaries. We use the line’s bounding box.
function expandContainerIfNeeded(svgContainer) {
  const line = svgContainer.currentLine;
  if (!line) return;
  
  // Get the bounding box of the line (in current SVG coordinates)
  const bbox = line.getBBox();
  const padding = 20; // extra space in SVG coordinate units
  
  // Get current viewBox
  let viewBox = svgContainer.getAttribute("viewBox");
  let [vbX, vbY, vbWidth, vbHeight] = viewBox.split(" ").map(Number);
  
  let needUpdate = false;
  let newVbX = vbX, newVbY = vbY, newVbWidth = vbWidth, newVbHeight = vbHeight;
  
  // If the left side of the line (bbox.x) is too close to the left boundary...
  if (bbox.x < vbX + padding) {
    newVbX = bbox.x - padding;
    newVbWidth = (vbX + vbWidth) - newVbX;
    needUpdate = true;
  }
  // If the top side is too close to the top boundary...
  if (bbox.y < vbY + padding) {
    newVbY = bbox.y - padding;
    newVbHeight = (vbY + vbHeight) - newVbY;
    needUpdate = true;
  }
  // If the right side exceeds the current boundary...
  if (bbox.x + bbox.width > vbX + vbWidth - padding) {
    newVbWidth = (bbox.x + bbox.width + padding) - vbX;
    needUpdate = true;
  }
  // If the bottom side exceeds the current boundary...
  if (bbox.y + bbox.height > vbY + vbHeight - padding) {
    newVbHeight = (bbox.y + bbox.height + padding) - vbY;
    needUpdate = true;
  }
  
  if (needUpdate) {
    // Update the SVG's viewBox and its width/height attributes.
    svgContainer.setAttribute("viewBox", `${newVbX} ${newVbY} ${newVbWidth} ${newVbHeight}`);
    svgContainer.setAttribute("width", newVbWidth);
    svgContainer.setAttribute("height", newVbHeight);
    
    // Also update the outer container (the div wrapping the SVG, e.g., .line-container)
    const outerContainer = svgContainer.closest('.line-container');
    if (outerContainer) {
      const toolbarHeight = 20; // fixed toolbar height
      outerContainer.style.left = newVbX + "px";
      outerContainer.style.top  = newVbY + "px";
      outerContainer.style.width  = newVbWidth + "px";
      outerContainer.style.height = (newVbHeight + toolbarHeight) + "px";
    }
  }
}


// New helper function to adjust the container
function adjustSVGContainer(svgElement) {
  const line = svgElement.currentLine;
  if (!line) return;
  
  // Get the current endpoint positions (in SVG coordinates)
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));
  
  // Determine the bounding box of the line and add padding
  const padding = 20;
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);
  const newWidth = (maxX - minX) + 2 * padding;
  const newHeight = (maxY - minY) + 2 * padding;
  
  // Update the SVG: set the viewBox so that (0,0) is at (minX - padding, minY - padding)
  svgElement.setAttribute("width", newWidth);
  svgElement.setAttribute("height", newHeight);
  svgElement.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);
  
  // Offset the line (and endpoints) so that they remain in the same place relative to the canvas.
  line.setAttribute("x1", x1 - minX + padding);
  line.setAttribute("y1", y1 - minY + padding);
  line.setAttribute("x2", x2 - minX + padding);
  line.setAttribute("y2", y2 - minY + padding);
  if (svgElement.endpoint1) {
    svgElement.endpoint1.setAttribute("cx", x1 - minX + padding);
    svgElement.endpoint1.setAttribute("cy", y1 - minY + padding);
  }
  if (svgElement.endpoint2) {
    svgElement.endpoint2.setAttribute("cx", x2 - minX + padding);
    svgElement.endpoint2.setAttribute("cy", y2 - minY + padding);
  }
  
  // Adjust the outer container’s position and size.
  const toolbarHeight = 20;
  const outerContainer = svgElement.closest('.draggable-element');
  if (outerContainer) {
    // Shift the container’s left and top by (minX - padding, minY - padding)
    let currentLeft = parseFloat(outerContainer.style.left) || 0;
    let currentTop = parseFloat(outerContainer.style.top) || 0;
    outerContainer.style.left = (currentLeft + minX - padding) + "px";
    outerContainer.style.top = (currentTop + minY - padding) + "px";
    outerContainer.style.width = newWidth + "px";
    outerContainer.style.height = (newHeight + toolbarHeight) + "px";
  }
}

function openEquationEditor(callback, initialLatex, initialFontSize) { // MODIFIED: Added initialFontSize parameter
  console.log("openEquationEditor called with initialLatex:", initialLatex, "initialFontSize:", initialFontSize); // MODIFIED: Log the new param
  initialLatex = initialLatex || '\\placeholder{}';
  // ADDED: Use the passed font size, or default to '24px' if not provided
  const editorFontSize = initialFontSize || '24px';

  // Create overlay
  const overlay = document.createElement('div');
  overlay.className = 'equation-editor-overlay';
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
  overlay.style.zIndex = '9998';
  overlay.addEventListener('click', () => {
    // Ensure modalContainer exists before trying to remove it
    if (modalContainer && modalContainer.parentNode) {
        document.body.removeChild(overlay);
        document.body.removeChild(modalContainer);
    } else if (overlay && overlay.parentNode) {
        // If only overlay exists (e.g., error during modal creation)
        document.body.removeChild(overlay);
    }
  });

  // Create the modal container
  const modalContainer = document.createElement('div');
  modalContainer.className = 'equation-editor-popup';
  modalContainer.style.position = 'fixed';
  modalContainer.style.top = '50px';
  modalContainer.style.left = '50%';
  modalContainer.style.transform = 'translateX(-50%)';
  modalContainer.style.width = '80%';
  modalContainer.style.maxWidth = '600px';
  modalContainer.style.backgroundColor = 'white';
  modalContainer.style.padding = '15px';
  modalContainer.style.borderRadius = '5px';
  modalContainer.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
  modalContainer.style.zIndex = '9999';

  // Create the MathLive field and set initial value AND FONT SIZE
  const mathField = document.createElement('math-field');
  mathField.setAttribute('virtualKeyboardTheme', 'light');
  mathField.setAttribute('virtualKeyboardMode', 'onfocus');
  mathField.style.width = '100%';
  // Original line: mathField.style.fontSize = '24px';
  mathField.style.fontSize = editorFontSize; // MODIFIED: Apply the initial/passed size
  mathField.value = initialLatex;

  // Prevent delete/backspace from bubbling up
  mathField.addEventListener('keydown', function(e) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      e.stopPropagation();
    }
  });

  // Focus/Keyboard logic - unchanged
  mathField.addEventListener('focus', () => {
    setTimeout(() => {
      const keyboard = document.querySelector('.ML__keyboard');
      if (keyboard) {
        keyboard.style.position = 'fixed';
        keyboard.style.top = 'auto';
        keyboard.style.bottom = '0';
        keyboard.style.left = '0';
        keyboard.style.right = '0';
        keyboard.style.zIndex = '10000';
        keyboard.style.boxShadow = '0 -2px 10px rgba(0,0,0,0.3)';
        keyboard.style.maxHeight = '300px';
        keyboard.style.transform = 'translateY(0)';
        keyboard.style.transition = 'none';
        const backdrop = document.querySelector('.ML__backdrop');
        if (backdrop) {
          backdrop.style.display = 'none';
          backdrop.style.opacity = '0';
          backdrop.style.pointerEvents = 'none';
        }
      }
      modalContainer.scrollIntoView({ block: 'start', behavior: 'smooth' });
    }, 300);
  });

  // Append the math field
  modalContainer.appendChild(mathField);

  // === Font Size Control ===
  const fontSizeContainer = document.createElement('div');
  fontSizeContainer.style.marginTop = '15px';
  fontSizeContainer.style.marginBottom = '10px';
  fontSizeContainer.style.display = 'flex';
  fontSizeContainer.style.alignItems = 'center';

  const fontSizeLabel = document.createElement('span');
  fontSizeLabel.textContent = 'Font Size:';
  fontSizeLabel.style.marginRight = '5px';
  fontSizeContainer.appendChild(fontSizeLabel);

  // Create a number input for font size
  const fontSizeInput = document.createElement('input');
  fontSizeInput.type = 'number';
  fontSizeInput.min = '8';
  fontSizeInput.max = '72';
  // Original line: fontSizeInput.value = '24'; // Default size
  // MODIFIED: Set input value from passed size (extract number part), default to 24 if parse fails
  fontSizeInput.value = parseInt(editorFontSize, 10) || 24;
  fontSizeInput.style.width = '50px';
  fontSizeInput.addEventListener('input', () => {
    // Validate input value before applying
    const newSize = parseInt(fontSizeInput.value, 10);
    if (!isNaN(newSize) && newSize >= 8 && newSize <= 72) { // Check bounds
        mathField.style.fontSize = newSize + 'px';
    } else if (fontSizeInput.value === '') {
        // Handle empty input case if needed, maybe default back?
        // mathField.style.fontSize = '24px'; // Or keep last valid
    }
  });
  fontSizeContainer.appendChild(fontSizeInput);

  // Add a "px" label after the input
  const pxLabel = document.createElement('span');
  pxLabel.textContent = 'px';
  pxLabel.style.marginLeft = '2px';
  fontSizeContainer.appendChild(pxLabel);

  // Insert the font size container
  modalContainer.appendChild(fontSizeContainer);

  // Create Insert/Cancel buttons container.
  const buttonContainer = document.createElement('div');
  buttonContainer.className = 'editor-buttons';
  buttonContainer.style.display = 'flex';
  buttonContainer.style.justifyContent = 'flex-end';
  buttonContainer.style.marginTop = '10px';

  const cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancel';
  cancelButton.style.padding = '5px 15px';
  cancelButton.style.marginLeft = '10px';
  cancelButton.style.cursor = 'pointer';
  cancelButton.addEventListener('click', (e) => {
    e.stopPropagation();
    // Safe removal of overlay and modal
    if (overlay && overlay.parentNode) document.body.removeChild(overlay);
    if (modalContainer && modalContainer.parentNode) document.body.removeChild(modalContainer);
  });

  const insertButton = document.createElement('button');
  insertButton.textContent = 'Insert';
  insertButton.style.backgroundColor = '#4CAF50';
  insertButton.style.color = 'white';
  insertButton.style.border = 'none';
  insertButton.style.padding = '5px 15px';
  insertButton.style.cursor = 'pointer';
  insertButton.addEventListener('click', (e) => {
    e.stopPropagation();
    const latex = mathField.value;
    // MODIFIED: Get final size from mathField, fallback to the initial editor size if style somehow unset
    const finalFontSize = mathField.style.fontSize || editorFontSize;

    if (mathField.virtualKeyboardState === 'visible') {
      mathField.closeVirtualKeyboard();
    }

    setTimeout(() => {
      // Safe removal of overlay and modal
      if (overlay && overlay.parentNode) document.body.removeChild(overlay);
      if (modalContainer && modalContainer.parentNode) document.body.removeChild(modalContainer);

      // Pass latex and FINAL fontSize to the callback
      callback(latex, finalFontSize); // Pass the final font size
    }, 50);
  });

  buttonContainer.appendChild(cancelButton);
  buttonContainer.appendChild(insertButton);

  // Append the button container
  modalContainer.appendChild(buttonContainer);

  // Append overlay and modal to the document.
  document.body.appendChild(overlay);
  document.body.appendChild(modalContainer);
  mathField.focus();
}


function addTextBox() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeTextboxElement) {
    window.activeTextboxElement = null;
  }
  // Global counter for textbox IDs
  if (!window.globalTextboxCounter) {
    window.globalTextboxCounter = 1;
  } else {
    window.globalTextboxCounter++;
  }

  // Create the container
     // --- Start Replacement Block ---

    // Create the container (Main draggable element) - Keeps position: absolute
    const container = document.createElement("div");
    container.className = "draggable-element textbox-container";
    container.style.position = "absolute"; // Keep this for positioning on canvas
    container.style.left = nextElementOffset + "px";
    container.style.top = nextElementOffset + "px";
    container.style.width = "300px"; // Initial width
    container.style.height = (toolbarHeight + 150) + "px"; // Initial height (toolbar + content)
    // container.style.backgroundColor = "#fff"; // We'll set this on content area or handle transparency
    container.style.boxShadow = "0 1px 3px rgba(0,0,0,0.12)";
    container.style.cursor = "pointer";
    container.style.border = "1px dashed #ccc"; // Add border for clarity when active
    // Apply initial background (important for transparency to work later)
    container.style.backgroundColor = "transparent"; // Start transparent, let content show color initially
    nextElementOffset += 10;
    container.isDragging = false;
    container.textboxID = window.globalTextboxCounter++; // Assign and increment ID

    // Initialize state properties
    container.backgroundColor = "#ffffff"; // Default logical background state is white
    container.hasMathEquation = false;
    container.mathEquations = [];

    // --- Create the toolbar --- (Sits naturally at the top, uses block layout)
    // --- Create the toolbar --- (Absolutely positioned to overlay content)
    const localToolbar = document.createElement("div");
    localToolbar.className = "textbox-toolbar element-controls";
    localToolbar.style.position = "absolute"; // *** ADD: Position relative to container ***
    localToolbar.style.top = "0";             // *** ADD: Stick to the top ***
    localToolbar.style.left = "0";            // *** ADD: Stick to the left ***
    localToolbar.style.width = "100%";        // Keep: Full width of container
    localToolbar.style.height = toolbarHeight + "px"; // Keep: Fixed height
    localToolbar.style.boxSizing = "border-box";      // Keep
    localToolbar.style.backgroundColor = "#f0f0f0";   // Keep
    localToolbar.style.display = "none";              // Keep: Start hidden
    localToolbar.style.alignItems = "center";         // Keep
    localToolbar.style.justifyContent = "space-between"; // Keep
    localToolbar.style.padding = "0 5px";             // Keep
    localToolbar.style.zIndex = "10"; // Keep: Ensure it's above content container
    localToolbar.style.borderBottom = "1px solid #ddd"; // Keep
    // NO absolute positioning needed here

    // --- Create the content container --- (Sits BELOW toolbar, uses block layout)
   // --- Create the content container --- (Fills parent, uses padding for toolbar space)
const contentContainer = document.createElement("div");
contentContainer.className = "textbox-content-container";
// NO absolute positioning needed
contentContainer.style.width = "100%";
contentContainer.style.height = "100%"; // Fill the parent container fully
contentContainer.style.boxSizing = "border-box";
// *** ADD PADDING TOP: Create space for the absolute toolbar ***
contentContainer.style.paddingTop = (toolbarHeight + 5) + "px"; // Toolbar height + little extra space
contentContainer.style.paddingLeft = "5px"; // Keep other padding
contentContainer.style.paddingRight = "5px";
contentContainer.style.paddingBottom = "5px";
contentContainer.style.overflow = "auto"; // Still handle scrolling
contentContainer.style.backgroundColor = container.backgroundColor; // Apply logical background
// We can add a lower z-index if needed, but often unnecessary if toolbar's is higher
// contentContainer.style.zIndex = "1"; Apply initial logical background

    // --- Add toolbar controls (drag handle, delete button) ---
    // (Assuming this code comes AFTER the toolbar and contentContainer are defined)
    const dragHandle = document.createElement("span");
    dragHandle.className = "drag-handle";
    dragHandle.style.cursor = "move";
    dragHandle.style.marginRight = "5px";
    dragHandle.textContent = "☰";
    const leftSide = document.createElement("div");
    leftSide.style.display = "flex";
    leftSide.style.alignItems = "center";
    leftSide.appendChild(dragHandle);
    localToolbar.appendChild(leftSide);

    const deleteButton = document.createElement("button");
    deleteButton.textContent = "Delete";
    deleteButton.style.fontSize = "12px";
    deleteButton.style.padding = "2px 8px";
    deleteButton.style.cursor = "pointer";
    deleteButton.addEventListener("mousedown", function(e) { e.stopPropagation(); }); // Stop propagation
    const rightSide = document.createElement("div");
    rightSide.style.display = "flex";
    rightSide.style.alignItems = "center";
    rightSide.appendChild(deleteButton);
    localToolbar.appendChild(rightSide);

    // --- Append toolbar and content container TO THE MAIN container ---
    container.appendChild(localToolbar);
    container.appendChild(contentContainer);

    // --- End Replacement Block ---

  // Create resize handle
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Create the modal for Summernote
  const modalId = "modal-" + Date.now();
  const modal = document.createElement("div");
  modal.id = modalId;
  modal.className = "textbox-modal";
  modal.style.display = "none";
  modal.style.position = "fixed";
  modal.style.zIndex = "1050";
  modal.style.left = "0";
  modal.style.top = "0";
  modal.style.width = "100%";
  modal.style.height = "100%";
  modal.style.overflow = "auto";
  modal.style.backgroundColor = "rgba(0,0,0,0.4)";
  
  // Modal content
  const modalContent = document.createElement("div");
  modalContent.className = "textbox-modal-content";
  modalContent.style.backgroundColor = "#fefefe";
  modalContent.style.margin = "50px auto";
  modalContent.style.padding = "20px";
  modalContent.style.border = "1px solid #888";
  modalContent.style.width = "80%";
  modalContent.style.maxWidth = "800px";
  modalContent.style.borderRadius = "5px";
  modalContent.style.boxShadow = "0 4px 8px rgba(0,0,0,0.1)";
  
  // Modal header
  const modalHeader = document.createElement("div");
  modalHeader.style.display = "flex";
  modalHeader.style.justifyContent = "space-between";
  modalHeader.style.alignItems = "center";
  modalHeader.style.marginBottom = "15px";
  
  const modalTitle = document.createElement("h3");
  modalTitle.textContent = "Edit Text";
  modalTitle.style.margin = "0";
  
  const closeButton = document.createElement("span");
  closeButton.innerHTML = "&times;";
  closeButton.style.cursor = "pointer";
  closeButton.style.fontSize = "24px";
  closeButton.style.fontWeight = "bold";
  
  modalHeader.appendChild(modalTitle);
  modalHeader.appendChild(closeButton);
  
  // Modal body
  const modalBody = document.createElement("div");
  
  // Add equation button container
  const equationButtonContainer = document.createElement("div");
  equationButtonContainer.style.marginBottom = "10px";
  equationButtonContainer.style.padding = "8px";
  equationButtonContainer.style.border = "1px solid #ddd";
  equationButtonContainer.style.borderRadius = "4px";
  equationButtonContainer.style.backgroundColor = "#f0f8ff";
  equationButtonContainer.style.display = "flex";
  equationButtonContainer.style.alignItems = "center";
  
  // Create equation button label
  const equationButtonLabel = document.createElement("span");
  equationButtonLabel.textContent = "Math Equation:";
  equationButtonLabel.style.fontWeight = "bold";
  equationButtonLabel.style.marginRight = "10px";
  equationButtonContainer.appendChild(equationButtonLabel);
  
  // Create equation button
  const equationButton = document.createElement("button");
  equationButton.textContent = "Insert Equation";
  equationButton.style.padding = "6px 12px";
  equationButton.style.backgroundColor = "#007bff";
  equationButton.style.color = "white";
  equationButton.style.border = "none";
  equationButton.style.borderRadius = "4px";
  equationButton.style.cursor = "pointer";
  equationButton.style.fontWeight = "bold";
  
  // Add hover effect
  equationButton.addEventListener("mouseover", function() {
    this.style.backgroundColor = "#0069d9";
  });
  
  equationButton.addEventListener("mouseout", function() {
    this.style.backgroundColor = "#007bff";
  });
  
  equationButtonContainer.appendChild(equationButton);

  // Create process LaTeX button
// Create process LaTeX button for the modal
const processLatexButtonInModal = document.createElement("button");
processLatexButtonInModal.textContent = "Process LaTeX";
processLatexButtonInModal.style.padding = "6px 12px";
processLatexButtonInModal.style.backgroundColor = "#ffefd5"; // Peach color
processLatexButtonInModal.style.color = "#333"; // Darker text for readability
processLatexButtonInModal.style.border = "none";
processLatexButtonInModal.style.borderRadius = "4px";
processLatexButtonInModal.style.cursor = "pointer";
processLatexButtonInModal.style.fontWeight = "bold";
processLatexButtonInModal.style.marginLeft = "10px"; // Space from the Insert Equation button

// Add hover effect
processLatexButtonInModal.addEventListener("mouseover", function() {
  this.style.backgroundColor = "#ffdab9"; // Darker peach on hover
});

processLatexButtonInModal.addEventListener("mouseout", function() {
  this.style.backgroundColor = "#ffefd5"; // Back to original color
});

// Add click event
processLatexButtonInModal.addEventListener("click", function(e) {
  e.preventDefault();
  // Process LaTeX in the Summernote editor content
  processLatexInSummernote(container, activeEditor);
});

equationButtonContainer.appendChild(processLatexButtonInModal);


  // Define grouped mathematical symbols
  const symbolGroups = [
    {
      name: "Greek Letters",
      symbols: [
        { symbol: "α", name: "alpha" },
        { symbol: "β", name: "beta" },
        { symbol: "γ", name: "gamma" },
        { symbol: "Γ", name: "Gamma" },
        { symbol: "δ", name: "delta" },
        { symbol: "Δ", name: "Delta" },
        { symbol: "ε", name: "epsilon" },
        { symbol: "η", name: "eta" },
        { symbol: "θ", name: "theta" },
        { symbol: "Θ", name: "Theta" },
        { symbol: "κ", name: "kappa" },
        { symbol: "λ", name: "lambda" },
        { symbol: "Λ", name: "Lambda" },
        { symbol: "μ", name: "mu" },
        { symbol: "ν", name: "nu" },
        { symbol: "π", name: "pi" },
        { symbol: "Π", name: "Pi" },
        { symbol: "ρ", name: "rho" },
        { symbol: "σ", name: "sigma" },
        { symbol: "Σ", name: "Sigma" },
        { symbol: "τ", name: "tau" },
        { symbol: "φ", name: "phi" },
        { symbol: "Φ", name: "Phi" },
        { symbol: "χ", name: "chi" },
        { symbol: "ψ", name: "psi" },
        { symbol: "Ψ", name: "Psi" },
        { symbol: "ω", name: "omega" },
        { symbol: "Ω", name: "Omega" }
      ]
    },
    {
      name: "Comparison",
      symbols: [
        { symbol: "=", name: "equals" },
        { symbol: "≠", name: "not equals" },
        { symbol: "≈", name: "approximately equals" },
        { symbol: "≊", name: "approximately equal to" },
        { symbol: "≡", name: "identical to" },
        { symbol: "<", name: "less than" },
        { symbol: ">", name: "greater than" },
        { symbol: "≤", name: "less than or equal to" },
        { symbol: "≥", name: "greater than or equal to" }
      ]
    },
    {
      name: "Operators",
      symbols: [
        { symbol: "+", name: "plus" },
        { symbol: "−", name: "minus" },
        { symbol: "±", name: "plus-minus" },
        { symbol: "×", name: "times" },
        { symbol: "÷", name: "divide" },
        { symbol: "∑", name: "summation" },
        { symbol: "∏", name: "product" },
        { symbol: "∫", name: "integral" },
        { symbol: "∂", name: "partial derivative" },
        { symbol: "∇", name: "nabla/gradient" },
        { symbol: "√", name: "square root" },
        { symbol: "∞", name: "infinity" }
      ]
    }
  ];

  // Create collapsible symbols panel
  const symbolsPanel = document.createElement("div");
  symbolsPanel.className = "symbols-panel";
  symbolsPanel.style.marginBottom = "10px";
  symbolsPanel.style.border = "1px solid #ddd";
  symbolsPanel.style.borderRadius = "4px";
  
  // Create the toggle button
  const toggleButton = document.createElement("button");
  toggleButton.className = "symbols-toggle";
  toggleButton.textContent = "Mathematical Symbols";
  toggleButton.style.width = "100%";
  toggleButton.style.padding = "8px 12px";
  toggleButton.style.backgroundColor = "#f8f9fa";
  toggleButton.style.border = "none";
  toggleButton.style.borderRadius = "4px 4px 0 0";
  toggleButton.style.textAlign = "left";
  toggleButton.style.fontSize = "14px";
  toggleButton.style.fontWeight = "bold";
  toggleButton.style.cursor = "pointer";
  toggleButton.style.display = "flex";
  toggleButton.style.alignItems = "center";
  toggleButton.style.justifyContent = "space-between";
  
  // Add arrow indicator
  const arrow = document.createElement("span");
  arrow.textContent = "▼";
  arrow.style.fontSize = "12px";
  arrow.style.transition = "transform 0.3s";
  toggleButton.appendChild(arrow);
  
  symbolsPanel.appendChild(toggleButton);
  
  // Create the collapsible content
  const symbolsContent = document.createElement("div");
  symbolsContent.className = "symbols-content";
  symbolsContent.style.padding = "10px";
  symbolsContent.style.display = "none"; // Start collapsed
  
  // Add each group to the content
  symbolGroups.forEach(group => {
    // Create group container
    const groupContainer = document.createElement("div");
    groupContainer.className = "symbol-group";
    groupContainer.style.marginBottom = "15px";
    
    // Create group header
    const groupHeader = document.createElement("div");
    groupHeader.textContent = group.name;
    groupHeader.style.fontWeight = "bold";
    groupHeader.style.fontSize = "13px";
    groupHeader.style.marginBottom = "8px";
    groupHeader.style.paddingBottom = "3px";
    groupHeader.style.borderBottom = "1px solid #eee";
    groupContainer.appendChild(groupHeader);
    
    // Create symbols grid for this group
    const groupGrid = document.createElement("div");
    groupGrid.style.display = "grid";
    groupGrid.style.gridTemplateColumns = "repeat(12, 1fr)";
    groupGrid.style.gap = "5px";
    
    // Add symbols to group grid
    group.symbols.forEach(item => {
      const symbolButton = document.createElement("button");
      symbolButton.className = "symbol-btn";
      symbolButton.textContent = item.symbol;
      symbolButton.title = item.name;
      symbolButton.style.width = "30px";
      symbolButton.style.height = "30px";
      symbolButton.style.padding = "0";
      symbolButton.style.display = "flex";
      symbolButton.style.justifyContent = "center";
      symbolButton.style.alignItems = "center";
      symbolButton.style.cursor = "pointer";
      symbolButton.style.border = "1px solid #ddd";
      symbolButton.style.backgroundColor = "#f8f9fa";
      symbolButton.style.borderRadius = "4px";
      symbolButton.style.fontSize = "16px";
      
      // Hover styles
      symbolButton.addEventListener("mouseover", function() {
        this.style.backgroundColor = "#e2e6ea";
      });
      
      symbolButton.addEventListener("mouseout", function() {
        this.style.backgroundColor = "#f8f9fa";
      });
      
      groupGrid.appendChild(symbolButton);
    });
    
    groupContainer.appendChild(groupGrid);
    symbolsContent.appendChild(groupContainer);
  });
  
  symbolsPanel.appendChild(symbolsContent);
  
  // Toggle the symbols panel
  toggleButton.addEventListener("click", function() {
    const isExpanded = symbolsContent.style.display === "block";
    symbolsContent.style.display = isExpanded ? "none" : "block";
    arrow.style.transform = isExpanded ? "rotate(0deg)" : "rotate(180deg)";
    
    // If expanding for the first time, set up the symbol button handlers
    if (!isExpanded && !toggleButton.hasSetupHandlers) {
      const symbolButtons = symbolsContent.querySelectorAll('.symbol-btn');
      symbolButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          if (activeEditor) {
            // Insert the symbol at cursor position
            activeEditor.summernote('insertText', this.textContent);
          }
        });
      });
      toggleButton.hasSetupHandlers = true;
    }
  });
  
  // Editor element
  const editor = document.createElement("div");
  editor.className = "summernote-editor";
  editor.style.minHeight = "300px";
  
  // Add equation container, symbols panel and editor to modal body
  modalBody.appendChild(equationButtonContainer);
  modalBody.appendChild(symbolsPanel);
  modalBody.appendChild(editor);
  
  // Modal footer
  const modalFooter = document.createElement("div");
  modalFooter.style.marginTop = "15px";
  modalFooter.style.textAlign = "right";
  
  const cancelButton = document.createElement("button");
  cancelButton.textContent = "Cancel";
  cancelButton.style.marginRight = "10px";
  cancelButton.style.padding = "8px 16px";
  
  const insertButton = document.createElement("button");
  insertButton.textContent = "Insert";
  insertButton.style.padding = "8px 16px";
  insertButton.style.backgroundColor = "#4CAF50";
  insertButton.style.color = "white";
  insertButton.style.border = "none";
  insertButton.style.borderRadius = "4px";
  insertButton.style.cursor = "pointer";
  
  modalFooter.appendChild(cancelButton);
  modalFooter.appendChild(insertButton);
  
  // Build the modal
  modalContent.appendChild(modalHeader);
  modalContent.appendChild(modalBody);
  modalContent.appendChild(modalFooter);
  modal.appendChild(modalContent);
  
  // Add modal to document
  document.body.appendChild(modal);

  // Function to handle equation editor
 // Function to handle equation editor opening from a textbox context
function openEquationEditorForTextbox(callback, initialLatex, initialFontSize) { // *** ADD initialFontSize parameter ***
  // Check if the openEquationEditor function exists (from your external code)
  if (typeof openEquationEditor === 'function') {
      // *** PASS initialFontSize along ***
      openEquationEditor(callback, initialLatex, initialFontSize);
  } else {
      console.error("openEquationEditor function is not defined. Make sure the MathLive library is loaded.");
      alert("Equation editor is not available. Please make sure the MathLive library is loaded.");
  }
}

  // Function to add math equation to the textbox
 // Function to add math equation to the textbox
 // Function to add math equation to the textbox
function addMathEquationForTextbox(container, contentContainer) {
  // Store the editor's HTML and current cursor position
  const editorContent = $(editor).summernote('code');
  
  // Store a marker for the cursor position
  const CURSOR_MARKER = '$$CURSOR_POSITION_MARKER$$';
  let markedContent = '';
  
  // Insert a marker at the cursor position
  $(editor).summernote('insertText', CURSOR_MARKER);
  markedContent = $(editor).summernote('code');
  
  // Restore the content without the marker (for clean state)
  $(editor).summernote('code', editorContent);
  
  openEquationEditorForTextbox(function(latex, fontSize) {
    if (!latex || latex === '\\placeholder{}') {
      return; // Don't insert empty equations.
    }
    
    const equationId = `math-equation-${container.textboxID}-${container.mathEquations.length + 1}`;
    
    // First, create and render an actual element outside the editor
    const tempDiv = document.createElement('div');
    document.body.appendChild(tempDiv);
    
    // Create the equation element
    const eqElement = document.createElement('span');
    eqElement.id = equationId + "-temp";
    eqElement.className = 'inline-equation';
    eqElement.setAttribute('contenteditable', 'false');
    eqElement.setAttribute('data-latex', latex);
    eqElement.style.display = 'inline-block';
    eqElement.style.cursor = 'pointer';
    eqElement.style.userSelect = 'none';
    eqElement.style.border = 'none';
    eqElement.style.padding = '0';
    eqElement.style.margin = '0 2px';
    eqElement.style.backgroundColor = 'transparent';
    eqElement.style.fontSize = fontSize || '24px';
    eqElement.innerHTML = '\\(' + latex + '\\)';
    
    // Add it to our temp container
    tempDiv.appendChild(eqElement);
    
    // Render it with MathLive
    if (typeof MathLive !== 'undefined' && typeof MathLive.renderMathInElement === 'function') {
      try {
        MathLive.renderMathInElement(eqElement);
      } catch(e) {
        console.error("Error rendering equation:", e);
      }
    }
    
    // Now get the fully rendered HTML
    const renderedHTML = eqElement.outerHTML;
    
    // Remove our temp elements
    document.body.removeChild(tempDiv);
    
    // Now insert the pre-rendered HTML at the marker position
    const newContent = markedContent.replace(CURSOR_MARKER, renderedHTML + ' ');
    $(editor).summernote('code', newContent);
    
    // Store equation info
    container.mathEquations.push({
      id: equationId,
      latex: latex
    });
    container.hasMathEquation = true;
    
    // Setup click handler for the equation
    setupEquationClickHandler();
  });
}
  
  // Click handler for the equation button
  equationButton.addEventListener("click", function(e) {
    e.preventDefault();
    addMathEquationForTextbox(container, contentContainer);
  });
  
    // Setup click handler for equations
    function setupEquationClickHandler() {
    // Remove previous handler if it exists
    if (window.equationClickHandler) {
      document.removeEventListener('click', window.equationClickHandler, true);
    }

    // Create new handler
    window.equationClickHandler = function(event) {
      // Find all equation elements
      // const equations = document.querySelectorAll('.inline-equation'); // Don't need this line

      // Check if the click was on an equation
      const eqElement = event.target.closest('.inline-equation'); // Get the clicked element directly
      if (eqElement) {
        console.log("Equation clicked:", eqElement.id);

        // Get the LaTeX from the data attribute
        const currentLatex = eqElement.getAttribute('data-latex') || '\\placeholder{}';

        // *** NEW: Get the CURRENT font size from the clicked element ***
        const currentFontSize = window.getComputedStyle(eqElement).fontSize || '24px'; // Get computed style, default if needed
        console.log("Current font size:", currentFontSize);
        // *** END NEW ***

        // Open the equation editor with the current LaTeX AND current font size
        openEquationEditorForTextbox(function(newLatex, newFontSize) { // Editor callback receives new size
          console.log("Updating equation with:", newLatex, newFontSize);

          // Update the equation element
          eqElement.setAttribute('data-latex', newLatex);
          // *** UPDATE FONT SIZE: Use the size returned from the editor callback ***
          if (newFontSize) { // Only update if editor provided a size
             eqElement.style.fontSize = newFontSize;
          }
          // *** END UPDATE ***

          // Re-render the equation
          if (typeof MathLive !== 'undefined' && typeof MathLive.renderMathInElement === 'function') {
            eqElement.innerHTML = '\\(' + newLatex + '\\)';
            MathLive.renderMathInElement(eqElement);
          } else {
            eqElement.textContent = newLatex;
          }
        }, currentLatex, currentFontSize); // *** PASS currentFontSize to the editor function ***

        event.stopPropagation();
        event.preventDefault();
      }
    };

    // Add the handler
    document.addEventListener('click', window.equationClickHandler, true);
  }

  // Initialize Summernote when the modal is shown
  let summernoteInitialized = false;
  let activeEditor = null;
  
  function showModal() {
    modal.style.display = "block";
    
    if (!summernoteInitialized) {
      // Initialize Summernote
      $(editor).summernote({
        height: 300,
        focus: true,
        // Refined toolbar without potentially problematic buttons
        toolbar: [
          ['style', ['style']], // Heading styles
          ['font', ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'clear']], // Text styling options including superscript and subscript
          ['fontname', ['fontname']], // Font family
          ['fontsize', ['fontsize']], // Font size
          ['color', ['color']], // Text and background color
          ['para', ['ul', 'ol', 'paragraph']], // Lists and paragraph alignment
          ['table', ['table']], // Tables
          // Removed: link, picture, video, fullscreen, codeview
        ],
        // Customize available styles in dropdown
        styleTags: ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre', 'blockquote'],
        // Font names
        fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Helvetica', 'Impact', 'Times New Roman', 'Verdana'],
        // Font sizes
        fontSizes: ['8', '9', '10', '11', '12', '14', '16', '18', '20', '24', '28', '36'],
        callbacks: {
          onInit: function() {
            setupEquationClickHandler();
          }
        }
      });
      
      // Store the editor instance for later use
      activeEditor = $(editor);
      
      // Set up common symbols button click handlers
      const symbolButtons = symbolsContent.querySelectorAll('.symbol-btn');
      symbolButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          if (activeEditor) {
            // Insert the symbol at cursor position
            activeEditor.summernote('insertText', this.textContent);
          }
        });
      });
      
      // If there's existing content, set it in the editor
      if (contentContainer.innerHTML.trim() && contentContainer.innerHTML !== "<p>Double-click to edit content</p>") {
        $(editor).summernote('code', contentContainer.innerHTML);
      }
      
      summernoteInitialized = true;
    } else {
      // Update content in case it changed
      $(editor).summernote('code', contentContainer.innerHTML);
    }
  }
  
  function hideModal() {
    modal.style.display = "none";
  }
  
  // Close modal events
  closeButton.addEventListener("click", hideModal);
  cancelButton.addEventListener("click", hideModal);
  
  modal.addEventListener("click", function(e) {
    if (e.target === modal) {
      hideModal();
    }
  });
  
  // Insert content from modal to textbox
  insertButton.addEventListener("click", function() {
    const content = $(editor).summernote('code');
    contentContainer.innerHTML = content;
    hideModal();
    
    // Re-setup equation click handlers after content is inserted
    if (container.hasMathEquation) {
      setupEquationClickHandler();
    }
  });
  
  // Edit button shows the modal




  function updateGlobalToolbar() {
  const globalToolbar = document.getElementById("global-toolbar");
  if (!globalToolbar) return;

  globalToolbar.innerHTML = "";
  
  const controls = document.createElement("div");
  controls.style.display = "flex";
  controls.style.alignItems = "center";
  
  // Identity label
  const identityLabel = document.createElement("span");
  identityLabel.textContent = "TextBox " + container.textboxID;
  identityLabel.style.fontSize = "12px";
  identityLabel.style.fontWeight = "bold";
  identityLabel.style.marginRight = "10px";
  controls.appendChild(identityLabel);
  
  // Add Equation button (in global toolbar for convenience)
  const addEquationBtn = document.createElement("button");
  addEquationBtn.textContent = "Add Equation";
  addEquationBtn.style.padding = "4px 8px";
  addEquationBtn.style.cursor = "pointer";
  addEquationBtn.style.backgroundColor = "#e0f0ff";
  addEquationBtn.style.marginRight = "10px";
  addEquationBtn.addEventListener("click", function() {
    // Open the editor modal first if it's not already open
    if (modal.style.display !== "block") {
      showModal();
    }
    
    // Then add math equation
    setTimeout(() => {
      addMathEquationForTextbox(container, contentContainer);
    }, 100);
  });
  controls.appendChild(addEquationBtn);
  
  // Add Process LaTeX button
  const processLatexBtn = document.createElement("button");
  processLatexBtn.textContent = "Process LaTeX";
  processLatexBtn.style.padding = "4px 8px";
  processLatexBtn.style.cursor = "pointer";
  processLatexBtn.style.backgroundColor = "#ffefd5"; // Peach color to differentiate
  processLatexBtn.style.marginRight = "10px";
  processLatexBtn.addEventListener("click", function() {
    processLatexInTextbox(container, contentContainer);
  });
  controls.appendChild(processLatexBtn);
  
  // Edit button in global toolbar
  const globalEditButton = document.createElement("button");
  globalEditButton.textContent = "Edit Content";
  globalEditButton.style.padding = "4px 8px";
  globalEditButton.style.cursor = "pointer";
  globalEditButton.addEventListener("click", function() {
    showModal();
  });
  controls.appendChild(globalEditButton);
  
  globalToolbar.appendChild(controls);
// --- Add Background Color Control (Corrected) ---
const bgColorGroup = document.createElement("span");
bgColorGroup.style.marginLeft = "10px"; // Add some space
bgColorGroup.style.display = "inline-flex"; // Keep items together
bgColorGroup.style.alignItems = "center";

const bgColorLabel = document.createElement("span");
bgColorLabel.textContent = "Background:";
bgColorLabel.style.fontSize = "12px";
bgColorLabel.style.marginRight = "3px";
bgColorGroup.appendChild(bgColorLabel);

const bgColorPicker = document.createElement("input");
bgColorPicker.type = "color";
bgColorPicker.style.width = "40px"; // Make it small
bgColorPicker.style.height = "28px"; // Match toolbar height
bgColorPicker.style.padding = "0 2px";
bgColorPicker.style.border = "1px solid #ccc";
// Set initial value based on container's state or default
bgColorPicker.value = container.backgroundColor && container.backgroundColor !== "transparent" ? container.backgroundColor : "#ffffff";

// Event listener to apply the chosen color
bgColorPicker.addEventListener("input", function(e) {
    e.stopPropagation(); // Prevent click from closing toolbar
    const newColor = this.value;
    const contentContainer = container.querySelector(".textbox-content-container");
    if (contentContainer) {
        container.backgroundColor = newColor; // Store the state
        contentContainer.style.backgroundColor = newColor;
        container.style.backgroundColor = newColor; // *** Also set outer container ***
    }
});
// Prevent clicks on the picker itself closing the toolbar
bgColorPicker.addEventListener("click", function(e) { e.stopPropagation(); });
bgColorPicker.addEventListener("mousedown", function(e) { e.stopPropagation(); });

bgColorGroup.appendChild(bgColorPicker);

// *** NEW: Button to set background to 'None' (transparent) ***
const bgNoneButton = document.createElement("button");
bgNoneButton.textContent = "None";
bgNoneButton.style.fontSize = "13px";
bgNoneButton.style.padding = "1px 4px";
bgNoneButton.style.marginLeft = "3px";
bgNoneButton.addEventListener("click", function(e) {
    e.stopPropagation(); // Prevent click from closing toolbar
    const contentContainer = container.querySelector(".textbox-content-container");
    if (contentContainer) {
        container.backgroundColor = "transparent"; // Store the state
        contentContainer.style.backgroundColor = "transparent"; // Set inner content bg
        container.style.backgroundColor = "transparent"; // *** Set outer container bg ***
        bgColorPicker.value = "#ffffff"; // Reset picker to white visually
    }
});
// Prevent clicks on the button itself closing the toolbar
bgNoneButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });

bgColorGroup.appendChild(bgNoneButton); // *** Add the None button to the group ***

// Add the whole background color group to the controls div
controls.appendChild(bgColorGroup);
// --- End of Background Color Control ---
}

  function activateTextbox() {
    // Deactivate the previously active element if any
    if (window.activeTextboxElement && window.activeTextboxElement !== container) {
      window.activeTextboxElement.style.border = "none";
      
      const prevToolbar = window.activeTextboxElement.querySelector(".textbox-toolbar");
      const prevResizeHandle = window.activeTextboxElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeTextboxElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivateTextbox() {
    if (window.activeTextboxElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeTextboxElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteTextbox() {
    if (window.activeTextboxElement === container) {
      window.activeTextboxElement = null;
    }
    
    try {
      // Destroy the Summernote instance
      if (summernoteInitialized) {
        $(editor).summernote('destroy');
      }
      
      // Remove the modal
      if (modal.parentNode) {
        document.body.removeChild(modal);
      }
      
      // Remove the textbox
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing elements:", err);
    }
  }

  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateTextbox();
    }
  });

  // Delete handler
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteTextbox();
  });

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(40, startWidth + (e.clientX - startX));
      const newHeight = Math.max(40, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
        e.preventDefault(); // Prevent text selection during drag
        e.stopPropagation(); // Prevent triggering canvas click handler

        let isDragging = false; // Use a local flag for this specific drag operation

        // Get elements and initial positions ON MOUSEDOWN
        const canvas = document.getElementById("problem-canvas");
        if (!canvas) return; // Safety check
        const canvasRect = canvas.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        // Calculate mouse offset relative to the container's top-left corner
        const shiftX = e.clientX - containerRect.left;
        const shiftY = e.clientY - containerRect.top;

        // Record starting mouse position (for detecting if a drag actually happened)
        const startX = e.clientX;
        const startY = e.clientY;

        function onMouseMove(e) {
            // Detect if a significant drag occurred (more than a few pixels)
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            if (!isDragging && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
                isDragging = true; // Mark as dragging
            }

            // Calculate the desired top-left corner position relative to the CANVAS
            let newLeft = e.clientX - canvasRect.left - shiftX;
            let newTop = e.clientY - canvasRect.top - shiftY;

            // --- Boundary Checks --- (Keep element inside the canvas)
            const minLeft = 0;
            // Use offsetWidth/Height for accurate boundary check including padding/border
            const maxLeft = canvasRect.width - container.offsetWidth;
            const minTop = 0; // Keep fully within top boundary
            const maxTop = canvasRect.height - container.offsetHeight;

            // Clamp the position within the bounds
            newLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));
            newTop = Math.max(minTop, Math.min(newTop, maxTop));
            // --- End Boundary Checks ---

            // Apply the calculated and clamped position
            container.style.left = newLeft + "px";
            container.style.top = newTop + "px";
        }

        function onMouseUp(e) {
            // Remove the listeners attached to the document
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);

            // If a drag actually occurred, set the flag to ignore the next click
            if (isDragging) {
                ignoreNextClick = true;
                // Add a tiny delay before resetting ignoreNextClick if needed
                // setTimeout(() => { ignoreNextClick = false; }, 50);
            }

             // Optional: Call the function to center text if needed after drag
             // setTimeout(() => centerTextVertically(container), 0);
        }

        // Add temporary listeners to the whole document for smooth dragging
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
    });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && 
        !modal.contains(e.target) && 
        window.activeTextboxElement === container) {
      deactivateTextbox();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Activate the textbox
  activateTextbox();
  
  // Set some initial placeholder text
  contentContainer.innerHTML = "<p>Double-click to edit content</p>";
  
  return container;
}

// Find LaTeX expressions in text (delimited by $$ pairs)
// Find LaTeX expressions in text (delimited by $$ pairs)
function findLatexExpressions(text) {
  const matches = [];
  let startIndex = 0;
  
  // Keep searching for $$ pairs
  while (startIndex < text.length) {
    // Find opening $$
    const openIndex = text.indexOf('$$', startIndex);
    if (openIndex === -1) break; // No more $$ found
    
    // Find closing $$
    const closeIndex = text.indexOf('$$', openIndex + 2);
    if (closeIndex === -1) break; // No closing $$ found
    
    // Extract LaTeX content without the $$ delimiters
    const latexContent = text.substring(openIndex + 2, closeIndex);
    
    // Add to matches
    matches.push({
      index: openIndex,
      endIndex: closeIndex + 2,
      latexContent: latexContent
    });
    
    // Continue searching after this match
    startIndex = closeIndex + 2;
  }
  
  return matches;
}

// Prepare LaTeX content for MathLive rendering
// This ensures curly braces like {x} are displayed literally
function prepareLatexForRendering(latex) {
  if (!latex) return '';
  
  // Replace curly braces around variable names with escaped versions
  // This will make MathLive display {x} as {x} rather than treating it as a group
  return latex.replace(/\{([a-zA-Z0-9_]+)\}/g, '\\{$1\\}');
}

// Get all text nodes in an element recursively
function getAllTextNodes(element) {
  const textNodes = [];
  
  function getTextNodes(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      // Skip empty text nodes
      if (node.textContent.trim() !== '') {
        textNodes.push(node);
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      // Skip existing equation elements
      if (!node.classList || !node.classList.contains('inline-equation')) {
        // Process child nodes
        for (let i = 0; i < node.childNodes.length; i++) {
          getTextNodes(node.childNodes[i]);
        }
      }
    }
  }
  
  getTextNodes(element);
  return textNodes;
}

/**
 * Safely parse strings like "π/3", "pi/2", "2π/#a#", "3/4" or "5.2" into Numbers.
 * Only the literal token Math.PI and digits / operators are allowed.
 */
 function parseGraphInput(str) {
  const v = String(str).trim().toLowerCase();

  // π-notation
  if (v.includes('π') || v.includes('pi')) {
    let norm = v
      .replace(/pi/g, 'π')                       // pi → π
      .replace(/(\d)(π)/g, '$1*π')              // 2π → 2*π
      .replace(/π/g, 'Math.PI');                // π → Math.PI

    // whitelist: only allow Math.PI or digits and these symbols
    const whitelist = /^(?:(?:Math\.PI)|[0-9\.\+\-\*\/\(\)\s])+$/;
    if (!whitelist.test(norm)) {
      console.warn('Invalid input:', str);
      return NaN;
    }

    try {
      return eval(norm);
    } catch {
      return NaN;
    }
  }

  // fraction a/b
  if (v.includes('/')) {
    const [n, d] = v.split('/').map(Number);
    if (!isNaN(n) && !isNaN(d) && d !== 0) {
      return n / d;
    }
    return NaN;
  }

  // plain decimal
  const num = parseFloat(v);
  return isNaN(num) ? NaN : num;
}

/**********************************************************************
 * helper 1 ─ tableToSVG(tableElement) ➜ returns raw SVG markup string
 *********************************************************************/
 function tableToSVG(table) {
  const rows = [...table.rows];
  if (!rows.length) return '';

  const colCount   = rows[0].cells.length;
  const colWidths  = Array(colCount).fill(0);
  // measure column widths & row heights
  const rowHeights = rows.map(row => {
    // spread row.cells so we can .forEach
    [...row.cells].forEach((cell, j) => {
      colWidths[j] = Math.max(colWidths[j], cell.offsetWidth);
    });
    // height of this row
    return row.cells[0].offsetHeight;
  });

  const W = colWidths.reduce((a,b)=>a+b,0),
        H = rowHeights.reduce((a,b)=>a+b,0);

  let svg = `<svg xmlns="http://www.w3.org/2000/svg"
                  width="${W}" height="${H}"
                  shape-rendering="crispEdges">`;

  // paint backgrounds and text (with correct font-weight!)
  let y = 0;
  rows.forEach((row,rIdx) => {
    let x = 0, rh = rowHeights[rIdx];
    [...row.cells].forEach((cell,cIdx) => {
      const cw = colWidths[cIdx],
            cs = getComputedStyle(cell),
            bg = cs.backgroundColor || '#fff',
            txt= cell.textContent
                     .replace(/&/g,'&amp;')
                     .replace(/</g,'&lt;')
                     .replace(/>/g,'&gt;');
      svg += `<rect x="${x}" y="${y}" width="${cw}" height="${rh}" fill="${bg}"/>`;
      svg += `<text x="${x + cw/2}" y="${y + rh/2}"
                    text-anchor="middle" dominant-baseline="middle"
                    font-family="${cs.fontFamily}"
                    font-size="${cs.fontSize}"
                    font-weight="${cs.fontWeight}">
                ${txt}
              </text>`;
      x += cw;
    });
    y += rh;
  });

  // draw grid lines inset by 0.5px so none get clipped
  svg += `<g stroke="#000" stroke-width="1">`;
  // horizontals
  svg += `<line x1="0" y1="0.5" x2="${W}" y2="0.5"/>`;
  y = 0;
  rowHeights.forEach((h,i) => {
    y += h;
    const pos = (i === rowHeights.length - 1 ? y - 0.5 : y);
    svg += `<line x1="0" y1="${pos}" x2="${W}" y2="${pos}"/>`;
  });
  // verticals
  let x = 0;
  svg += `<line x1="0.5" y1="0" x2="0.5" y2="${H}"/>`;
  colWidths.forEach((w,i) => {
    x += w;
    const pos = (i === colWidths.length - 1 ? x - 0.5 : x + 0.5);
    svg += `<line x1="${pos}" y1="0" x2="${pos}" y2="${H}"/>`;
  });
  svg += `</g></svg>`;

  return svg;
}

function replaceTablesWithSVG(root) {
  root.querySelectorAll('.table-container table').forEach(tbl => {
    const svgMarkup = tableToSVG(tbl);
    if (!svgMarkup) return;

    const img = new Image();
    img.src    = 'data:image/svg+xml;base64,' +
                 btoa(unescape(encodeURIComponent(svgMarkup)));
    img.style.display = 'block';
    img.style.width   = tbl.offsetWidth  + 'px';
    img.style.height  = tbl.offsetHeight + 'px';

    tbl.parentNode.replaceChild(img, tbl);
  });
}

// Function to process circle, chords and sectors for preview
function processCircleChordsAndSectors(cloneCanvas, computedVars) {
  const circleElements = cloneCanvas.querySelectorAll('.circle-container');
  console.log(`Processing ${circleElements.length} circles`);
  
  // Helper function for substitute values
  function substituteValue(value, variables) {
    if (typeof value !== 'string') return value;
    
    if (value.includes('#')) {
      // Get the variable name between # symbols
      const matches = value.match(/#([^#]+)#/g);
      if (matches && matches.length > 0) {
        let substitutedValue = value;
        matches.forEach(match => {
          const varName = match.substring(1, match.length - 1);
          if (variables.hasOwnProperty(varName)) {
            substitutedValue = substitutedValue.replace(match, variables[varName]);
          }
        });
        return substitutedValue;
      }
    }
    
    return value;
  }
  
  // Helper function to find segment intersection
  function segmentIntersection(p1, p2, p3, p4) {
    const [x1, y1, x2, y2] = [p1.x, p1.y, p2.x, p2.y];
    const [x3, y3, x4, y4] = [p3.x, p3.y, p4.x, p4.y];
    const denom = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
    if (Math.abs(denom) < 1e-6) return null;
    const xi = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/denom;
    const yi = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/denom;
    const onSeg = xi>=Math.min(x1,x2)-1e-6 && xi<=Math.max(x1,x2)+1e-6 && 
                  yi>=Math.min(y1,y2)-1e-6 && yi<=Math.max(y1,y2)+1e-6 && 
                  xi>=Math.min(x3,x4)-1e-6 && xi<=Math.max(x3,x4)+1e-6 && 
                  yi>=Math.min(y3,y4)-1e-6 && yi<=Math.max(y3,y4)+1e-6;
    return onSeg ? { x: xi, y: yi } : null;
  }
  
  // Process each circle element
  circleElements.forEach(element => {
    // Get the canvas element and its context
    const circleCanvas = element.querySelector("[id^='circleCanvas-']");
    if (!circleCanvas) return;
    
    // Get the stored data
    const data = element.circleData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process center point label if it contains variables
    if (typeof processedData.centerPoint.name === 'string' && processedData.centerPoint.name.includes('#')) {
      processedData.centerPoint.name = substituteValue(processedData.centerPoint.name, computedVars);
    }
    
    // Process point labels and positions if they contain variables
    processedData.userPoints.forEach(point => {
      // Process point names
      if (typeof point.name === 'string' && point.name.includes('#')) {
        point.name = substituteValue(point.name, computedVars);
      }
    });
    
    // Process intersection point names
    Object.keys(processedData.intersectionRegistry).forEach(key => {
      const intersection = processedData.intersectionRegistry[key];
      if (typeof intersection.name === 'string' && intersection.name.includes('#')) {
        intersection.name = substituteValue(intersection.name, computedVars);
      }
    });
    
    // Process sectors - check angle values and handle variables
    processedData.sectors.forEach(sector => {
      // Process angle if it's stored and contains variables
      if (sector.angle && typeof sector.angle === 'string' && sector.angle.includes('#')) {
        const angleStr = substituteValue(sector.angle, computedVars);
        const angleVal = parseFloat(angleStr);
        
        if (!isNaN(angleVal)) {
          // We got a valid numeric angle, update the sector points to match
          const cx = circleCanvas.width/2;
          const cy = circleCanvas.height/2;
          const rad = Math.min(circleCanvas.width, circleCanvas.height) * 0.35;
          const a1 = Math.atan2(
            processedData.userPoints[sector.a].y - cy,
            processedData.userPoints[sector.a].x - cx
          );
          const ang = angleVal * Math.PI / 180;
          
          // Update the second point position based on the angle
          processedData.userPoints[sector.b].x = cx + rad * Math.cos(ang + a1);
          processedData.userPoints[sector.b].y = cy + rad * Math.sin(ang + a1);
        }
      }
      
      // Process color if it's a variable
      if (typeof sector.color === 'string' && sector.color.includes('#')) {
        sector.color = substituteValue(sector.color, computedVars);
      }
    });
    
    // Process chords - check any variables
    processedData.chords.forEach(chord => {
      // Process color if it's a variable
      if (typeof chord.color === 'string' && chord.color.includes('#')) {
        chord.color = substituteValue(chord.color, computedVars);
      }
    });
    
    // Resize the preview-canvas to match its container
    const wrapper = circleCanvas.parentElement;
    circleCanvas.width = wrapper.clientWidth;
    circleCanvas.height = wrapper.clientHeight;
    
    // Recenter all points around the new canvas center
    const centerX = circleCanvas.width / 2;
    const centerY = circleCanvas.height / 2;
    const rad = Math.min(circleCanvas.width, circleCanvas.height) * 0.35;
    
    // Adjust all points to be on the circle circumference
    processedData.userPoints.forEach(point => {
      const angle = Math.atan2(point.y - centerY, point.x - centerX);
      point.x = centerX + rad * Math.cos(angle);
      point.y = centerY + rad * Math.sin(angle);
    });
    
    // Find and process intersections
    // Clear the visible intersections array
    processedData.visibleIntersections = [];
    
    // Set to track which stored intersections are still valid
    const validIntersectionKeys = new Set();
    
    const cx = centerX, cy = centerY;
    let newIntersectionCount = 0;
    
    // Process chord-chord intersections
    for (let i=0; i<processedData.chords.length; i++) {
      for (let j=i+1; j<processedData.chords.length; j++) {
        const ip = segmentIntersection(
          processedData.userPoints[processedData.chords[i].a], 
          processedData.userPoints[processedData.chords[i].b],
          processedData.userPoints[processedData.chords[j].a], 
          processedData.userPoints[processedData.chords[j].b]
        );
        
        if (ip) {
          // Create a unique key for this intersection
          const key = `chord${processedData.chords[i].a}-${processedData.chords[i].b}_chord${processedData.chords[j].a}-${processedData.chords[j].b}`;
          const reverseKey = `chord${processedData.chords[j].a}-${processedData.chords[j].b}_chord${processedData.chords[i].a}-${processedData.chords[i].b}`;
          
          let intersectionKey = null;
          
          // Check if we already have this intersection
          if (processedData.intersectionRegistry[key]) {
            intersectionKey = key;
          } else if (processedData.intersectionRegistry[reverseKey]) {
            intersectionKey = reverseKey;
          } else {
            // New intersection
            intersectionKey = key;
            processedData.intersectionRegistry[key] = {
              name: `I${++newIntersectionCount}`,
              color: '#000',
              visible: true,
              labelOffsetX: 10,
              labelOffsetY: -10
            };
          }
          
          // Mark this intersection as still valid
          validIntersectionKeys.add(intersectionKey);
          
          // Add to visible intersections if it's set to be visible
          if (processedData.intersectionRegistry[intersectionKey].visible) {
            processedData.visibleIntersections.push({
              x: ip.x,
              y: ip.y,
              key: intersectionKey,
              ...processedData.intersectionRegistry[intersectionKey]
            });
          }
        }
      }
    }
    
    // Process chord-radius intersections
    for (let i=0; i<processedData.chords.length; i++) {
      for (let j=0; j<processedData.userPoints.length; j++) {
        if (processedData.userPoints[j].r && processedData.userPoints[j].visible) {
          // Create a radius segment from center to point
          const radiusEnd = processedData.userPoints[j];
          const ip = segmentIntersection(
            processedData.userPoints[processedData.chords[i].a], 
            processedData.userPoints[processedData.chords[i].b],
            {x: cx, y: cy}, 
            radiusEnd
          );
          
          if (ip && 
              Math.hypot(ip.x-cx, ip.y-cy) > 1e-3 && // Not at center
              Math.hypot(ip.x-radiusEnd.x, ip.y-radiusEnd.y) > 1e-3 && // Not at end point
              Math.hypot(ip.x-processedData.userPoints[processedData.chords[i].a].x, ip.y-processedData.userPoints[processedData.chords[i].a].y) > 1e-3 && // Not at chord endpoints
              Math.hypot(ip.x-processedData.userPoints[processedData.chords[i].b].x, ip.y-processedData.userPoints[processedData.chords[i].b].y) > 1e-3)
          {
            // Create a unique key for this intersection
            const key = `chord${processedData.chords[i].a}-${processedData.chords[i].b}_radius${j}`;
            
            let intersectionKey = null;
            
            // Check if we already have this intersection
            if (processedData.intersectionRegistry[key]) {
              intersectionKey = key;
            } else {
              // New intersection
              intersectionKey = key;
              processedData.intersectionRegistry[key] = {
                name: `I${++newIntersectionCount}`,
                color: '#000',
                visible: true,
                labelOffsetX: 10,
                labelOffsetY: -10
              };
            }
            
            // Mark this intersection as still valid
            validIntersectionKeys.add(intersectionKey);
            
            // Add to visible intersections if it's set to be visible
            if (processedData.intersectionRegistry[intersectionKey].visible) {
              processedData.visibleIntersections.push({
                x: ip.x,
                y: ip.y,
                key: intersectionKey,
                ...processedData.intersectionRegistry[intersectionKey]
              });
            }
          }
        }
      }
    }
    
    // Remove any stored intersections that are no longer valid
    Object.keys(processedData.intersectionRegistry).forEach(key => {
      if (!validIntersectionKeys.has(key)) {
        delete processedData.intersectionRegistry[key];
      }
    });
    
    // Now draw the circle with processed data
    drawProcessedCircle(circleCanvas, processedData);
  });
  
  // Function to draw the processed circle
  function drawProcessedCircle(circleCanvas, data) {
    const ctx = circleCanvas.getContext('2d');
    
    // Get the dimensions
    const w = circleCanvas.width;
    const h = circleCanvas.height;
    const cx = w/2;
    const cy = h/2;
    const rad = Math.min(w, h) * 0.35;
    
    // Get style settings
    const fs = data.fontSize;
    const ps = data.pointSize;
    const th = data.radiusThickness;
    
    // Clear canvas
    ctx.clearRect(0, 0, w, h);
    
    // Set font size for all text
    ctx.font = `${fs}px Arial`;
    
    // Draw sectors
    data.sectors.forEach(s => {
      const p1 = data.userPoints[s.a];
      const p2 = data.userPoints[s.b];
      let a1 = Math.atan2(p1.y-cy, p1.x-cx);
      let a2 = Math.atan2(p2.y-cy, p2.x-cx);
      if (a2 < a1) a2 += 2*Math.PI;
      
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, rad, a1, a2);
      ctx.closePath();
      ctx.fill();
    });
    
    // Draw chord shades
    data.chords.forEach(c => {
      if (c.shade) {
        const p1 = data.userPoints[c.a];
        const p2 = data.userPoints[c.b];
        let a1 = (Math.atan2(p1.y-cy, p1.x-cx) + 2*Math.PI) % (2*Math.PI);
        let a2 = (Math.atan2(p2.y-cy, p2.x-cx) + 2*Math.PI) % (2*Math.PI);
        let diff = (a2-a1+2*Math.PI) % (2*Math.PI);
let ac = diff <= Math.PI;

ctx.save();
ctx.globalAlpha = 1;
ctx.fillStyle = c.color;
ctx.beginPath();
ctx.moveTo(p1.x, p1.y);
ctx.lineTo(p2.x, p2.y);
ctx.arc(cx, cy, rad, a2, a1, ac);
ctx.closePath();
ctx.fill();
ctx.restore();
      }
    });
    
    // Draw chord outlines
    data.chords.forEach(c => {
      const p1 = data.userPoints[c.a];
      const p2 = data.userPoints[c.b];
      ctx.strokeStyle = '#000';
      ctx.lineWidth = th;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    });
    
    // Draw circle
    ctx.strokeStyle = '#000';
    ctx.lineWidth = th;
    ctx.beginPath();
    ctx.arc(cx, cy, rad, 0, 2*Math.PI);
    ctx.stroke();
    
    // Draw radii
    data.userPoints.forEach(p => {
      if (p.r && p.visible) {
        ctx.strokeStyle = '#000';
        ctx.lineWidth = th;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
    });
    
    // Draw center
    if (data.centerPoint.visible) {
      ctx.fillStyle = data.centerPoint.color;
      ctx.beginPath();
      ctx.arc(cx, cy, ps, 0, 2*Math.PI);
      ctx.fill();
      
      // Draw center label
      ctx.fillText(data.centerPoint.name, 
                   cx + data.centerPoint.labelOffsetX, 
                   cy + data.centerPoint.labelOffsetY);
    }
    
    // Draw user points and their labels
    data.userPoints.forEach(p => {
      if (p.visible) {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, ps, 0, 2*Math.PI);
        ctx.fill();
        
        // Initialize labelOffset if not present
        if (p.labelOffsetX === undefined) p.labelOffsetX = ps;
        if (p.labelOffsetY === undefined) p.labelOffsetY = -ps;
        
        // Draw label
        ctx.fillText(p.name, p.x + p.labelOffsetX, p.y + p.labelOffsetY);
      }
    });
    
    // Draw intersection points and their labels
    data.visibleIntersections.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, ps, 0, 2*Math.PI);
      ctx.fill();
      
      // Draw label
      ctx.fillText(p.name, p.x + p.labelOffsetX, p.y + p.labelOffsetY);
    });
  }
}

function processAngle(cloneCanvas, computedVars) {
  const angleElements = cloneCanvas.querySelectorAll('.angle-container');
  console.log(`Processing ${angleElements.length} angles`);
  
  // Helper functions
  function drawSolidArrow(ctx, x1, y1, x2, y2) {
    const headLen = 15;
    const ang = Math.atan2(y2 - y1, x2 - x1);
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.stroke();
    
    const p1x = x2 - headLen * Math.cos(ang - Math.PI/6);
    const p1y = y2 - headLen * Math.sin(ang - Math.PI/6);
    const p2x = x2 - headLen * Math.cos(ang + Math.PI/6);
    const p2y = y2 - headLen * Math.sin(ang + Math.PI/6);
    
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(p1x, p1y);
    ctx.lineTo(p2x, p2y);
    ctx.closePath();
    ctx.fillStyle = '#333';
    ctx.fill();
  }
  
  function drawRightAngleSymbol(ctx, x, y, angle1, angle2) {
  const radius = 40 * 0.6;
  const markSize = 22;
  const p1x = x + radius * Math.cos(angle1);
  const p1y = y + radius * Math.sin(angle1);
  const p2x = x + radius * Math.cos(angle2);
  const p2y = y + radius * Math.sin(angle2);

  const perp1 = angle1 + Math.PI/2;
  const perp2 = angle2 - Math.PI/2;
  const end1x = p1x + markSize * Math.cos(perp1);
  const end1y = p1y + markSize * Math.sin(perp1);
  const end2x = p2x + markSize * Math.cos(perp2);
  const end2y = p2y + markSize * Math.sin(perp2);

  ctx.beginPath();
  ctx.moveTo(p1x, p1y);
  ctx.lineTo(end1x, end1y);
  ctx.lineTo(end2x, end2y);
  ctx.lineTo(p2x, p2y);
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

  
  // Check if angles are right angles
  function getInteriorAngle(a, b) {
    let d = (b - a + 2*Math.PI) % (2*Math.PI);
    return d > Math.PI ? 2*Math.PI - d : d;
  }
  
 function isRightAngleRad(rad) {
  let deg = ((rad + 2*Math.PI) % (2*Math.PI)) * 180/Math.PI;
  deg = deg > 180 ? 360 - deg : deg;
  return Math.abs(deg - 90) < 1.0;
}
  
  // Draw right angle symbols 
function drawAnyRightAngles(ctx, B, start, end, subVals, subAngles) {
  const rays = [ start, ...subAngles, end ], drawn = [];
  // single segments
  for (let i = 0; i < rays.length - 1; i++) {
    if (isRightAngleRad(rays[i+1] - rays[i])) {
      drawRightAngleSymbol(ctx, B.x, B.y, rays[i], rays[i+1]);
      drawn.push(`${i}-${i+1}`);
    }
  }
  // forward contiguous sums
  for (let i = 0; i < subVals.length; i++) {
    let sum = 0;
    for (let j = i; j < subVals.length; j++) {
      sum += subVals[j];
      if (Math.abs(sum - 90) < 1 && !drawn.includes(`${i}-${j+1}`)) {
        drawRightAngleSymbol(ctx, B.x, B.y, rays[i], rays[j+1]);
        drawn.push(`${i}-${j+1}`);
      }
    }
  }
}
  
  // This function is crucial and was missing before - it's in the original code
function drawRightAngleSymbols(ctx, B, start, end, subVals, subAngles) {
  // 1) your original per‐segment & forward‐sum logic
  drawAnyRightAngles(ctx, B, start, end, subVals, subAngles);

  // 2) backwards‐from‐rightmost contiguous sum
  const rays = [ start, ...subAngles, end ];
  const totalDeg = ((end - start) * 180/Math.PI + 360) % 360;
  const segs = subVals.slice();
  const used = segs.reduce((a,b)=>a+b, 0);
  segs.push(totalDeg - used);

  let acc = 0;
  for (let i = segs.length - 1; i >= 0; i--) {
    acc += segs[i];
    if (Math.abs(acc - 90) < 0.5) {
      drawRightAngleSymbol(ctx, B.x, B.y, rays[i], rays[rays.length - 1]);
      break;
    }
  }

  // 3) fallback if the entire angle ≈ 90°
  const interior = totalDeg > 180 ? 360 - totalDeg : totalDeg;
  if (Math.abs(interior - 90) < 0.5) {
    drawRightAngleSymbol(ctx, B.x, B.y, start, end);
  }
}

  // Main function to draw a processed angle
  function drawProcessedAngle(angleCanvas, data) {
    const ctx = angleCanvas.getContext('2d');
    const width = angleCanvas.width;
    const height = angleCanvas.height;
    
    // Constants from original drawing function
    const handleFactor = 0.78;
    const arcR = 40;
    const baseSpanRadius = arcR + 5;
    const spanRadiusIncrement = 8;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    const B = data.points[1];
    
    // Draw arrows
    drawSolidArrow(ctx, B.x, B.y, data.points[0].x, data.points[0].y);
    drawSolidArrow(ctx, B.x, B.y, data.points[2].x, data.points[2].y);
    
    // Draw subdivisions if any
    const lenAvg = (Math.hypot(data.points[0].x - B.x, data.points[0].y - B.y) + 
                   Math.hypot(data.points[2].x - B.x, data.points[2].y - B.y)) / 2;
    
    if (data.subAngles && data.subAngles.length > 0) {
      data.subAngles.forEach(theta => {
        const rx = B.x + lenAvg * Math.cos(theta);
        const ry = B.y + lenAvg * Math.sin(theta);
        drawSolidArrow(ctx, B.x, B.y, rx, ry);
      });
    }
    
    // Get angle information
    const v1 = Math.atan2(data.points[0].y - B.y, data.points[0].x - B.x);
    const v2 = Math.atan2(data.points[2].y - B.y, data.points[2].x - B.x);
    let start = v1, end = v2;
    if (end < start) end += 2 * Math.PI;
    
    // Draw spans based on span mode
    if (data.spanMode === 'all') {
      // Draw sub-arcs if there are subdivisions
      if (data.subdivisions > 1) {
        let currentStart = start;
        const colors = ['#0000ff', '#ff0000', '#00A000', '#A000A0']; // Blue, red, green, purple
        
        // Draw each subarc
        data.subAngles.forEach((theta, i) => {
          ctx.beginPath();
          ctx.arc(B.x, B.y, arcR, currentStart, theta);
          ctx.lineWidth = 3;
          ctx.strokeStyle = colors[i % colors.length];
          ctx.stroke();
          
          // Add notation and measure
          const midAngle = (currentStart + theta) / 2;
          
          // Get label position with offset if it exists
          const arcLabelKey = `arc-${i}`;
          let offset = data.labelOffsets[arcLabelKey] || { x: 0, y: 0 };
          const labelX = B.x + (arcR + 20) * Math.cos(midAngle) + offset.x;
          const labelY = B.y + (arcR + 20) * Math.sin(midAngle) + offset.y;
          
          const angleDeg = Math.round((theta - currentStart) * 180 / Math.PI);
          ctx.font = `${Math.round(data.fontSize * 0.85)}px sans-serif`;
          ctx.fillStyle = colors[i % colors.length];
          
          let labelText = '';
          if (data.showAngleNotation) {
            if (i === 0) {
              labelText += `∠${data.labels[0]}${data.labels[1]}${data.subLabels[0] || 'D'} `;
            } else {
              labelText += `∠${data.subLabels[i-1] || 'X'}${data.labels[1]}${data.subLabels[i] || 'Y'} `;
            }
          }
          if (data.showAngleMeasure) {
            labelText += `${angleDeg}°`;
          }
          
          ctx.fillText(labelText, labelX, labelY);
          
          currentStart = theta;
        });
        
        // Last segment
        ctx.beginPath();
        ctx.arc(B.x, B.y, arcR, currentStart, end);
        ctx.lineWidth = 3;
        ctx.strokeStyle = colors[data.subAngles.length % colors.length];
        ctx.stroke();
        
        // Add notation and measure for last segment
        const midAngle = (currentStart + end) / 2;
        
        // Get label position with offset if it exists
        const arcLabelKey = `arc-${data.subAngles.length}`;
        let offset = data.labelOffsets[arcLabelKey] || { x: 0, y: 0 };
        const labelX = B.x + (arcR + 20) * Math.cos(midAngle) + offset.x;
        const labelY = B.y + (arcR + 20) * Math.sin(midAngle) + offset.y;
        
        const angleDeg = Math.round((end - currentStart) * 180 / Math.PI);
        ctx.font = `${Math.round(data.fontSize * 0.85)}px sans-serif`;
        ctx.fillStyle = colors[data.subAngles.length % colors.length];
        
        let labelText = '';
        if (data.showAngleNotation) {
          labelText += `∠${data.subLabels[data.subAngles.length-1] || 'X'}${data.labels[1]}${data.labels[2]} `;
        }
        if (data.showAngleMeasure) {
          labelText += `${angleDeg}°`;
        }
        
        ctx.fillText(labelText, labelX, labelY);
      } else {
        // If no subdivisions, just draw the main arc
        ctx.beginPath();
        ctx.arc(B.x, B.y, arcR, start, end);
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#0000ff'; // Blue for single arc
        ctx.stroke();
        
        // Add angle notation and measure to main arc
        const midAngle = (start + end) / 2;
        
        // Calculate position with offset
        const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
        const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
        const offset = data.mainAngleLabelOffset || { x: 0, y: 0 };
        const labelX = baseX + offset.x;
        const labelY = baseY + offset.y;
        
        ctx.font = `${data.fontSize}px sans-serif`;
        ctx.fillStyle = '#0000ff';
        
        let labelText = '';
        if (data.showAngleNotation) {
          labelText += `∠${data.labels[0]}${data.labels[1]}${data.labels[2]} `;
        }
        if (data.showAngleMeasure) {
          labelText += `${parseFloat(data.angleDegrees) || 60}°`;
        }
        
        ctx.fillText(labelText, labelX, labelY);
      }
    } else if (data.spanMode === 'whole') {
      // Draw whole angle arc
      ctx.beginPath();
      ctx.arc(B.x, B.y, arcR, start, end);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#0000ff'; // Blue for whole arc
      ctx.stroke();
      
      // Add angle notation and measure
      const midAngle = (start + end) / 2;
      
      // Calculate position with offset
      const baseX = B.x + (arcR + 20) * Math.cos(midAngle);
      const baseY = B.y + (arcR + 20) * Math.sin(midAngle);
      const offset = data.mainAngleLabelOffset || { x: 0, y: 0 };
      const labelX = baseX + offset.x;
      const labelY = baseY + offset.y;
      
      ctx.font = `${data.fontSize}px sans-serif`;
      ctx.fillStyle = '#0000ff';
      
      let labelText = '';
      if (data.showAngleNotation) {
        labelText += `∠${data.labels[0]}${data.labels[1]}${data.labels[2]} `;
      }
      if (data.showAngleMeasure) {
        labelText += `${parseFloat(data.angleDegrees) || 60}°`;
      }
      
      ctx.fillText(labelText, labelX, labelY);
    } else if (data.spanMode === 'custom' && data.customSpans.length > 0) {
      // Draw custom spans
      data.customSpans.forEach((span, index) => {
        const radiusOffset = span.radius || baseSpanRadius;
        
        if (span.type === 'whole') {
          // Draw whole angle span
          ctx.beginPath();
          ctx.arc(B.x, B.y, radiusOffset, start, end);
          ctx.lineWidth = 3;
          ctx.strokeStyle = span.color;
          ctx.stroke();
          
          // Add notation and measure
          const midAngle = (start + end) / 2;
          
          // Get position with offset
          const baseX = B.x + (radiusOffset + 20) * Math.cos(midAngle);
          const baseY = B.y + (radiusOffset + 20) * Math.sin(midAngle);
          const spanKey = `span-${index}`;
          const offset = data.spanLabelOffsets[spanKey] || { x: 0, y: 0 };
          const labelX = baseX + offset.x;
          const labelY = baseY + offset.y;
          
          ctx.font = `${data.fontSize}px sans-serif`;
          ctx.fillStyle = span.color;
          
          let labelText = '';
          if (data.showAngleNotation) {
            labelText += `${span.notation} `;
          }
          if (data.showAngleMeasure) {
            labelText += `${span.measure}°`;
          }
          
          ctx.fillText(labelText, labelX, labelY);
        } else if (span.type === 'sub') {
          // Draw subangle span
          let segmentStart, segmentEnd;
          
          // For start angle: if first index is 0, use global start, else use subAngles[index - 1]
          if (span.indices[0] === 0) {
            segmentStart = start;
          } else {
            segmentStart = data.subAngles[span.indices[0] - 1];
          }
          
          // For end angle: if last index is the last segment, use global end, else use subAngles[index]
          if (span.indices[span.indices.length - 1] === data.subdivisions - 1) {
            segmentEnd = end;
          } else {
            segmentEnd = data.subAngles[span.indices[span.indices.length - 1]];
          }
          
          ctx.beginPath();
          ctx.arc(B.x, B.y, radiusOffset, segmentStart, segmentEnd);
          ctx.lineWidth = 3;
          ctx.strokeStyle = span.color;
          ctx.stroke();
          
          // Add notation and measure
          const midAngle = (segmentStart + segmentEnd) / 2;
          
          // Get position with offset
          const baseX = B.x + (radiusOffset + 20) * Math.cos(midAngle);
          const baseY = B.y + (radiusOffset + 20) * Math.sin(midAngle);
          const spanKey = `span-${index}`;
          const offset = data.spanLabelOffsets[spanKey] || { x: 0, y: 0 };
          const labelX = baseX + offset.x;
          const labelY = baseY + offset.y;
          
          ctx.font = `${data.fontSize}px sans-serif`;
          ctx.fillStyle = span.color;
          
          let labelText = '';
          if (data.showAngleNotation) {
            labelText += `${span.notation} `;
          }
          if (data.showAngleMeasure) {
            labelText += `${span.measure}°`;
          }
          
          ctx.fillText(labelText, labelX, labelY);
        }
      });
    }
    
    // Use the correct function to draw right angle symbols
    drawRightAngleSymbols(
      ctx,
      B,              // vertex point
      start,          // first ray angle
      end,            // second ray angle
      data.subAngleValues,
      data.subAngles,
      data.angleDegrees,
      data.spanMode,
      data.customSpans,
      baseSpanRadius
    );
    
    // Draw points
    if (data.showPoints) {
      // Draw handles for main points
      [data.points[0], data.points[2]].forEach(p => {
        const ang = Math.atan2(p.y - B.y, p.x - B.x);
        const len = Math.hypot(p.x - B.x, p.y - B.y);
        const hx = B.x + len * handleFactor * Math.cos(ang);
        const hy = B.y + len * handleFactor * Math.sin(ang);
        
        ctx.beginPath();
        ctx.arc(hx, hy, data.pointSize, 0, 2 * Math.PI);
        ctx.fillStyle = '#000';
        ctx.fill();
      });
      
      // Draw handles for subdivision points
      if (data.subAngles && data.subAngles.length > 0) {
        data.subAngles.forEach(theta => {
          const hx = B.x + lenAvg * handleFactor * Math.cos(theta);
          const hy = B.y + lenAvg * handleFactor * Math.sin(theta);
          
          ctx.beginPath();
          ctx.arc(hx, hy, data.pointSize, 0, 2 * Math.PI);
          ctx.fillStyle = '#000';
          ctx.fill();
        });
      }
      
      // Draw center point B
      ctx.beginPath();
      ctx.arc(B.x, B.y, data.pointSize, 0, 2 * Math.PI);
      ctx.fillStyle = '#000';
      ctx.fill();
    }
    
    // Draw labels
    if (data.showLabels) {
      // Draw main labels
      data.points.forEach((p, i) => {
        const ang = Math.atan2(p.y - B.y, p.x - B.x);
        const len = Math.hypot(p.x - B.x, p.y - B.y);
        
        let baseX, baseY;
        if (i === 1) {
          baseX = p.x;
          baseY = p.y;
        } else {
          baseX = B.x + len * handleFactor * Math.cos(ang);
          baseY = B.y + len * handleFactor * Math.sin(ang);
        }
        
        // Get offset
        const labelKey = `main-${i}`;
        const offset = data.labelOffsets[labelKey] || { x: 4, y: -4 };
        
        const labelX = baseX + offset.x;
        const labelY = baseY + offset.y;
        
        ctx.font = `${data.labelFontSize}px sans-serif`;
        ctx.fillStyle = '#333';
        ctx.fillText(data.labels[i], labelX, labelY);
      });
      
      // Draw sublabels if needed
      if (data.subLabels && data.subLabels.length > 0 && data.subAngles && data.subAngles.length > 0) {
        data.subAngles.forEach((theta, i) => {
          const baseX = B.x + lenAvg * handleFactor * Math.cos(theta);
          const baseY = B.y + lenAvg * handleFactor * Math.sin(theta);
          
          // Get offset
          const labelKey = `sub-${i}`;
          const offset = data.labelOffsets[labelKey] || { x: 4, y: -4 };
          
          const labelX = baseX + offset.x;
          const labelY = baseY + offset.y;
          
          ctx.font = `${data.labelFontSize}px sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(data.subLabels[i] || '', labelX, labelY);
        });
      }
    }
  }
  
  // Process each angle element
  angleElements.forEach(element => {
    // Get the canvas element and its context
    const angleCanvas = element.querySelector("[id^='angleCanvas-']");
    if (!angleCanvas) return;
    
    // Get the stored data
    const data = element.angleData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process angle parameters
    if (typeof data.angleDegrees === 'string' && data.angleDegrees.includes('#')) {
      const sub = substituteValue(data.angleDegrees, computedVars);
      const num = typeof sub === 'number' ? sub : parseFloat(sub);
      processedData.angleDegrees = isNaN(num) ? 90 : Math.min(360, Math.max(0, num));
      
      // Update angle points to reflect the new angle value
      const rad = processedData.angleDegrees * Math.PI / 180;
      const B = processedData.points[1];
      const v1 = Math.atan2(processedData.points[0].y - B.y, processedData.points[0].x - B.x);
      const len = Math.hypot(processedData.points[2].x - B.x, processedData.points[2].y - B.y);
      const newAng = v1 + rad;
      
      processedData.points[2].x = B.x + len * Math.cos(newAng);
      processedData.points[2].y = B.y + len * Math.sin(newAng);
    }
    
    // Process point labels if they contain variables
    for (let i = 0; i < processedData.labels.length; i++) {
      if (typeof processedData.labels[i] === 'string' && processedData.labels[i].includes('#')) {
        processedData.labels[i] = substituteValue(processedData.labels[i], computedVars);
      }
    }
    
    // Process subdivisions if needed
    if (typeof data.subdivisions === 'string' && data.subdivisions.includes('#')) {
      const sub = substituteValue(data.subdivisions, computedVars);
      const num = typeof sub === 'number' ? sub : parseInt(sub);
      processedData.subdivisions = isNaN(num) ? 1 : Math.max(1, Math.min(10, num));
    }
    
    // Setup sub-labels based on subdivisions
    processedData.subLabels = [];
    for (let i = 1; i < processedData.subdivisions; i++) {
      const char = String.fromCharCode('A'.charCodeAt(0) + 2 + i);
      processedData.subLabels.push(char);
    }
    
    // Process sublabels if they contain variables (after they're generated)
    if (processedData.subLabels) {
      for (let i = 0; i < processedData.subLabels.length; i++) {
        if (typeof processedData.subLabels[i] === 'string' && processedData.subLabels[i].includes('#')) {
          processedData.subLabels[i] = substituteValue(processedData.subLabels[i], computedVars);
        }
      }
    }
    
    // Calculate sub-angles
 // Preserve any user-dragged subdivisions
processedData.subAngles      = data.subAngles.slice();
processedData.subAngleValues = data.subAngleValues.slice();

    
    // Update custom spans if any
    if (processedData.customSpans && processedData.customSpans.length > 0) {
      processedData.customSpans.forEach(span => {
        if (span.type === 'whole') {
          span.measure = processedData.angleDegrees;
        } else if (span.type === 'sub') {
          // Calculate the measure of this span
          let spanMeasure = 0;
          for (let i = span.indices[0]; i <= span.indices[span.indices.length - 1]; i++) {
            if (i === processedData.subdivisions - 1) {
              // Last segment
              const totalSubAngles = processedData.subAngleValues.reduce((sum, val) => sum + val, 0);
              spanMeasure += processedData.angleDegrees - totalSubAngles;
            } else {
              spanMeasure += processedData.subAngleValues[i];
            }
          }
          span.measure = Math.round(spanMeasure);
        }
      });
    }
    
    // Resize the preview-canvas to match its container
    const wrapper = angleCanvas.parentElement;
    angleCanvas.width = wrapper.clientWidth;
    angleCanvas.height = wrapper.clientHeight;
    
    // Recenter all points around the new canvas center
    const centerX = angleCanvas.width / 2;
    const centerY = angleCanvas.height / 2;
    const oldB = processedData.points[1];
    const shiftX = centerX - oldB.x;
    const shiftY = centerY - oldB.y;
    processedData.points.forEach(pt => {
      pt.x += shiftX;
      pt.y += shiftY;
    });
    
    // Now draw the angle with processed data
    drawProcessedAngle(angleCanvas, processedData);
  });
}


// Process number lines in the cloned canvas
function processNumberLine(cloneCanvas, computedVars) {
  const numberLineElements = cloneCanvas.querySelectorAll('.number-line-container');
  console.log(`Processing ${numberLineElements.length} number lines`);
  
  numberLineElements.forEach(element => {
    // Get the SVG container and the stored data
    const svgContainer = element.querySelector("[id^='numberLineSVG-']");
    if (!svgContainer) return;
    
    const data = element.numberLineData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process number line parameters
    // Min and Max values
    if (typeof data.minValue === 'string' && data.minValue.includes('#')) {
      const sub = substituteValue(data.minValue, computedVars);
      const num = typeof sub === 'number' ? sub : parseFloat(sub);
      processedData.minValue = isNaN(num) ? -10 : num;
    }
    
    if (typeof data.maxValue === 'string' && data.maxValue.includes('#')) {
      const sub = substituteValue(data.maxValue, computedVars);
      const num = typeof sub === 'number' ? sub : parseFloat(sub);
      processedData.maxValue = isNaN(num) ? 10 : num;
    }
    
    if (typeof data.tickInterval === 'string' && data.tickInterval.includes('#')) {
      const sub = substituteValue(data.tickInterval, computedVars);
      processedData.tickInterval = isNaN(sub) ? 1 : sub;
    }
    
    if (typeof data.labelInterval === 'string' && data.labelInterval.includes('#')) {
      const sub = substituteValue(data.labelInterval, computedVars);
      processedData.labelInterval = isNaN(sub) ? 1 : sub;
    }
    
    // Process points
    processedData.points.forEach((pt, i) => {
      // Process value
      if (typeof data.points[i].value === 'string' && data.points[i].value.includes('#')) {
        const processedValue = substituteValue(data.points[i].value, computedVars);
        const numValue = Number(processedValue);
        pt.value = isNaN(numValue) ? 0 : numValue;
      }
      
      // Process label if it contains variables
      if (typeof data.points[i].label === 'string' && data.points[i].label.includes('#')) {
        pt.label = substituteValue(data.points[i].label, computedVars);
      }
    });
    
    // Process inequalities
    processedData.inequalities.forEach((ineq, i) => {
      if (ineq.type === 'simple') {
        // Process simple inequality value
        if (typeof data.inequalities[i].value === 'string' && data.inequalities[i].value.includes('#')) {
          const processedValue = substituteValue(data.inequalities[i].value, computedVars);
          const numValue = Number(processedValue);
          ineq.value = isNaN(numValue) ? 0 : numValue;
        }
      } else if (ineq.type === 'and' || ineq.type === 'or') {
        // Process combined inequality values
        if (typeof data.inequalities[i].value1 === 'string' && data.inequalities[i].value1.includes('#')) {
          const processedValue = substituteValue(data.inequalities[i].value1, computedVars);
          const numValue = Number(processedValue);
          ineq.value1 = isNaN(numValue) ? 0 : numValue;
        }
        
        if (typeof data.inequalities[i].value2 === 'string' && data.inequalities[i].value2.includes('#')) {
          const processedValue = substituteValue(data.inequalities[i].value2, computedVars);
          const numValue = Number(processedValue);
          ineq.value2 = isNaN(numValue) ? 0 : numValue;
        }
      }
    });
    
    // Process spans
    processedData.spans.forEach((span, i) => {
      // Process start value
      if (typeof data.spans[i].startValue === 'string' && data.spans[i].startValue.includes('#')) {
        const processedValue = substituteValue(data.spans[i].startValue, computedVars);
        const numValue = Number(processedValue);
        span.startValue = isNaN(numValue) ? 0 : numValue;
      }
      
      // Process end value
      if (typeof data.spans[i].endValue === 'string' && data.spans[i].endValue.includes('#')) {
        const processedValue = substituteValue(data.spans[i].endValue, computedVars);
        const numValue = Number(processedValue);
        span.endValue = isNaN(numValue) ? 0 : numValue;
      }
    });
    
    // Now draw the number line with processed data
    // Create safe HTML escaping function
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
    
    // Parse input helper function
    function parseInput(input) {
      if (!input) {
        return null;
      }
      
      // If input is not a string, convert it to a string
      if (typeof input !== 'string') {
        input = String(input);
      }
      
      // Now we can safely trim
      input = input.trim();
      
      // Check if it's a fraction
      if (input.includes('/')) {
        const parts = input.split('/');
        if (parts.length !== 2) {
          return null;
        }
        
        const numerator = parseFloat(parts[0]);
        const denominator = parseFloat(parts[1]);
        
        if (isNaN(numerator) || isNaN(denominator) || denominator === 0) {
          return null;
        }
        
        return numerator / denominator;
      }
      
      // Otherwise, it's a regular number
      const num = parseFloat(input);
      return isNaN(num) ? null : num;
    }
    
    // Get values from processed data
    const minValue = processedData.minValue;
    const maxValue = processedData.maxValue;
    const tickInterval = parseInput(processedData.tickInterval) || 1;
    const labelInterval = parseInput(processedData.labelInterval) || 1;
    
    // Generate tick positions
    const tickPositions = [];
    for (let i = minValue; i <= maxValue; i = parseFloat((i + tickInterval).toFixed(6))) {
      tickPositions.push(i);
    }
    
    // Generate label positions
    const labelPositions = [];
    for (let i = minValue; i <= maxValue; i = parseFloat((i + labelInterval).toFixed(6))) {
      labelPositions.push(i);
    }
    
    // Fixed positions for visual elements
    const leftEdge = 50; // Position for minValue
    const rightEdge = 550; // Position for maxValue
    const lineY = 80; // Y-position of the number line
    const arrowElevation = 25; // How high above the number line the arrows should be
    
    // Convert a value to an x-position on the SVG
    const valueToPosition = (value) => {
      const percentage = (value - minValue) / (maxValue - minValue);
      return leftEdge + percentage * (rightEdge - leftEdge);
    };
    
    // Function to check for no solution in AND inequalities
    function isNoSolutionAnd(ineq) {
      if (ineq.type !== 'and') return false;
      // Collect all ">" bounds as lows, all "<" bounds as highs
      const lows = [];
      const highs = [];

      [['operator1','value1'], ['operator2','value2']].forEach(([opKey,valKey])=>{
        const op = ineq[opKey], v = ineq[valKey];
        if (op === '>' || op === '>=') lows.push({v, inc: op==='>='}); 
        if (op === '<' || op === '<=') highs.push({v, inc: op==='<='});
      });

      if (!lows.length || !highs.length) return false;
      // Pick the strictest: max(low.v) and min(high.v)
      const low = lows.reduce((a,b)=> b.v>a.v?b:a);
      const high = highs.reduce((a,b)=> b.v<a.v?b:a);
      // No solution if low > high,
      // or if low==high but at least one is open
      if (low.v > high.v) return true;
      if (low.v === high.v && !(low.inc && high.inc)) return true;
      return false;
    }
    
    // Function to normalize inequalities
    function normalizeInequalities(raw) {
      return raw.map(ineq => {
        // Shallow copy so we don't mutate the original
        let q = { ...ineq };

        if (q.type === 'and') {
          // Two lower bounds: collapse to the stricter >-type
          if ((q.operator1 === '>' || q.operator1 === '>=') &&
              (q.operator2 === '>' || q.operator2 === '>=')) {
            const v = Math.max(q.value1, q.value2);
            let op;
            if (q.value1 > q.value2) op = q.operator1;
            else if (q.value2 > q.value1) op = q.operator2;
            else op = (q.operator1==='>'||q.operator2==='>')?'>':'>=';
            q = { type:'simple', operator: op, value: v, color: q.color };
          }
          // Two upper bounds: collapse to the stricter <-type
          if ((q.operator1 === '<' || q.operator1 === '<=') &&
              (q.operator2 === '<' || q.operator2 === '<=')) {
            const v = Math.min(q.value1, q.value2);
            let op;
            if (q.value1 < q.value2) op = q.operator1;
            else if (q.value2 < q.value1) op = q.operator2;
            else op = (q.operator1==='<'||q.operator2==='<')?'<':'<=';
            q = { type:'simple', operator: op, value: v, color: q.color };
          }
        }

        if (q.type === 'or') {
          // Two "<" parts collapse to the stricter one
          if ((q.operator1 === '<' || q.operator1 === '<=') &&
              (q.operator2 === '<' || q.operator2 === '<=')) {
            const v = Math.max(q.value1, q.value2);
            let op;
            if (q.value1 > q.value2) op = q.operator1;
            else if (q.value2 > q.value1) op = q.operator2;
            else op = (q.operator1==='<'||q.operator2==='<')?'<':'<=';
            q = { type:'simple', operator: op, value: v, color: q.color };
          }
          // Two ">" parts collapse to the stricter one
          if ((q.operator1 === '>' || q.operator1 === '>=') &&
              (q.operator2 === '>' || q.operator2 === '>=')) {
            const v = Math.min(q.value1, q.value2);
            let op;
            if (q.value1 < q.value2) op = q.operator1;
            else if (q.value2 < q.value1) op = q.operator2;
            else op = (q.operator1==='>'||q.operator2==='>')?'>':'>=';
            q = { type:'simple', operator: op, value: v, color: q.color };
          }

          // Truly "everything covered" only when the <-cutoff ≥ the >-cutoff
          if ((q.operator1 === '<' || q.operator1 === '<=') &&
              (q.operator2 === '>' || q.operator2 === '>=') &&
              q.value1 >= q.value2) {
            q = { type:'all', color: q.color };
          }
          if ((q.operator1 === '>' || q.operator1 === '>=') &&
              (q.operator2 === '<' || q.operator2 === '<=') &&
              q.value1 <= q.value2) {
            q = { type:'all', color: q.color };
          }
        }

        return q;
      });
    }
    
    // Start building SVG content
    let svgContent = `<svg viewBox="0 0 600 150" xmlns="http://www.w3.org/2000/svg">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Computer+Modern&amp;display=swap');
  </style>`;
    
    // Add inequalities as elevated arrows
    // Check if any AND-compound has no overlap
    const noSolution = processedData.inequalities.some(isNoSolutionAnd);
    const normIneq = noSolution ? [] : normalizeInequalities(processedData.inequalities);
    
    normIneq.forEach(ineq => {
      const color = ineq.color || '#0000FF';

      if (ineq.type === 'all') {
        // Full-width band
        svgContent += `
  <line
    x1="${leftEdge}" y1="${lineY - arrowElevation}"
    x2="${rightEdge}" y2="${lineY - arrowElevation}"
    stroke="${color}" stroke-width="4" />`;
      }
      else if (ineq.type === 'simple') {
        // x < a  or  x > a
        const startX = valueToPosition(ineq.value);
        const endX = (ineq.operator === '<' || ineq.operator === '<=')
                       ? leftEdge
                       : rightEdge;
        const includeStart = ineq.operator === '<=' || ineq.operator === '>=';

        // Line + arrowhead
        svgContent += `
  <line x1="${startX}" y1="${lineY - arrowElevation}"
        x2="${endX}"   y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}"/>`;

        if (startX < endX) {
          // Right-pointing
          svgContent += `
  <polygon points="${endX},${lineY - arrowElevation}
                  ${endX-10},${lineY - arrowElevation-5}
                  ${endX-10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />`;
        } else {
          // Left-pointing
          svgContent += `
  <polygon points="${endX},${lineY - arrowElevation}
                  ${endX+10},${lineY - arrowElevation-5}
                  ${endX+10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />`;
        }

        // Open vs closed circle
        svgContent += `
  <circle
    cx="${startX}" cy="${lineY - arrowElevation}"
    r="5"
    fill="${includeStart ? color : 'white'}"
    stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
      }
      else if (ineq.type === 'and') {
        // a < x < b  (or variants)
        let leftPoint, rightPoint, leftOp, rightOp;
        if (ineq.value1 <= ineq.value2) {
          leftPoint = ineq.value1;  leftOp = ineq.operator1;
          rightPoint = ineq.value2; rightOp = ineq.operator2;
        } else {
          leftPoint = ineq.value2;  leftOp = ineq.operator2;
          rightPoint = ineq.value1; rightOp = ineq.operator1;
        }
        const x1 = valueToPosition(leftPoint);
        const x2 = valueToPosition(rightPoint);
        const fill1 = (leftOp === '>=' ? color : 'white');
        const fill2 = (rightOp === '<=' ? color : 'white');

        // Connecting line
        svgContent += `
  <line x1="${x1}" y1="${lineY - arrowElevation}"
        x2="${x2}" y2="${lineY - arrowElevation}"
        stroke="${color}"stroke-width="${ineq.strokeWidth || 2}"/>`;

        // Endpoints
        svgContent += `
  <circle cx="${x1}" cy="${lineY - arrowElevation}"
          r="5" fill="${fill1}" stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <circle cx="${x2}" cy="${lineY - arrowElevation}"
          r="5" fill="${fill2}" stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
      }
      else if (ineq.type === 'or') {
        // x < a OR x > b
        const v1 = ineq.value1, v2 = ineq.value2;
        const x1 = valueToPosition(v1), x2 = valueToPosition(v2);
        const inc1 = ineq.operator1.includes('=');
        const inc2 = ineq.operator2.includes('=');

        // Left-side
        if (ineq.operator1.startsWith('<')) {
          svgContent += `
  <line x1="${x1}" y1="${lineY - arrowElevation}"
        x2="${leftEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <polygon points="${leftEdge},${lineY - arrowElevation}
                  ${leftEdge+10},${lineY - arrowElevation-5}
                  ${leftEdge+10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x1}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc1 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}"/>`;
        } else {
          svgContent += `
  <line x1="${x1}" y1="${lineY - arrowElevation}"
        x2="${rightEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <polygon points="${rightEdge},${lineY - arrowElevation}
                  ${rightEdge-10},${lineY - arrowElevation-5}
                  ${rightEdge-10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x1}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc1 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
        }

        // Right-side
        if (ineq.operator2.startsWith('<')) {
          svgContent += `
  <line x1="${x2}" y1="${lineY - arrowElevation}"
        x2="${leftEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <polygon points="${leftEdge},${lineY - arrowElevation}
                  ${leftEdge+10},${lineY - arrowElevation-5}
                  ${leftEdge+10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x2}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc2 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
        } else {
          svgContent += `
  <line x1="${x2}" y1="${lineY - arrowElevation}"
        x2="${rightEdge}" y2="${lineY - arrowElevation}"
        stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />
  <polygon points="${rightEdge},${lineY - arrowElevation}
                  ${rightEdge-10},${lineY - arrowElevation-5}
                  ${rightEdge-10},${lineY - arrowElevation+5}"
           fill="${color}" stroke="${color}" />
  <circle cx="${x2}" cy="${lineY - arrowElevation}"
          r="5" fill="${inc2 ? color : 'white'}"
          stroke="${color}" stroke-width="${ineq.strokeWidth || 2}" />`;
        }
      }
    });
    
    // Add spans
    // Initial Y position for the first span (higher than default)
    let currentSpanY = lineY - 20; // Increased from -15 to -30 for higher placement
    const spanVerticalSpacing = 13; // Space between multiple spans

    processedData.spans.forEach((span) => {
      // Validate span data
      if (isNaN(span.startValue) || isNaN(span.endValue) || 
          span.startValue < minValue || span.startValue > maxValue ||
          span.endValue < minValue || span.endValue > maxValue) {
        return; // Skip invalid spans
      }
      
      const x1 = valueToPosition(span.startValue);
      const x2 = valueToPosition(span.endValue);
      const y = currentSpanY; // Use the current span height
      const safeColor = /^#[0-9A-Fa-f]{6}$/.test(span.color) ? span.color : "#0000FF"; // Changed default to blue
      const width = Math.min(Math.max(1, span.width), 5);
      
      if (span.type === 'line') {
        // Simple span with vertical bars at ends: |-----|
        svgContent += `
  <line x1="${x1}" y1="${y-5}" x2="${x1}" y2="${y+5}" stroke="${safeColor}" stroke-width="${width}" />
  <line x1="${x1}" y1="${y}" x2="${x2}" y2="${y}" stroke="${safeColor}" stroke-width="${width}" />
  <line x1="${x2}" y1="${y-5}" x2="${x2}" y2="${y+5}" stroke="${safeColor}" stroke-width="${width}" />`;
      } else if (span.type === 'arrow') {
        // Arrow from start to end
        const arrowSize = width * 4; 

        svgContent += `
  <line x1="${x1}" y1="${y}" x2="${x2}" y2="${y}" stroke="${safeColor}" stroke-width="${width}" />`;
        
        // Add arrow head
        if (x1 < x2) {
          // Right-pointing arrow
          svgContent += `
  <polygon points="${x2},${y} ${x2-arrowSize},${y-arrowSize/2} ${x2-arrowSize},${y+arrowSize/2}" fill="${safeColor}" stroke="${safeColor}" />`;
        } else {
          // Left-pointing arrow
          svgContent += `
  <polygon points="${x2},${y} ${x2+arrowSize},${y-arrowSize/2} ${x2+arrowSize},${y+arrowSize/2}" fill="${safeColor}" stroke="${safeColor}" />`;
        }
      } else if (span.type === 'bouncy') {
        // Bouncy arrow (curved path)
        const midX = (x1 + x2) / 2;
        const controlY = y - 20; // Control point height
        const arrowSize = width * 4; 

        
        // Create curved path
        svgContent += `
  <path d="M ${x1} ${y} Q ${midX} ${controlY} ${x2} ${y}" fill="none" stroke="${safeColor}" stroke-width="${width}" />`;
        
        // Add arrow head
        if (x1 < x2) {
          // Right-pointing arrow at end
          const dx = x2 - (x2 - midX) * 0.1; // Calculate position for arrow direction
          const dy = y - (y - controlY) * 0.1;
          const angle = Math.atan2(y - dy, x2 - dx);
          
          const ax1 = x2 - arrowSize * Math.cos(angle - Math.PI/6);
          const ay1 = y - arrowSize * Math.sin(angle - Math.PI/6);
          const ax2 = x2 - arrowSize * Math.cos(angle + Math.PI/6);
          const ay2 = y - arrowSize * Math.sin(angle + Math.PI/6);
          
          svgContent += `
  <polygon points="${x2},${y} ${ax1},${ay1} ${ax2},${ay2}" fill="${safeColor}" stroke="${safeColor}" />`;
        } else {
          // Left-pointing arrow at end
          // Compute true end-tangent from control-point (midX, controlY) → end-point (x2, y)
          const dx = x2 - midX;
          const dy = y - controlY;
          // Direction of the tangent, then flip by π so arrow wings point backward
          const angle = Math.atan2(dy, dx) + Math.PI;

          // Build the two "wings" at ±30° (π/6) around that flipped angle
          const ax1 = x2 + arrowSize * Math.cos(angle - Math.PI/6);
          const ay1 = y + arrowSize * Math.sin(angle - Math.PI/6);
          const ax2 = x2 + arrowSize * Math.cos(angle + Math.PI/6);
          const ay2 = y + arrowSize * Math.sin(angle + Math.PI/6);

          svgContent += `
  <polygon points="${x2},${y} ${ax1},${ay1} ${ax2},${ay2}"
         fill="${safeColor}" stroke="${safeColor}" />`;
        }
      }
      
      // Move down for the next span
      currentSpanY -= spanVerticalSpacing;
    });
    
    // Continue with base SVG elements
    svgContent += `
  <!-- Number Line with Short Ticks and Compact Spacing -->
  <line x1="25" y1="${lineY}" x2="575" y2="${lineY}" stroke="black" stroke-width="3"/>
  <polygon points="0,${lineY} 25,${lineY-8} 25,${lineY+8}" fill="black"/>
  <polygon points="600,${lineY} 575,${lineY-8} 575,${lineY+8}" fill="black"/>
  
  <!-- Tick marks and numbers -->`;
    
    // Add tick marks
    tickPositions.forEach((value) => {
      const xPosition = valueToPosition(value);
      
      svgContent += `
  <line x1="${xPosition}" y1="${lineY-10}" x2="${xPosition}" y2="${lineY+10}" stroke="black" stroke-width="2"/>`;
    });
    
    // Add labels
    labelPositions.forEach((value) => {
      const xPosition = valueToPosition(value);
      
      let labelText = Number.isInteger(value) ? value : parseFloat(value.toFixed(3));
      
      svgContent += `
  <text x="${xPosition}" y="${lineY+30}" font-family="Computer Modern, serif" font-size="16" text-anchor="middle" font-weight="bold">${escapeHtml(labelText.toString())}</text>`;
    });
    
    // Add points
    processedData.points.forEach((point) => {
      // Validate point data
      if (isNaN(point.value) || point.value < minValue || point.value > maxValue) {
        return; // Skip invalid points
      }
      
      const xPosition = valueToPosition(point.value);
      
      // Validate and limit size
      const size = Math.min(Math.max(1, point.size || 4), 20);
      const safeColor = /^#[0-9A-Fa-f]{6}$/.test(point.color) ? point.color : "#000000";
      
      // Add point
      svgContent += `
  <circle cx="${xPosition}" cy="${lineY}" r="${size}" fill="${safeColor}"/>`;
      
      // If showLabel is false, don't draw the label
      if (!point.showLabel) return;
      
      // Calculate label position
      let labelX = xPosition;
      let labelY = lineY;
      const fontSize = Math.min(Math.max(6, point.fontSize || 12), 48);
      const offset = 10 + fontSize / 2;
      
      // Validate position
      const position = ['up', 'down', 'left', 'right', 'upleft', 'upright', 'downleft', 'downright'].includes(point.position) ? point.position : 'up';
      
      switch(position) {
        case 'up':
          labelY -= offset;
          break;
        case 'down':
          labelY += offset;
          break;
        case 'left':
          labelX -= offset;
          break;
        case 'right':
          labelX += offset;
          break;
        case 'upleft':
          labelX -= offset/1.5;
          labelY -= offset/1.5;
          break;
        case 'upright':
          labelX += offset/1.5;
          labelY -= offset/1.5;
          break;
        case 'downleft':
          labelX -= offset/1.5;
          labelY += offset/1.5;
          break;
        case 'downright':
          labelX += offset/1.5;
          labelY += offset/1.5;
          break;
        default:
          labelY -= offset;
      }
      
      // Sanitize and limit label length
      const safeLabel = escapeHtml(point.label.substring(0, 10) || "");
      
      // Add label
      svgContent += `
  <text x="${labelX}" y="${labelY}"
        font-family="Computer Modern, serif"
        font-size="${fontSize}"
        text-anchor="middle"
        fill="${safeColor}">
    ${safeLabel}
  </text>`;
    });
    
    // Close SVG
    svgContent += `
</svg>`;
    
    // Update preview
    svgContainer.innerHTML = svgContent;
  });
}


// Process quad one graphs in the cloned canvas
function processQuadOneGraphInClone(cloneCanvas, computedVars) {
  const quadOneGraphElements = cloneCanvas.querySelectorAll('.quad-one-graph-container');
  console.log(`Processing ${quadOneGraphElements.length} quadrant one graphs`);
  
  quadOneGraphElements.forEach(element => {
    // Get the canvas element and the stored data
    const graphCanvas = element.querySelector("canvas");
    if (!graphCanvas) return;
    
    const data = element.graphData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process axis parameters
    // X-axis parameters
    if (typeof data.xmin === 'string') {
      const sub = substituteValue(data.xmin, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xmin = isNaN(num) ? 0 : Math.max(0, num); // Ensure xmin is not negative
    }
    
    if (typeof data.xmax === 'string') {
      const sub = substituteValue(data.xmax, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xmax = isNaN(num) ? 10 : num;
    }
    
    if (typeof data.xscale === 'string') {
      const sub = substituteValue(data.xscale, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xscale = isNaN(num) ? 1 : num;
    }
    
    if (typeof data.xlabelInterval === 'string') {
      const sub = substituteValue(data.xlabelInterval, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xlabelInterval = isNaN(num) ? 1 : num;
    }
    
    // Y-axis parameters
    if (typeof data.ymin === 'string') {
      const sub = substituteValue(data.ymin, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.ymin = isNaN(num) ? 0 : Math.max(0, num); // Ensure ymin is not negative
    }
    
    if (typeof data.ymax === 'string') {
      const sub = substituteValue(data.ymax, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.ymax = isNaN(num) ? 10 : num;
    }
    
    if (typeof data.yscale === 'string') {
      const sub = substituteValue(data.yscale, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.yscale = isNaN(num) ? 1 : num;
    }
    
    if (typeof data.ylabelInterval === 'string') {
      const sub = substituteValue(data.ylabelInterval, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.ylabelInterval = isNaN(num) ? 1 : num;
    }
    
    // Process custom labels if they contain variables
    if (typeof data.xAxisLabel === 'string' && data.xAxisLabel.includes('#')) {
      processedData.xAxisLabel = substituteValue(data.xAxisLabel, computedVars);
    }
    
    if (typeof data.yAxisLabel === 'string' && data.yAxisLabel.includes('#')) {
      processedData.yAxisLabel = substituteValue(data.yAxisLabel, computedVars);
    }
    
    // Process equations
    processedData.equations.forEach((eq, i) => {
      // Process domain restrictions
      if (typeof data.equations[i].domainMin === 'string') {
        const processedDomainMin = substituteValue(data.equations[i].domainMin, computedVars);
        const numDomainMin = Number(processedDomainMin);
        eq.domainMin = isNaN(numDomainMin) ? '' : Math.max(0, numDomainMin).toString(); // Ensure domainMin is not negative
      }
      
      if (typeof data.equations[i].domainMax === 'string') {
        const processedDomainMax = substituteValue(data.equations[i].domainMax, computedVars);
        const numDomainMax = Number(processedDomainMax);
        eq.domainMax = isNaN(numDomainMax) ? '' : numDomainMax.toString();
      }
      
      // Process equation text if it contains variables
      if (typeof data.equations[i].equation === 'string' && data.equations[i].equation.includes('#')) {
        eq.equation = substituteValue(data.equations[i].equation, computedVars);
      }
    });
    
    // Process points
    processedData.points.forEach((pt, i) => {
      // Process x coordinate
      if (typeof data.points[i].x === 'string') {
        const processedX = substituteValue(data.points[i].x, computedVars);
        const numX = Number(processedX);
        pt.x = isNaN(numX) ? 0 : Math.max(0, numX); // Ensure x is not negative
      }
      
      // Process y coordinate
      if (typeof data.points[i].y === 'string') {
        const processedY = substituteValue(data.points[i].y, computedVars);
        const numY = Number(processedY);
        pt.y = isNaN(numY) ? 0 : Math.max(0, numY); // Ensure y is not negative
      }
      
      // Process label if it contains variables
      if (typeof data.points[i].label === 'string' && data.points[i].label.includes('#')) {
        pt.label = substituteValue(data.points[i].label, computedVars);
      }
    });
    
    // Process segments
    processedData.segments.forEach((seg, i) => {
      // Process start point (x1, y1)
      if (typeof data.segments[i].x1 === 'string') {
        const processedX1 = substituteValue(data.segments[i].x1, computedVars);
        const numX1 = Number(processedX1);
        seg.x1 = isNaN(numX1) ? 0 : Math.max(0, numX1); // Ensure x1 is not negative
      }
      
      if (typeof data.segments[i].y1 === 'string') {
        const processedY1 = substituteValue(data.segments[i].y1, computedVars);
        const numY1 = Number(processedY1);
        seg.y1 = isNaN(numY1) ? 0 : Math.max(0, numY1); // Ensure y1 is not negative
      }
      
      // Process end point (x2, y2)
      if (typeof data.segments[i].x2 === 'string') {
        const processedX2 = substituteValue(data.segments[i].x2, computedVars);
        const numX2 = Number(processedX2);
        seg.x2 = isNaN(numX2) ? 0 : Math.max(0, numX2); // Ensure x2 is not negative
      }
      
      if (typeof data.segments[i].y2 === 'string') {
        const processedY2 = substituteValue(data.segments[i].y2, computedVars);
        const numY2 = Number(processedY2);
        seg.y2 = isNaN(numY2) ? 0 : Math.max(0, numY2); // Ensure y2 is not negative
      }
    });
    
    // Now draw the graph with the processed data
    const ctx = graphCanvas.getContext('2d');
    const W = graphCanvas.width;
    const H = graphCanvas.height;
    
    // --- Axis parameters ---
    let xmin = processedData.xmin,
        xmax = processedData.xmax,
        xscale = processedData.xscale,
        xi = processedData.xlabelInterval;
        
    let ymin = processedData.ymin,
        ymax = processedData.ymax,
        yscale = processedData.yscale,
        yi = processedData.ylabelInterval;
    
    const tickFontSize = processedData.tickFontSize;
    const axisLabelFontSize = processedData.axisLabelFontSize;
    const tickFontFamily = processedData.tickFontFamily;
    const axisLabelFontFamily = processedData.axisLabelFontFamily;
    const axisLabelItalic = processedData.axisLabelItalic;
    const axisLabelBold = processedData.axisLabelBold;
    const xAxisLabel = processedData.xAxisLabel;
    const yAxisLabel = processedData.yAxisLabel;
    
    const axMin = xmin - xscale, axMax = xmax + xscale;
    const ayMin = ymin - yscale, ayMax = ymax + yscale;
    
    // --- Canvas & transforms ---
    ctx.clearRect(0, 0, W, H);

// carve out a left margin (for Y-numbers & label)…
const marginLeftPx   = processedData.tickFontSize + 8;
// carve out a bottom margin (for X-numbers + axis-label)…
const marginBottomPx = processedData.tickFontSize
                     + processedData.axisLabelFontSize
                     +   8;

// effective drawing area
const drawW = W - marginLeftPx;
const drawH = H - marginBottomPx;

// remap coords into that “safe” box
const toPxX = x => marginLeftPx + (x - axMin) * (drawW / (axMax - axMin));
const toPxY = y => drawH        - (y - ayMin) * (drawH / (ayMax - ayMin));

// new origin in px
const x0 = toPxX(0), y0 = toPxY(0);
    
    // --- Grid lines ---
    ctx.setLineDash([]);
    ctx.strokeStyle = 'rgba(128,128,128,0.5)';
    ctx.lineWidth = 0.5;
    
    // Draw vertical grid lines (only from x-axis upward)
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath(); 
      ctx.moveTo(px, y0); 
      ctx.lineTo(px, 0);  
      ctx.stroke();
    }
    
    // Draw horizontal grid lines (only from y-axis rightward)
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath(); 
      ctx.moveTo(x0, py);  
      ctx.lineTo(W, py);   
      ctx.stroke();
    }
    
    // --- Axes ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; 
    ctx.lineWidth = 2.5;
    
    // Draw x-axis only from 0 to positive values
    ctx.beginPath(); 
    ctx.moveTo(x0, y0);
    ctx.lineTo(toPxX(axMax), y0);
    ctx.stroke();
    
    // Draw y-axis only from 0 to positive values
    ctx.beginPath(); 
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0, toPxY(ayMax));
    ctx.stroke();
    
    // --- Arrowheads ---
    ctx.fillStyle = '#000'; const head = 12;
    
    // +X arrowhead
    ctx.beginPath(); 
    ctx.moveTo(toPxX(axMax), y0);
    ctx.lineTo(toPxX(axMax) - head, y0 - head/2);
    ctx.lineTo(toPxX(axMax) - head, y0 + head/2);
    ctx.closePath(); 
    ctx.fill();
    
    // +Y arrowhead
    ctx.beginPath(); 
    ctx.moveTo(x0, toPxY(ayMax));
    ctx.lineTo(x0 - head/2, toPxY(ayMax) + head);
    ctx.lineTo(x0 + head/2, toPxY(ayMax) + head);
    ctx.closePath(); 
    ctx.fill();
    
    // --- Ticks & numeric labels ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; 
    ctx.lineWidth = 1; 
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    ctx.font = `${tickFontSize}px ${tickFontFamily}`;
    
    // Helper to format labels with Pi if appropriate
    function formatLabel(val) {
      // Handle integer values
      if (Number.isInteger(val)) return val.toString();
      
      // Check if it's close to a multiple of pi
      const piVal = val / Math.PI;
      const eps = 1e-4; // More precise comparison
      
      // Check for common π fractions
      for (let den = 1; den <= 12; den++) {
        // Only check denominators that are common for π fractions
        if (den > 6 && den !== 12) continue;
        
        const num = Math.round(piVal * den);
        if (Math.abs(piVal - num / den) < eps) {
          // Handle various special cases
          if (num === 0) return "0";
          
          // Full pi multiples
          if (den === 1) {
            if (num === 1) return "π";
            if (num === -1) return "-π";
            return `${num}π`;
          }
          
          // Simplified fractions of pi
          const gcd = function(a, b) { 
            return b ? gcd(b, a % b) : a; 
          };
          
          const g = gcd(Math.abs(num), den);
          const simplifiedNum = num / g;
          const simplifiedDen = den / g;
          
          if (simplifiedNum === 1) return `π/${simplifiedDen}`;
          if (simplifiedNum === -1) return `-π/${simplifiedDen}`;
          
          return `${simplifiedNum}π/${simplifiedDen}`;
        }
      }
      
      // Handle regular decimals
      return val.toFixed(2);
    }
    
    // X‑ticks
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath();
      ctx.moveTo(px, y0 - 5);
      ctx.lineTo(px, y0 + 5);
      ctx.stroke();
      
      // → robust label test
      const ratio = x / xi;
      if (x !== 0 && Math.abs(ratio - Math.round(ratio)) < 1e-6) {
        ctx.fillText(formatLabel(x), px, y0 + tickFontSize + 4);
      }
    }
    
    // Y‑ticks
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath();
      ctx.moveTo(x0 - 5, py);
      ctx.lineTo(x0 + 5, py);
      ctx.stroke();
      if (y !== 0 && y % yi === 0) {
        ctx.fillText(formatLabel(y), x0 - tickFontSize - 4, py);
      }
    }
    
    // Origin "0"
    ctx.fillText('0', x0 - tickFontSize/2, y0 + tickFontSize/2+3);
    
    // --- Axis labels ---
    ctx.fillStyle = '#000';
    
    // Build font style string based on selected options
    let fontStyle = '';
    if (axisLabelItalic) fontStyle += 'italic ';
    if (axisLabelBold) fontStyle += 'bold ';
    ctx.font = `${fontStyle}${axisLabelFontSize}px ${axisLabelFontFamily}`;
    
    // X-axis label (center bottom)
// X-axis label (always below the tick numbers)
ctx.textAlign    = 'center';
ctx.textBaseline = 'top';
// find where your tick-numbers finish:
const tickCenterY = y0 + processedData.tickFontSize + 4;
const bottomTickY = tickCenterY + processedData.tickFontSize/2;
// push a few px further down, but never below the canvas:
const desiredY    = bottomTickY + 6;
const xLabelY     = Math.min(desiredY, H - processedData.axisLabelFontSize);
// if you want to nudge right, add to the first arg:
ctx.fillText(xAxisLabel, W/2 + 15, xLabelY);

    
    // Y-axis label (center left, rotated)
// Y-axis label (centered in left margin)
ctx.save();
// sit halfway into your left-margin
const leftPadding            = marginLeftPx/2;
// and shift up a bit if you like:
const yLabelVerticalPosition = H/2 - 20;
ctx.translate(leftPadding, yLabelVerticalPosition);
ctx.rotate(-Math.PI/2);
ctx.textAlign    = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(yAxisLabel, 0, 0);
ctx.restore();

    
    // --- Plot equations ---
    const maxSamples = 1000;
    const plotXmin = Math.max(0, axMin);
    const plotXmax = axMax;
    const dx = (plotXmax - plotXmin) / maxSamples;
    
    try {
      processedData.equations.forEach(eq => {
        const eqStr = eq.equation;
        
        try {
          const expr = math.compile(eqStr);
          ctx.strokeStyle = eq.color;
          ctx.lineWidth = eq.width;
          ctx.setLineDash(eq.style === 'dotted' ? [2,3]
                           : eq.style === 'dashed' ? [5,5]
                           : []);
          
          ctx.beginPath();
          let first = true;
          for (let x = Math.max(0, plotXmin); x <= plotXmax; x += dx) {
            // Check domain restrictions
            const skipDueToMinDomain = 
              (eq.domainMinOp === '<' && x <= parseFloat(eq.domainMin)) || 
              (eq.domainMinOp === '≤' && x < parseFloat(eq.domainMin));
            
            const skipDueToMaxDomain = 
              (eq.domainMaxOp === '<' && x >= parseFloat(eq.domainMax)) || 
              (eq.domainMaxOp === '≤' && x > parseFloat(eq.domainMax));
              
            // Skip this x value if it's outside the domain
            if ((eq.domainMinOp !== 'none' && eq.domainMin && skipDueToMinDomain) || 
                (eq.domainMaxOp !== 'none' && eq.domainMax && skipDueToMaxDomain)) {
              if (!first) { // End the current path segment
                ctx.stroke();
                ctx.beginPath();
                first = true;
              }
              continue;
            }
            
            // Handle special cases by equation type
            let y;
            
            if (eq.type === 'absoluteValue') {
              try {
                const exprStr = eqStr.includes('abs(') ? eqStr : `abs(${eqStr})`;
                y = math.evaluate(exprStr, { x });
              } catch (e) {
                console.error("Error evaluating absolute value:", e);
                continue;
              }
            } else {
              try {
                y = expr.evaluate({ x });
              } catch (e) {
                console.error("Error evaluating expression:", e);
                continue;
              }
            }
            
            // Only plot points where y is positive (Quadrant 1)
            if (!isNaN(y) && isFinite(y) && y >= 0) {
              const px = toPxX(x), py = toPxY(y);
              first ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
              first = false;
            }
          }
          
          ctx.stroke();
          ctx.setLineDash([]);
        } catch (e) {
          console.error("Error plotting equation:", e);
        }
      });
    } catch (e) {
      console.error("Error processing equations:", e);
    }
    
    // --- Draw segments ---
    try {
      processedData.segments.forEach(seg => {
        // Only draw segments with positive coordinates (Quadrant 1)
        if (seg.x1 >= 0 && seg.y1 >= 0 && seg.x2 >= 0 && seg.y2 >= 0) {
          ctx.strokeStyle = seg.color;
          ctx.lineWidth = seg.width;
          ctx.setLineDash(seg.style === 'dashed' ? [5,5] : []);
          const x1 = toPxX(seg.x1), y1 = toPxY(seg.y1);
          const x2 = toPxX(seg.x2), y2 = toPxY(seg.y2);
          ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
          ctx.setLineDash([]);
        }
      });
    } catch (e) {
      console.error("Error drawing segments:", e);
    }
    
    // --- Draw points & labels ---
    try {
      processedData.points.forEach(pt => {
        // Only draw points with positive coordinates (Quadrant 1)
        if (pt.x >= 0 && pt.y >= 0) {
          const px = toPxX(pt.x), py = toPxY(pt.y);
          
          // Draw the point
          ctx.fillStyle = '#000';
          ctx.beginPath(); ctx.arc(px, py, pt.pointSize || 4, 0, 2*Math.PI); ctx.fill();
          
          // Draw the label
          ctx.fillStyle = pt.color;
          ctx.font = pt.fontSize + 'px ' + tickFontFamily;
          const m = ctx.measureText(pt.label), w = m.width, h = pt.fontSize;
          
          // Position the label based on the specified position
          let dxOff = 0, dyOff = 0;
          switch(pt.position) {
            case 'up':       dyOff = -h - 2; break;
            case 'down':     dyOff = 16;     break;
            case 'left':     dxOff = -w;     break;
            case 'right':    dxOff = 21;     break;
            case 'upleft':   dxOff = -w; dyOff = -h+3; break;
            case 'upright':  dxOff = 10; dyOff = -h-2; break;
            case 'downleft': dxOff = -w; dyOff = 10;   break;
            case 'downright':dxOff = 10; dyOff = 17;   break;
          }
          
          // Draw the label text
          ctx.fillText(pt.label, px + dxOff, py + dyOff);
        }
      });
    } catch (e) {
      console.error("Error drawing points:", e);
    }
    
    // Draw domain endpoints
    try {
      processedData.equations.forEach(eq => {
        if ((eq.domainMinOp === '<' || eq.domainMinOp === '≤') && eq.domainMin) {
          const x = parseFloat(eq.domainMin);
          // Only draw if within visible range and positive (Quadrant 1)
          if (x >= xmin && x <= xmax && x >= 0) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              // Only draw if y is positive (Quadrant 1)
              if (!isNaN(y) && isFinite(y) && y >= 0) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMinOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating min domain endpoint:", e);
            }
          }
        }

        if ((eq.domainMaxOp === '<' || eq.domainMaxOp === '≤') && eq.domainMax) {
          const x = parseFloat(eq.domainMax);
          // Only draw if within visible range and positive (Quadrant 1)
          if (x >= xmin && x <= xmax && x >= 0) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              // Only draw if y is positive (Quadrant 1)
              if (!isNaN(y) && isFinite(y) && y >= 0) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMaxOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating max domain endpoint:", e);
            }
          }
        }
      });
    } catch (e) {
      console.error("Error drawing domain endpoints:", e);
    }
  });
}

// Process four quadrant graphs in the cloned canvas
function processFourQuadrantGraphsInClone(cloneCanvas, computedVars) {
  const fourQuadrantGraphElements = cloneCanvas.querySelectorAll('.four-quadrant-graph-container');
  console.log(`Processing ${fourQuadrantGraphElements.length} four quadrant graphs`);
  


  
  fourQuadrantGraphElements.forEach(element => {
    // Get the canvas element and the stored data
    const graphCanvas = element.querySelector("canvas");
    if (!graphCanvas) return;
    
    const data = element.graphData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process axis parameters
    // X-axis parameters
    // X-axis parameters
    if (typeof data.xmin === 'string') {
      const sub = substituteValue(data.xmin, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xmin = isNaN(num) ? -10 : num;
    }
    
    if (typeof data.xmax === 'string') {
      const sub = substituteValue(data.xmax, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xmax = isNaN(num) ? 10 : num;
    }
    
    if (typeof data.xscale === 'string') {
      const sub = substituteValue(data.xscale, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xscale = isNaN(num) ? 1 : num;
    }
    
    if (typeof data.xlabelInterval === 'string') {
      const sub = substituteValue(data.xlabelInterval, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.xlabelInterval = isNaN(num) ? 1 : num;
    }
    
    // Y-axis parameters
    if (typeof data.ymin === 'string') {
      const sub = substituteValue(data.ymin, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.ymin = isNaN(num) ? -10 : num;
    }
    
    if (typeof data.ymax === 'string') {
      const sub = substituteValue(data.ymax, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.ymax = isNaN(num) ? 10 : num;
    }
    
    if (typeof data.yscale === 'string') {
      const sub = substituteValue(data.yscale, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.yscale = isNaN(num) ? 1 : num;
    }
    
    if (typeof data.ylabelInterval === 'string') {
      const sub = substituteValue(data.ylabelInterval, computedVars);
      const num = typeof sub === 'number'
        ? sub
        : parseGraphInput(sub);
      processedData.ylabelInterval = isNaN(num) ? 1 : num;
    }
    
    
    // Process equations
    processedData.equations.forEach((eq, i) => {
      // Process domain restrictions
      if (typeof data.equations[i].domainMin === 'string') {
        const processedDomainMin = substituteValue(data.equations[i].domainMin, computedVars);
        const numDomainMin = Number(processedDomainMin);
        eq.domainMin = isNaN(numDomainMin) ? '' : numDomainMin.toString();
      }
      
      if (typeof data.equations[i].domainMax === 'string') {
        const processedDomainMax = substituteValue(data.equations[i].domainMax, computedVars);
        const numDomainMax = Number(processedDomainMax);
        eq.domainMax = isNaN(numDomainMax) ? '' : numDomainMax.toString();
      }
      
      // Process equation text if it contains variables
      if (typeof data.equations[i].equation === 'string' && data.equations[i].equation.includes('#')) {
        eq.equation = substituteValue(data.equations[i].equation, computedVars);
      }
    });
    
    // Process points
    processedData.points.forEach((pt, i) => {
      // Process x coordinate
      if (typeof data.points[i].x === 'string') {
        const processedX = substituteValue(data.points[i].x, computedVars);
        const numX = Number(processedX);
        pt.x = isNaN(numX) ? 0 : numX;
      }
      
      // Process y coordinate
      if (typeof data.points[i].y === 'string') {
        const processedY = substituteValue(data.points[i].y, computedVars);
        const numY = Number(processedY);
        pt.y = isNaN(numY) ? 0 : numY;
      }
      
      // Process label if it contains variables
      if (typeof data.points[i].label === 'string' && data.points[i].label.includes('#')) {
        pt.label = substituteValue(data.points[i].label, computedVars);
      }
    });
    
    // Process segments
    processedData.segments.forEach((seg, i) => {
      // Process start point (x1, y1)
      if (typeof data.segments[i].x1 === 'string') {
        const processedX1 = substituteValue(data.segments[i].x1, computedVars);
        const numX1 = Number(processedX1);
        seg.x1 = isNaN(numX1) ? 0 : numX1;
      }
      
      if (typeof data.segments[i].y1 === 'string') {
        const processedY1 = substituteValue(data.segments[i].y1, computedVars);
        const numY1 = Number(processedY1);
        seg.y1 = isNaN(numY1) ? 0 : numY1;
      }
      
      // Process end point (x2, y2)
      if (typeof data.segments[i].x2 === 'string') {
        const processedX2 = substituteValue(data.segments[i].x2, computedVars);
        const numX2 = Number(processedX2);
        seg.x2 = isNaN(numX2) ? 0 : numX2;
      }
      
      if (typeof data.segments[i].y2 === 'string') {
        const processedY2 = substituteValue(data.segments[i].y2, computedVars);
        const numY2 = Number(processedY2);
        seg.y2 = isNaN(numY2) ? 0 : numY2;
      }
    });
    
    // Now draw the graph with the processed data
    const ctx = graphCanvas.getContext('2d');
    const W = graphCanvas.width;
    const H = graphCanvas.height;
    
    // --- Axis parameters ---
    let xmin = processedData.xmin,
        xmax = processedData.xmax,
        xscale = processedData.xscale,
        xi = processedData.xlabelInterval;
        
    let ymin = processedData.ymin,
        ymax = processedData.ymax,
        yscale = processedData.yscale,
        yi = processedData.ylabelInterval;
        
    const axMin = xmin - xscale, axMax = xmax + xscale;
    const ayMin = ymin - yscale, ayMax = ymax + yscale;
    
    // Define plot ranges that extend beyond visible area
    const plotXmin = axMin;
    const plotXmax = axMax;
    
    // --- Style parameters ---
    const tickFontSize = processedData.tickFontSize;
    const axisLabelFontSize = processedData.axisLabelFontSize;
    
    // --- Canvas & transforms ---
    ctx.clearRect(0, 0, W, H);
    const toPxX = x => (x - axMin) * (W / (axMax - axMin));
    const toPxY = y => H - (y - ayMin) * (H / (ayMax - ayMin));
    
    // --- Grid lines ---
    ctx.setLineDash([]);
    ctx.strokeStyle = 'rgba(128,128,128,0.5)';
    ctx.lineWidth = 0.5;
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, H); ctx.stroke();
    }
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(W, py); ctx.stroke();
    }
    
    // --- Axes ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
    const x0 = toPxX(0), y0 = toPxY(0);
    ctx.beginPath(); ctx.moveTo(toPxX(axMin), y0); ctx.lineTo(toPxX(axMax), y0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x0, toPxY(ayMin)); ctx.lineTo(x0, toPxY(ayMax)); ctx.stroke();
    
    // --- Arrowheads ---
    ctx.fillStyle = '#000'; const head = 12;
    // +X
    ctx.beginPath(); ctx.moveTo(toPxX(axMax), y0);
    ctx.lineTo(toPxX(axMax) - head, y0 - head/2);
    ctx.lineTo(toPxX(axMax) - head, y0 + head/2);
    ctx.closePath(); ctx.fill();
    // –X
    ctx.beginPath(); ctx.moveTo(toPxX(axMin), y0);
    ctx.lineTo(toPxX(axMin) + head, y0 - head/2);
    ctx.lineTo(toPxX(axMin) + head, y0 + head/2);
    ctx.closePath(); ctx.fill();
    // +Y
    ctx.beginPath(); ctx.moveTo(x0, toPxY(ayMax));
    ctx.lineTo(x0 - head/2, toPxY(ayMax) + head);
    ctx.lineTo(x0 + head/2, toPxY(ayMax) + head);
    ctx.closePath(); ctx.fill();
    // –Y
    ctx.beginPath(); ctx.moveTo(x0, toPxY(ayMin));
    ctx.lineTo(x0 - head/2, toPxY(ayMin) - head);
    ctx.lineTo(x0 + head/2, toPxY(ayMin) - head);
    ctx.closePath(); ctx.fill();
    
    // --- Ticks & numeric labels ---
    ctx.setLineDash([]);
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.fillStyle = '#000';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.font = tickFontSize + 'px Computer Modern Serif';
    
    // Helper to format labels with Pi if appropriate
    function formatLabel(val) {
      // Handle integer values
      if (Number.isInteger(val)) return val.toString();
      
      // Check if it's close to a multiple of pi
      const piVal = val / Math.PI;
      const eps = 1e-4; // More precise comparison
      
      // Check for common π fractions: π/6, π/4, π/3, π/2, 2π/3, 3π/4, 5π/6, π, etc.
      for (let den = 1; den <= 12; den++) {
        // Only check denominators that are common for π fractions (1, 2, 3, 4, 6)
        if (den > 6 && den !== 12) continue;
        
        const num = Math.round(piVal * den);
        if (Math.abs(piVal - num / den) < eps) {
          // Handle various special cases
          if (num === 0) return "0";
          
          // Full pi multiples
          if (den === 1) {
            if (num === 1) return "π";
            if (num === -1) return "-π";
            return `${num}π`;
          }
          
          // Simplified fractions of pi
          const g = gcd(Math.abs(num), den);
          const simplifiedNum = num / g;
          const simplifiedDen = den / g;
          
          if (simplifiedNum === 1) return `π/${simplifiedDen}`;
          if (simplifiedNum === -1) return `-π/${simplifiedDen}`;
          
          return `${simplifiedNum}π/${simplifiedDen}`;
        }
      }
      
      // Handle regular decimals
      return val.toFixed(2);
    }
    
    // X‑ticks
    for (let x = xmin; x <= xmax; x += xscale) {
      const px = toPxX(x);
      ctx.beginPath();
      ctx.moveTo(px, y0 - 5);
      ctx.lineTo(px, y0 + 5);
      ctx.stroke();
      
      // → robust label test instead of "x % xi === 0"
      const ratio = x / xi;
      if (x !== 0 && Math.abs(ratio - Math.round(ratio)) < 1e-6) {
        ctx.fillText(formatLabel(x), px, y0 + tickFontSize + 4);
      }
    }
    
    // Y‑ticks
    for (let y = ymin; y <= ymax; y += yscale) {
      const py = toPxY(y);
      ctx.beginPath(); ctx.moveTo(x0 - 5, py); ctx.lineTo(x0 + 5, py); ctx.stroke();
      if (y !== 0 && y % yi === 0) {
        ctx.fillText(formatLabel(y), x0 - tickFontSize - 4, py);
      }
    }
    
    // Origin "0"
    ctx.fillText('0', x0 - tickFontSize/2, y0 + tickFontSize/2+3);
    
    // --- Axis labels ---
    ctx.fillStyle = '#000';
    ctx.font = 'italic ' + axisLabelFontSize + 'px Computer Modern Serif';
    ctx.fillText('x',
      toPxX(axMax) - axisLabelFontSize/1.5,
      y0 - axisLabelFontSize - 1
    );
    ctx.fillText('y',
      x0 + axisLabelFontSize,
      toPxY(ayMax) + axisLabelFontSize/1.5
    );
    
    // Function for greatest common divisor (used in formatLabel)
    function gcd(a, b) { 
      return b ? gcd(b, a % b) : a; 
    }
    
    // --- Plot equations ---
    const maxSamples = 1000;
    const dx = (plotXmax - plotXmin) / maxSamples;
    
    try {
      processedData.equations.forEach(eq => {
        const eqStr = eq.equation;
        
        try {
          const expr = math.compile(eqStr);
          ctx.strokeStyle = eq.color;
          ctx.lineWidth = eq.width;
          ctx.setLineDash(eq.style === 'dotted' ? [2,3]
                           : eq.style === 'dashed' ? [5,5]
                           : []);
          
          ctx.beginPath();
          let first = true;
          for (let x = plotXmin; x <= plotXmax; x += dx) {
            // Check domain restrictions
            const skipDueToMinDomain = 
              (eq.domainMinOp === '<' && x <= parseFloat(eq.domainMin)) || 
              (eq.domainMinOp === '≤' && x < parseFloat(eq.domainMin));
            
            const skipDueToMaxDomain = 
              (eq.domainMaxOp === '<' && x >= parseFloat(eq.domainMax)) || 
              (eq.domainMaxOp === '≤' && x > parseFloat(eq.domainMax));
              
            // Skip this x value if it's outside the domain
            if ((eq.domainMinOp !== 'none' && eq.domainMin && skipDueToMinDomain) || 
                (eq.domainMaxOp !== 'none' && eq.domainMax && skipDueToMaxDomain)) {
              if (!first) { // End the current path segment
                ctx.stroke();
                ctx.beginPath();
                first = true;
              }
              continue;
            }
            
            // Handle special cases by equation type
            let y;
            
            if (eq.type === 'absoluteValue') {
              try {
                const exprStr = eqStr.includes('abs(') ? eqStr : `abs(${eqStr})`;
                y = math.evaluate(exprStr, { x });
              } catch (e) {
                console.error("Error evaluating absolute value:", e);
                continue;
              }
            } else if (eq.type === 'sine') {
              try {
                const xArg = eq.useDegrees ? x * Math.PI/180 : x;
                if (eqStr.includes('sin(')) {
                  y = math.evaluate(eqStr, { x: xArg });
                } else {
                  y = Math.sin(xArg);
                }
              } catch (e) {
                console.error("Error evaluating sine:", e);
                continue;
              }
            } else if (eq.type === 'cosine') {
              try {
                const xArg = eq.useDegrees ? x * Math.PI/180 : x;
                if (eqStr.includes('cos(')) {
                  y = math.evaluate(eqStr, { x: xArg });
                } else {
                  y = Math.cos(xArg);
                }
              } catch (e) {
                console.error("Error evaluating cosine:", e);
                continue;
              }
            } else if (eq.type === 'tangent') {
              try {
                const xArg = eq.useDegrees ? x * Math.PI/180 : x;
                if (eqStr.includes('tan(')) {
                  y = math.evaluate(eqStr, { x: xArg });
                } else {
                  y = Math.tan(xArg);
                }
              } catch (e) {
                console.error("Error evaluating tangent:", e);
                continue;
              }
            } else {
              try {
                y = expr.evaluate({ x });
              } catch (e) {
                console.error("Error evaluating expression:", e);
                continue;
              }
            }
            
            if (!isNaN(y) && isFinite(y)) {
              const px = toPxX(x), py = toPxY(y);
              first ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
              first = false;
            }
          }
          
          ctx.stroke();
          ctx.setLineDash([]);
        } catch (e) {
          console.error("Error plotting equation:", e);
        }
      });
    } catch (e) {
      console.error("Error processing equations:", e);
    }
    
    // --- Draw segments ---
    try {
        processedData.segments.forEach(seg => {
        ctx.strokeStyle = seg.color;
        ctx.lineWidth = seg.width;
        ctx.setLineDash(seg.style === 'dashed' ? [5,5] : []);
        const x1 = toPxX(seg.x1), y1 = toPxY(seg.y1);
        const x2 = toPxX(seg.x2), y2 = toPxY(seg.y2);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        ctx.setLineDash([]);
      });
    } catch (e) {
      console.error("Error drawing segments:", e);
    }
    
    // --- Draw points & labels ---
    try {
      processedData.points.forEach(pt => {
        const px = toPxX(pt.x), py = toPxY(pt.y);
        
        // Draw the point
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(px, py, pt.pointSize || 4, 0, 2*Math.PI); ctx.fill();
        
        // Draw the label
        ctx.fillStyle = pt.color;
        ctx.font = pt.fontSize + 'px Computer Modern Serif';
        const m = ctx.measureText(pt.label), w = m.width, h = pt.fontSize;
        
        // Position the label based on the specified position
        let dxOff = 0, dyOff = 0;
        switch(pt.position) {
          case 'up':       dyOff = -h - 2; break;
          case 'down':     dyOff = 16;     break;
          case 'left':     dxOff = -w;     break;
          case 'right':    dxOff = 21;     break;
          case 'upleft':   dxOff = -w; dyOff = -h+3; break;
          case 'upright':  dxOff = 10; dyOff = -h-2; break;
          case 'downleft': dxOff = -w; dyOff = 10;   break;
          case 'downright':dxOff = 10; dyOff = 17;   break;
        }
        
        // Draw the label text
        ctx.fillText(pt.label, px + dxOff, py + dyOff);
      });
    } catch (e) {
      console.error("Error drawing points:", e);
    }
    
    // Draw domain endpoints
    try {
      processedData.equations.forEach(eq => {
        if ((eq.domainMinOp === '<' || eq.domainMinOp === '≤') && eq.domainMin) {
          const x = parseFloat(eq.domainMin);
          // Only draw if within visible range
          if (x >= xmin && x <= xmax) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              if (!isNaN(y) && isFinite(y)) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMinOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating min domain endpoint:", e);
            }
          }
        }
        
        if ((eq.domainMaxOp === '<' || eq.domainMaxOp === '≤') && eq.domainMax) {
          const x = parseFloat(eq.domainMax);
          // Only draw if within visible range
          if (x >= xmin && x <= xmax) {
            try {
              const expr = math.compile(eq.equation);
              const y = expr.evaluate({x: x});
              
              if (!isNaN(y) && isFinite(y)) {
                const px = toPxX(x);
                const py = toPxY(y);
                
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Fill circle if non-strict inequality (≤)
                if (eq.domainMaxOp === '≤') {
                  ctx.fillStyle = eq.color;
                  ctx.fill();
                } else {
                  // For open circle, fill with white
                  ctx.fillStyle = 'white';
                  ctx.fill();
                }
              }
            } catch (e) {
              console.error("Error evaluating max domain endpoint:", e);
            }
          }
        }
      });
    } catch (e) {
      console.error("Error drawing domain endpoints:", e);
    }
  });
}

// Process line graphs in the cloned canvas
function processLineGraphsInClone(cloneCanvas, computedVars) {
  const lineGraphElements = cloneCanvas.querySelectorAll('.line-graph-container');
  console.log(`Processing ${lineGraphElements.length} line graphs`);
  
  lineGraphElements.forEach(element => {
    // Get the SVG element and the stored data
    const graphSVG = element.querySelector("svg");
    if (!graphSVG) return;
    
    const data = element.lineGraphData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process variables in the title and labels
    processedData.title = substituteValue(data.title, computedVars);
    processedData.xAxisLabel = substituteValue(data.xAxisLabel, computedVars);
    processedData.yAxisLabel = substituteValue(data.yAxisLabel, computedVars);
    
    // Process Y-axis values if they're strings with variables
    if (typeof data.yMin === 'string') {
      const processedYMin = substituteValue(data.yMin, computedVars);
      const numYMin = Number(processedYMin);
      processedData.yMin = isNaN(numYMin) ? 0 : numYMin;
    }
    
    if (typeof data.yMax === 'string') {
      const processedYMax = substituteValue(data.yMax, computedVars);
      const numYMax = Number(processedYMax);
      processedData.yMax = isNaN(numYMax) ? 25 : numYMax;
    }
    
    if (typeof data.yInterval === 'string') {
      const processedYInterval = substituteValue(data.yInterval, computedVars);
      const numYInterval = Number(processedYInterval);
      processedData.yInterval = isNaN(numYInterval) ? 5 : numYInterval;
    }
    
    // Process X-axis values if not using categories and they're strings with variables
    if (!processedData.useCategories) {
      if (typeof data.xMin === 'string') {
        const processedXMin = substituteValue(data.xMin, computedVars);
        const numXMin = Number(processedXMin);
        processedData.xMin = isNaN(numXMin) ? 0 : numXMin;
      }
      
      if (typeof data.xMax === 'string') {
        const processedXMax = substituteValue(data.xMax, computedVars);
        const numXMax = Number(processedXMax);
        processedData.xMax = isNaN(numXMax) ? 10 : numXMax;
      }
      
      if (typeof data.xInterval === 'string') {
        const processedXInterval = substituteValue(data.xInterval, computedVars);
        const numXInterval = Number(processedXInterval);
        processedData.xInterval = isNaN(numXInterval) ? 1 : numXInterval;
      }
    }
    
    // Process variables in the lines
    processedData.lines.forEach((line, lineIndex) => {
      // Process line name
      line.name = substituteValue(data.lines[lineIndex].name, computedVars);
      
      // Process data points
      line.dataPoints.forEach((point, pointIndex) => {
        // Process x value if it's a string (either category or variable)
        if (typeof data.lines[lineIndex].dataPoints[pointIndex].x === 'string') {
          const processedX = substituteValue(data.lines[lineIndex].dataPoints[pointIndex].x, computedVars);
          if (!processedData.useCategories) {
            // If not using categories, try to convert to number
            const numX = Number(processedX);
            point.x = isNaN(numX) ? processedX : numX;
          } else {
            point.x = processedX;
          }
        }
        
        // Process y value
        if (typeof data.lines[lineIndex].dataPoints[pointIndex].y === 'string') {
          const processedY = substituteValue(data.lines[lineIndex].dataPoints[pointIndex].y, computedVars);
          const numY = Number(processedY);
          point.y = isNaN(numY) ? 0 : numY;
        }
        
        // Process label
        if (typeof data.lines[lineIndex].dataPoints[pointIndex].label === 'string') {
          point.label = substituteValue(data.lines[lineIndex].dataPoints[pointIndex].label, computedVars);
        }
      });
    });
    
    // Ensure valid numerical values for calculations (prevent division by zero)
    if (processedData.yMin >= processedData.yMax) {
      processedData.yMax = processedData.yMin + 10;
    }
    
    if (processedData.yInterval <= 0) {
      processedData.yInterval = 5;
    }
    
    if (!processedData.useCategories) {
      if (processedData.xMin >= processedData.xMax) {
        processedData.xMax = processedData.xMin + 10;
      }
      
      if (processedData.xInterval <= 0) {
        processedData.xInterval = 1;
      }
    }
    
    // Get the container dimensions from the SVG
    const w = parseInt(graphSVG.getAttribute("width"));
    const h = parseInt(graphSVG.getAttribute("height"));
    
    // Clear the SVG
    while (graphSVG.firstChild) {
      graphSVG.removeChild(graphSVG.firstChild);
    }
    
    // Set up chart layout parameters
    const padding = { 
      top: Math.max(30, h * 0.12), 
      right: Math.max(30, w * 0.08), 
      bottom: Math.max(40, h * 0.15), 
      left: Math.max(40, w * 0.1) 
    };
    
    const chartW = w - padding.left - padding.right;
    const chartH = h - padding.top - padding.bottom;
    
    // Helper function to create SVG elements
    function createSvgElement(type, attrs) {
      const el = document.createElementNS("http://www.w3.org/2000/svg", type);
      for (const key in attrs) {
        el.setAttribute(key, attrs[key]);
      }
      return el;
    }
    
    // Helper function to get unique categories
    function getUniqueCategories() {
      const allCategories = [];
      processedData.lines.forEach(line => {
        line.dataPoints.forEach(point => {
          if (!allCategories.includes(point.x)) {
            allCategories.push(point.x);
          }
        });
      });
      return allCategories;
    }
    
    // Scaling functions
    function scaleX(x) {
      if (processedData.useCategories) {
        const categories = getUniqueCategories();
        const idx = categories.indexOf(x);
        const count = categories.length;
        if (count <= 1) return padding.left + (chartW / 2);
        return padding.left + ((idx + 0.5) / count) * chartW;
      } else {
        // Convert to number for numeric x-axis
        const xv = (typeof x === "string") ? (parseFloat(x) || processedData.xMin) : x;
        return padding.left + ((xv - processedData.xMin) / (processedData.xMax - processedData.xMin || 1)) * chartW;
      }
    }
    
    function scaleY(y) {
      const yv = (typeof y === "string") ? (parseFloat(y) || processedData.yMin) : y;
      return h - padding.bottom - ((yv - processedData.yMin) / (processedData.yMax - processedData.yMin || 1)) * chartH;
    }
    
    // Calculate ticks for y-axis
    const yTicks = [];
    try {
      for (let v = processedData.yMin; v <= processedData.yMax; v += processedData.yInterval) {
        yTicks.push(v);
        if (yTicks.length > 100) break; // Safety limit
      }
    } catch (err) {
      console.error("Error calculating y-ticks:", err);
    }
    
    // Calculate ticks/categories for x-axis
    const xTicks = [];
    try {
      if (processedData.useCategories) {
        xTicks.push(...getUniqueCategories());
      } else {
        for (let v = processedData.xMin; v <= processedData.xMax; v += processedData.xInterval) {
          xTicks.push(v);
          if (xTicks.length > 100) break; // Safety limit
        }
      }
    } catch (err) {
      console.error("Error calculating x-ticks:", err);
    }
    
    // Draw grid lines for y-axis
    yTicks.forEach(t => {
      try {
        const yPos = scaleY(t);
        const line = createSvgElement("line", {
          x1: padding.left,
          y1: yPos,
          x2: padding.left + chartW,
          y2: yPos,
          stroke: "#ddd",
          "stroke-width": "1",
          "stroke-dasharray": "3,3"
        });
        graphSVG.appendChild(line);
      } catch (err) {
        console.error("Error drawing y-grid line:", err);
      }
    });
    
    // Draw grid lines for x-axis
    xTicks.forEach(t => {
      try {
        const xPos = scaleX(t);
        const line = createSvgElement("line", {
          x1: xPos,
          y1: padding.top,
          x2: xPos,
          y2: h - padding.bottom,
          stroke: "#ddd",
          "stroke-width": "1",
          "stroke-dasharray": "3,3"
        });
        graphSVG.appendChild(line);
      } catch (err) {
        console.error("Error drawing x-grid line:", err);
      }
    });
    
    // Draw axes
    const xAxis = createSvgElement("line", {
      x1: padding.left,
      y1: h - padding.bottom,
      x2: padding.left + chartW,
      y2: h - padding.bottom,
      stroke: "black",
      "stroke-width": "2"
    });
    graphSVG.appendChild(xAxis);
    
    const yAxis = createSvgElement("line", {
      x1: padding.left,
      y1: padding.top,
      x2: padding.left,
      y2: h - padding.bottom,
      stroke: "black",
      "stroke-width": "2"
    });
    graphSVG.appendChild(yAxis);
    
    // Draw Y-axis ticks & labels
    yTicks.forEach(t => {
      try {
        const yPos = scaleY(t);
        
        // Tick
        const tick = createSvgElement("line", {
          x1: padding.left - 5,
          y1: yPos,
          x2: padding.left,
          y2: yPos,
          stroke: "black",
          "stroke-width": "1"
        });
        graphSVG.appendChild(tick);
        
        // Label
        const label = createSvgElement("text", {
          x: padding.left - 10,
          y: yPos,
          "text-anchor": "end",
          "dominant-baseline": "middle",
          "font-size": processedData.labelFontSize
        });
        label.textContent = t;
        graphSVG.appendChild(label);
      } catch (err) {
        console.error("Error drawing y-tick:", err);
      }
    });
    
    // Draw X-axis ticks & labels
    xTicks.forEach(t => {
      try {
        const xPos = scaleX(t);
        
        // Tick
        const tick = createSvgElement("line", {
          x1: xPos,
          y1: h - padding.bottom,
          x2: xPos,
          y2: h - padding.bottom + 5,
          stroke: "black",
          "stroke-width": "1"
        });
        graphSVG.appendChild(tick);
        
        // Label
        const label = createSvgElement("text", {
          x: xPos,
          y: h - padding.bottom + 20,
          "text-anchor": "middle",
          "font-size": processedData.labelFontSize
        });
        label.textContent = t;
        graphSVG.appendChild(label);
      } catch (err) {
        console.error("Error drawing x-tick:", err);
      }
    });
    
    // Draw lines & points
    try {
      processedData.lines.forEach(line => {
        // Filter valid points
        const validPoints = line.dataPoints.filter(point => {
          let y = point.y;
          if (typeof y === 'string') {
            y = parseFloat(y);
            if (isNaN(y)) return false;
          }
          return y >= processedData.yMin && y <= processedData.yMax;
        });
        
        if (validPoints.length < 2) return; // Need at least 2 points to draw a line
        
        // Sort points by x-value if not using categories
        if (!processedData.useCategories) {
          validPoints.sort((a, b) => {
            const aX = typeof a.x === 'string' ? parseFloat(a.x) : a.x;
            const bX = typeof b.x === 'string' ? parseFloat(b.x) : b.x;
            return aX - bX;
          });
        } else {
          // Sort by category order
          const categories = getUniqueCategories();
          validPoints.sort((a, b) => categories.indexOf(a.x) - categories.indexOf(b.x));
        }
        
        // Create line path
        let pathData = '';
        validPoints.forEach((point, i) => {
          try {
            const x = scaleX(point.x);
            const y = scaleY(typeof point.y === 'string' ? parseFloat(point.y) : point.y);
            if (i === 0) {
              pathData += `M ${x},${y}`;
            } else {
              pathData += ` L ${x},${y}`;
            }
          } catch (err) {
            console.error("Error processing point in path:", err);
          }
        });
        
        if (!pathData) return; // No valid path data
        
        // Line shadow
        const shadowPath = createSvgElement("path", {
          d: pathData,
          fill: "none",
          stroke: "rgba(0,0,0,0.1)",
          "stroke-width": "4",
          transform: "translate(2,2)"
        });
        graphSVG.appendChild(shadowPath);
        
        // Actual line
        const linePath = createSvgElement("path", {
          d: pathData,
          fill: "none",
          stroke: line.color,
          "stroke-width": "3",
          "stroke-linejoin": "round",
          "stroke-dasharray": line.style === "dashed" ? "5,5" : "none"
        });
        graphSVG.appendChild(linePath);
        
        // Draw points
        validPoints.forEach(point => {
          try {
            const x = scaleX(point.x);
            const y = scaleY(typeof point.y === 'string' ? parseFloat(point.y) : point.y);
            
            // Point shadow
            const shadowCircle = createSvgElement("circle", {
              cx: x + 1,
              cy: y + 1,
              r: "5",
              fill: "rgba(0,0,0,0.2)"
            });
            graphSVG.appendChild(shadowCircle);
            
            // Point circle
            const circle = createSvgElement("circle", {
              cx: x,
              cy: y,
              r: "5",
              fill: line.color,
              stroke: "#fff",
              "stroke-width": "1"
            });
            graphSVG.appendChild(circle);
            
            // Value label
            if (processedData.showValues) {
              const valueLabel = createSvgElement("text", {
                x: x,
                y: y - 12,
                "text-anchor": "middle",
                "font-size": processedData.labelFontSize
              });
              valueLabel.textContent = point.y;
              graphSVG.appendChild(valueLabel);
            }
          } catch (err) {
            console.error("Error drawing point:", err);
          }
        });
      });
    } catch (err) {
      console.error("Error drawing lines:", err);
    }
    
    // Draw title
    try {
      if (processedData.title) {
        const title = createSvgElement("text", {
          x: w / 2,
          y: padding.top / 2,
          "text-anchor": "middle",
          "dominant-baseline": "middle",
          "font-size": processedData.titleFontSize,
          "font-weight": "bold"
        });
        title.textContent = processedData.title;
        graphSVG.appendChild(title);
      }
    } catch (err) {
      console.error("Error drawing title:", err);
    }
    
    // Draw axis labels
    try {
      if (processedData.xAxisLabel) {
        const xAxisTitle = createSvgElement("text", {
          x: padding.left + chartW / 2,
          y: h - 5,
          "text-anchor": "middle",
          "font-size": processedData.labelFontSize
        });
        xAxisTitle.textContent = processedData.xAxisLabel;
        graphSVG.appendChild(xAxisTitle);
      }
      
      if (processedData.yAxisLabel) {
        const yAxisTitle = createSvgElement("text", {
          transform: `rotate(-90,${padding.left/3},${padding.top+chartH/2})`,
          x: padding.left / 3,
          y: padding.top + chartH / 2,
          "text-anchor": "middle",
          "font-size": processedData.labelFontSize
        });
        yAxisTitle.textContent = processedData.yAxisLabel;
        graphSVG.appendChild(yAxisTitle);
      }
    } catch (err) {
      console.error("Error drawing axis labels:", err);
    }
    
    // Draw legend
    try {
      if (processedData.showLegend && processedData.lines.length > 0) {
        const legendX = w - padding.right - 100;
        const legendY = padding.top + 10;
        const lineHeight = 20;
        const legendWidth = 120;
        const legendHeight = processedData.lines.length * lineHeight + 10;
        
        // Legend background
        const legendBg = createSvgElement("rect", {
          x: legendX - 10,
          y: legendY - 5,
          width: legendWidth,
          height: legendHeight,
          fill: "white",
          stroke: "#ddd",
          "stroke-width": "1",
          rx: "3"
        });
        graphSVG.appendChild(legendBg);
        
        // Legend items
        processedData.lines.forEach((line, i) => {
          const itemY = legendY + i * lineHeight;
          
          // Line sample
          const lineSample = createSvgElement("line", {
            x1: legendX,
            y1: itemY + 10,
            x2: legendX + 15,
            y2: itemY + 10,
            stroke: line.color,
            "stroke-width": "2",
            "stroke-dasharray": line.style === "dashed" ? "3,3" : "none"
          });
          graphSVG.appendChild(lineSample);
          
          // Point sample
          const pointSample = createSvgElement("circle", {
            cx: legendX + 7.5,
            cy: itemY + 10,
            r: "3",
            fill: line.color,
            stroke: "#fff",
            "stroke-width": "0.5"
          });
          graphSVG.appendChild(pointSample);
          
          // Line name
          const lineName = createSvgElement("text", {
            x: legendX + 20,
            y: itemY + 14,
            "font-size": "12px"
          });
          lineName.textContent = line.name;
          graphSVG.appendChild(lineName);
        });
      }
    } catch (err) {
      console.error("Error drawing legend:", err);
    }
  });
}

// Process bar graphs in the cloned canvas
function processBarGraphsInClone(cloneCanvas, computedVars) {
  const barGraphElements = cloneCanvas.querySelectorAll('.bar-graph-container');
  console.log(`Processing ${barGraphElements.length} bar graphs`);
  
  barGraphElements.forEach(element => {
    // Get the SVG element and the stored data
    const graphSVG = element.querySelector("svg");
    if (!graphSVG) return;
    
    const data = element.barGraphData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process variables in the title and labels
    processedData.title = substituteValue(data.title, computedVars);
    processedData.xAxisLabel = substituteValue(data.xAxisLabel, computedVars);
    processedData.yAxisLabel = substituteValue(data.yAxisLabel, computedVars);
    
    // Process variables in the bars
    processedData.bars.forEach((bar, index) => {
      // Process bar name
      bar.name = substituteValue(data.bars[index].name, computedVars);
      
      // Process bar value whether it's a string or number
      if (typeof data.bars[index].value === 'string') {
        // Process any variables in the string
        const processedValue = substituteValue(data.bars[index].value, computedVars);
        // Convert to number if it doesn't contain variables anymore
        const numValue = Number(processedValue);
        bar.value = isNaN(numValue) ? processedValue : numValue;
      }
    });
    
    // Process Y-axis values if they're strings with variables
    if (typeof data.yMin === 'string') {
      const processedYMin = substituteValue(data.yMin, computedVars);
      const numYMin = Number(processedYMin);
      processedData.yMin = isNaN(numYMin) ? 0 : numYMin;
    }
    
    if (typeof data.yMax === 'string') {
      const processedYMax = substituteValue(data.yMax, computedVars);
      const numYMax = Number(processedYMax);
      processedData.yMax = isNaN(numYMax) ? 25 : numYMax;
    }
    
    if (typeof data.yInterval === 'string') {
      const processedYInterval = substituteValue(data.yInterval, computedVars);
      const numYInterval = Number(processedYInterval);
      processedData.yInterval = isNaN(numYInterval) ? 5 : numYInterval;
    }
    
    // Ensure valid numerical values for calculations (prevent division by zero)
    if (processedData.yMin >= processedData.yMax) {
      processedData.yMax = processedData.yMin + 10;
    }
    
    if (processedData.yInterval <= 0) {
      processedData.yInterval = 5;
    }
    
    // Get container dimensions from the SVG
    const w = parseInt(graphSVG.getAttribute("width"));
    const h = parseInt(graphSVG.getAttribute("height"));
    
    // Scale padding relative to graph size for better responsiveness
    const padding = { 
      top: Math.max(30, h * 0.12), 
      right: Math.max(20, w * 0.05), 
      bottom: Math.max(40, h * 0.15), 
      left: Math.max(40, w * 0.1) 
    };
    const yMin = processedData.yMin;
    const yMax = processedData.yMax;
    const interval = processedData.yInterval;
    const fs = processedData.labelFontSize;
    const titleFs = processedData.titleFontSize;
    const bwPct = processedData.barWidthPercent / 100;

    const titleText = processedData.title;
    const xLabel = processedData.xAxisLabel;
    const yLabel = processedData.yAxisLabel;
    const showVals = processedData.showValues;

    // Clear the SVG
    while (graphSVG.firstChild) {
      graphSVG.removeChild(graphSVG.firstChild);
    }

    const chartW = w - padding.left - padding.right;
    const chartH = h - padding.top - padding.bottom;

    // Calculate ticks
    const ticks = [];
    // Limit the number of ticks to prevent excessive calculations
    const maxTicks = 20;
    let tickCount = 0;
    for (let v = yMin; v <= yMax && tickCount < maxTicks; v += interval) {
      ticks.push(v);
      tickCount++;
    }
    
    // Add an additional check - if no ticks were created, add at least one
    if (ticks.length === 0) {
      ticks.push(yMin);
      if (yMin !== yMax) {
        ticks.push(yMax);
      }
    }

    // Create SVG element helper function
    function createSvgElement(type, attrs) {
      const el = document.createElementNS("http://www.w3.org/2000/svg", type);
      for (const key in attrs) {
        el.setAttribute(key, attrs[key]);
      }
      return el;
    }

    // Grid lines
    ticks.forEach(t => {
      const yPos = h - padding.bottom - ((t - yMin)/(yMax-yMin))*chartH;
      const line = createSvgElement("line", {
        x1: padding.left,
        y1: yPos,
        x2: padding.left + chartW,
        y2: yPos,
        stroke: "#ddd",
        "stroke-width": "1",
        "stroke-dasharray": "3,3"
      });
      graphSVG.appendChild(line);
    });

    // Axes
    const xAxis = createSvgElement("line", {
      x1: padding.left,
      y1: h - padding.bottom,
      x2: padding.left + chartW,
      y2: h - padding.bottom,
      stroke: "black",
      "stroke-width": "2"
    });
    graphSVG.appendChild(xAxis);

    const yAxis = createSvgElement("line", {
      x1: padding.left,
      y1: padding.top,
      x2: padding.left,
      y2: h - padding.bottom,
      stroke: "black",
      "stroke-width": "2"
    });
    graphSVG.appendChild(yAxis);

    // Y ticks & labels
    ticks.forEach(t => {
      const yPos = h - padding.bottom - ((t - yMin)/(yMax-yMin))*chartH;
      
      const tick = createSvgElement("line", {
        x1: padding.left - 5,
        y1: yPos,
        x2: padding.left,
        y2: yPos,
        stroke: "black",
        "stroke-width": "1"
      });
      graphSVG.appendChild(tick);
      
      const label = createSvgElement("text", {
        x: padding.left - 10,
        y: yPos,
        "text-anchor": "end",
        "dominant-baseline": "middle",
        "font-size": fs
      });
      label.textContent = t;
      graphSVG.appendChild(label);
    });

    // Draw the bars and x labels with error protection
    if (processedData.bars && processedData.bars.length > 0) {
      const barW = (chartW / processedData.bars.length) * bwPct;
      processedData.bars.forEach((bar, i) => {
        try {
          // Convert bar.value to number if it's a string
          const barValue = typeof bar.value === 'string' ? parseFloat(bar.value) : bar.value;
          
          // Skip invalid values
          if (isNaN(barValue)) return;
          
          const xSlot = padding.left + (i + 0.5) * (chartW / processedData.bars.length);
          const barH = Math.max(0, ((barValue - yMin) / Math.max(0.1, yMax - yMin)) * chartH);
          const yPos = h - padding.bottom - barH;
  
          const rect = createSvgElement("rect", {
            x: xSlot - barW / 2,
            y: yPos,
            width: barW,
            height: barH,
            fill: bar.color
          });
          graphSVG.appendChild(rect);
  
          if (showVals) {
            const valueLabel = createSvgElement("text", {
              x: xSlot,
              y: yPos - 8,
              "text-anchor": "middle",
              "font-size": fs
            });
            valueLabel.textContent = barValue;
            graphSVG.appendChild(valueLabel);
          }
  
          const categoryLabel = createSvgElement("text", {
            x: xSlot,
            y: h - padding.bottom + 20,
            "text-anchor": "middle",
            "font-size": fs
          });
          categoryLabel.textContent = bar.name;
          graphSVG.appendChild(categoryLabel);
        } catch (error) {
          console.error("Error processing bar:", error);
        }
      });
    }

    // Title
    if (titleText) {
      const title = createSvgElement("text", {
        x: w / 2,
        y: padding.top / 2,
        "text-anchor": "middle",
        "dominant-baseline": "middle",
        "font-size": titleFs,
        "font-weight": "bold"
      });
      title.textContent = titleText;
      graphSVG.appendChild(title);
    }

    // Axis titles
    if (xLabel) {
      const xAxisTitle = createSvgElement("text", {
        x: padding.left + chartW / 2,
        y: h - 5,
        "text-anchor": "middle",
        "font-size": fs
      });
      xAxisTitle.textContent = xLabel;
      graphSVG.appendChild(xAxisTitle);
    }

    if (yLabel) {
      const yAxisTitle = createSvgElement("text", {
        transform: `rotate(-90,${padding.left/3},${padding.top+chartH/2})`,
        x: padding.left / 3,
        y: padding.top + chartH / 2,
        "text-anchor": "middle",
        "font-size": fs
      });
      yAxisTitle.textContent = yLabel;
      graphSVG.appendChild(yAxisTitle);
    }
  });
}

function processRectangle(targetContainer, computedVars) {
  if (!targetContainer || !targetContainer.classList.contains('rectangle-container')) return;
  
  // Get expressions from data attributes
  const totalSections = targetContainer.getAttribute("data-total-sections");
  const shadedSections = targetContainer.getAttribute("data-shaded-sections");
  
  // Check if we need to process variable substitution
  if (totalSections && totalSections.includes('#') && computedVars) {
    let substitutedTotal = substituteValue(totalSections, computedVars);
    let numTotal = parseInt(substitutedTotal);
    if (!isNaN(numTotal) && numTotal > 0) {
      targetContainer.dataset.sections = numTotal.toString();
    }
  }
  
  if (shadedSections && shadedSections.includes('#') && computedVars) {
    let substitutedShaded = substituteValue(shadedSections, computedVars);
    let numShaded = parseInt(substitutedShaded);
    
    if (!isNaN(numShaded) && numShaded > 0) {
      // Get total sections
      const sections = parseInt(targetContainer.dataset.sections);
      if (!isNaN(sections) && sections > 0) {
        // Ensure shaded doesn't exceed total
        numShaded = Math.min(numShaded, sections);
        
        // Generate new section fills array
        const shadedColor = targetContainer.getAttribute("data-shaded-color") || "#ff0000";
        const unshadedColor = targetContainer.getAttribute("data-unshaded-color") || "#ffffff";
        
        let sectionFills = new Array(sections).fill(unshadedColor);
        
        // Randomly shade the specified number of sections
        const indices = [];
        for (let i = 0; i < sections; i++) {
          indices.push(i);
        }
        
        // Shuffle array to get random indices
        for (let i = indices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }
        
        // Shade the first 'shaded' sections in the shuffled array
        for (let i = 0; i < numShaded; i++) {
          sectionFills[indices[i]] = shadedColor;
        }
        
        targetContainer.dataset.sectionFills = JSON.stringify(sectionFills);
      }
    }
  }
  
  // Update the rectangle
  if (window.updateRectangle) {
    window.updateRectangle(targetContainer);
  }
}


function processRectangleInClone(cloneCanvas, computedVars) {
  cloneCanvas.querySelectorAll('.rectangle-container').forEach(container => {
    console.log('Processing rectangle in clone for preview');
    
    // Check if we're using automate mode
    const useAutomate = container.dataset.useAutomate === "yes";
    
    if (useAutomate) {
      // Process using automate settings
      const totalSections = container.getAttribute("data-total-sections");
      const shadedSections = container.getAttribute("data-shaded-sections");
      const shadedColor = container.getAttribute("data-shaded-color") || "#ff0000";
      const unshadedColor = container.getAttribute("data-unshaded-color") || "#ffffff";
      
      let totalSectionsValue = totalSections;
      let shadedSectionsValue = shadedSections;
      
      // Process variable substitution
      if (totalSections && totalSections.includes('#') && computedVars) {
        totalSectionsValue = substituteValue(totalSections, computedVars);
        console.log(`Substituted total sections: ${totalSections} -> ${totalSectionsValue}`);
      }
      
      if (shadedSections && shadedSections.includes('#') && computedVars) {
        shadedSectionsValue = substituteValue(shadedSections, computedVars);
        console.log(`Substituted shaded sections: ${shadedSections} -> ${shadedSectionsValue}`);
      }
      
      // Convert to numbers
      const numTotal = parseInt(totalSectionsValue);
      const numShaded = parseInt(shadedSectionsValue);
      
      // Only proceed if we have valid numbers
      if (!isNaN(numTotal) && numTotal > 0) {
        // Update container dataset for rendering
        container.dataset.sections = numTotal.toString();
        
        // Get container dimensions for SVG generation
        const content = container.querySelector('.rectangle-content');
        const width = content ? content.clientWidth : 200;
        const height = content ? content.clientHeight : 150;
        
        // Generate new section fills for preview
        if (!isNaN(numShaded) && numShaded > 0 && numShaded <= numTotal) {
          // Create section fills array
          let sectionFills = new Array(numTotal).fill(unshadedColor);
          
          // Randomly select sections to shade
          const indices = [];
          for (let i = 0; i < numTotal; i++) {
            indices.push(i);
          }
          
          // Shuffle array
          for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
          }
          
          // Shade the selected sections
          for (let i = 0; i < numShaded; i++) {
            sectionFills[indices[i]] = shadedColor;
          }
          
          // Save back to container
          container.dataset.sectionFills = JSON.stringify(sectionFills);
        }
        
        // Generate SVG for preview
        try {
          const svgString = generateRectangleSVG(
            numTotal,
            numShaded,
            shadedColor,
            unshadedColor,
            width,
            height,
            JSON.parse(container.dataset.sectionFills || "[]")
          );
          
          // Replace the existing content with the new SVG
          const svg = container.querySelector('svg');
          if (svg) {
            // Create a temporary div to hold the SVG string
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = svgString;
            const newSvg = tempDiv.firstChild;
            
            // Replace old SVG with new one
            svg.parentNode.replaceChild(newSvg, svg);
          }
        } catch (e) {
          console.error("Error generating rectangle SVG:", e);
        }
      }
    } else {
      // Manual mode - use standard settings
      const strokeColor = container.dataset.strokeColor || "#000000";
      const strokeWidth = container.dataset.strokeWidth || "2";
      const fillColor = container.dataset.fillColor || "transparent";
      const showVertices = container.dataset.showVertices === "yes";
      const showRightAngles = container.dataset.showRightAngles === "yes";
      const sections = parseInt(container.dataset.sections || "0");
      
      // Update the SVG elements based on current settings
      const svg = container.querySelector('svg');
      if (!svg) return;
      
      // Update main rectangle
      const rect = svg.querySelector('rect');
      if (rect) {
        rect.setAttribute("stroke", strokeColor);
        rect.setAttribute("stroke-width", strokeWidth);
        rect.setAttribute("fill", fillColor);
      }
      
      // Handle vertices visibility
      svg.querySelectorAll('.vertex-marker').forEach(vertex => {
        vertex.setAttribute("fill", strokeColor);
        vertex.style.display = showVertices ? "block" : "none";
      });
      
      // Handle right angle markers visibility
      svg.querySelectorAll('.right-angle-marker').forEach(angle => {
        angle.setAttribute("stroke", strokeColor);
        angle.style.display = showRightAngles ? "block" : "none";
      });
      
      // Handle sections
      if (sections > 0) {
        // Clear existing sections
        svg.querySelectorAll('.section-path').forEach(path => path.remove());
        
        // Get the rectangle dimensions
        const x = parseFloat(rect.getAttribute("x"));
        const y = parseFloat(rect.getAttribute("y"));
        const width = parseFloat(rect.getAttribute("width"));
        const height = parseFloat(rect.getAttribute("height"));
        
        // Get section fills
        let sectionFills = [];
        try {
          sectionFills = JSON.parse(container.dataset.sectionFills || "[]");
        } catch (e) {
          console.error("Error parsing section fills:", e);
          sectionFills = new Array(sections).fill("transparent");
        }
        
        // Ensure sectionFills array is properly sized
        while (sectionFills.length < sections) {
          sectionFills.push("transparent");
        }
        
        // Draw the sections based on even/odd rule
        if (sections % 2 === 0) {
          // Even number: 2 x whatever
          const cols = 2;
          const rows = sections / 2;
          
          const cellWidth = width / cols;
          const cellHeight = height / rows;
          
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const sectionIndex = row * cols + col;
              const sectionX = x + col * cellWidth;
              const sectionY = y + row * cellHeight;
              
              const section = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              section.setAttribute("x", sectionX);
              section.setAttribute("y", sectionY);
              section.setAttribute("width", cellWidth);
              section.setAttribute("height", cellHeight);
              section.setAttribute("stroke", strokeColor);
              section.setAttribute("stroke-width", "1");
              section.setAttribute("fill", sectionFills[sectionIndex] || "transparent");
              section.setAttribute("class", "section-path");
              
              svg.appendChild(section);
            }
          }
        } else {
          // Odd number: 1 x whatever
          const rows = sections;
          const cellHeight = height / rows;
          
          for (let row = 0; row < rows; row++) {
            const sectionY = y + row * cellHeight;
            
            const section = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            section.setAttribute("x", x);
            section.setAttribute("y", sectionY);
            section.setAttribute("width", width);
            section.setAttribute("height", cellHeight);
            section.setAttribute("stroke", strokeColor);
            section.setAttribute("stroke-width", "1");
            section.setAttribute("fill", sectionFills[row] || "transparent");
            section.setAttribute("class", "section-path");
            
            svg.appendChild(section);
          }
        }
      }
    }
  });
}

// Fallback function if updateRectangle isn't available in the preview context
function renderRectangleForPreview(container) {
  const svg = container.querySelector('svg');
  if (!svg) return;
  
  // Get rectangle properties
  const rect = svg.querySelector('rect');
  if (!rect) return;
  
  // Update rectangle appearance
  rect.setAttribute("stroke", container.dataset.strokeColor || "#000000");
  rect.setAttribute("stroke-width", container.dataset.strokeWidth || "2");
  rect.setAttribute("fill", container.dataset.fillColor || "transparent");
  
  // Handle sections
  const sections = parseInt(container.dataset.sections || "0");
  if (sections <= 0) return;
  
  // Clear existing sections
  svg.querySelectorAll('.section-path').forEach(path => path.remove());
  
  // Get section fills
  const sectionFills = JSON.parse(container.dataset.sectionFills || "[]");
  
  // Get rectangle dimensions
  const x = parseFloat(rect.getAttribute("x") || "0");
  const y = parseFloat(rect.getAttribute("y") || "0");
  const width = parseFloat(rect.getAttribute("width") || "100");
  const height = parseFloat(rect.getAttribute("height") || "100");
  
  // Draw sections based on even/odd rule
  if (sections % 2 === 0) {
    // Even number: 2 x whatever
    const cols = 2;
    const rows = sections / 2;
    
    const cellWidth = width / cols;
    const cellHeight = height / rows;
    
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const sectionIndex = row * cols + col;
        const sectionX = x + col * cellWidth;
        const sectionY = y + row * cellHeight;
        
        const section = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        section.setAttribute("x", sectionX);
        section.setAttribute("y", sectionY);
        section.setAttribute("width", cellWidth);
        section.setAttribute("height", cellHeight);
        section.setAttribute("stroke", container.dataset.strokeColor || "#000000");
        section.setAttribute("stroke-width", "1");
        section.setAttribute("fill", sectionFills[sectionIndex] || "transparent");
        section.setAttribute("class", "section-path");
        
        svg.appendChild(section);
      }
    }
  } else {
    // Odd number: 1 x whatever
    const rows = sections;
    const cellHeight = height / rows;
    
    for (let row = 0; row < rows; row++) {
      const sectionY = y + row * cellHeight;
      
      const section = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      section.setAttribute("x", x);
      section.setAttribute("y", sectionY);
      section.setAttribute("width", width);
      section.setAttribute("height", cellHeight);
      section.setAttribute("stroke", container.dataset.strokeColor || "#000000");
      section.setAttribute("stroke-width", "1");
      section.setAttribute("fill", sectionFills[row] || "transparent");
      section.setAttribute("class", "section-path");
      
      svg.appendChild(section);
    }
  }
  
  // Handle vertices and right angles if needed
  const showVertices = container.dataset.showVertices === "yes";
  const showRightAngles = container.dataset.showRightAngles === "yes";
  
  // Clear existing markers
  svg.querySelectorAll('.vertex-marker, .right-angle-marker').forEach(marker => marker.remove());
  
  if (showVertices) {
    // Add vertex markers at the corners
    const vertexPositions = [
      { x: x, y: y }, // top-left
      { x: x + width, y: y }, // top-right
      { x: x + width, y: y + height }, // bottom-right
      { x: x, y: y + height } // bottom-left
    ];
    
    for (const pos of vertexPositions) {
      const vertex = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      vertex.setAttribute("cx", pos.x);
      vertex.setAttribute("cy", pos.y);
      vertex.setAttribute("r", "5");
      vertex.setAttribute("fill", container.dataset.strokeColor || "#000000");
      vertex.setAttribute("stroke", "#ffffff");
      vertex.setAttribute("stroke-width", "1");
      vertex.setAttribute("class", "vertex-marker");
      svg.appendChild(vertex);
    }
  }
  
  if (showRightAngles) {
    // Add right angle markers at the corners
    const cornerPositions = [
      { x: x, y: y }, // top-left
      { x: x + width, y: y }, // top-right
      { x: x + width, y: y + height }, // bottom-right
      { x: x, y: y + height } // bottom-left
    ];
    
    for (let i = 0; i < 4; i++) {
      const corner = cornerPositions[i];
      const prevCorner = cornerPositions[(i + 3) % 4];
      const nextCorner = cornerPositions[(i + 1) % 4];
      
      const size = 10; // Size of right angle marker
      
      // Calculate directions from corner to adjacent corners
      const dir1x = prevCorner.x - corner.x;
      const dir1y = prevCorner.y - corner.y;
      const dir2x = nextCorner.x - corner.x;
      const dir2y = nextCorner.y - corner.y;
      
      // Normalize
      const len1 = Math.sqrt(dir1x * dir1x + dir1y * dir1y);
      const len2 = Math.sqrt(dir2x * dir2x + dir2y * dir2y);
      
      if (len1 > 0 && len2 > 0) {
        const norm1x = dir1x / len1;
        const norm1y = dir1y / len1;
        const norm2x = dir2x / len2;
        const norm2y = dir2y / len2;
        
        // Points for right angle marker
        const p1x = corner.x + norm1x * size;
        const p1y = corner.y + norm1y * size;
        const p2x = corner.x;
        const p2y = corner.y;
        const p3x = corner.x + norm2x * size;
        const p3y = corner.y + norm2y * size;
        
        const rightAngle = document.createElementNS("http://www.w3.org/2000/svg", "path");
        rightAngle.setAttribute("d", `M ${p1x} ${p1y} L ${p2x} ${p2y} L ${p3x} ${p3y}`);
        rightAngle.setAttribute("fill", "none");
        rightAngle.setAttribute("stroke", container.dataset.strokeColor || "#000000");
        rightAngle.setAttribute("stroke-width", "1");
        rightAngle.setAttribute("class", "right-angle-marker");
        svg.appendChild(rightAngle);
      }
    }
  }
}

function processBoxAndWhisker(element, computedVars) {
  // Skip if not a box-whisker container
  if (!element.classList.contains("box-whisker-container")) return;
  
  // Get the canvas element and the stored data
  const plotCanvas = element.querySelector("canvas");
  if (!plotCanvas) return;
  
  const data = element.boxWhiskerData;
  if (!data) return;
  
  // Clone the data to avoid modifying the original
  const processedData = JSON.parse(JSON.stringify(data));
  
  // Process variables in the number line settings
  processedData.numberLine.min = processVariableValue(data.numberLine.min, computedVars);
  processedData.numberLine.max = processVariableValue(data.numberLine.max, computedVars);
  processedData.numberLine.tickInterval = processVariableValue(data.numberLine.tickInterval, computedVars);
  processedData.numberLine.labelInterval = processVariableValue(data.numberLine.labelInterval, computedVars);
  
  // Process variables in the boxes
  processedData.boxes.forEach((box, index) => {
    box.min = processVariableValue(data.boxes[index].min, computedVars);
    box.q1 = processVariableValue(data.boxes[index].q1, computedVars);
    box.med = processVariableValue(data.boxes[index].med, computedVars);
    box.q3 = processVariableValue(data.boxes[index].q3, computedVars);
    box.max = processVariableValue(data.boxes[index].max, computedVars);
  });
  
  // Draw the updated box-and-whisker plot
  drawProcessedBoxAndWhisker(plotCanvas, processedData);
}

// Helper function to process variable values
function processVariableValue(value, computedVars) {
  if (typeof value !== 'string') return value;
  
  // Check if the value contains variables
  let processedValue = value;
  
  // Replace variables like #a# with computed values
  const variableRegex = /#([a-z0-9]+)#/gi;
  let match;
  
  while ((match = variableRegex.exec(value)) !== null) {
    const variableName = match[1];
    if (computedVars && computedVars[variableName] !== undefined) {
      processedValue = processedValue.replace(match[0], computedVars[variableName]);
    }
  }
  
  // After replacing variables, try to convert to number
  const numValue = parseFloat(processedValue);
  return isNaN(numValue) ? processedValue : numValue;
}

// Function to draw the processed box-and-whisker plot
function drawProcessedBoxAndWhisker(plotCanvas, data) {
  const ctx = plotCanvas.getContext('2d');
  ctx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

  const fontSize = data.titleFontSize;

  // Title
  ctx.font = `bold ${fontSize}px sans-serif`;
ctx.textAlign = 'center';
ctx.fillText(data.title, plotCanvas.width/2, fontSize + 5);

ctx.textAlign = 'start';

  const nlMin = parseFloat(data.numberLine.min);
  const nlMax = parseFloat(data.numberLine.max);
  const nlInt = parseFloat(data.numberLine.tickInterval);
  const labelInt = parseFloat(data.numberLine.labelInterval);
  const boxThk = parseFloat(data.boxThickness);
  const axisLabel = data.numberLine.axisLabel;

  const padding = 60;
  const axisY = plotCanvas.height - 60;
  const plotWidth = plotCanvas.width - 2*padding;
  const scale = plotWidth / (nlMax - nlMin);
  const xOf = v => padding + (v - nlMin)*scale;

  // Axis line
  ctx.beginPath();
  ctx.strokeStyle = '#000'; 
  ctx.lineWidth = 2;
  ctx.moveTo(xOf(nlMin), axisY);
  ctx.lineTo(xOf(nlMax), axisY);
  ctx.stroke();

  // Ticks & labels
  ctx.font = `bold ${fontSize}px sans-serif`;
ctx.fillStyle = '#000';
ctx.lineWidth = 1;
for (let v = nlMin; v <= nlMax; v += nlInt) {
  const x = xOf(v);
  ctx.beginPath();
    ctx.moveTo(x, axisY - 5);
    ctx.lineTo(x, axisY + 5);
  ctx.stroke();
  if (labelInt > 0 && ((v - nlMin) % labelInt) === 0) {
    ctx.fillText(
      v,
      x - ctx.measureText(v).width/2,
      axisY + fontSize + 5
    );
  }
}

  // Axis label
  ctx.font = `bold ${fontSize}px sans-serif`;
ctx.fillStyle = '#000';
ctx.textAlign = 'center';
ctx.textBaseline = 'top';
ctx.fillText(
  axisLabel,
  plotCanvas.width/2,
  axisY + fontSize + 10
);

  // Plot boxes
  const whiskerYBase = axisY - 30;
  const boxYBase = axisY - 50;
  const boxHeight = 30;

  data.boxes.forEach((box, i) => {
    const mn = parseFloat(box.min), q1 = parseFloat(box.q1);
    const md = parseFloat(box.med), q3 = parseFloat(box.q3);
    const mx = parseFloat(box.max);

    ctx.strokeStyle = '#000'; 
    ctx.lineWidth = boxThk;
    
    // Whiskers
    ctx.beginPath();
    ctx.moveTo(xOf(mn), whiskerYBase - i*(boxHeight+10));
    ctx.lineTo(xOf(q1), whiskerYBase - i*(boxHeight+10));
    ctx.moveTo(xOf(q3), whiskerYBase - i*(boxHeight+10));
    ctx.lineTo(xOf(mx), whiskerYBase - i*(boxHeight+10));
    ctx.stroke();
    
    // Caps
    [mn, mx].forEach(val => {
      const x = xOf(val);
      ctx.beginPath();
      ctx.moveTo(x, whiskerYBase - 10 - i*(boxHeight+10));
      ctx.lineTo(x, whiskerYBase + 10 - i*(boxHeight+10));
      ctx.stroke();
    });

    // Box
    const top = boxYBase - i*(boxHeight+10);
    ctx.strokeRect(xOf(q1), top, xOf(q3) - xOf(q1), boxHeight);
    
    // Median
    ctx.beginPath();
    const xm = xOf(md);
    ctx.moveTo(xm, top);
    ctx.lineTo(xm, top+boxHeight);
    ctx.stroke();

    // Box label
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textBaseline = 'alphabetic';
    ctx.fillText(box.name, 40, top - 5);
  });
}


// Function to process LaTeX in the textbox content
function processLatexInTextbox(container, contentContainer) {
  // Get the current content
  const content = contentContainer.innerHTML;
  
  // Create a temporary div to parse HTML content
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = content;
  
  // Define a regex to find LaTeX expressions between $$ delimiters
  const latexRegex = /\$\$([\s\S]*?)\$\$/g;
  
  // Get the HTML content
  let html = tempDiv.innerHTML;
  
  // Check if any LaTeX expressions are found
  if (!latexRegex.test(html)) {
    alert("No LaTeX expressions (enclosed in $$ symbols) found in the text.");
    return;
  }
  
  // Reset the regex (since we used it in the test)
  latexRegex.lastIndex = 0;
  
  // Replace all LaTeX expressions with MathLive equations without substitution yet
  html = html.replace(latexRegex, function(match, latexContent) {
    // Create a unique ID for this equation
    const equationId = `math-equation-${container.textboxID}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    
    // Store equation info with original LaTeX
    container.mathEquations.push({
      id: equationId,
      latex: latexContent
    });
    container.hasMathEquation = true;
    
    // Return the HTML for this equation with original LaTeX
    return `<span id="${equationId}" class="inline-equation" contenteditable="false" 
            data-latex="${latexContent}" 
            style="display:inline-block; cursor:pointer; user-select:none; 
                   border:none; padding:0; margin:0 2px; background-color:transparent; 
                   font-size:24px;">\\(${latexContent}\\)</span>`;
  });
  
  // Update the content
  contentContainer.innerHTML = html;
  
  // Render equations with MathLive if available
  if (typeof MathLive !== 'undefined' && typeof MathLive.renderMathInElement === 'function') {
    try {
      // First render all equations
      contentContainer.querySelectorAll('.inline-equation').forEach(eqElement => {
        MathLive.renderMathInElement(eqElement);
      });
      
      // Then apply the substitution using the existing processMathLiveEquationsInClone function
      const computedVars = computeAllVariables();
      processMathLiveEquationsInClone(contentContainer, computedVars);
      
    } catch(e) {
      console.error("Error rendering equations:", e);
    }
  }
  
  // Setup click handler for the equations
  setupEquationClickHandler();
}

// Function to process LaTeX in Summernote editor
function processLatexInSummernote(container, editor) {
  if (!editor) return;
  
  // Get current editor content
  const content = editor.summernote('code');
  
  // Create a temporary div to hold the content for processing
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = content;
  
  // Define a regex to find LaTeX expressions between $$ delimiters
  const latexRegex = /\$\$([\s\S]*?)\$\$/g;
  
  // Get the HTML content
  let html = tempDiv.innerHTML;
  
  // Check if any LaTeX expressions are found
  if (!latexRegex.test(html)) {
    alert("No LaTeX expressions (enclosed in $$ symbols) found in the text.");
    return;
  }
  
  // Reset the regex (since we used it in the test)
  latexRegex.lastIndex = 0;
  
  // Replace all LaTeX expressions with MathLive equations without substitution yet
  html = html.replace(latexRegex, function(match, latexContent) {
    // Create a unique ID for this equation
    const equationId = `math-equation-${container.textboxID}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    
    // Store equation info with original LaTeX
    container.mathEquations.push({
      id: equationId,
      latex: latexContent
    });
    container.hasMathEquation = true;
    
    // Return the HTML for this equation with original LaTeX
    return `<span id="${equationId}" class="inline-equation" contenteditable="false" 
            data-latex="${latexContent}" 
            style="display:inline-block; cursor:pointer; user-select:none; 
                   border:none; padding:0; margin:0 2px; background-color:transparent; 
                   font-size:24px;">\\(${latexContent}\\)</span>`;
  });
  
  // Update the editor content with processed HTML
  editor.summernote('code', html);
  
  // Render equations with MathLive if available
  if (typeof MathLive !== 'undefined' && typeof MathLive.renderMathInElement === 'function') {
    try {
      // Re-get the content after update
      const updatedContent = editor.summernote('code');
      const updatedDiv = document.createElement('div');
      updatedDiv.innerHTML = updatedContent;
      
      // Find equations in the updated content
      const equations = updatedDiv.querySelectorAll('.inline-equation');
      
      if (equations.length > 0) {
        // First render all equations
        equations.forEach(eq => {
          MathLive.renderMathInElement(eq);
        });
        
        // Then apply the substitution using the existing processMathLiveEquationsInClone function
        const computedVars = computeAllVariables();
        processMathLiveEquationsInClone(updatedDiv, computedVars);
        
        // Update Summernote with rendered equations
        editor.summernote('code', updatedDiv.innerHTML);
      }
    } catch(e) {
      console.error("Error rendering equations in editor:", e);
    }
  }
  
  // Setup click handler for the equations
  setupEquationClickHandler();
}

function addEquation() {
  // Get the canvas element
  const problemCanvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeEquationElement) {
    window.activeEquationElement = null;
  }
  // Global counter for equation IDs
  if (!window.globalEquationCounter) {
    window.globalEquationCounter = 1;
  } else {
    window.globalEquationCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element equation-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "250px";
  container.style.height = (toolbarHeight + 100) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc";
  container.style.backgroundColor = "#ffffff";
  nextElementOffset += 10;
  container.isDragging = false;
  container.equationID = window.globalEquationCounter;
  
  // State properties
  container.fontSize = 24;
  container.equationValue = '\\placeholder{}';

  // Local toolbar
  const localToolbar = document.createElement("div");
  localToolbar.className = "equation-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex";
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "equation-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.padding = "10px";
  content.style.boxSizing = "border-box";
  content.style.overflow = "visible";
  content.style.display = "flex";
  content.style.alignItems = "center";
  content.style.justifyContent = "center";
  content.style.backgroundColor = "#ffffff";
  container.appendChild(content);

  // Create the MathLive field
  const mathField = document.createElement("math-field");
  mathField.setAttribute("virtualKeyboardTheme", "light");
  // Use manual mode so we can control when the keyboard appears
  mathField.setAttribute("virtualKeyboardMode", "manual");
  mathField.style.width = "100%";
  mathField.style.fontSize = container.fontSize + "px";
  mathField.value = container.equationValue;

  // Handle changes to the equation
  mathField.addEventListener('input', () => {
    container.equationValue = mathField.value;
  });

  content.appendChild(mathField);

  // Create resize handle
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  /* -----------
     Update Global Toolbar
     ----------- */
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;

    globalToolbar.innerHTML = "";
    globalToolbar.style.display = "block";
    
    // Row 1: Identity and font size control
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Equation " + container.equationID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Font size control
    const fontSizeLabel = document.createElement("span");
    fontSizeLabel.textContent = "Size:";
    fontSizeLabel.style.fontSize = "12px";
    fontSizeLabel.style.marginRight = "5px";
    row1.appendChild(fontSizeLabel);
    
    const fontSizeInput = document.createElement("input");
fontSizeInput.type = "number";
fontSizeInput.min = "8";  // Minimum size
fontSizeInput.max = "72"; // Maximum size
fontSizeInput.value = initialFontSize; // Set to current equation font size
fontSizeInput.style.width = "50px";
fontSizeInput.addEventListener("input", function() {
  // Update the font size when the value changes
  const newSize = parseInt(this.value, 10);
  // Update your equation's font size here
});
    row1.appendChild(fontSizeInput);
    
    globalToolbar.appendChild(row1);
    
    // Row 2: Edit and keyboard toggle buttons
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";
    
    // Edit equation button
    const editButton = document.createElement("button");
    editButton.textContent = "Edit Equation";
    editButton.style.fontSize = "12px";
    editButton.style.padding = "2px 8px";
    editButton.style.backgroundColor = "#e0f0ff";
    editButton.style.marginRight = "10px";
    editButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    editButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      // Open the equation editor with current value
      openEquationEditor(function(latex) {
        mathField.value = latex;
        container.equationValue = latex;
      });
    });
    row2.appendChild(editButton);
    
    // Keyboard toggle button
    const keyboardButton = document.createElement("button");
    keyboardButton.textContent = "Show Keyboard";
    keyboardButton.style.fontSize = "12px";
    keyboardButton.style.padding = "2px 8px";
    keyboardButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    keyboardButton.addEventListener("click", function(e) {
      e.stopPropagation();
      if (mathField.hasVirtualKeyboard && mathField.virtualKeyboardState === 'visible') {
        mathField.closeVirtualKeyboard();
        keyboardButton.textContent = "Show Keyboard";
      } else {
        mathField.openVirtualKeyboard();
        keyboardButton.textContent = "Hide Keyboard";
        
        // Fix keyboard positioning
        setTimeout(() => {
          const keyboard = document.querySelector('.ML__keyboard');
          if (keyboard) {
            keyboard.style.position = 'fixed';
            keyboard.style.bottom = '0';
            keyboard.style.left = '0';
            keyboard.style.right = '0';
            keyboard.style.zIndex = '10000';
            
            // Remove backdrop
            const backdrop = document.querySelector('.ML__backdrop');
            if (backdrop) {
              backdrop.style.display = 'none';
              backdrop.style.opacity = '0';
              backdrop.style.pointerEvents = 'none';
            }
            
            // Scroll to make mathField visible
            mathField.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }
        }, 100);
      }
    });
    row2.appendChild(keyboardButton);
    
    // Focus lock button (if manager exists)
    if (window.focusLockManager) {
      const lockFocusButton = document.createElement("button");
      lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
      lockFocusButton.style.fontSize = "12px";
      lockFocusButton.style.padding = "2px 8px";
      lockFocusButton.style.marginLeft = "10px";
      lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
      lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
      lockFocusButton.addEventListener("click", function(e) {
        e.stopPropagation();
        if (window.focusLockManager.isLockedElement(container)) {
          window.focusLockManager.unlock();
          this.textContent = "Lock Focus";
          this.style.backgroundColor = "#ccffcc";
        } else {
          window.focusLockManager.unlock();
          window.focusLockManager.lock(container);
          this.textContent = "Unlock Focus";
          this.style.backgroundColor = "#ffcccc";
        }
      });
      row2.appendChild(lockFocusButton);
    }
    
    globalToolbar.appendChild(row2);
  }

  /* -----------
     Activation / Deactivation
     ----------- */
  function activateEquation() {
    // Deactivate the previously active element if any
    if (window.activeEquationElement && window.activeEquationElement !== container) {
      window.activeEquationElement.style.border = "none";
      
      const prevToolbar = window.activeEquationElement.querySelector(".equation-toolbar");
      const prevResizeHandle = window.activeEquationElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeEquationElement = container;
    
    container.style.border = window.focusLockManager && window.focusLockManager.isLockedElement(container) 
      ? "2px solid #ff6666" 
      : "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivateEquation() {
    if (window.activeEquationElement === container && 
        !(window.focusLockManager && window.focusLockManager.isLockedElement(container))) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeEquationElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
        globalToolbar.style.display = "none";
      }
    }
  }

  function deleteEquation() {
    if (window.activeEquationElement === container) {
      window.activeEquationElement = null;
    }
    
    if (window.focusLockManager && window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
        globalToolbar.style.display = "none";
      }
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  /* -----------
     Event Listeners
     ----------- */
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (window.focusLockManager && window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateEquation();
    }
  });

  // Deletion
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteEquation();
  });

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(100, startWidth + (e.clientX - startX));
      const newHeight = Math.max(50, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = problemCanvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Boundary checking
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    if (!container.contains(e.target) && !clickedInGlobalToolbar && 
        window.activeEquationElement === container && 
        !(window.focusLockManager && window.focusLockManager.isLockedElement(container))) {
      deactivateEquation();
    }
  });

  // Append to canvas and activate
  problemCanvas.appendChild(container);
  activateEquation();
  
  // Open the equation editor immediately upon creation
  setTimeout(() => {
    openEquationEditor(function(latex) {
      mathField.value = latex;
      container.equationValue = latex;
    });
  }, 100);
  
  return container;
}


function updateTextboxBackground(container, content, newColor) {
  // If "none" is chosen, set effectiveColor to transparent
  const effectiveColor = (newColor === "none" || newColor === "") ? "transparent" : newColor;
  
  // Save the effective color on the container object for later use
  container.backgroundColor = effectiveColor;
  
  // Update the container's CSS variable (if using one)
  container.style.setProperty('--textbox-bg', effectiveColor);
  
  // Update the content area background.
  content.style.backgroundColor = effectiveColor;
  
  // Update any inline equation elements within the text box.
  container.querySelectorAll('.equation-button').forEach(eq => {
    eq.style.backgroundColor = effectiveColor;
  });


// Event listener for the hex color picker:
document.getElementById("textbox-bg-picker").addEventListener("input", function() {
  const container = window.activeTextboxElement;
  if (!container) return;
  const content = container.querySelector(".textbox-content");
  if (!content) return;
  
  // The value is a hex code (e.g., "#ffffff")
  updateTextboxBackground(container, content, this.value);
});

// Event listener for the "None" button:
document.getElementById("bg-none").addEventListener("click", function() {
  const container = window.activeTextboxElement;
  if (!container) return;
  const content = container.querySelector(".textbox-content");
  if (!content) return;
  
  updateTextboxBackground(container, content, "none");
});
}

function showShadeModal(pieces, currentFills, callback) {
  // Create the modal overlay.
  const modalOverlay = document.createElement("div");
  modalOverlay.style.position = "fixed";
  modalOverlay.style.top = "0";
  modalOverlay.style.left = "0";
  modalOverlay.style.width = "100%";
  modalOverlay.style.height = "100%";
  modalOverlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  modalOverlay.style.display = "flex";
  modalOverlay.style.justifyContent = "center";
  modalOverlay.style.alignItems = "center";
  modalOverlay.style.zIndex = "10000";
  
  // Create the modal container.
  const modal = document.createElement("div");
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "5px";
  modal.style.textAlign = "center";
  modal.style.minWidth = "320px";
  modalOverlay.appendChild(modal);
  
  const title = document.createElement("h3");
  title.innerText = "Shade Pieces";
  modal.appendChild(title);
  
  // Create an SVG element to display the circle.
  const svgSize = 300;
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", svgSize);
  svg.setAttribute("height", svgSize);
  svg.setAttribute("viewBox", `0 0 ${svgSize} ${svgSize}`);
  modal.appendChild(svg);
  
  const cx = svgSize / 2;
  const cy = svgSize / 2;
  const radius = svgSize * 0.4;
  const angleStep = (2 * Math.PI) / pieces;
  
  // Initialize fills array.
  let fills = (currentFills && currentFills.length === pieces)
    ? [...currentFills]
    : new Array(pieces).fill("transparent");
  
  // Track currently selected wedge (by index) and store wedge elements.
  let currentSelectedIndex = null;
  const wedgeElements = [];
  
  // Function to update wedge highlighting.
  function updateHighlight() {
    wedgeElements.forEach((w, idx) => {
      if (idx === currentSelectedIndex) {
        w.setAttribute("stroke", "red");
        w.setAttribute("stroke-width", "3");
      } else {
        w.setAttribute("stroke", "#000");
        w.setAttribute("stroke-width", "1");
      }
    });
  }
  
  // Create each wedge.
  for (let i = 0; i < pieces; i++) {
    const startAngle = i * angleStep;
    const endAngle = (i + 1) * angleStep;
    const x1 = cx + radius * Math.cos(startAngle);
    const y1 = cy + radius * Math.sin(startAngle);
    const x2 = cx + radius * Math.cos(endAngle);
    const y2 = cy + radius * Math.sin(endAngle);
    
    const path = document.createElementNS(svgNS, "path");
    const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;
    const d = `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
    path.setAttribute("d", d);
    path.setAttribute("stroke", "#000");
    path.setAttribute("stroke-width", "1");
    path.setAttribute("fill", fills[i]);
    path.style.cursor = "pointer";
    path.dataset.index = i;
    
    // Wedge click handler:
    // • If the wedge is already selected, open a color picker near it.
    // • If not, select it (highlight it).
    path.addEventListener("click", function(e) {
      e.stopPropagation();
      const idx = parseInt(path.dataset.index);
      if (currentSelectedIndex === idx) {
        // Open the system color picker near this wedge.
        const rect = path.getBoundingClientRect();
        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.value = fills[idx] === "transparent" ? "#ffffff" : fills[idx];
        // Position the color input near the wedge.
        colorInput.style.position = "absolute";
        colorInput.style.left = rect.left + "px";
        colorInput.style.top = (rect.bottom + 5) + "px";
        document.body.appendChild(colorInput);
        
        // When the user picks a color (via change), update the wedge and palette.
        colorInput.addEventListener("change", function(e) {
          fills[idx] = colorInput.value;
          path.setAttribute("fill", colorInput.value);
          updatePalette();
          document.body.removeChild(colorInput);
        });
        
        // If the input loses focus, remove it and remove the highlight.
        colorInput.addEventListener("blur", function(e) {
          if (document.body.contains(colorInput)) {
            document.body.removeChild(colorInput);
          }
          updateHighlight();
        });
        
        // On double click, finalize the color immediately and close the picker.
        colorInput.addEventListener("dblclick", function(e) {
          fills[idx] = colorInput.value;
          path.setAttribute("fill", colorInput.value);
          updatePalette();
          document.body.removeChild(colorInput);
          updateHighlight();
        });
        
        colorInput.focus();
        colorInput.click();
      } else {
        // Select this wedge.
        currentSelectedIndex = idx;
        updateHighlight();
      }
    });
    
    wedgeElements.push(path);
    svg.appendChild(path);
  }
  
  // Create a palette area below the SVG that shows a swatch for each piece.
  const palette = document.createElement("div");
  palette.style.marginTop = "10px";
  modal.appendChild(palette);
  
  function updatePalette() {
    palette.innerHTML = "";
    for (let i = 0; i < pieces; i++) {
      const swatch = document.createElement("div");
      swatch.style.display = "inline-block";
      swatch.style.width = "25px";
      swatch.style.height = "25px";
      swatch.style.margin = "0 5px";
      swatch.style.border = "1px solid #000";
      swatch.style.backgroundColor = fills[i];
      swatch.title = "Piece " + (i + 1);
      swatch.dataset.index = i;
      // Clicking a swatch updates the currently selected wedge's color.
      swatch.addEventListener("click", function(e) {
        e.stopPropagation();
        if (currentSelectedIndex !== null) {
          fills[currentSelectedIndex] = swatch.style.backgroundColor;
          wedgeElements[currentSelectedIndex].setAttribute("fill", swatch.style.backgroundColor);
          updatePalette();
        }
      });
      palette.appendChild(swatch);
    }
  }
  updatePalette();
  
  // OK and Cancel buttons.
  const btnContainer = document.createElement("div");
  btnContainer.style.marginTop = "15px";
  
  const okBtn = document.createElement("button");
  okBtn.innerText = "OK";
  okBtn.style.margin = "0 10px";
  okBtn.addEventListener("click", function() {
    document.body.removeChild(modalOverlay);
    callback(fills);
  });
  btnContainer.appendChild(okBtn);
  
  const cancelBtn = document.createElement("button");
  cancelBtn.innerText = "Cancel";
  cancelBtn.style.margin = "0 10px";
  cancelBtn.addEventListener("click", function() {
    document.body.removeChild(modalOverlay);
  });
  btnContainer.appendChild(cancelBtn);
  
  modal.appendChild(btnContainer);
  document.body.appendChild(modalOverlay);
}




function addCircle() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20; // Fixed toolbar height
  let nextElementOffset = 10;

  // Global state for active circle and counter.
  if (!window.activeCircleElement) window.activeCircleElement = null;
  if (!window.globalCircleCounter) {
    window.globalCircleCounter = 1;
  } else {
    window.globalCircleCounter++;
  }

  // Create the outer container.
  const container = document.createElement("div");
  container.className = "draggable-element circle-container";
  container.style.position = "absolute";
  container.style.left = `${nextElementOffset}px`;
  container.style.top = `${nextElementOffset}px`;
  container.style.width = "150px";
  container.style.height = "170px"; // Toolbar + content
  container.style.cursor = "default";
  nextElementOffset += 10;
  container.circleID = window.globalCircleCounter;

  // Store initial properties.
  container.dataset.fillColor = "transparent"; // Default fill
  container.dataset.strokeColor = "#000000";     // Default stroke
  container.dataset.pieFills = JSON.stringify([]); // Array for pie wedge fills

  // Create local toolbar.
  const localToolbar = document.createElement("div");
  localToolbar.className = "circle-toolbar element-controls";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.width = "100%";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Initially hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Left controls (drag handle).
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);

  // Right controls (delete button).
  const rightControls = document.createElement("div");
  rightControls.style.display = "flex";
  rightControls.style.alignItems = "center";
  const deleteButton = document.createElement("button");
  deleteButton.className = "delete-button";
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  deleteButton.addEventListener("mousedown", (e) => {
    e.stopPropagation();
  });
  rightControls.appendChild(deleteButton);

  localToolbar.appendChild(leftControls);
  localToolbar.appendChild(rightControls);
  container.appendChild(localToolbar);

  // Create content div (holds SVG and center marker).
  const content = document.createElement("div");
  content.className = "circle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create SVG element.
  const svgWidth = 150;
  const svgHeight = 150;
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  svg.style.pointerEvents = "auto"; // Allow pointer events
  content.appendChild(svg);

  // Create main circle.
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  const center = { x: 0.5, y: 0.5 };
  let pieWedges = [];
  let radiusLine = null;
  let diameterLine = null;
  circle.setAttribute("stroke", container.dataset.strokeColor);
  circle.setAttribute("stroke-width", "2");
  circle.setAttribute("fill", container.dataset.fillColor);
  svg.appendChild(circle);

  // Create center marker.
  const centerMarker = document.createElement("div");
  centerMarker.className = "circle-center";
  centerMarker.style.position = "absolute";
  centerMarker.style.width = "10px";
  centerMarker.style.height = "10px";
  centerMarker.style.background = container.dataset.strokeColor;
  centerMarker.style.borderRadius = "50%";
  centerMarker.style.cursor = "move";
  centerMarker.style.zIndex = "100";
  centerMarker.style.display = "none"; // Initially hidden
  function updateCenterMarker() {
    const w = svg.clientWidth || svgWidth;
    const h = svg.clientHeight || svgHeight;
    centerMarker.style.left = `${center.x * w - 5}px`;
    centerMarker.style.top = `${center.y * h - 5}px`;
  }
  updateCenterMarker();
  content.appendChild(centerMarker);

  // Create resize handle (hidden by default).
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none";
  container.appendChild(resizeHandle);

  // Main update function.
function updateCircle() {
  // Force container to be square
  const containerWidth = parseInt(container.style.width);
  const toolbarHeight = 20; // Fixed toolbar height
  container.style.height = `${containerWidth + toolbarHeight}px`;
  content.style.height = `${containerWidth}px`;
  
  // Update SVG dimensions to match content area
  const w = containerWidth;
  const h = containerWidth;
  svg.setAttribute("width", w);
  svg.setAttribute("height", h);
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  
  // Calculate radius - use a slightly smaller percentage to ensure it stays within bounds
  const radius = Math.min(w, h) * 0.45;
  
  // Set circle attributes - use exact pixel values for center
  const centerX = w * center.x;
  const centerY = h * center.y;
  
  circle.setAttribute("cx", centerX);
  circle.setAttribute("cy", centerY);
  circle.setAttribute("r", radius);
  circle.setAttribute("fill", container.dataset.fillColor);
  circle.setAttribute("stroke", container.dataset.strokeColor);
  circle.setAttribute("stroke-width", "2");
  
  // Update center marker position and color
  centerMarker.style.background = container.dataset.strokeColor;
  centerMarker.style.left = `${centerX - 5}px`;
  centerMarker.style.top = `${centerY - 5}px`;

  // Update radius or diameter lines if present
  if (radiusLine) {
    radiusLine.setAttribute("x1", centerX);
    radiusLine.setAttribute("y1", centerY);
    radiusLine.setAttribute("x2", centerX + radius);
    radiusLine.setAttribute("y2", centerY);
    radiusLine.setAttribute("stroke", container.dataset.strokeColor);
  }
  
  if (diameterLine) {
    diameterLine.setAttribute("x1", centerX - radius);
    diameterLine.setAttribute("y1", centerY);
    diameterLine.setAttribute("x2", centerX + radius);
    diameterLine.setAttribute("y2", centerY);
    diameterLine.setAttribute("stroke", container.dataset.strokeColor);
  }

  // Remove any old pie wedges
  pieWedges.forEach(wedge => {
    if (wedge.parentNode) wedge.parentNode.removeChild(wedge);
  });
  pieWedges = [];

  // Create pie wedges if pie mode is active
  const pieMode = true;
  if (pieMode) {
    // Read the number of pieces from a global toolbar input
    const pieInput = document.querySelector("#global-toolbar input[type='number']");
    const pieces = pieInput ? parseInt(pieInput.value) : 0;
    const pieFills = JSON.parse(container.dataset.pieFills || "[]");

    if (pieces > 0) {
      const angleStep = (2 * Math.PI) / pieces;
      for (let i = 0; i < pieces; i++) {
        const startAngle = i * angleStep;
        const endAngle = (i + 1) * angleStep;
        const x1 = centerX + radius * Math.cos(startAngle);
        const y1 = centerY + radius * Math.sin(startAngle);
        const x2 = centerX + radius * Math.cos(endAngle);
        const y2 = centerY + radius * Math.sin(endAngle);
        
        const wedge = document.createElementNS("http://www.w3.org/2000/svg", "path");
        wedge.classList.add("pie-wedge");
        const largeArc = (endAngle - startAngle > Math.PI) ? 1 : 0;
        const d = `M ${centerX} ${centerY} ` +
                  `L ${x1} ${y1} ` +
                  `A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} ` +
                  `Z`;
        wedge.setAttribute("d", d);
        wedge.setAttribute("stroke", container.dataset.strokeColor);
        wedge.setAttribute("stroke-width", "1");
        wedge.setAttribute("fill", pieFills[i] || "transparent");
        wedge.style.pointerEvents = "all";
        wedge.dataset.wedgeIndex = i;
        
        svg.appendChild(wedge);
        pieWedges.push(wedge);
      }
    }
  }

  // Update center marker position
  updateCenterMarker();
}

  // Expose updateCircle if needed externally.
  if (!window.updateCircle) {
    window.updateCircle = function(targetContainer) {
      if (targetContainer === container) {
        updateCircle();
      }
    };
  }
  updateCircle();

  // Delete function.
  function deleteCircle() {
    if (window.activeCircleElement === container) {
      window.activeCircleElement = null;
    }
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }
  deleteButton.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    deleteCircle();
  });
  deleteButton.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    deleteCircle();
  });

  // Make container draggable.
  dragHandle.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    let canvasRect = canvas.getBoundingClientRect();
    let rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    function onMouseMove(e) {
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Resize handle functionality.
 // Resize handle functionality.
resizeHandle.addEventListener("mousedown", (e) => {
  e.preventDefault();
  e.stopPropagation();
  const startX = e.clientX;
  const startWidth = container.offsetWidth;
  
  function onMouseMove(e) {
    // Calculate new width based on mouse movement
    const newWidth = Math.max(50, startWidth + (e.clientX - startX));
    
    // Update container dimensions
    container.style.width = newWidth + "px";
    container.style.height = (newWidth + toolbarHeight) + "px";
    
    // Update content and SVG
    content.style.height = newWidth + "px";
    
    // Call updateCircle to properly position everything
    updateCircle();
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

  // Activate circle on mousedown (if not dragging).
  container.addEventListener("mousedown", (e) => {
    if (e.target !== dragHandle && e.target !== resizeHandle && !e.target.classList.contains('oval-marker')) {
      activateCircle();
    }
  });

  // Center marker drag functionality.
  centerMarker.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    const containerRect = content.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const startCenterX = center.x;
    const startCenterY = center.y;
    function onMouseMove(e) {
      const dx = (e.clientX - startX) / containerRect.width;
      const dy = (e.clientY - startY) / containerRect.height;
      center.x = Math.max(0.1, Math.min(0.9, startCenterX + dx));
      center.y = Math.max(0.1, Math.min(0.9, startCenterY + dy));
      updateCircle();
      updateCenterMarker();
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click handler for deactivation.
  document.addEventListener("click", (e) => {
    const globalToolbar = document.getElementById("global-toolbar");
    const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    if (!container.contains(e.target) && !isClickInGlobalToolbar && window.activeCircleElement === container) {
      deactivateCircle();
    }
  });

  // Activate the circle (show its toolbar and resize handle).
  function activateCircle() {
    if (window.activeCircleElement && window.activeCircleElement !== container) {
      window.activeCircleElement.style.border = "none";
      const prevToolbar = window.activeCircleElement.querySelector(".circle-toolbar");
      const prevCenterMarker = window.activeCircleElement.querySelector(".circle-center");
      const prevResizeHandle = window.activeCircleElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevCenterMarker) prevCenterMarker.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    window.activeCircleElement = container;
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    // Show center marker if indicated by a global toolbar select.
    const showCenterSelect = document.querySelector("#global-toolbar .show-center");
    if (showCenterSelect && showCenterSelect.value === "yes") {
      centerMarker.style.display = "block";
    }
    updateCircle();
    updateGlobalToolbar(container);
  }

  // Deactivate the active circle.
  function deactivateCircle() {
  if (window.activeCircleElement === container) {
    container.style.border = "none";
    const localToolbar = container.querySelector(".circle-toolbar");
    const centerMarker = container.querySelector(".circle-center");
    const resizeHandle = container.querySelector(".resize-handle");
    if (localToolbar) localToolbar.style.display = "none";
    if (resizeHandle) resizeHandle.style.display = "none";
    // Only hide the center marker if the user selected "no"
    if (!container.dataset.showCenter || container.dataset.showCenter === "no") {
      if (centerMarker) centerMarker.style.display = "none";
    }
    window.activeCircleElement = null;
    const globalToolbar = document.getElementById("global-toolbar");
    if (globalToolbar) globalToolbar.innerHTML = "";
  }
}


  // Global toolbar update.
 function updateGlobalToolbar(container) {
  const globalToolbar = document.getElementById("global-toolbar");
  if (!globalToolbar) return;
  globalToolbar.innerHTML = "";

  // Create two rows for controls.
  const topRow = document.createElement("div");
  topRow.style.display = "flex";
  topRow.style.alignItems = "center";
  topRow.style.marginBottom = "5px";
  topRow.style.flexWrap = "wrap";
  const bottomRow = document.createElement("div");
  bottomRow.style.display = "flex";
  bottomRow.style.alignItems = "center";
  bottomRow.style.flexWrap = "wrap";

  // Identity label.
  const identityLabel = document.createElement("span");
  identityLabel.textContent = "Circle " + container.circleID;
  identityLabel.style.fontSize = "12px";
  identityLabel.style.fontWeight = "bold";
  identityLabel.style.marginRight = "10px";
  topRow.appendChild(identityLabel);

  // Stroke control.
  const strokeGroup = document.createElement("div");
  strokeGroup.style.display = "flex";
  strokeGroup.style.alignItems = "center";
  strokeGroup.style.marginRight = "10px";
  const strokeLabel = document.createElement("span");
  strokeLabel.textContent = "Line:";
  strokeLabel.style.fontSize = "12px";
  strokeGroup.appendChild(strokeLabel);
  const strokeDisplay = document.createElement("input");
  strokeDisplay.type = "color";
  strokeDisplay.value = container.dataset.strokeColor;
  strokeDisplay.style.marginLeft = "5px";
  strokeDisplay.addEventListener("click", (e) => { e.stopPropagation(); });
  strokeDisplay.addEventListener("change", (e) => {
    e.stopPropagation();
    container.dataset.strokeColor = strokeDisplay.value;
    updateCircle(container);
  });
  strokeDisplay.addEventListener("input", (e) => {
    e.stopPropagation();
    container.dataset.strokeColor = strokeDisplay.value;
    updateCircle(container);
  });
  strokeGroup.appendChild(strokeDisplay);
  topRow.appendChild(strokeGroup);

  // Fill control.
  const fillGroup = document.createElement("div");
  fillGroup.style.display = "flex";
  fillGroup.style.alignItems = "center";
  fillGroup.style.marginRight = "10px";
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Shade:";
  fillLabel.style.fontSize = "12px";
  fillGroup.appendChild(fillLabel);
  const fillDisplay = document.createElement("div");
  fillDisplay.className = "fill-display";
  fillDisplay.style.width = "20px";
  fillDisplay.style.height = "20px";
  if (container.dataset.fillColor === "transparent") {
    fillDisplay.style.backgroundColor = "#ffffff";
    fillDisplay.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
    fillDisplay.style.backgroundSize = "10px 10px";
    fillDisplay.style.backgroundPosition = "0 0, 5px 5px";
  } else {
    fillDisplay.style.backgroundColor = container.dataset.fillColor;
  }
  fillDisplay.style.cursor = "pointer";
  fillDisplay.style.border = "1px solid #ccc";
  fillDisplay.style.marginLeft = "5px";
  fillDisplay.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    // Open a modal to choose the fill color.
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
    overlay.style.zIndex = "10000";
    overlay.style.display = "flex";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";
    const modal = document.createElement("div");
    modal.style.background = "#fff";
    modal.style.padding = "10px";
    modal.style.border = "1px solid #ccc";
    modal.style.fontSize = "14px";
    modal.innerHTML = `<div style="margin-bottom:10px;">Choose Fill Color</div>`;
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = container.dataset.fillColor === "transparent" ? "#ffffff" : container.dataset.fillColor;
    modal.appendChild(colorInput);
    const noneBtn = document.createElement("button");
    noneBtn.textContent = "None";
    noneBtn.style.marginLeft = "10px";
    modal.appendChild(noneBtn);
    const okBtn = document.createElement("button");
    okBtn.textContent = "OK";
    okBtn.style.marginLeft = "10px";
    modal.appendChild(okBtn);
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancel";
    cancelBtn.style.marginLeft = "10px";
    modal.appendChild(cancelBtn);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    function cleanup() {
      document.body.removeChild(overlay);
    }
    okBtn.addEventListener("click", () => {
      const selectedColor = colorInput.value;
      fillDisplay.style.backgroundColor = selectedColor;
      fillDisplay.style.backgroundImage = "none";
      container.dataset.fillColor = selectedColor;
      updateCircle(container);
      cleanup();
    });
    noneBtn.addEventListener("click", () => {
      fillDisplay.style.backgroundColor = "#ffffff";
      fillDisplay.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
      fillDisplay.style.backgroundSize = "10px 10px";
      fillDisplay.style.backgroundPosition = "0 0, 5px 5px";
      container.dataset.fillColor = "transparent";
      updateCircle(container);
      cleanup();
    });
    cancelBtn.addEventListener("click", cleanup);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) cleanup(); });
  });
  fillGroup.appendChild(fillDisplay);
  topRow.appendChild(fillGroup);

  // Show Center control.
  const centerGroup = document.createElement("div");
centerGroup.style.display = "flex";
centerGroup.style.alignItems = "center";
centerGroup.style.marginRight = "10px";

const centerLabel = document.createElement("span");
centerLabel.textContent = "Show Center:";
centerLabel.style.fontSize = "12px";
centerGroup.appendChild(centerLabel);

const showCenterSelect = document.createElement("select");
showCenterSelect.className = "show-center";
showCenterSelect.style.marginLeft = "5px";
showCenterSelect.style.fontSize = "12px";
showCenterSelect.addEventListener("click", (e) => { e.stopPropagation(); });

// Create options.
const centerYes = document.createElement("option");
centerYes.value = "yes";
centerYes.textContent = "Yes";

const centerNo = document.createElement("option");
centerNo.value = "no";
centerNo.textContent = "No";

// Append options.
showCenterSelect.appendChild(centerYes);
showCenterSelect.appendChild(centerNo);

// Set a default value in the dataset if not already set.
if (!container.dataset.showCenter) {
  container.dataset.showCenter = "no";
}
// Initialize the select with the current dataset value.
showCenterSelect.value = container.dataset.showCenter;

showCenterSelect.addEventListener("change", (e) => {
  e.stopPropagation();
  // Save the current selection to the container's dataset.
  container.dataset.showCenter = e.target.value;
  const centerMarker = container.querySelector(".circle-center");
  if (centerMarker) {
    centerMarker.style.display = e.target.value === "yes" ? "block" : "none";
  }
});

centerGroup.appendChild(showCenterSelect);
topRow.appendChild(centerGroup);


  // Draw Radius control.
  const radiusGroup = document.createElement("div");
  radiusGroup.style.display = "flex";
  radiusGroup.style.alignItems = "center";
  radiusGroup.style.marginRight = "10px";
  const radiusLabel = document.createElement("span");
  radiusLabel.textContent = "Draw Radius:";
  radiusLabel.style.fontSize = "12px";
  radiusGroup.appendChild(radiusLabel);
  const drawRadiusSelect = document.createElement("select");
  drawRadiusSelect.className = "draw-radius";
  drawRadiusSelect.style.marginLeft = "5px";
  drawRadiusSelect.style.fontSize = "12px";
  drawRadiusSelect.addEventListener("click", (e) => { e.stopPropagation(); });
  const radiusYes = document.createElement("option");
  radiusYes.value = "yes";
  radiusYes.textContent = "Yes";
  const radiusNo = document.createElement("option");
  radiusNo.value = "no";
  radiusNo.textContent = "No";
  radiusNo.selected = true;
  drawRadiusSelect.appendChild(radiusYes);
  drawRadiusSelect.appendChild(radiusNo);
  drawRadiusSelect.addEventListener("change", (e) => {
    e.stopPropagation();
    if (e.target.value === "yes") {
      const drawDiameterSelect = container.querySelector(".draw-diameter");
      if (drawDiameterSelect) { drawDiameterSelect.value = "no"; }
      if (typeof diameterLine !== 'undefined' && diameterLine) {
        diameterLine.remove();
        diameterLine = null;
      }
      if (typeof radiusLine === 'undefined' || !radiusLine) {
        radiusLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        radiusLine.setAttribute("stroke", container.dataset.strokeColor);
        radiusLine.setAttribute("stroke-width", "2");
        const svg = container.querySelector("svg");
        svg.appendChild(radiusLine);
      }
    } else if (typeof radiusLine !== 'undefined' && radiusLine) {
      radiusLine.remove();
      radiusLine = null;
    }
    updateCircle(container);
  });
  radiusGroup.appendChild(drawRadiusSelect);
  bottomRow.appendChild(radiusGroup);

  // Draw Diameter control.
  const diameterGroup = document.createElement("div");
  diameterGroup.style.display = "flex";
  diameterGroup.style.alignItems = "center";
  diameterGroup.style.marginRight = "10px";
  const diameterLabel = document.createElement("span");
  diameterLabel.textContent = "Draw Diameter:";
  diameterLabel.style.fontSize = "12px";
  diameterGroup.appendChild(diameterLabel);
  const drawDiameterSelect = document.createElement("select");
  drawDiameterSelect.className = "draw-diameter";
  drawDiameterSelect.style.marginLeft = "5px";
  drawDiameterSelect.style.fontSize = "12px";
  drawDiameterSelect.addEventListener("click", (e) => { e.stopPropagation(); });
  const diameterYes = document.createElement("option");
  diameterYes.value = "yes";
  diameterYes.textContent = "Yes";
  const diameterNo = document.createElement("option");
  diameterNo.value = "no";
  diameterNo.textContent = "No";
  diameterNo.selected = true;
  drawDiameterSelect.appendChild(diameterYes);
  drawDiameterSelect.appendChild(diameterNo);
  drawDiameterSelect.addEventListener("change", (e) => {
    e.stopPropagation();
    if (e.target.value === "yes") {
      const drawRadiusSelect = container.querySelector(".draw-radius");
      if (drawRadiusSelect) { drawRadiusSelect.value = "no"; }
      if (typeof radiusLine !== 'undefined' && radiusLine) {
        radiusLine.remove();
        radiusLine = null;
      }
      if (typeof diameterLine === 'undefined' || !diameterLine) {
        diameterLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        diameterLine.setAttribute("stroke", container.dataset.strokeColor);
        diameterLine.setAttribute("stroke-width", "2");
        const svg = container.querySelector("svg");
        svg.appendChild(diameterLine);
      }
    } else if (typeof diameterLine !== 'undefined' && diameterLine) {
      diameterLine.remove();
      diameterLine = null;
    }
    updateCircle(container);
  });
  diameterGroup.appendChild(drawDiameterSelect);
  bottomRow.appendChild(diameterGroup);

  // Pie Pieces control.
  const pieGroup2 = document.createElement("div");
  pieGroup2.style.display = "flex";
  pieGroup2.style.alignItems = "center";
  pieGroup2.style.marginRight = "10px";
  const pieLabel2 = document.createElement("span");
  pieLabel2.textContent = "Pie Pieces:";
  pieLabel2.style.fontSize = "12px";
  pieGroup2.appendChild(pieLabel2);
  const pieInput2 = document.createElement("input");
  pieInput2.type = "number";
  pieInput2.min = "0";
  pieInput2.style.width = "40px";
  pieInput2.style.marginLeft = "5px";
  pieInput2.style.fontSize = "12px";
  const currentFills2 = JSON.parse(container.dataset.pieFills || "[]");
  pieInput2.value = currentFills2.length > 0 ? currentFills2.length : 0;
  pieInput2.addEventListener("click", (e) => { e.stopPropagation(); });
  pieInput2.addEventListener("mousedown", (e) => { e.stopPropagation(); });
  pieInput2.addEventListener("input", (e) => {
    e.stopPropagation();
    let piecesValue = parseInt(pieInput2.value);
    let currentFills2 = JSON.parse(container.dataset.pieFills || "[]");
    if (piecesValue > 0) {
      let newFills = Array(piecesValue).fill("transparent");
      for (let i = 0; i < Math.min(currentFills2.length, newFills.length); i++) {
        newFills[i] = currentFills2[i];
      }
      container.dataset.pieFills = JSON.stringify(newFills);
    } else if (currentFills2.length > 0) {
      pieInput2.value = currentFills2.length;
    }
    updateCircle(container);
  });
  pieGroup2.appendChild(pieInput2);
  bottomRow.appendChild(pieGroup2);

  // "Shade Pieces" button.
  const shadePiecesBtn = document.createElement("button");
  shadePiecesBtn.textContent = "Shade Pieces";
  shadePiecesBtn.style.fontSize = "12px";
  shadePiecesBtn.style.marginRight = "10px";
  shadePiecesBtn.style.padding = "2px 8px";
  shadePiecesBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
  });
  shadePiecesBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    const pieces = parseInt(pieInput2.value);
    if (isNaN(pieces) || pieces <= 0) {
      alert("Please set Pie Pieces to a number greater than 0 to shade individual pieces.");
      return;
    }
    let currentFills = JSON.parse(container.dataset.pieFills || "[]");
    if (currentFills.length !== pieces) {
      currentFills = new Array(pieces).fill("transparent");
    }
    // Launch the modal.
    showShadeModal(pieces, currentFills, (newFills) => {
  container.dataset.pieFills = JSON.stringify(newFills);
  updateCircle(container);
  // Activate the container after OK is clicked.
  activateCircle(container);
});

  });
  bottomRow.appendChild(shadePiecesBtn);

  // "Automate" button.
  const automateBtn = document.createElement("button");
  automateBtn.textContent = "Automate";
  automateBtn.className = "automate-btn";
  automateBtn.style.fontSize = "12px";
  automateBtn.style.marginRight = "10px";
  automateBtn.style.padding = "2px 8px";
  automateBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    showPieChartModal(container);
  });
  bottomRow.appendChild(automateBtn);

  globalToolbar.appendChild(topRow);
  globalToolbar.appendChild(bottomRow);
  globalToolbar.addEventListener("click", (e) => { e.stopPropagation(); });
  globalToolbar.addEventListener("mousedown", (e) => { e.stopPropagation(); });

  // Immediately update the circle so changes are reflected without requiring another click.
  updateCircle(container);
}


  // Append the container and activate this circle.
  canvas.appendChild(container);
  updateCircle();
  activateCircle();
}

// Function to show a color picker when a pie wedge is clicked
function showPieColorPicker(wedge, wedgeIndex) {
  // Get the container from the wedge's parent chain
  const svg = wedge.closest('svg');
  const content = svg.closest('.circle-content');
  const container = content.closest('.circle-container');
  
  // Create an overlay for the color picker
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  overlay.style.zIndex = "10000";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  
  // Create the color picker modal
  const modal = document.createElement("div");
  modal.style.background = "#fff";
  modal.style.padding = "15px";
  modal.style.borderRadius = "5px";
  modal.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
  
  // Get current fill color
  const currentFills = JSON.parse(container.dataset.pieFills || "[]");
  const currentColor = currentFills[wedgeIndex] || "transparent";
  
  // Add title
  const title = document.createElement("div");
  title.style.fontWeight = "bold";
  title.style.marginBottom = "10px";
  title.textContent = `Choose Color for Pie Piece ${wedgeIndex + 1}`;
  modal.appendChild(title);
  
  // Create color input
  const colorRow = document.createElement("div");
  colorRow.style.display = "flex";
  colorRow.style.alignItems = "center";
  colorRow.style.marginBottom = "15px";
  
  const colorLabel = document.createElement("span");
  colorLabel.textContent = "Color:";
  colorLabel.style.marginRight = "10px";
  colorRow.appendChild(colorLabel);
  
  const colorInput = document.createElement("input");
  colorInput.type = "color";
  colorInput.value = currentColor === "transparent" ? "#ffffff" : currentColor;
  colorRow.appendChild(colorInput);
  
  modal.appendChild(colorRow);
  
  // Add button row
  const buttonRow = document.createElement("div");
  buttonRow.style.display = "flex";
  buttonRow.style.justifyContent = "space-between";
  
  // None button (for transparent fill)
  const noneBtn = document.createElement("button");
  noneBtn.textContent = "None";
  noneBtn.style.padding = "5px 10px";
  buttonRow.appendChild(noneBtn);
  
  // OK button
  const okBtn = document.createElement("button");
  okBtn.textContent = "OK";
  okBtn.style.padding = "5px 10px";
  okBtn.style.marginLeft = "10px";
  buttonRow.appendChild(okBtn);
  
  // Cancel button
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.padding = "5px 10px";
  cancelBtn.style.marginLeft = "10px";
  buttonRow.appendChild(cancelBtn);
  
  modal.appendChild(buttonRow);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // Handle actions
  function cleanup() {
    document.body.removeChild(overlay);
  }
  
  // Apply the selected color
  okBtn.addEventListener("click", () => {
    const selectedColor = colorInput.value;
    wedge.setAttribute("fill", selectedColor);
    
    // Update the stored fills array
    const fills = JSON.parse(container.dataset.pieFills || "[]");
    while (fills.length <= wedgeIndex) {
      fills.push("transparent");
    }
    fills[wedgeIndex] = selectedColor;
    container.dataset.pieFills = JSON.stringify(fills);
    
    cleanup();
  });
  
  // Make the wedge transparent
  noneBtn.addEventListener("click", () => {
    wedge.setAttribute("fill", "transparent");
    
    // Update the stored fills array
    const fills = JSON.parse(container.dataset.pieFills || "[]");
    while (fills.length <= wedgeIndex) {
      fills.push("transparent");
    }
    fills[wedgeIndex] = "transparent";
    container.dataset.pieFills = JSON.stringify(fills);
    
    cleanup();
  });
  
  // Cancel without changes
  cancelBtn.addEventListener("click", cleanup);
  
  // Close when clicking the overlay background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) cleanup();
  });
}

// Make the function available globally
window.showPieColorPicker = showPieColorPicker;


function showPieChartModal(container) {
  const modal = document.getElementById("pieChartModal");
  const overlay = document.getElementById("modalOverlay");
  
  // Get the color input elements
  const shadedColorInput = document.getElementById("pie-shaded-color");
  const unshadedColorInput = document.getElementById("pie-unshaded-color");
  
  // Load existing values from container, if any
  const totalPieces = container.getAttribute("data-total-pieces") || "";
  const shadedPieces = container.getAttribute("data-shaded-pieces") || "";
  const shadedColor = container.getAttribute("data-shaded-color") || "#ff0000";
  const unshadedColor = container.getAttribute("data-unshaded-color") || "#ffffff";

  document.getElementById("pie-total-pieces").value = totalPieces;
  document.getElementById("pie-shaded-pieces").value = shadedPieces;
  
  // Make sure color inputs are properly set
  shadedColorInput.value = shadedColor;
  unshadedColorInput.value = unshadedColor;
  
  // Ensure color inputs are enabled and working
  shadedColorInput.disabled = false;
  unshadedColorInput.disabled = false;

  modal.style.display = "block";
  overlay.style.display = "block";

  function onOK() {
  const total = document.getElementById("pie-total-pieces").value;
  const shaded = document.getElementById("pie-shaded-pieces").value;
  const shadedCol = shadedColorInput.value;
  const unshadedCol = unshadedColorInput.value;

  console.log("Saving pie chart settings:", {
    total, shaded, shadedCol, unshadedCol
  });

  container.setAttribute("data-total-pieces", total);
  container.setAttribute("data-shaded-pieces", shaded);
  container.setAttribute("data-shaded-color", shadedCol);
  container.setAttribute("data-unshaded-color", unshadedCol);

  // Update the pieInput element's value inside the container
  const pieInput = container.querySelector('input[type="number"]');
  if (pieInput) {
    pieInput.value = total;
  }

  // Update the circle to reflect new settings
  window.updateCircle(container);

  cleanup();
}

  function onCancel() {
    cleanup();
  }

  function cleanup() {
    modal.style.display = "none";
    overlay.style.display = "none";
    document.getElementById("pieChartOK").removeEventListener("click", onOK);
    document.getElementById("pieChartCancel").removeEventListener("click", onCancel);
  }

  // Remove any existing event listeners first
  document.getElementById("pieChartOK").removeEventListener("click", onOK);
  document.getElementById("pieChartCancel").removeEventListener("click", onCancel);
  
  // Add fresh event listeners
  document.getElementById("pieChartOK").addEventListener("click", onOK);
  document.getElementById("pieChartCancel").addEventListener("click", onCancel);
}

function updateCircle(container) {
  // Get necessary elements
  const svg = container.querySelector('svg');
  const circle = container.querySelector('circle');
  const pieInput = container.querySelector('input[type="number"]');
  const drawRadiusSelect = container.querySelector('.draw-radius');
  const drawDiameterSelect = container.querySelector('.draw-diameter');

  if (!svg || !circle) return;

  // Get actual container dimensions
  const containerRect = container.getBoundingClientRect();
  const containerWidth = containerRect.width;
  container.style.height = `${containerWidth}px`; // Force a square

  // Get SVG dimensions
  const w = svg.clientWidth || containerWidth;
  const h = svg.clientHeight || containerWidth;

  // Check if we have a stored center position from dragging
  // If not, use the default center (0.5, 0.5)
  let center = { x: 0.5, y: 0.5 };
  
  // If container has stored center coordinates, use those instead
  if (container.dataset.centerX && container.dataset.centerY) {
    center = {
      x: parseFloat(container.dataset.centerX),
      y: parseFloat(container.dataset.centerY)
    };
  }
  
  // Calculate radius based on minimum dimension, using 45% as in the working version
  const radius = Math.min(w, h) * 0.45;

  // Update the SVG dimensions
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("width", w);
  svg.setAttribute("height", h);

  // Update circle with proportional center coordinates
  circle.setAttribute("cx", center.x*w );
  circle.setAttribute("cy", center.y*h);
  circle.setAttribute("r", radius);
  circle.setAttribute("stroke", container.dataset.strokeColor || "#000000");
  circle.setAttribute("stroke-width", "2");

  // Determine if we're in pie mode.
  const pieMode = pieInput && parseInt(pieInput.value) > 0;
  const pieces = pieMode ? parseInt(pieInput.value) : 0;
  const pieFills = JSON.parse(container.dataset.pieFills || "[]");

  // Set fill based on mode.
  if (pieMode && pieFills.length === pieces) {
    circle.setAttribute("fill", "transparent");
  } else if (pieMode) {
    const unshadedColor = container.getAttribute("data-unshaded-color") || "#ffffff";
    circle.setAttribute("fill", unshadedColor);
  } else {
    circle.setAttribute("fill", container.dataset.fillColor || "transparent");
  }

  // Remove any old pie wedges, radius, and diameter lines.
  svg.querySelectorAll('.pie-wedge').forEach(wedge => wedge.remove());
  let radiusLine = svg.querySelector('.radius-line');
  let diameterLine = svg.querySelector('.diameter-line');

  // Draw the radius line if enabled and not in pie mode.
  if (drawRadiusSelect && drawRadiusSelect.value === "yes" && !pieMode) {
    if (!radiusLine) {
      radiusLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
      radiusLine.classList.add("radius-line");
      svg.appendChild(radiusLine);
    }
    // Use proportional center coordinates like in the working version
    radiusLine.setAttribute("x1", center.x * w);
    radiusLine.setAttribute("y1", center.y * h);
    radiusLine.setAttribute("x2", center.x * w + radius);
    radiusLine.setAttribute("y2", center.y * h);
    radiusLine.setAttribute("stroke", container.dataset.strokeColor || "#000000");
    radiusLine.setAttribute("stroke-width", "2");
  } else if (radiusLine) {
    radiusLine.remove();
  }

  // Draw the diameter line if enabled and not in pie mode.
  if (drawDiameterSelect && drawDiameterSelect.value === "yes" && !pieMode) {
    if (!diameterLine) {
      diameterLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
      diameterLine.classList.add("diameter-line");
      svg.appendChild(diameterLine);
    }
    // Use proportional center coordinates like in the working version
    diameterLine.setAttribute("x1", center.x * w - radius);
    diameterLine.setAttribute("y1", center.y * h);
    diameterLine.setAttribute("x2", center.x * w + radius);
    diameterLine.setAttribute("y2", center.y * h);
    diameterLine.setAttribute("stroke", container.dataset.strokeColor || "#000000");
    diameterLine.setAttribute("stroke-width", "2");
  } else if (diameterLine) {
    diameterLine.remove();
  }

  // Create pie wedges if in pie mode.
  if (pieMode && pieces > 0) {
    const angleStep = (2 * Math.PI) / pieces;
    for (let i = 0; i < pieces; i++) {
      const startAngle = i * angleStep;
      const endAngle = (i + 1) * angleStep;
      // Use proportional center coordinates
      const centerX = center.x * w;
      const centerY = center.y * h;
      const x1 = centerX + radius * Math.cos(startAngle);
      const y1 = centerY + radius * Math.sin(startAngle);
      const x2 = centerX + radius * Math.cos(endAngle);
      const y2 = centerY + radius * Math.sin(endAngle);

      const wedge = document.createElementNS("http://www.w3.org/2000/svg", "path");
      wedge.classList.add("pie-wedge");
      const largeArc = (endAngle - startAngle > Math.PI) ? 1 : 0;
      const d = `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
      wedge.setAttribute("d", d);
      wedge.setAttribute("stroke", container.dataset.strokeColor || "#000000");
      wedge.setAttribute("stroke-width", "1");
      wedge.setAttribute("fill", pieFills[i] || "transparent");
      wedge.style.pointerEvents = "all";
      wedge.dataset.wedgeIndex = i;

      svg.appendChild(wedge);

      // Attach click event for shading if needed.
      wedge.addEventListener("click", (e) => {
        if (container.dataset.isShadingMode === "true") {
          e.stopPropagation();
          e.stopImmediatePropagation();
          showPieColorPicker(wedge, i);
        }
      });
    }
  }

  // Update the center marker position if it exists.
  const centerMarker = container.querySelector('.circle-center');
  if (centerMarker) {
    // Use proportional center coordinates
    centerMarker.style.left = `${center.x * w - 5}px`;
    centerMarker.style.top = `${center.y * h - 5}px`;
    centerMarker.style.background = container.dataset.strokeColor || "#000000";
  }
  
  // Set up drag handling for the center marker if it exists
  if (centerMarker && !centerMarker._hasInitialized) {
    centerMarker._hasInitialized = true;
    
    // Make sure the marker is visible
    centerMarker.style.cursor = 'move';
    
    // Add mouse down event to handle dragging
    centerMarker.addEventListener('mousedown', function(e) {
      e.preventDefault();
      
      // Store the initial position
      const startX = e.clientX;
      const startY = e.clientY;
      const startLeft = parseFloat(centerMarker.style.left);
      const startTop = parseFloat(centerMarker.style.top);
      
      // Function to handle mouse movement
      function handleMouseMove(e) {
        // Calculate the new position
        const newLeft = startLeft + (e.clientX - startX);
        const newTop = startTop + (e.clientY - startY);
        
        // Update marker position
        centerMarker.style.left = `${newLeft}px`;
        centerMarker.style.top = `${newTop}px`;
        
        // Calculate and store the normalized center
        const normalizedX = (newLeft + 5) / w;  // Add 5 to compensate for the marker offset
        const normalizedY = (newTop + 5) / h;
        
        // Store the new center in the container's dataset
        container.dataset.centerX = normalizedX;
        container.dataset.centerY = normalizedY;
        
        // Update the circle and other elements to the new center
        updateCircle(container);
      }
      
      // Function to handle mouse up
      function handleMouseUp() {
        // Remove event listeners
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      }
      
      // Add event listeners for dragging
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    });
  }
}


function generatePieChartSVG(totalPieces, shadedPieces, shadedColor, unshadedColor, width, height, pieFills) {
  console.log("Entering generatePieChartSVG with:", { totalPieces, shadedPieces, shadedColor, unshadedColor, width, height, pieFills });
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  const cx = width / 2;
  const cy = height / 2;
  const radius = Math.min(width, height) * 0.45;

  // Background circle
  const background = document.createElementNS(svgNS, "circle");
  background.setAttribute("cx", cx);
  background.setAttribute("cy", cy);
  background.setAttribute("r", radius);
  background.setAttribute("fill", unshadedColor || "#ffffff");
  background.setAttribute("stroke", "#000000");
  background.setAttribute("stroke-width", "2");
  svg.appendChild(background);
  console.log("Added background circle");

  // Shaded pieces
  const numShaded = Math.min(Math.max(Math.round(shadedPieces), 0), totalPieces);
  console.log("Num shaded:", numShaded);
  if (numShaded > 0) {
    const angleStep = (2 * Math.PI) / totalPieces;
    const forcedShadedColor = shadedColor || "#ff0000";
    console.log("Using shaded color:", forcedShadedColor);

    const startingPiece = Math.floor(Math.random() * totalPieces);
    for (let i = 0; i < numShaded; i++) {
      const pieceIndex = (startingPiece + i) % totalPieces;
      const startAngle = pieceIndex * angleStep;
      const endAngle = (pieceIndex + 1) * angleStep;
      const startX = cx + radius * Math.cos(startAngle);
      const startY = cy + radius * Math.sin(startAngle);
      const endX = cx + radius * Math.cos(endAngle);
      const endY = cy + radius * Math.sin(endAngle);
      const largeArc = (endAngle - startAngle > Math.PI) ? 1 : 0;

      const sector = document.createElementNS(svgNS, "path");
      const d = `M ${cx} ${cy} L ${startX} ${startY} A ${radius} ${radius} 0 ${largeArc} 1 ${endX} ${endY} Z`;
      sector.setAttribute("d", d);
      sector.setAttribute("fill", forcedShadedColor);
      sector.setAttribute("stroke", "#000000");
      sector.setAttribute("stroke-width", "2");
      svg.appendChild(sector);
      console.log(`Sector ${pieceIndex} added with fill: ${forcedShadedColor}`);
    }
  }

  // Dividing lines
  if (totalPieces > 1) {
    const angleStep = (2 * Math.PI) / totalPieces;
    for (let i = 0; i < totalPieces; i++) {
      const angle = i * angleStep;
      const endX = cx + radius * Math.cos(angle);
      const endY = cy + radius * Math.sin(angle);
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", cx);
      line.setAttribute("y1", cy);
      line.setAttribute("x2", endX);
      line.setAttribute("y2", endY);
      line.setAttribute("stroke", "#000000");
      line.setAttribute("stroke-width", "2");
      svg.appendChild(line);
      console.log(`Added dividing line ${i}`);
    }
  }

  // Outline
  const outline = document.createElementNS(svgNS, "circle");
  outline.setAttribute("cx", cx);
  outline.setAttribute("cy", cy);
  outline.setAttribute("r", radius);
  outline.setAttribute("fill", "none");
  outline.setAttribute("stroke", "#000000");
  outline.setAttribute("stroke-width", "2");
  svg.appendChild(outline);
  console.log("Added outline");

  const svgString = svg.outerHTML;
  console.log("Final SVG:", svgString);
  return svgString;
}



function svgToCanvas(svgString, width, height) {
  return new Promise((resolve, reject) => {
    const scaleFactor = 4; // 4x resolution for smoother edges
    const internalWidth = width * scaleFactor;
    const internalHeight = height * scaleFactor;

    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = internalWidth;
      canvas.height = internalHeight;
      const ctx = canvas.getContext("2d");

      // Enable high-quality rendering
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      // Draw at higher resolution
      ctx.drawImage(img, 0, 0, internalWidth, internalHeight);

      // Create a final canvas at the target size
      const finalCanvas = document.createElement("canvas");
      finalCanvas.width = width;
      finalCanvas.height = height;
      const finalCtx = finalCanvas.getContext("2d");
      finalCtx.imageSmoothingEnabled = true;
      finalCtx.imageSmoothingQuality = "high";
      finalCtx.drawImage(canvas, 0, 0, internalWidth, internalHeight, 0, 0, width, height);

      resolve(finalCanvas);
    };
    img.onerror = (e) => reject(e);
    img.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgString)));
  });
}



function addRectangle() {


  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20; // Fixed toolbar height
  let nextElementOffset = 10;

  // Global state for active rectangle and counter
  if (!window.activeRectangleElement) window.activeRectangleElement = null;
  if (!window.globalRectangleCounter) {
    window.globalRectangleCounter = 1;
  } else {
    window.globalRectangleCounter++;
  }

  // Create the outer container
  const container = document.createElement("div");

  
  container.dataset.useAutomate = "no"; // Default to manual mode
  
  // And make sure to properly set data attributes for automate mode
  container.setAttribute("data-total-sections", "0");
  container.setAttribute("data-shaded-sections", "0");
  container.setAttribute("data-shaded-color", "#ff0000");
  container.setAttribute("data-unshaded-color", "#ffffff");


  container.className = "draggable-element rectangle-container";
  container.style.position = "absolute";
  container.style.left = `${nextElementOffset}px`;
  container.style.top = `${nextElementOffset}px`;
  container.style.width = "200px";
  container.style.height = "150px"; // Toolbar + content
  container.style.cursor = "default";
  nextElementOffset += 10;
  container.rectangleID = window.globalRectangleCounter;

  // Store initial properties
  container.dataset.fillColor = "transparent"; // Default fill
  container.dataset.strokeColor = "#000000"; // Default stroke
  container.dataset.strokeWidth = "2"; // Default stroke width
  container.dataset.showVertices = "yes"; // Default: don't show vertices
  container.dataset.showRightAngles = "no"; // Default: don't show right angles
  container.dataset.sections = "0"; // Default: no sections
  container.dataset.sectionFills = JSON.stringify([]); // Array for section fills

  // Create local toolbar
  const localToolbar = document.createElement("div");
  localToolbar.className = "rectangle-toolbar element-controls";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.width = "100%";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Initially hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Left controls (drag handle)
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);

  // Right controls (delete button)
  const rightControls = document.createElement("div");
  rightControls.style.display = "flex";
  rightControls.style.alignItems = "center";
  const deleteButton = document.createElement("button");
  deleteButton.className = "delete-button";
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  deleteButton.addEventListener("mousedown", (e) => {
    e.stopPropagation();
  });
  rightControls.appendChild(deleteButton);

  localToolbar.appendChild(leftControls);
  localToolbar.appendChild(rightControls);
  container.appendChild(localToolbar);

  // Create content div (holds SVG)
  const content = document.createElement("div");
  content.className = "rectangle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create SVG element
  const svgWidth = 200;
  const svgHeight = 130;
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  svg.style.pointerEvents = "auto"; // Allow pointer events
  content.appendChild(svg);

  // Create main rectangle
  const rectangle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  rectangle.setAttribute("x", "10");
  rectangle.setAttribute("y", "10");
  rectangle.setAttribute("width", svgWidth - 20);
  rectangle.setAttribute("height", svgHeight - 20);
  rectangle.setAttribute("stroke", container.dataset.strokeColor);
  rectangle.setAttribute("stroke-width", container.dataset.strokeWidth);
  rectangle.setAttribute("fill", container.dataset.fillColor);
  svg.appendChild(rectangle);

  // Initialize vertices
  const vertices = [];
  const vertexRadius = 5;
  const vertexPositions = [
    { x: 10, y: 10 }, // top-left
    { x: svgWidth - 10, y: 10 }, // top-right
    { x: svgWidth - 10, y: svgHeight - 10 }, // bottom-right
    { x: 10, y: svgHeight - 10 } // bottom-left
  ];

  // Create vertex markers (initially hidden)
for (let i = 0; i < 4; i++) {
  const vertex = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  vertex.setAttribute("cx", vertexPositions[i].x);
  vertex.setAttribute("cy", vertexPositions[i].y);
  vertex.setAttribute("r", vertexRadius);
  vertex.setAttribute("fill", container.dataset.strokeColor);
  vertex.setAttribute("stroke", "#ffffff");
  vertex.setAttribute("stroke-width", "1");
  vertex.setAttribute("class", "vertex-marker");
  vertex.style.display = "none"; // Initially hidden
  vertex.style.cursor = "move";
  vertex.dataset.vertexIndex = i;
  
  // Add drag functionality to vertices
  vertex.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  const startX = e.clientX;
  const startY = e.clientY;
  const initialX = parseFloat(this.getAttribute("cx"));
  const initialY = parseFloat(this.getAttribute("cy"));
  const vertexIndex = parseInt(this.dataset.vertexIndex);
  
  function onMouseMove(e) {
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Get SVG element
    const svgElement = vertex.closest('svg');
    
    // Calculate the new vertex position within SVG coordinates
    const newX = Math.max(0, Math.min(parseFloat(svgElement.getAttribute("width")), initialX + dx));
    const newY = Math.max(0, Math.min(parseFloat(svgElement.getAttribute("height")), initialY + dy));
    
    // Update this vertex position
    vertex.setAttribute("cx", newX);
    vertex.setAttribute("cy", newY);
    vertexPositions[vertexIndex].x = newX;
    vertexPositions[vertexIndex].y = newY;
    
    // Now update the other vertices to maintain a perfect rectangle shape
    if (vertexIndex === 0) { // top-left
      // update top-right (keep y the same, x stays where it is)
      vertices[1].setAttribute("cy", newY);
      vertexPositions[1].y = newY;
      
      // update bottom-left (keep x the same, y stays where it is)
      vertices[3].setAttribute("cx", newX);
      vertexPositions[3].x = newX;
    } 
    else if (vertexIndex === 1) { // top-right
      // update top-left (keep y the same, x stays where it is)
      vertices[0].setAttribute("cy", newY);
      vertexPositions[0].y = newY;
      
      // update bottom-right (keep x the same, y stays where it is)
      vertices[2].setAttribute("cx", newX);
      vertexPositions[2].x = newX;
    }
    else if (vertexIndex === 2) { // bottom-right
      // update bottom-left (keep y the same, x stays where it is)
      vertices[3].setAttribute("cy", newY);
      vertexPositions[3].y = newY;
      
      // update top-right (keep x the same, y stays where it is)
      vertices[1].setAttribute("cx", newX);
      vertexPositions[1].x = newX;
    }
    else if (vertexIndex === 3) { // bottom-left
      // update bottom-right (keep y the same, x stays where it is)
      vertices[2].setAttribute("cy", newY);
      vertexPositions[2].y = newY;
      
      // update top-left (keep x the same, y stays where it is)
      vertices[0].setAttribute("cx", newX);
      vertexPositions[0].x = newX;
    }
    
    // Update rectangle shape
    updateRectangleFromVertices();
    
    // This is the key addition - update right angle markers during vertex movement
    if (container.dataset.showRightAngles === "yes") {
      updateRightAngleMarkers();
    }
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    
    // One final update when mouse is released
    if (container.dataset.showRightAngles === "yes") {
      updateRightAngleMarkers();
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});
  
  svg.appendChild(vertex);
  vertices.push(vertex);
}

  // Create right angle markers (initially hidden)
  const rightAngles = [];
  for (let i = 0; i < 4; i++) {
    const rightAngle = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const size = 10; // Size of the right angle marker
    
    rightAngle.setAttribute("fill", "none");
    rightAngle.setAttribute("stroke", container.dataset.strokeColor);
    rightAngle.setAttribute("stroke-width", "1");
    rightAngle.setAttribute("class", "right-angle-marker");
    rightAngle.style.display = "none"; // Initially hidden
    svg.appendChild(rightAngle);
    rightAngles.push(rightAngle);
  }

  // Create resize handle (hidden by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none";
  container.appendChild(resizeHandle);
  function updateRectangleFromVertices() {
  // Find the bounding box of all vertices
  let minX = Math.min(...vertices.map(v => parseFloat(v.getAttribute("cx"))));
  let minY = Math.min(...vertices.map(v => parseFloat(v.getAttribute("cy"))));
  let maxX = Math.max(...vertices.map(v => parseFloat(v.getAttribute("cx"))));
  let maxY = Math.max(...vertices.map(v => parseFloat(v.getAttribute("cy"))));
  
  // Update the rectangle based on the bounding box
  rectangle.setAttribute("x", minX);
  rectangle.setAttribute("y", minY);
  rectangle.setAttribute("width", maxX - minX);
  rectangle.setAttribute("height", maxY - minY);
  
  // Update container size based on rectangle dimensions with a buffer
  const buffer = 20; // Buffer space between rectangle edge and container edge
  const minContainerWidth = 150; // Minimum container width
  const minContentHeight = 100; // Minimum content height
  
  // Calculate new container dimensions
  const newContainerWidth = Math.max(minContainerWidth, maxX + buffer);
  const newContentHeight = Math.max(minContentHeight, maxY + buffer);
  
  // Update SVG dimensions
  svg.setAttribute("width", newContainerWidth);
  svg.setAttribute("height", newContentHeight);
  svg.setAttribute("viewBox", `0 0 ${newContainerWidth} ${newContentHeight}`);
  
  // Update container dimensions
  container.style.width = `${newContainerWidth}px`;
  container.style.height = `${newContentHeight + toolbarHeight}px`;
  content.style.height = `${newContentHeight}px`;
  
  // This is the critical fix - ALWAYS update right angle markers if they're enabled
  if (container.dataset.showRightAngles === "yes") {
    updateRightAngleMarkers();
  }
  
  // Update sections
  updateSections();
}

// Function to properly reinitialize vertices after rectangle resize or update
// Function to properly reinitialize vertices to the corners of the rectangle
function reinitializeVertices() {
  const x = parseFloat(rectangle.getAttribute("x"));
  const y = parseFloat(rectangle.getAttribute("y"));
  const width = parseFloat(rectangle.getAttribute("width"));
  const height = parseFloat(rectangle.getAttribute("height"));
  
  // Important: Position vertices EXACTLY at the corners, not along the edges
  vertexPositions[0] = { x: x, y: y }; // top-left
  vertexPositions[1] = { x: x + width, y: y }; // top-right
  vertexPositions[2] = { x: x + width, y: y + height }; // bottom-right
  vertexPositions[3] = { x: x, y: y + height }; // bottom-left
  
  // Apply these positions to the vertex elements
  for (let i = 0; i < 4; i++) {
    vertices[i].setAttribute("cx", vertexPositions[i].x);
    vertices[i].setAttribute("cy", vertexPositions[i].y);
  }
}

  // Function to update section display
  function updateSections() {
    // Clear existing sections
    svg.querySelectorAll('.section-path').forEach(path => path.remove());
    
    const sections = parseInt(container.dataset.sections || "0");
    if (sections <= 0) return;
    
    const x = parseFloat(rectangle.getAttribute("x"));
    const y = parseFloat(rectangle.getAttribute("y"));
    const width = parseFloat(rectangle.getAttribute("width"));
    const height = parseFloat(rectangle.getAttribute("height"));
    
    // Get section fills
    const sectionFills = JSON.parse(container.dataset.sectionFills || "[]");
    
    // Calculate sections based on whether the number is even or odd
    if (sections % 2 === 0) {
      // Even number: 2 x whatever
      const cols = 2;
      const rows = sections / 2;
      
      const cellWidth = width / cols;
      const cellHeight = height / rows;
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const sectionIndex = row * cols + col;
          const sectionX = x + col * cellWidth;
          const sectionY = y + row * cellHeight;
          
          const section = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          section.setAttribute("x", sectionX);
          section.setAttribute("y", sectionY);
          section.setAttribute("width", cellWidth);
          section.setAttribute("height", cellHeight);
          section.setAttribute("stroke", container.dataset.strokeColor);
          section.setAttribute("stroke-width", "1");
          section.setAttribute("fill", sectionFills[sectionIndex] || "transparent");
          section.setAttribute("class", "section-path");
          section.dataset.sectionIndex = sectionIndex;
          
          // Add click event for section coloring
          section.addEventListener("click", function(e) {
            if (container.dataset.isShadingMode === "true") {
              e.stopPropagation();
              showSectionColorPicker(section, sectionIndex);
            }
          });
          
          svg.appendChild(section);
        }
      }
    } else {
      // Odd number: 1 x whatever
      const cols = 1;
      const rows = sections;
      
      const cellHeight = height / rows;
      
      for (let row = 0; row < rows; row++) {
        const sectionY = y + row * cellHeight;
        
        const section = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        section.setAttribute("x", x);
        section.setAttribute("y", sectionY);
        section.setAttribute("width", width);
        section.setAttribute("height", cellHeight);
        section.setAttribute("stroke", container.dataset.strokeColor);
        section.setAttribute("stroke-width", "1");
        section.setAttribute("fill", sectionFills[row] || "transparent");
        section.setAttribute("class", "section-path");
        section.dataset.sectionIndex = row;
        
        // Add click event for section coloring
        section.addEventListener("click", function(e) {
          if (container.dataset.isShadingMode === "true") {
            e.stopPropagation();
            showSectionColorPicker(section, row);
          }
        });
        
        svg.appendChild(section);
      }
    }
  }

// ─────────────────────────────────────────────────────────────
// Drop‑in replacement for updateRightAngleMarkers()
// ─────────────────────────────────────────────────────────────
function updateRightAngleMarkers() {
  const show = container.dataset.showRightAngles === "yes";
  const delta = 14;                      // ← length of each leg
  const stroke      = container.dataset.strokeColor || "#000";
  const strokeWidth = 2;

  rightAngles.forEach((path, i) => {
    // Hide all if the toggle is off
    if (!show) { path.style.display = "none"; return; }

    const cx = parseFloat(vertices[i].getAttribute("cx"));  // corner coords
    const cy = parseFloat(vertices[i].getAttribute("cy"));
    let d;   // SVG path data

    switch (i) {
      // vertex order: 0 TL, 1 TR, 2 BR, 3 BL
      case 0: // top‑left (legs go right then down)
        d = `M ${cx} ${cy + delta} L ${cx + delta} ${cy + delta} L ${cx + delta} ${cy}`;
        break;

      case 1: // top‑right (legs go left then down)
        d = `M ${cx} ${cy + delta} L ${cx - delta} ${cy + delta} L ${cx - delta} ${cy}`;
        break;

      case 2: // bottom‑right (legs go left then up)
        d = `M ${cx} ${cy - delta} L ${cx - delta} ${cy - delta} L ${cx - delta} ${cy}`;
        break;

      case 3: // bottom‑left (legs go right then up)
        d = `M ${cx} ${cy - delta} L ${cx + delta} ${cy - delta} L ${cx + delta} ${cy}`;
        break;
    }

    path.setAttribute("d", d);            // draw the “square corner”
    path.setAttribute("stroke", stroke);
    path.setAttribute("stroke-width", strokeWidth);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-linecap", "square");
    path.style.pointerEvents = "none";
    path.style.display = "block";
  });
}


  // Main update function
  function updateRectangle() {
  // First, ensure the container is large enough to accommodate the rectangle
  const buffer = 20; // Buffer space around rectangle
  
  // Get current rectangle dimensions
  const rectX = parseFloat(rectangle.getAttribute("x"));
  const rectY = parseFloat(rectangle.getAttribute("y"));
  const rectWidth = parseFloat(rectangle.getAttribute("width"));
  const rectHeight = parseFloat(rectangle.getAttribute("height"));
  
  // Calculate minimum required dimensions with buffer
  const requiredWidth = rectX + rectWidth + buffer;
  const requiredHeight = rectY + rectHeight + buffer;
  
  // Get actual dimensions from container
  let containerWidth = parseInt(container.style.width) || 200; // Default if not set
  
  // Check if container needs to be larger
  if (containerWidth < requiredWidth) {
    containerWidth = requiredWidth;
    container.style.width = `${containerWidth}px`;
  }
  
  // Set content height while maintaining proper proportions
  const contentHeight = Math.max(requiredHeight, containerWidth * 0.65);
  container.style.height = `${contentHeight + toolbarHeight}px`;
  content.style.height = `${contentHeight}px`;
  
  // Update SVG dimensions
  svg.setAttribute("width", containerWidth);
  svg.setAttribute("height", contentHeight);
  svg.setAttribute("viewBox", `0 0 ${containerWidth} ${contentHeight}`);
  
  // Update rectangle attributes
  rectangle.setAttribute("stroke", container.dataset.strokeColor);
  rectangle.setAttribute("stroke-width", container.dataset.strokeWidth);
  rectangle.setAttribute("fill", container.dataset.fillColor);
  
  // Reinitialize vertices when rectangle changes
  reinitializeVertices();
  
  // Update vertex colors and visibility
  vertices.forEach(vertex => {
    vertex.setAttribute("fill", container.dataset.strokeColor);
    vertex.style.display = container.dataset.showVertices === "yes" ? "block" : "none";
  });
  
  // Update right angle markers visibility and explicitly call updateRightAngleMarkers
  rightAngles.forEach(angle => {
    angle.setAttribute("stroke", container.dataset.strokeColor);
    angle.style.display = container.dataset.showRightAngles === "yes" ? "block" : "none";
  });
  
  // Always call updateRightAngleMarkers if right angles should be shown
  if (container.dataset.showRightAngles === "yes") {
    updateRightAngleMarkers();
  }

  // Update sections
  updateSections();
}

  // Expose updateRectangle if needed externally
  if (!window.updateRectangle) {
    window.updateRectangle = function(targetContainer) {
      if (targetContainer === container) {
        updateRectangle();
      }
    };
  }
  updateRectangle();

  // Delete function
  function deleteRectangle() {
    if (window.activeRectangleElement === container) {
      window.activeRectangleElement = null;
    }
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }
  deleteButton.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    deleteRectangle();
  });
  deleteButton.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    deleteRectangle();
  });

  // Make container draggable
  dragHandle.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    let canvasRect = canvas.getBoundingClientRect();
    let rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    function onMouseMove(e) {
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Resize handle functionality
// Resize handle functionality
resizeHandle.addEventListener("mousedown", (e) => {
  e.preventDefault();
  e.stopPropagation();
  const startX = e.clientX;
  const startWidth = container.offsetWidth;
  
  function onMouseMove(e) {
    // Calculate new width based on mouse movement
    const newWidth = Math.max(100, startWidth + (e.clientX - startX));
    
    // Update container dimensions
    container.style.width = newWidth + "px";
    
    // Call updateRectangle to properly position everything
    updateRectangle();
    
    // Explicitly update right angle markers if they're supposed to be shown
    if (container.dataset.showRightAngles === "yes") {
      updateRightAngleMarkers();
    }
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    
    // One final update when mouse is released
    if (container.dataset.showRightAngles === "yes") {
      updateRightAngleMarkers();
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});


  // Activate rectangle on mousedown (if not dragging)
  container.addEventListener("mousedown", (e) => {
    if (e.target !== dragHandle && e.target !== resizeHandle && 
        !e.target.classList.contains('vertex-marker') && 
        !e.target.classList.contains('right-angle-marker')) {
      activateRectangle();
    }
  });

  // Document click handler for deactivation
  document.addEventListener("click", (e) => {
    const globalToolbar = document.getElementById("global-toolbar");
    const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    if (!container.contains(e.target) && !isClickInGlobalToolbar && window.activeRectangleElement === container) {
      deactivateRectangle();
    }
  });

  // Activate the rectangle (show its toolbar and resize handle)
// Activate the rectangle (show its toolbar and resize handle)
function activateRectangle() {
  if (window.activeRectangleElement && window.activeRectangleElement !== container) {
    window.activeRectangleElement.style.border = "none";
    const prevToolbar = window.activeRectangleElement.querySelector(".rectangle-toolbar");
    const prevResizeHandle = window.activeRectangleElement.querySelector(".resize-handle");
    if (prevToolbar) prevToolbar.style.display = "none";
    if (prevResizeHandle) prevResizeHandle.style.display = "none";
  }
  
  window.activeRectangleElement = container;
  container.style.border = "1px dashed #ccc";
  localToolbar.style.display = "flex";
  resizeHandle.style.display = "block";
  
  // Before activating, ensure the container is large enough
  // to fully contain the rectangle with buffer
  const buffer = 20;
  
  // Get current rectangle dimensions from the SVG element
  const rectX = parseFloat(rectangle.getAttribute("x"));
  const rectY = parseFloat(rectangle.getAttribute("y"));
  const rectWidth = parseFloat(rectangle.getAttribute("width"));
  const rectHeight = parseFloat(rectangle.getAttribute("height"));
  
  // Calculate needed dimensions with buffer
  const minWidth = rectX + rectWidth + buffer;
  const minHeight = rectY + rectHeight + buffer;
  
  // Update SVG if needed
  const svgElement = rectangle.closest('svg');
  const currentSvgWidth = parseFloat(svgElement.getAttribute("width"));
  const currentSvgHeight = parseFloat(svgElement.getAttribute("height"));
  
  if (currentSvgWidth < minWidth || currentSvgHeight < minHeight) {
    const newWidth = Math.max(currentSvgWidth, minWidth);
    const newHeight = Math.max(currentSvgHeight, minHeight);
    
    svgElement.setAttribute("width", newWidth);
    svgElement.setAttribute("height", newHeight);
    svgElement.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);
    
    // Also update container dimensions
    container.style.width = `${newWidth}px`;
    container.style.height = `${newHeight + toolbarHeight}px`;
    content.style.height = `${newHeight}px`;
  }
  
  // Show vertex markers if indicated
  if (container.dataset.showVertices === "yes") {
    vertices.forEach(vertex => {
      vertex.style.display = "block";
    });
  }
  
  // Show right angle markers if indicated
  if (container.dataset.showRightAngles === "yes") {
    updateRightAngleMarkers(); // Explicitly call this function here
    rightAngles.forEach(angle => {
      angle.style.display = "block";
      angle.setAttribute("stroke-width", "2"); // Add this
      angle.setAttribute("stroke", "#000000"); // Add this
    });
  }
  
  updateRectangle();
  updateGlobalToolbar(container);
}

  // Deactivate the active rectangle
function deactivateRectangle() {
  if (window.activeRectangleElement === container) {
    container.style.border = "none";
    localToolbar.style.display = "none";
    resizeHandle.style.display = "none";
    
    // Before deactivating, make sure the container is large enough
    // to fully contain the rectangle with buffer
    const rect = rectangle.getBoundingClientRect();
    const buffer = 20;
    
    // Get current rectangle dimensions from the actual SVG element
    const rectX = parseFloat(rectangle.getAttribute("x"));
    const rectY = parseFloat(rectangle.getAttribute("y"));
    const rectWidth = parseFloat(rectangle.getAttribute("width"));
    const rectHeight = parseFloat(rectangle.getAttribute("height"));
    
    // Calculate needed dimensions with buffer
    const minWidth = rectX + rectWidth + buffer;
    const minHeight = rectY + rectHeight + buffer;
    
    // Update SVG if needed
    const svgElement = rectangle.closest('svg');
    const currentSvgWidth = parseFloat(svgElement.getAttribute("width"));
    const currentSvgHeight = parseFloat(svgElement.getAttribute("height"));
    
    if (currentSvgWidth < minWidth || currentSvgHeight < minHeight) {
      const newWidth = Math.max(currentSvgWidth, minWidth);
      const newHeight = Math.max(currentSvgHeight, minHeight);
      
      svgElement.setAttribute("width", newWidth);
      svgElement.setAttribute("height", newHeight);
      svgElement.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);
      
      // Also update container dimensions
      container.style.width = `${newWidth}px`;
      container.style.height = `${newHeight + toolbarHeight}px`;
      content.style.height = `${newHeight}px`;
    }
    
    // Hide vertex markers if not set to show
    if (container.dataset.showVertices !== "yes") {
      vertices.forEach(vertex => {
        vertex.style.display = "none";
      });
    }
    
    // Hide right angle markers if not set to show
    if (container.dataset.showRightAngles !== "yes") {
      rightAngles.forEach(angle => {
        angle.style.display = "none";
      });
    }
    
    window.activeRectangleElement = null;
    const globalToolbar = document.getElementById("global-toolbar");
    if (globalToolbar) globalToolbar.innerHTML = "";
  }
}


function updateGlobalToolbar(container) {
  const globalToolbar = document.getElementById("global-toolbar");
  if (!globalToolbar) return;
  globalToolbar.innerHTML = "";

  // Create two rows for controls
  const topRow = document.createElement("div");
  topRow.style.display = "flex";
  topRow.style.alignItems = "center";
  topRow.style.marginBottom = "5px";
  topRow.style.flexWrap = "wrap";
  const bottomRow = document.createElement("div");
  bottomRow.style.display = "flex";
  bottomRow.style.alignItems = "center";
  bottomRow.style.flexWrap = "wrap";

  // Identity label
  const identityLabel = document.createElement("span");
  identityLabel.textContent = "Rectangle " + container.rectangleID;
  identityLabel.style.fontSize = "12px";
  identityLabel.style.fontWeight = "bold";
  identityLabel.style.marginRight = "10px";
  topRow.appendChild(identityLabel);

  // Add Automate toggle at the start of top row
  const automateGroup = document.createElement("div");
  automateGroup.style.display = "flex";
  automateGroup.style.alignItems = "center";
  automateGroup.style.marginRight = "15px";
  const automateLabel = document.createElement("span");
  automateLabel.textContent = "Automate:";
  automateLabel.style.fontSize = "12px";
  automateGroup.appendChild(automateLabel);
  const automateSelect = document.createElement("select");
  automateSelect.style.marginLeft = "5px";
  automateSelect.style.fontSize = "12px";
  const automateYes = document.createElement("option");
  automateYes.value = "yes";
  automateYes.textContent = "Yes";
  const automateNo = document.createElement("option");
  automateNo.value = "no";
  automateNo.textContent = "No";
  automateNo.selected = container.dataset.useAutomate !== "yes";
  automateYes.selected = container.dataset.useAutomate === "yes";
  automateSelect.appendChild(automateYes);
  automateSelect.appendChild(automateNo);
  automateSelect.addEventListener("click", (e) => { e.stopPropagation(); });
  automateSelect.addEventListener("change", (e) => {
    e.stopPropagation();
    container.dataset.useAutomate = e.target.value;
    
    // If switching to automate mode, show the automate modal
    if (e.target.value === "yes") {
      showRectangleAutoModal(container);
    } else {
      // If switching to manual mode, update the rectangle
      updateRectangle();
    }
  });
  automateGroup.appendChild(automateSelect);
  topRow.appendChild(automateGroup);

  // Stroke control
  const strokeGroup = document.createElement("div");
  strokeGroup.style.display = "flex";
  strokeGroup.style.alignItems = "center";
  strokeGroup.style.marginRight = "10px";
  const strokeLabel = document.createElement("span");
  strokeLabel.textContent = "Line:";
  strokeLabel.style.fontSize = "12px";
  strokeGroup.appendChild(strokeLabel);
  const strokeDisplay = document.createElement("input");
  strokeDisplay.type = "color";
  strokeDisplay.value = container.dataset.strokeColor;
  strokeDisplay.style.marginLeft = "5px";
  strokeDisplay.addEventListener("click", (e) => { e.stopPropagation(); });
  strokeDisplay.addEventListener("change", (e) => {
    e.stopPropagation();
    container.dataset.strokeColor = strokeDisplay.value;
    updateRectangle();
  });
  strokeDisplay.addEventListener("input", (e) => {
    e.stopPropagation();
    container.dataset.strokeColor = strokeDisplay.value;
    updateRectangle();
  });
  strokeGroup.appendChild(strokeDisplay);
  topRow.appendChild(strokeGroup);

  // Line thickness control
  const thicknessGroup = document.createElement("div");
  thicknessGroup.style.display = "flex";
  thicknessGroup.style.alignItems = "center";
  thicknessGroup.style.marginRight = "10px";
  const thicknessLabel = document.createElement("span");
  thicknessLabel.textContent = "Thickness:";
  thicknessLabel.style.fontSize = "12px";
  thicknessGroup.appendChild(thicknessLabel);
  const thicknessSelect = document.createElement("select");
  thicknessSelect.style.marginLeft = "5px";
  thicknessSelect.style.fontSize = "12px";
  [1, 2, 3, 4, 5].forEach(size => {
    const option = document.createElement("option");
    option.value = size;
    option.textContent = size;
    if (size.toString() === container.dataset.strokeWidth) {
      option.selected = true;
    }
    thicknessSelect.appendChild(option);
  });
  thicknessSelect.addEventListener("click", (e) => { e.stopPropagation(); });
  thicknessSelect.addEventListener("change", (e) => {
    e.stopPropagation();
    container.dataset.strokeWidth = e.target.value;
    updateRectangle();
  });
  thicknessGroup.appendChild(thicknessSelect);
  topRow.appendChild(thicknessGroup);

  // Fill control
  const fillGroup = document.createElement("div");
  fillGroup.style.display = "flex";
  fillGroup.style.alignItems = "center";
  fillGroup.style.marginRight = "10px";
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Fill:";
  fillLabel.style.fontSize = "12px";
  fillGroup.appendChild(fillLabel);
  const fillDisplay = document.createElement("div");
  fillDisplay.className = "fill-display";
  fillDisplay.style.width = "20px";
  fillDisplay.style.height = "20px";
  if (container.dataset.fillColor === "transparent") {
    fillDisplay.style.backgroundColor = "#ffffff";
    fillDisplay.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
    fillDisplay.style.backgroundSize = "10px 10px";
    fillDisplay.style.backgroundPosition = "0 0, 5px 5px";
  } else {
    fillDisplay.style.backgroundColor = container.dataset.fillColor;
  }
  fillDisplay.style.cursor = "pointer";
  fillDisplay.style.border = "1px solid #ccc";
  fillDisplay.style.marginLeft = "5px";
  fillDisplay.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    // Open a modal to choose the fill color
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
    overlay.style.zIndex = "10000";
    overlay.style.display = "flex";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";
    const modal = document.createElement("div");
    modal.style.background = "#fff";
    modal.style.padding = "10px";
    modal.style.border = "1px solid #ccc";
    modal.style.fontSize = "14px";
    modal.innerHTML = `<div style="margin-bottom:10px;">Choose Fill Color</div>`;
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = container.dataset.fillColor === "transparent" ? "#ffffff" : container.dataset.fillColor;
    modal.appendChild(colorInput);
    const noneBtn = document.createElement("button");
    noneBtn.textContent = "None";
    noneBtn.style.marginLeft = "10px";
    modal.appendChild(noneBtn);
    const okBtn = document.createElement("button");
    okBtn.textContent = "OK";
    okBtn.style.marginLeft = "10px";
    modal.appendChild(okBtn);
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancel";
    cancelBtn.style.marginLeft = "10px";
    modal.appendChild(cancelBtn);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    function cleanup() {
      document.body.removeChild(overlay);
    }
    okBtn.addEventListener("click", () => {
      const selectedColor = colorInput.value;
      fillDisplay.style.backgroundColor = selectedColor;
      fillDisplay.style.backgroundImage = "none";
      container.dataset.fillColor = selectedColor;
      updateRectangle();
      cleanup();
    });
    noneBtn.addEventListener("click", () => {
      fillDisplay.style.backgroundColor = "#ffffff";
      fillDisplay.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
      fillDisplay.style.backgroundSize = "10px 10px";
      fillDisplay.style.backgroundPosition = "0 0, 5px 5px";
      container.dataset.fillColor = "transparent";
      updateRectangle();
      cleanup();
    });
    cancelBtn.addEventListener("click", cleanup);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) cleanup(); });
  });
  fillGroup.appendChild(fillDisplay);
  topRow.appendChild(fillGroup);

  // Show Vertices control
  const verticesGroup = document.createElement("div");
  verticesGroup.style.display = "flex";
  verticesGroup.style.alignItems = "center";
  verticesGroup.style.marginRight = "10px";
  const verticesLabel = document.createElement("span");
  verticesLabel.textContent = "Show Vertices:";
  verticesLabel.style.fontSize = "12px";
  verticesGroup.appendChild(verticesLabel);
  const verticesSelect = document.createElement("select");
  verticesSelect.style.marginLeft = "5px";
  verticesSelect.style.fontSize = "12px";
  const verticesYes = document.createElement("option");
  verticesYes.value = "yes";
  verticesYes.textContent = "Yes";
  const verticesNo = document.createElement("option");
  verticesNo.value = "no";
  verticesNo.textContent = "No";
  verticesNo.selected = container.dataset.showVertices === "no";
  verticesYes.selected = container.dataset.showVertices === "yes";
  verticesSelect.appendChild(verticesYes);
  verticesSelect.appendChild(verticesNo);
  verticesSelect.addEventListener("click", (e) => { e.stopPropagation(); });
  verticesSelect.addEventListener("change", (e) => {
    e.stopPropagation();
    container.dataset.showVertices = e.target.value;
    updateRectangle();
  });
  verticesGroup.appendChild(verticesSelect);
  topRow.appendChild(verticesGroup);

  // Show Right Angles control
  const rightAnglesGroup = document.createElement("div");
  rightAnglesGroup.style.display = "flex";
  rightAnglesGroup.style.alignItems = "center";
  rightAnglesGroup.style.marginRight = "10px";
  const rightAnglesLabel = document.createElement("span");
  rightAnglesLabel.textContent = "Show Right Angles:";
  rightAnglesLabel.style.fontSize = "12px";
  rightAnglesGroup.appendChild(rightAnglesLabel);
  const rightAnglesSelect = document.createElement("select");
  rightAnglesSelect.style.marginLeft = "5px";
  rightAnglesSelect.style.fontSize = "12px";
  const rightAnglesYes = document.createElement("option");
  rightAnglesYes.value = "yes";
  rightAnglesYes.textContent = "Yes";
  const rightAnglesNo = document.createElement("option");
  rightAnglesNo.value = "no";
  rightAnglesNo.textContent = "No";
  rightAnglesNo.selected = container.dataset.showRightAngles === "no";
  rightAnglesYes.selected = container.dataset.showRightAngles === "yes";
  rightAnglesSelect.appendChild(rightAnglesYes);
  rightAnglesSelect.appendChild(rightAnglesNo);
  rightAnglesSelect.addEventListener("click", (e) => { e.stopPropagation(); });
  rightAnglesSelect.addEventListener("change", (e) => {
  e.stopPropagation();
  container.dataset.showRightAngles = e.target.value;
  console.log("Right angle setting changed to:", e.target.value);
  updateRectangle();
});
  rightAnglesGroup.appendChild(rightAnglesSelect);
  topRow.appendChild(rightAnglesGroup);

  // Sections control
  const sectionsGroup = document.createElement("div");
  sectionsGroup.style.display = "flex";
  sectionsGroup.style.alignItems = "center";
  sectionsGroup.style.marginRight = "10px";
  const sectionsLabel = document.createElement("span");
  sectionsLabel.textContent = "Sections:";
  sectionsLabel.style.fontSize = "12px";
  sectionsGroup.appendChild(sectionsLabel);
  const sectionsInput = document.createElement("input");
  sectionsInput.type = "number";
  sectionsInput.min = "0";
  sectionsInput.style.width = "40px";
  sectionsInput.style.marginLeft = "5px";
  sectionsInput.style.fontSize = "12px";
  sectionsInput.value = container.dataset.sections || "0";
  sectionsInput.addEventListener("click", (e) => { e.stopPropagation(); });
  sectionsInput.addEventListener("change", (e) => {
    e.stopPropagation();
    let sectionsValue = parseInt(sectionsInput.value);
    if (isNaN(sectionsValue) || sectionsValue < 0) {
      sectionsValue = 0;
      sectionsInput.value = "0";
    }
    container.dataset.sections = sectionsValue.toString();
    
    // Initialize section fills array
    let currentFills = JSON.parse(container.dataset.sectionFills || "[]");
    if (sectionsValue > 0) {
      // Ensure there are enough fill entries for all sections
      while (currentFills.length < sectionsValue) {
        currentFills.push("transparent");
      }
      // Trim the array if there are too many
      if (currentFills.length > sectionsValue) {
        currentFills = currentFills.slice(0, sectionsValue);
      }
      container.dataset.sectionFills = JSON.stringify(currentFills);
    }
    
    updateRectangle();
  });
  sectionsGroup.appendChild(sectionsInput);
  bottomRow.appendChild(sectionsGroup);

  // "Shade Sections" button
  const shadeSectionsBtn = document.createElement("button");
  shadeSectionsBtn.textContent = "Shade Sections";
  shadeSectionsBtn.style.fontSize = "12px";
  shadeSectionsBtn.style.marginRight = "10px";
  shadeSectionsBtn.style.padding = "2px 8px";
  shadeSectionsBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
  });
  shadeSectionsBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    const sections = parseInt(container.dataset.sections);
    if (isNaN(sections) || sections <= 0) {
      alert("Please set Sections to a number greater than 0 to shade individual sections.");
      return;
    }
    let currentFills = JSON.parse(container.dataset.sectionFills || "[]");
    if (currentFills.length !== sections) {
      currentFills = new Array(sections).fill("transparent");
    }
    // Launch the shade modal
    showShadeModal(sections, currentFills, (newFills) => {
      container.dataset.sectionFills = JSON.stringify(newFills);
      updateRectangle();
      // Activate the container after OK is clicked
      activateRectangle();
    });
  });
  bottomRow.appendChild(shadeSectionsBtn);

  // "Automate" button (for direct access to automate modal)
  const automateBtn = document.createElement("button");
  automateBtn.textContent = "Automate Settings";
  automateBtn.className = "automate-btn";
  automateBtn.style.fontSize = "12px";
  automateBtn.style.marginRight = "10px";
  automateBtn.style.padding = "2px 8px";
  automateBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    showRectangleAutoModal(container);
  });
  bottomRow.appendChild(automateBtn);

  globalToolbar.appendChild(topRow);
  globalToolbar.appendChild(bottomRow);
  globalToolbar.addEventListener("click", (e) => { e.stopPropagation(); });
  globalToolbar.addEventListener("mousedown", (e) => { e.stopPropagation(); });

  // Immediately update the rectangle so changes are reflected without requiring another click
  updateRectangle();
}

  // Append the container and activate this rectangle
  canvas.appendChild(container);
  updateRectangle();
  activateRectangle();
}

// Function to show a color picker when a section is clicked
function showSectionColorPicker(section, sectionIndex) {
  // Get the container from the section's parent chain
  const svg = section.closest('svg');
  const content = svg.closest('.rectangle-content');
  const container = content.closest('.rectangle-container');
  
  // Create an overlay for the color picker
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  overlay.style.zIndex = "10000";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  
  // Create the color picker modal
  const modal = document.createElement("div");
  modal.style.background = "#fff";
  modal.style.padding = "15px";
  modal.style.borderRadius = "5px";
  modal.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
  
  // Get current fill color
  const currentFills = JSON.parse(container.dataset.sectionFills || "[]");
  const currentColor = currentFills[sectionIndex] || "transparent";
  
  // Add title
  const title = document.createElement("div");
  title.style.fontWeight = "bold";
  title.style.marginBottom = "10px";
  title.textContent = `Choose Color for Section ${sectionIndex + 1}`;
  modal.appendChild(title);
  
  // Create color input
  const colorRow = document.createElement("div");
  colorRow.style.display = "flex";
  colorRow.style.alignItems = "center";
  colorRow.style.marginBottom = "15px";
  
  const colorLabel = document.createElement("span");
  colorLabel.textContent = "Color:";
  colorLabel.style.marginRight = "10px";
  colorRow.appendChild(colorLabel);
  
  const colorInput = document.createElement("input");
  colorInput.type = "color";
  colorInput.value = currentColor === "transparent" ? "#ffffff" : currentColor;
  colorRow.appendChild(colorInput);
  
  modal.appendChild(colorRow);
  
  // Add button row
  const buttonRow = document.createElement("div");
  buttonRow.style.display = "flex";
  buttonRow.style.justifyContent = "space-between";
  
  // None button (for transparent fill)
  const noneBtn = document.createElement("button");
  noneBtn.textContent = "None";
  noneBtn.style.padding = "5px 10px";
  buttonRow.appendChild(noneBtn);
  
  // OK button
  const okBtn = document.createElement("button");
  okBtn.textContent = "OK";
  okBtn.style.padding = "5px 10px";
  okBtn.style.marginLeft = "10px";
  buttonRow.appendChild(okBtn);
  
  // Cancel button
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.padding = "5px 10px";
  cancelBtn.style.marginLeft = "10px";
  buttonRow.appendChild(cancelBtn);
  
  modal.appendChild(buttonRow);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // Handle actions
  function cleanup() {
    document.body.removeChild(overlay);
  }
  
  // Apply the selected color
  okBtn.addEventListener("click", () => {
    const selectedColor = colorInput.value;
    section.setAttribute("fill", selectedColor);
    
    // Update the stored fills array
    const fills = JSON.parse(container.dataset.sectionFills || "[]");
    while (fills.length <= sectionIndex) {
      fills.push("transparent");
    }
    fills[sectionIndex] = selectedColor;
    container.dataset.sectionFills = JSON.stringify(fills);
    
    cleanup();
  });
  
  // Make the section transparent
  noneBtn.addEventListener("click", () => {
    section.setAttribute("fill", "transparent");
    
    // Update the stored fills array
    const fills = JSON.parse(container.dataset.sectionFills || "[]");
    while (fills.length <= sectionIndex) {
      fills.push("transparent");
    }
    fills[sectionIndex] = "transparent";
    container.dataset.sectionFills = JSON.stringify(fills);
    
    cleanup();
  });
  
  // Cancel without changes
  cancelBtn.addEventListener("click", cleanup);
  
  // Close when clicking the overlay background
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) cleanup();
  });
}

// Make the function available globally
window.showSectionColorPicker = showSectionColorPicker;

function showRectangleAutoModal(container) {
  // Create modal overlay
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  overlay.style.zIndex = "10000";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  
  // Create modal window
  const modal = document.createElement("div");
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "5px";
  modal.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
  modal.style.width = "380px";
  
  // Add title
  const title = document.createElement("h3");
  title.textContent = "Rectangle Automation";
  title.style.marginTop = "0";
  title.style.marginBottom = "15px";
  modal.appendChild(title);
  
  // Sections row
  const sectionsRow = document.createElement("div");
  sectionsRow.style.display = "flex";
  sectionsRow.style.alignItems = "center";
  sectionsRow.style.marginBottom = "15px";
  
  const sectionsLabel = document.createElement("label");
  sectionsLabel.textContent = "Total Sections:";
  sectionsLabel.style.width = "120px";
  sectionsRow.appendChild(sectionsLabel);
  
  const sectionsInput = document.createElement("input");
  sectionsInput.type = "text"; // Changed to text to allow variable input
  sectionsInput.id = "rect-total-sections";
  sectionsInput.style.width = "100px";
  sectionsInput.value = container.getAttribute("data-total-sections") || "0";
  sectionsRow.appendChild(sectionsInput);
  
  modal.appendChild(sectionsRow);
  
  // Shaded sections row
  const shadedRow = document.createElement("div");
  shadedRow.style.display = "flex";
  shadedRow.style.alignItems = "center";
  shadedRow.style.marginBottom = "15px";
  
  const shadedLabel = document.createElement("label");
  shadedLabel.textContent = "Shaded Sections:";
  shadedLabel.style.width = "120px";
  shadedRow.appendChild(shadedLabel);
  
  const shadedInput = document.createElement("input");
  shadedInput.type = "text"; // Changed to text to allow variable input
  shadedInput.id = "rect-shaded-sections";
  shadedInput.style.width = "100px";
  shadedInput.value = container.getAttribute("data-shaded-sections") || "0";
  shadedRow.appendChild(shadedInput);
  
  modal.appendChild(shadedRow);
  
  // Shaded color row
  const shadedColorRow = document.createElement("div");
  shadedColorRow.style.display = "flex";
  shadedColorRow.style.alignItems = "center";
  shadedColorRow.style.marginBottom = "15px";
  
  const shadedColorLabel = document.createElement("label");
  shadedColorLabel.textContent = "Shaded Color:";
  shadedColorLabel.style.width = "120px";
  shadedColorRow.appendChild(shadedColorLabel);
  
  const shadedColorInput = document.createElement("input");
  shadedColorInput.type = "color";
  shadedColorInput.id = "rect-shaded-color";
  shadedColorInput.value = container.getAttribute("data-shaded-color") || "#ff0000";
  shadedColorRow.appendChild(shadedColorInput);
  
  modal.appendChild(shadedColorRow);
  
  // Unshaded color row
  const unshadedColorRow = document.createElement("div");
  unshadedColorRow.style.display = "flex";
  unshadedColorRow.style.alignItems = "center";
  unshadedColorRow.style.marginBottom = "20px";
  
  const unshadedColorLabel = document.createElement("label");
  unshadedColorLabel.textContent = "Unshaded Color:";
  unshadedColorLabel.style.width = "120px";
  unshadedColorRow.appendChild(unshadedColorLabel);
  
  const unshadedColorInput = document.createElement("input");
  unshadedColorInput.type = "color";
  unshadedColorInput.id = "rect-unshaded-color";
  unshadedColorInput.value = container.getAttribute("data-unshaded-color") || "#ffffff";
  unshadedColorRow.appendChild(unshadedColorInput);
  
  modal.appendChild(unshadedColorRow);
  
  // Variable substitution note with improved styling
  const variableNote = document.createElement("div");
  variableNote.style.backgroundColor = "#f8f9fa";
  variableNote.style.border = "1px solid #ddd";
  variableNote.style.borderRadius = "4px";
  variableNote.style.padding = "10px";
  variableNote.style.marginBottom = "15px";
  
  const variableTitle = document.createElement("div");
  variableTitle.style.fontWeight = "bold";
  variableTitle.style.marginBottom = "5px";
  variableTitle.textContent = "Variable Substitution";
  variableNote.appendChild(variableTitle);
  
  const variableText = document.createElement("div");
  variableText.style.fontSize = "12px";
  variableText.innerHTML = `
    You can use variables in numeric fields:<br>
    • <code>#a#</code>, <code>#b#</code>, <code>#c#</code>, etc. for substitution<br>
    • Example: Type <code>#a#</code> for total sections to use variable 'a'<br>
    • Variables are computed during preview generation
  `;
  variableNote.appendChild(variableText);
  
  modal.appendChild(variableNote);
  
  // Buttons row
  const buttonsRow = document.createElement("div");
  buttonsRow.style.display = "flex";
  buttonsRow.style.justifyContent = "flex-end";
  
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.padding = "8px 15px";
  cancelBtn.style.marginRight = "10px";
  buttonsRow.appendChild(cancelBtn);
  
  const okBtn = document.createElement("button");
  okBtn.textContent = "OK";
  okBtn.style.padding = "8px 15px";
  buttonsRow.appendChild(okBtn);
  
  modal.appendChild(buttonsRow);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // Handle actions
  function cleanup() {
    document.body.removeChild(overlay);
  }
  
  okBtn.addEventListener("click", () => {
    // Save settings to container
    const totalSections = document.getElementById("rect-total-sections").value;
    const shadedSections = document.getElementById("rect-shaded-sections").value;
    const shadedColor = document.getElementById("rect-shaded-color").value;
    const unshadedColor = document.getElementById("rect-unshaded-color").value;
    
    container.setAttribute("data-total-sections", totalSections);
    container.setAttribute("data-shaded-sections", shadedSections);
    container.setAttribute("data-shaded-color", shadedColor);
    container.setAttribute("data-unshaded-color", unshadedColor);
    
    // Check if we should immediately compute values or use variables
    if (!totalSections.includes('#') && !shadedSections.includes('#')) {
      // No variables - apply directly
      const sections = parseInt(totalSections);
      if (!isNaN(sections) && sections > 0) {
        container.dataset.sections = sections.toString();
        
        // Generate section fills array
        const shaded = parseInt(shadedSections);
        if (!isNaN(shaded) && shaded > 0 && shaded <= sections) {
          let sectionFills = new Array(sections).fill(unshadedColor);
          
          // Randomly shade the specified number of sections
          const indices = [];
          for (let i = 0; i < sections; i++) {
            indices.push(i);
          }
          
          // Shuffle array to get random indices
          for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
          }
          
          // Shade the first 'shaded' sections in the shuffled array
          for (let i = 0; i < shaded; i++) {
            sectionFills[indices[i]] = shadedColor;
          }
          
          container.dataset.sectionFills = JSON.stringify(sectionFills);
        }
      }
    }
    
    // Update the rectangle display
    if (window.updateRectangle) {
      window.updateRectangle(container);
    }
    
    cleanup();
  });
  
  cancelBtn.addEventListener("click", cleanup);
  
  // Close when clicking overlay
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) cleanup();
  });
}

// Function to show shade modal for multiple sections
function showShadeModal(sections, currentFills, callback) {
  // Create modal overlay
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  overlay.style.zIndex = "10000";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  
  // Create modal window
  const modal = document.createElement("div");
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "5px";
  modal.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
  modal.style.width = "420px"; // Wider to accommodate color history
  modal.style.maxHeight = "80vh";
  modal.style.overflowY = "auto";
  
  // Add title
  const title = document.createElement("h3");
  title.textContent = "Shade Sections";
  title.style.marginTop = "0";
  title.style.marginBottom = "15px";
  modal.appendChild(title);
  
  // Add color history panel
  const historyPanel = document.createElement("div");
  historyPanel.style.marginBottom = "15px";
  historyPanel.style.padding = "10px";
  historyPanel.style.backgroundColor = "#f5f5f5";
  historyPanel.style.borderRadius = "4px";
  
  const historyTitle = document.createElement("div");
  historyTitle.textContent = "Color History:";
  historyTitle.style.marginBottom = "8px";
  historyTitle.style.fontWeight = "bold";
  historyPanel.appendChild(historyTitle);
  
  const historyColors = document.createElement("div");
  historyColors.style.display = "flex";
  historyColors.style.flexWrap = "wrap";
  historyColors.style.gap = "6px";
  
  // Track color selections and build history
  const colorSet = new Set();
  
  // Add transparent option in history
  const transparentBox = document.createElement("div");
  transparentBox.style.width = "24px";
  transparentBox.style.height = "24px";
  transparentBox.style.border = "1px solid #ccc";
  transparentBox.style.cursor = "pointer";
  transparentBox.style.backgroundColor = "#ffffff";
  transparentBox.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
  transparentBox.style.backgroundSize = "12px 12px";
  transparentBox.style.backgroundPosition = "0 0, 6px 6px";
  transparentBox.title = "Transparent";
  transparentBox.setAttribute("data-color", "transparent");
  historyColors.appendChild(transparentBox);
  
  // Add existing colors to history
  for (const fill of currentFills) {
    if (fill !== "transparent" && !colorSet.has(fill)) {
      colorSet.add(fill);
      
      const colorBox = document.createElement("div");
      colorBox.style.width = "24px";
      colorBox.style.height = "24px";
      colorBox.style.backgroundColor = fill;
      colorBox.style.border = "1px solid #ccc";
      colorBox.style.cursor = "pointer";
      colorBox.title = fill;
      colorBox.setAttribute("data-color", fill);
      historyColors.appendChild(colorBox);
    }
  }
  
  historyPanel.appendChild(historyColors);
  modal.appendChild(historyPanel);
  
  // Section color selectors
  const colorSelectors = [];
  for (let i = 0; i < sections; i++) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "10px";
    
    const label = document.createElement("label");
    label.textContent = `Section ${i + 1}:`;
    label.style.width = "80px";
    row.appendChild(label);
    
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = currentFills[i] === "transparent" ? "#ffffff" : currentFills[i];
    colorInput.style.marginRight = "10px";
    colorInput.dataset.index = i;
    colorInput.addEventListener("change", function() {
      // Add to color history if new
      if (!colorSet.has(this.value)) {
        colorSet.add(this.value);
        
        const colorBox = document.createElement("div");
        colorBox.style.width = "24px";
        colorBox.style.height = "24px";
        colorBox.style.backgroundColor = this.value;
        colorBox.style.border = "1px solid #ccc";
        colorBox.style.cursor = "pointer";
        colorBox.title = this.value;
        colorBox.setAttribute("data-color", this.value);
        colorBox.className = "history-color";
        
        historyColors.appendChild(colorBox);
        
        // Add click handler for the new color
        setupHistoryColorHandlers(colorBox);
      }
    });
    row.appendChild(colorInput);
    
    const transparentBtn = document.createElement("button");
    transparentBtn.textContent = "None";
    transparentBtn.className = "transparent-btn";
    transparentBtn.style.padding = "2px 5px";
    transparentBtn.style.fontSize = "12px";
    transparentBtn.dataset.index = i;
    transparentBtn.addEventListener("click", (e) => {
      e.preventDefault();
      const index = parseInt(e.target.dataset.index);
      colorSelectors[index].isTransparent = true;
      e.target.style.backgroundColor = "#ddd";
      e.target.style.color = "#000";
      e.target.nextElementSibling.style.backgroundColor = "";
      e.target.nextElementSibling.style.color = "";
    });
    
    if (currentFills[i] === "transparent") {
      transparentBtn.style.backgroundColor = "#ddd";
      transparentBtn.style.color = "#000";
    }
    
    row.appendChild(transparentBtn);
    
    const filledBtn = document.createElement("button");
    filledBtn.textContent = "Color";
    filledBtn.className = "filled-btn";
    filledBtn.style.padding = "2px 5px";
    filledBtn.style.fontSize = "12px";
    filledBtn.style.marginLeft = "5px";
    filledBtn.dataset.index = i;
    filledBtn.addEventListener("click", (e) => {
      e.preventDefault();
      const index = parseInt(e.target.dataset.index);
      colorSelectors[index].isTransparent = false;
      e.target.style.backgroundColor = "#ddd";
      e.target.style.color = "#000";
      e.target.previousElementSibling.style.backgroundColor = "";
      e.target.previousElementSibling.style.color = "";
    });
    
    if (currentFills[i] !== "transparent") {
      filledBtn.style.backgroundColor = "#ddd";
      filledBtn.style.color = "#000";
    }
    
    row.appendChild(filledBtn);
    
    // Add section indicator for the row
    const sectionIndicator = document.createElement("div");
    sectionIndicator.style.width = "18px";
    sectionIndicator.style.height = "18px";
    sectionIndicator.style.marginLeft = "10px";
    sectionIndicator.style.border = "1px solid #ccc";
    sectionIndicator.style.backgroundColor = currentFills[i] === "transparent" ? "transparent" : currentFills[i];
    if (currentFills[i] === "transparent") {
      sectionIndicator.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
      sectionIndicator.style.backgroundSize = "9px 9px";
      sectionIndicator.style.backgroundPosition = "0 0, 4px 4px";
    }
    sectionIndicator.dataset.index = i;
    row.appendChild(sectionIndicator);
    
    modal.appendChild(row);
    
    colorSelectors.push({
      input: colorInput,
      isTransparent: currentFills[i] === "transparent",
      indicator: sectionIndicator,
      index: i
    });
  }
  
  // Function to set up history color click handlers
  function setupHistoryColorHandlers(colorBox) {
    colorBox.addEventListener("click", function() {
      // Find which section is currently being edited
      const activeSection = document.activeElement;
      let targetIndex = -1;
      
      if (activeSection && activeSection.dataset && activeSection.dataset.index) {
        targetIndex = parseInt(activeSection.dataset.index);
      }
      
      // Default to the currently hovered/highlighted row if no active element
      if (targetIndex === -1 && hoveredSection !== null) {
        targetIndex = hoveredSection;
      }
      
      // If we still don't have a target, show a selection modal
      if (targetIndex === -1) {
        showSectionSelectModal(this.getAttribute("data-color"));
        return;
      }
      
      // Apply the color to the target section
      applyColorToSection(targetIndex, this.getAttribute("data-color"));
    });
  }
  
  // Track which section row is being hovered
  let hoveredSection = null;
  
  // Add hover effect to rows to indicate which section will receive the color
  colorSelectors.forEach((selector, index) => {
    const row = selector.input.parentElement;
    
    row.addEventListener("mouseenter", () => {
      hoveredSection = index;
      row.style.backgroundColor = "#f0f0f0";
    });
    
    row.addEventListener("mouseleave", () => {
      hoveredSection = null;
      row.style.backgroundColor = "";
    });
  });
  
  // Apply color to a specific section
  function applyColorToSection(sectionIndex, color) {
    if (sectionIndex >= 0 && sectionIndex < colorSelectors.length) {
      const selector = colorSelectors[sectionIndex];
      
      if (color === "transparent") {
        selector.isTransparent = true;
        const row = selector.input.parentElement;
        const transparentBtn = row.querySelector(".transparent-btn");
        const filledBtn = row.querySelector(".filled-btn");
        
        transparentBtn.style.backgroundColor = "#ddd";
        transparentBtn.style.color = "#000";
        filledBtn.style.backgroundColor = "";
        filledBtn.style.color = "";
        
        // Update the indicator
        selector.indicator.style.backgroundColor = "transparent";
        selector.indicator.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
        selector.indicator.style.backgroundSize = "9px 9px";
        selector.indicator.style.backgroundPosition = "0 0, 4px 4px";
      } else {
        selector.isTransparent = false;
        selector.input.value = color;
        
        const row = selector.input.parentElement;
        const transparentBtn = row.querySelector(".transparent-btn");
        const filledBtn = row.querySelector(".filled-btn");
        
        filledBtn.style.backgroundColor = "#ddd";
        filledBtn.style.color = "#000";
        transparentBtn.style.backgroundColor = "";
        transparentBtn.style.color = "";
        
        // Update the indicator
        selector.indicator.style.backgroundColor = color;
        selector.indicator.style.backgroundImage = "none";
      }
    }
  }
  
  // Show a modal to select which section to apply the color to
  function showSectionSelectModal(color) {
    const selectOverlay = document.createElement("div");
    selectOverlay.style.position = "fixed";
    selectOverlay.style.top = "0";
    selectOverlay.style.left = "0";
    selectOverlay.style.width = "100%";
    selectOverlay.style.height = "100%";
    selectOverlay.style.backgroundColor = "rgba(0,0,0,0.5)";
    selectOverlay.style.zIndex = "10001";
    selectOverlay.style.display = "flex";
    selectOverlay.style.justifyContent = "center";
    selectOverlay.style.alignItems = "center";
    
    const selectModal = document.createElement("div");
    selectModal.style.background = "#fff";
    selectModal.style.padding = "15px";
    selectModal.style.borderRadius = "5px";
    selectModal.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    selectModal.style.width = "300px";
    
    const selectTitle = document.createElement("h4");
    selectTitle.textContent = "Select Section";
    selectTitle.style.marginTop = "0";
    selectTitle.style.marginBottom = "10px";
    selectModal.appendChild(selectTitle);
    
    const colorPreview = document.createElement("div");
    colorPreview.style.display = "flex";
    colorPreview.style.alignItems = "center";
    colorPreview.style.marginBottom = "15px";
    colorPreview.innerHTML = `<span style="margin-right: 10px;">Selected Color:</span>`;
    
    const colorBox = document.createElement("div");
    colorBox.style.width = "20px";
    colorBox.style.height = "20px";
    
    if (color === "transparent") {
      colorBox.style.backgroundColor = "transparent";
      colorBox.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
      colorBox.style.backgroundSize = "10px 10px";
      colorBox.style.backgroundPosition = "0 0, 5px 5px";
    } else {
      colorBox.style.backgroundColor = color;
    }
    colorBox.style.border = "1px solid #ccc";
    colorPreview.appendChild(colorBox);
    selectModal.appendChild(colorPreview);
    
    const sectionList = document.createElement("div");
    sectionList.style.maxHeight = "200px";
    sectionList.style.overflowY = "auto";
    
    for (let i = 0; i < sections; i++) {
      const sectionBtn = document.createElement("button");
      sectionBtn.textContent = `Section ${i + 1}`;
      sectionBtn.style.display = "block";
      sectionBtn.style.width = "100%";
      sectionBtn.style.marginBottom = "5px";
      sectionBtn.style.padding = "8px";
      sectionBtn.style.textAlign = "left";
      sectionBtn.style.cursor = "pointer";
      sectionBtn.addEventListener("click", function() {
        applyColorToSection(i, color);
        document.body.removeChild(selectOverlay);
      });
      sectionList.appendChild(sectionBtn);
    }
    
    selectModal.appendChild(sectionList);
    
    const cancelSectionBtn = document.createElement("button");
    cancelSectionBtn.textContent = "Cancel";
    cancelSectionBtn.style.marginTop = "15px";
    cancelSectionBtn.style.padding = "5px 10px";
    cancelSectionBtn.addEventListener("click", function() {
      document.body.removeChild(selectOverlay);
    });
    selectModal.appendChild(cancelSectionBtn);
    
    selectOverlay.appendChild(selectModal);
    document.body.appendChild(selectOverlay);
    
    // Close when clicking overlay
    selectOverlay.addEventListener("click", (e) => {
      if (e.target === selectOverlay) document.body.removeChild(selectOverlay);
    });
  }
  
  // Set up handlers for initial history colors
  historyColors.querySelectorAll("div").forEach(colorBox => {
    setupHistoryColorHandlers(colorBox);
  });
  
  // Buttons row
  const buttonsRow = document.createElement("div");
  buttonsRow.style.display = "flex";
  buttonsRow.style.justifyContent = "flex-end";
  buttonsRow.style.marginTop = "15px";
  
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.padding = "5px 15px";
  cancelBtn.style.marginRight = "10px";
  buttonsRow.appendChild(cancelBtn);
  
  const okBtn = document.createElement("button");
  okBtn.textContent = "OK";
  okBtn.style.padding = "5px 15px";
  buttonsRow.appendChild(okBtn);
  
  modal.appendChild(buttonsRow);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // Handle actions
  function cleanup() {
    document.body.removeChild(overlay);
  }
  
  okBtn.addEventListener("click", () => {
    // Create new fills array
    const newFills = colorSelectors.map(selector => 
      selector.isTransparent ? "transparent" : selector.input.value
    );
    
    if (callback) {
      callback(newFills);
    }
    
    cleanup();
  });
  
  cancelBtn.addEventListener("click", cleanup);
  
  // Close when clicking overlay
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) cleanup();
  });
}

function generateRectangleSVG(totalSections, shadedSections, shadedColor, unshadedColor, width, height, sectionFills) {
  console.log("Generating rectangle SVG with:", { totalSections, shadedSections, shadedColor, unshadedColor, width, height });
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  
  // Add padding for better visuals
  const padding = 10;
  const rectWidth = width - (padding * 2);
  const rectHeight = height - (padding * 2);
  
  // Main rectangle background
  const background = document.createElementNS(svgNS, "rect");
  background.setAttribute("x", padding);
  background.setAttribute("y", padding);
  background.setAttribute("width", rectWidth);
  background.setAttribute("height", rectHeight);
  background.setAttribute("fill", unshadedColor || "#ffffff");
  background.setAttribute("stroke", "#000000");
  background.setAttribute("stroke-width", "2");
  svg.appendChild(background);
  console.log("Added background rectangle");

  // Handle sections
  const numSections = parseInt(totalSections);
  const numShaded = Math.min(Math.max(Math.round(shadedSections), 0), numSections);
  
  if (numSections > 0) {
    // Determine layout based on whether sections is even or odd
    const isEven = numSections % 2 === 0;
    const cols = isEven ? 2 : 1;
    const rows = isEven ? numSections / 2 : numSections;
    
    // Calculate cell dimensions
    const cellWidth = rectWidth / cols;
    const cellHeight = rectHeight / rows;
    
    // Create all section cells
    const sectionElements = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const sectionIndex = isEven ? (row * cols + col) : row;
        if (sectionIndex >= numSections) continue;
        
        const sectionX = padding + (col * cellWidth);
        const sectionY = padding + (row * cellHeight);
        
        const section = document.createElementNS(svgNS, "rect");
        section.setAttribute("x", sectionX);
        section.setAttribute("y", sectionY);
        section.setAttribute("width", cellWidth);
        section.setAttribute("height", cellHeight);
        section.setAttribute("fill", "transparent");
        section.setAttribute("stroke", "#000000");
        section.setAttribute("stroke-width", "1");
        section.setAttribute("data-section-index", sectionIndex);
        
        sectionElements.push({
          element: section,
          index: sectionIndex
        });
        
        svg.appendChild(section);
      }
    }
    
    // Determine which sections to shade
    let shadedIndices = [];
    if (numShaded > 0) {
      // If custom section fills are provided, use those
      if (Array.isArray(sectionFills) && sectionFills.length >= numSections) {
        for (let i = 0; i < numSections; i++) {
          if (sectionFills[i] && sectionFills[i] !== "transparent") {
            shadedIndices.push(i);
          }
        }
      } else {
        // Otherwise, randomly select sections to shade
        const allIndices = Array.from({ length: numSections }, (_, i) => i);
        
        // Shuffle array to get random indices
        for (let i = allIndices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];
        }
        
        // Take the first numShaded indices
        shadedIndices = allIndices.slice(0, numShaded);
      }
      
      // Apply shading to selected sections
      for (const sectionObj of sectionElements) {
        if (shadedIndices.includes(sectionObj.index)) {
          const fillColor = Array.isArray(sectionFills) && sectionFills[sectionObj.index] !== "transparent" 
            ? sectionFills[sectionObj.index] 
            : shadedColor;
          sectionObj.element.setAttribute("fill", fillColor);
        }
      }
    }
  }
  
  // Add outline to ensure the rectangle border is visible
  const outline = document.createElementNS(svgNS, "rect");
  outline.setAttribute("x", padding);
  outline.setAttribute("y", padding);
  outline.setAttribute("width", rectWidth);
  outline.setAttribute("height", rectHeight);
  outline.setAttribute("fill", "none");
  outline.setAttribute("stroke", "#000000");
  outline.setAttribute("stroke-width", "2");
  svg.appendChild(outline);
  
  const svgString = svg.outerHTML;
  console.log("Final Rectangle SVG:", svgString);
  return svgString;
}

function addPieChart() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activePieElement) {
    window.activePieElement = null;
  }
  // Global counter for pie chart IDs
  if (!window.globalPieCounter) {
    window.globalPieCounter = 1;
  } else {
    window.globalPieCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element pie-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "500px";
  container.style.height = (toolbarHeight + 400) + "px";
  container.style.cursor = "pointer";
  container.style.backgroundColor = "#ffffff";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this pie chart
  container.pieID = window.globalPieCounter;
  // give this pie a unique ID so we can find it in the original canvas
  container.dataset.pieId = window.nextPieId++;

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "pie-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "pie-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  content.style.display = "flex";
  content.style.flexDirection = "column"; // Stack chart and legend vertically
  container.appendChild(content);

  // Create the chart container
  const chartContainer = document.createElement("div");
  chartContainer.style.flex = "1"; // Take up available space
  chartContainer.style.display = "flex";
  chartContainer.style.justifyContent = "center";
  chartContainer.style.alignItems = "center";
  content.appendChild(chartContainer);

  // Create the chart canvas
  const pieChartCanvas = document.createElement("canvas");
  pieChartCanvas.id = "pieChart-" + container.pieID;
  pieChartCanvas.width = 500;
  pieChartCanvas.height = 400;
  pieChartCanvas.style.width = "100%";
  pieChartCanvas.style.height = "100%";
  chartContainer.appendChild(pieChartCanvas);

  // Create legend div (hidden by default)
  const chartLegend = document.createElement("div");
  chartLegend.id = "chartLegend-" + container.pieID;
  chartLegend.className = "legend";
  chartLegend.style.display = "none";
  chartLegend.style.alignSelf = "center"; // Center the legend
  chartLegend.style.marginTop = "10px";
  chartLegend.style.marginBottom = "10px";
  content.appendChild(chartLegend);

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Store chart data
  container.chartData = {
    categories: [
      { name: "Category 1", value: 50, color: "#ff0000" },
      { name: "Category 2", value: 30, color: "#1f77b4" },
      { name: "Category 3", value: 20, color: "#2ca02c" }
    ],
    
    title: "Pie Chart",
    displayFormat: "percentInPie",
    showLegend: false,
    colorMode: "color",
    fontSettings: {
      titleFont: "Arial",
      titleFontSize: 20,
      titleFontColor: "#000000",
      labelFont: "Arial",
      labelFontSize: 16,
      labelFontColor: "#FFFFFF"
    },
    inputType: "percentage",
    roundingType: "whole"
  };

  // Key functions
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;

    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Pie Chart " + container.pieID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    controls.appendChild(identityLabel);

    // Adjust Font button
    const fontButton = document.createElement("button");
    fontButton.textContent = "Adjust Font";
    fontButton.style.fontSize = "12px";
    fontButton.style.padding = "2px 8px";
    fontButton.style.marginRight = "10px";
    fontButton.addEventListener("click", showFontDialog);
    controls.appendChild(fontButton);

    // Graph Settings button
    const settingsButton = document.createElement("button");
    settingsButton.textContent = "Graph Settings";
    settingsButton.style.fontSize = "12px";
    settingsButton.style.padding = "2px 8px";
    settingsButton.style.marginRight = "10px";
    settingsButton.addEventListener("click", showGraphSettingsDialog);
    controls.appendChild(settingsButton);

    // Edit Categories button
    const categoriesButton = document.createElement("button");
    categoriesButton.textContent = "Edit Categories";
    categoriesButton.style.fontSize = "12px";
    categoriesButton.style.padding = "2px 8px";
    categoriesButton.addEventListener("click", showCategoriesDialog);
    controls.appendChild(categoriesButton);

    globalToolbar.appendChild(controls);
  }

  function drawPieChart() {
    const { categories, title, displayFormat, showLegend, fontSettings, colorMode } = container.chartData;
    const canvas = pieChartCanvas;
    const ctx = canvas.getContext('2d');
    const legend = chartLegend;
    
    // Colors for grayscale mode
    const matplotlibColors = [
      '#ff0000','#1f77b4','#2ca02c','#ff7f0e','#9467bd',
      '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'
    ];
    const grayscaleShades = [
      '#000000','#333333','#666666','#999999','#cccccc',
      '#1a1a1a','#4d4d4d','#808080','#b3b3b3','#e6e6e6'
    ];
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const r = Math.min(cx, cy) * 0.7; // Slightly smaller radius to fit legend
    
    const computedVars = computeAllVariables(); 
    const total = categories.reduce((sum, cat) => sum + parseFloat(cat.value), 0);
    
    // Draw title
    ctx.font = `bold ${fontSettings.titleFontSize}px ${fontSettings.titleFont}`;
    ctx.fillStyle = fontSettings.titleFontColor;
    ctx.textAlign = 'center';
    ctx.fillText(title, cx, 30);
    
    // Set up legend
 
    
    // Draw pie slices
    let angle = -Math.PI / 2;
    
    categories.forEach((cat, i) => {
      const value = parseFloat(cat.value);
      const arcAngle = value / total * 2 * Math.PI;
      
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, r, angle, angle + arcAngle);
      ctx.closePath();
      
      const fillColor = (colorMode === 'grayscale') 
        ? grayscaleShades[i % grayscaleShades.length] 
        : cat.color || matplotlibColors[i % matplotlibColors.length];
      
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.lineWidth   = 2     // or hard-code 2 if you like
      ctx.strokeStyle = container.chartData.lineColor;
      
      ctx.stroke();
      
      // Add labels
      const midAngle = angle + arcAngle / 2;
      const tx = cx + Math.cos(midAngle) * r * 0.6;
      const ty = cy + Math.sin(midAngle) * r * 0.6;
      
      ctx.font = `bold ${fontSettings.labelFontSize}px ${fontSettings.labelFont}`;
      ctx.fillStyle = fontSettings.labelFontColor;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (displayFormat === 'percentInPie') {
        ctx.fillText(cat.value + '%', tx, ty);
      } else if (displayFormat === 'nameInPie') {
        ctx.fillText(cat.name, tx, ty);
      } else {
        const lineSpacing = parseInt(fontSettings.labelFontSize) * 1.2;
        ctx.fillText(cat.name, tx, ty - lineSpacing / 2);
        ctx.fillText(cat.value + '%', tx, ty + lineSpacing / 2);
      }
      
      // Add to legend if enabled
 
      
      angle += arcAngle;
    });
  }

  function showFontDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "500px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Font Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Title font settings
    const titleSection = document.createElement("div");
    titleSection.style.marginBottom = "20px";
    
    const titleHeader = document.createElement("h4");
    titleHeader.textContent = "Title Font";
    titleHeader.style.marginBottom = "10px";
    titleSection.appendChild(titleHeader);
    
    const titleFontRow = document.createElement("div");
    titleFontRow.style.display = "flex";
    titleFontRow.style.gap = "15px";
    titleFontRow.style.marginBottom = "10px";
    
    // Title font family
    const titleFontGroup = document.createElement("div");
    titleFontGroup.style.flex = "1";
    
    const titleFontLabel = document.createElement("label");
    titleFontLabel.textContent = "Font:";
    titleFontLabel.style.display = "block";
    titleFontLabel.style.marginBottom = "5px";
    titleFontGroup.appendChild(titleFontLabel);
    
    const titleFontSelect = document.createElement("select");
    titleFontSelect.style.width = "100%";
    titleFontSelect.style.padding = "5px";
    const fontOptions = ["Arial", "Times New Roman", "Courier New", "Georgia", "Verdana", "Helvetica", "Tahoma", "Trebuchet MS"];
    
    fontOptions.forEach(font => {
      const option = document.createElement("option");
      option.value = font;
      option.textContent = font;
      if (font === container.chartData.fontSettings.titleFont) {
        option.selected = true;
      }
      titleFontSelect.appendChild(option);
    });
    
    titleFontGroup.appendChild(titleFontSelect);
    titleFontRow.appendChild(titleFontGroup);
    
    // Title font size
    const titleSizeGroup = document.createElement("div");
    titleSizeGroup.style.width = "80px";
    
    const titleSizeLabel = document.createElement("label");
    titleSizeLabel.textContent = "Size:";
    titleSizeLabel.style.display = "block";
    titleSizeLabel.style.marginBottom = "5px";
    titleSizeGroup.appendChild(titleSizeLabel);
    
    const titleSizeInput = document.createElement("input");
    titleSizeInput.type = "number";
    titleSizeInput.min = "10";
    titleSizeInput.max = "48";
    titleSizeInput.style.width = "100%";
    titleSizeInput.style.padding = "5px";
    titleSizeInput.value = container.chartData.fontSettings.titleFontSize;
    titleSizeGroup.appendChild(titleSizeInput);
    
    titleFontRow.appendChild(titleSizeGroup);
    
    // Title font color
    const titleColorGroup = document.createElement("div");
    titleColorGroup.style.width = "120px";
    
    const titleColorLabel = document.createElement("label");
    titleColorLabel.textContent = "Color:";
    titleColorLabel.style.display = "block";
    titleColorLabel.style.marginBottom = "5px";
    titleColorGroup.appendChild(titleColorLabel);
    
    const titleColorInput = document.createElement("input");
    titleColorInput.type = "color";
    titleColorInput.style.width = "100%";
    titleColorInput.style.padding = "2px";
    titleColorInput.value = container.chartData.fontSettings.titleFontColor;
    titleColorGroup.appendChild(titleColorInput);
    
    titleFontRow.appendChild(titleColorGroup);
    titleSection.appendChild(titleFontRow);
    
    dialogBox.appendChild(titleSection);
    
    // Label font settings
    const labelSection = document.createElement("div");
    
    const labelHeader = document.createElement("h4");
    labelHeader.textContent = "Slice Label Font";
    labelHeader.style.marginBottom = "10px";
    labelSection.appendChild(labelHeader);
    
    const labelFontRow = document.createElement("div");
    labelFontRow.style.display = "flex";
    labelFontRow.style.gap = "15px";
    labelFontRow.style.marginBottom = "10px";
    
    // Label font family
    const labelFontGroup = document.createElement("div");
    labelFontGroup.style.flex = "1";
    
    const labelFontLabel = document.createElement("label");
    labelFontLabel.textContent = "Font:";
    labelFontLabel.style.display = "block";
    labelFontLabel.style.marginBottom = "5px";
    labelFontGroup.appendChild(labelFontLabel);
    
    const labelFontSelect = document.createElement("select");
    labelFontSelect.style.width = "100%";
    labelFontSelect.style.padding = "5px";
    
    fontOptions.forEach(font => {
      const option = document.createElement("option");
      option.value = font;
      option.textContent = font;
      if (font === container.chartData.fontSettings.labelFont) {
        option.selected = true;
      }
      labelFontSelect.appendChild(option);
    });
    
    labelFontGroup.appendChild(labelFontSelect);
    labelFontRow.appendChild(labelFontGroup);
    
    // Label font size
    const labelSizeGroup = document.createElement("div");
    labelSizeGroup.style.width = "80px";
    
    const labelSizeLabel = document.createElement("label");
    labelSizeLabel.textContent = "Size:";
    labelSizeLabel.style.display = "block";
    labelSizeLabel.style.marginBottom = "5px";
    labelSizeGroup.appendChild(labelSizeLabel);
    
    const labelSizeInput = document.createElement("input");
    labelSizeInput.type = "number";
    labelSizeInput.min = "8";
    labelSizeInput.max = "36";
    labelSizeInput.style.width = "100%";
    labelSizeInput.style.padding = "5px";
    labelSizeInput.value = container.chartData.fontSettings.labelFontSize;
    labelSizeGroup.appendChild(labelSizeInput);
    
    labelFontRow.appendChild(labelSizeGroup);
    
    // Label font color
    const labelColorGroup = document.createElement("div");
    labelColorGroup.style.width = "120px";
    
    const labelColorLabel = document.createElement("label");
    labelColorLabel.textContent = "Color:";
    labelColorLabel.style.display = "block";
    labelColorLabel.style.marginBottom = "5px";
    labelColorGroup.appendChild(labelColorLabel);
    
    const labelColorInput = document.createElement("input");
    labelColorInput.type = "color";
    labelColorInput.style.width = "100%";
    labelColorInput.style.padding = "2px";
    labelColorInput.value = container.chartData.fontSettings.labelFontColor;
    labelColorGroup.appendChild(labelColorInput);
    
    labelFontRow.appendChild(labelColorGroup);
    labelSection.appendChild(labelFontRow);
    
    dialogBox.appendChild(labelSection);
    
    // Buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    buttonsContainer.style.gap = "10px";
    
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.padding = "8px 16px";
    cancelButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    buttonsContainer.appendChild(cancelButton);
    
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.padding = "8px 16px";
    applyButton.style.backgroundColor = "#4CAF50";
    applyButton.style.color = "white";
    applyButton.style.border = "none";
    applyButton.addEventListener("click", function() {
      // Update font settings
      container.chartData.fontSettings.titleFont = titleFontSelect.value;
      container.chartData.fontSettings.titleFontSize = parseInt(titleSizeInput.value);
      container.chartData.fontSettings.titleFontColor = titleColorInput.value;
      container.chartData.fontSettings.labelFont = labelFontSelect.value;
      container.chartData.fontSettings.labelFontSize = parseInt(labelSizeInput.value);
      container.chartData.fontSettings.labelFontColor = labelColorInput.value;
      
      // Redraw the chart
      drawPieChart();
      
      // Close dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonsContainer.appendChild(applyButton);
    
    dialogBox.appendChild(buttonsContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  function showGraphSettingsDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "400px";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Graph Settings";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Chart title
    const titleGroup = document.createElement("div");
    titleGroup.style.marginBottom = "15px";
    
    const titleLabel = document.createElement("label");
    titleLabel.textContent = "Chart Title:";
    titleLabel.style.display = "block";
    titleLabel.style.marginBottom = "5px";
    titleGroup.appendChild(titleLabel);
    
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.style.width = "100%";
    titleInput.style.padding = "8px";
    titleInput.style.boxSizing = "border-box";
    titleInput.value = container.chartData.title;
    titleGroup.appendChild(titleInput);
    
    dialogBox.appendChild(titleGroup);
    
    // Input type
   
    
    // Rounding type
    const roundingGroup = document.createElement("div");
    roundingGroup.style.marginBottom = "15px";
    
    const roundingLabel = document.createElement("label");
    roundingLabel.textContent = "Rounding:";
    roundingLabel.style.display = "block";
    roundingLabel.style.marginBottom = "5px";
    roundingGroup.appendChild(roundingLabel);
    
    const roundingSelect = document.createElement("select");
    roundingSelect.style.width = "100%";
    roundingSelect.style.padding = "8px";
    
    const roundingOptions = [
      { value: "whole", text: "Whole Number" },
      { value: "tenth", text: "One Decimal Place" }
    ];
    
    roundingOptions.forEach(option => {
      const optionElement = document.createElement("option");
      optionElement.value = option.value;
      optionElement.textContent = option.text;
      if (option.value === container.chartData.roundingType) {
        optionElement.selected = true;
      }
      roundingSelect.appendChild(optionElement);
    });
    
    roundingGroup.appendChild(roundingSelect);
    dialogBox.appendChild(roundingGroup);
    
    // Display format
    const displayFormatGroup = document.createElement("div");
    displayFormatGroup.style.marginBottom = "15px";
    
    const displayFormatLabel = document.createElement("label");
    displayFormatLabel.textContent = "Display Format:";
    displayFormatLabel.style.display = "block";
    displayFormatLabel.style.marginBottom = "5px";
    displayFormatGroup.appendChild(displayFormatLabel);
    
    const displayFormatSelect = document.createElement("select");
    displayFormatSelect.style.width = "100%";
    displayFormatSelect.style.padding = "8px";
    
    const displayFormatOptions = [
      { value: "percentInPie", text: "Percent Inside Pie" },
      { value: "nameInPie", text: "Name Inside Pie" },
      { value: "nameAndPercentInPie", text: "Name & Percent Inside Pie" }
    ];
    
    displayFormatOptions.forEach(option => {
      const optionElement = document.createElement("option");
      optionElement.value = option.value;
      optionElement.textContent = option.text;
      if (option.value === container.chartData.displayFormat) {
        optionElement.selected = true;
      }
      displayFormatSelect.appendChild(optionElement);
    });
    
    displayFormatGroup.appendChild(displayFormatSelect);
    dialogBox.appendChild(displayFormatGroup);

    // ── Separator Line Color ──
    const lineColorGroup = document.createElement("div");
  lineColorGroup.style.marginBottom = "15px";

  const lineColorLabel = document.createElement("label");
  lineColorLabel.textContent = "Separator Line Color:";
  lineColorLabel.style.display = "block";
  lineColorLabel.style.marginBottom = "5px";
  lineColorGroup.appendChild(lineColorLabel);

  // **Here** we create the select *before* we ever reference it:
  const lineColorSelect = document.createElement("select");
  lineColorSelect.style.width = "100%";
  lineColorSelect.style.padding = "8px";

  [ { value: "#000000", text: "Black" },
  { value: "#ffffff", text: "White" }
 
].forEach(opt => {
  const o = document.createElement("option");
  o.value = opt.value;
  o.textContent = opt.text;
  // Remove the condition based on container.chartData.lineColor
  // Just set white (#ffffff) as selected
  if (opt.value === "#000000") o.selected = true;
  lineColorSelect.appendChild(o);
});

  lineColorGroup.appendChild(lineColorSelect);
  dialogBox.appendChild(lineColorGroup);
    
    // Color mode
    const colorModeGroup = document.createElement("div");
    colorModeGroup.style.marginBottom = "15px";
    
    const colorModeLabel = document.createElement("label");
    colorModeLabel.textContent = "Color Mode:";
    colorModeLabel.style.display = "block";
    colorModeLabel.style.marginBottom = "5px";
    colorModeGroup.appendChild(colorModeLabel);
    
    const colorModeSelect = document.createElement("select");
    colorModeSelect.style.width = "100%";
    colorModeSelect.style.padding = "8px";
    
    const colorModeOptions = [
      { value: "color", text: "Color" },
      { value: "grayscale", text: "Grayscale" }
    ];
    
    colorModeOptions.forEach(option => {
      const optionElement = document.createElement("option");
      optionElement.value = option.value;
      optionElement.textContent = option.text;
      if (option.value === container.chartData.colorMode) {
        optionElement.selected = true;
      }
      colorModeSelect.appendChild(optionElement);
    });
    
    colorModeGroup.appendChild(colorModeSelect);
    dialogBox.appendChild(colorModeGroup);
    
    // Show legend
    const showLegendGroup = document.createElement("div");
    showLegendGroup.style.marginBottom = "15px";
    
    const showLegendLabel = document.createElement("label");
    showLegendLabel.textContent = "Show Legend:";
    showLegendLabel.style.display = "block";
    showLegendLabel.style.marginBottom = "5px";
    showLegendGroup.appendChild(showLegendLabel);
    
    const showLegendSelect = document.createElement("select");
    showLegendSelect.style.width = "100%";
    showLegendSelect.style.padding = "8px";
    
    const showLegendOptions = [
      { value: "false", text: "No" },
      { value: "true", text: "Yes" }
    ];
    
   showLegendOptions.forEach(option => {
      const optionElement = document.createElement("option");
      optionElement.value = option.value;
      optionElement.textContent = option.text;
      if ((option.value === "true" && container.chartData.showLegend) || 
          (option.value === "false" && !container.chartData.showLegend)) {
        optionElement.selected = true;
      }
      showLegendSelect.appendChild(optionElement);
    });
    
    showLegendGroup.appendChild(showLegendSelect);
    dialogBox.appendChild(showLegendGroup);
    
    // Buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    buttonsContainer.style.gap = "10px";
    
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.padding = "8px 16px";
    cancelButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    buttonsContainer.appendChild(cancelButton);
    
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.padding = "8px 16px";
    applyButton.style.backgroundColor = "#4CAF50";
    applyButton.style.color = "white";
    applyButton.style.border = "none";
    applyButton.addEventListener("click", function() {
      // Update chart settings
      container.chartData.title = titleInput.value;
      // force percent-mode no matter what
container.chartData.inputType = "percentage";

      container.chartData.roundingType = roundingSelect.value;
      container.chartData.displayFormat = displayFormatSelect.value;
      container.chartData.colorMode = colorModeSelect.value;
      container.chartData.previewShowLegend = showLegendSelect.value === "true";
      
      // Update percentages if input type is total
      if (container.chartData.inputType === "total") {
        const total = container.chartData.categories.reduce((sum, cat) => sum + parseFloat(cat.value), 0);
        container.chartData.categories.forEach(cat => {
          cat.value = cat.value / total * 100;
        });
      }
      
      // Apply rounding
      container.chartData.categories.forEach(cat => {
        cat.value = container.chartData.roundingType === "whole" 
          ? Math.round(cat.value) 
          : Math.round(cat.value * 10) / 10;
      });
      
      // Update separator color
container.chartData.lineColor = lineColorSelect.value;

      // Redraw the chart
      drawPieChart();
      
      // Close dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonsContainer.appendChild(applyButton);
    
    dialogBox.appendChild(buttonsContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  function showCategoriesDialog() {
    const dialogBackdrop = document.createElement("div");
    dialogBackdrop.style.position = "fixed";
    dialogBackdrop.style.top = "0";
    dialogBackdrop.style.left = "0";
    dialogBackdrop.style.width = "100%";
    dialogBackdrop.style.height = "100%";
    dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    dialogBackdrop.style.zIndex = "1000";
    dialogBackdrop.style.display = "flex";
    dialogBackdrop.style.justifyContent = "center";
    dialogBackdrop.style.alignItems = "center";
    
    const dialogBox = document.createElement("div");
    dialogBox.style.backgroundColor = "white";
    dialogBox.style.padding = "20px";
    dialogBox.style.borderRadius = "5px";
    dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    dialogBox.style.width = "600px";
    dialogBox.style.maxHeight = "80vh";
    dialogBox.style.overflowY = "auto";
    
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = "Edit Categories";
    dialogTitle.style.marginTop = "0";
    dialogBox.appendChild(dialogTitle);
    
    // Categories container
    const categoriesContainer = document.createElement("div");
    categoriesContainer.style.marginBottom = "20px";
    
    // Error message area
    const errorMessage = document.createElement("div");
    errorMessage.style.color = "red";
    errorMessage.style.marginBottom = "10px";
    errorMessage.style.fontSize = "14px";
    dialogBox.appendChild(errorMessage);
    
    function showError(message) {
      errorMessage.textContent = message;
      setTimeout(() => {
        errorMessage.textContent = "";
      }, 3000);
    }
    
    // Add category button
    const addCategoryButton = document.createElement("button");
    addCategoryButton.textContent = "Add Category";
    addCategoryButton.style.padding = "8px 16px";
    addCategoryButton.style.backgroundColor = "#2196F3";
    addCategoryButton.style.color = "white";
    addCategoryButton.style.border = "none";
    addCategoryButton.style.marginBottom = "15px";
    addCategoryButton.addEventListener("click", function() {
      if (document.querySelectorAll('.category-row').length >= 20) {
        showError("Maximum of 20 categories allowed");
        return;
      }
      
      addCategoryRow();
    });
    
    dialogBox.appendChild(addCategoryButton);
    dialogBox.appendChild(categoriesContainer);
    
    // Color palettes
    const matplotlibColors = [
      '#ff0000','#1f77b4','#2ca02c','#ff7f0e','#9467bd',
      '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'
    ];
    
    // Add a category row
    function addCategoryRow(category) {
      const row = document.createElement("div");
      row.className = "category-row";
      row.style.display = "flex";
      row.style.gap = "10px";
      row.style.marginBottom = "10px";
      row.style.alignItems = "center";
      
      // Category name
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.className = "category-name";
      nameInput.placeholder = "Category Name";
      nameInput.style.flex = "1";
      nameInput.style.padding = "8px";
      if (category) {
        nameInput.value = category.name;
      }
      
      // Category value
      const valueInput = document.createElement("input");
      valueInput.type = "text"; // Changed to text to allow variables like #a#
      valueInput.className = "category-value";
      valueInput.placeholder = "Value";
      valueInput.style.width = "80px";
      valueInput.style.padding = "8px";
      if (category) {
        valueInput.value = category.value;
      }
      
      // Color picker container
      const colorContainer = document.createElement("div");
      colorContainer.className = "color-input-container";
      colorContainer.style.position = "relative";
      colorContainer.style.width = "50px";
      
      // Color input
      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.className = "category-color";
      colorInput.style.width = "50px";
      colorInput.style.height = "36px";
      colorInput.style.padding = "0";
      if (category) {
        colorInput.value = category.color;
      } else {
        const existingCount = document.querySelectorAll('.category-row').length;
        colorInput.value = matplotlibColors[existingCount % matplotlibColors.length];
      }
      
      // Remove button
      const removeButton = document.createElement("button");
      removeButton.className = "remove-btn";
      removeButton.textContent = "×";
      removeButton.style.backgroundColor = "#f44336";
      removeButton.style.color = "white";
      removeButton.style.border = "none";
      removeButton.style.borderRadius = "4px";
      removeButton.style.cursor = "pointer";
      removeButton.style.width = "30px";
      removeButton.style.height = "36px";
      removeButton.addEventListener("click", function() {
        if (document.querySelectorAll('.category-row').length > 1) {
          row.remove();
        } else {
          showError("You must have at least one category");
        }
      });
      
      // Add elements to row
      row.appendChild(nameInput);
      row.appendChild(valueInput);
      
      colorContainer.appendChild(colorInput);
      row.appendChild(colorContainer);
      
      row.appendChild(removeButton);
      
      // Add row to container
      categoriesContainer.appendChild(row);
    }
    
    // Add existing categories
    container.chartData.categories.forEach(category => {
      addCategoryRow(category);
    });
    
    // Add at least one category if none exist
    if (container.chartData.categories.length === 0) {
      addCategoryRow({
        name: "Category 1",
        value: 100,
        color: matplotlibColors[0]
      });
    }
    
// Add this right before the "Buttons" section in showCategoriesDialog()
// ── Separator Line Color ──
const lineColorGroup = document.createElement("div");
lineColorGroup.style.marginBottom = "15px";

const lineColorLabel = document.createElement("label");
lineColorLabel.textContent = "Separator Line Color:";
lineColorLabel.style.display = "block";
lineColorLabel.style.marginBottom = "5px";
lineColorGroup.appendChild(lineColorLabel);

const lineColorSelect = document.createElement("select");
lineColorSelect.style.width = "100%";
lineColorSelect.style.padding = "8px";

[ { value: "#000000", text: "Black" },
  { value: "#ffffff", text: "White" }
 
].forEach(opt => {
  const o = document.createElement("option");
  o.value = opt.value;
  o.textContent = opt.text;
  // Remove the condition based on container.chartData.lineColor
  // Just set white (#ffffff) as selected
  if (opt.value === "#000000") o.selected = true;
  lineColorSelect.appendChild(o);
});

lineColorGroup.appendChild(lineColorSelect);
dialogBox.appendChild(lineColorGroup);

    // Buttons
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    buttonsContainer.style.gap = "10px";
    
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.style.padding = "8px 16px";
    cancelButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    buttonsContainer.appendChild(cancelButton);
    
    const applyButton = document.createElement("button");
    applyButton.textContent = "Apply";
    applyButton.style.padding = "8px 16px";
    applyButton.style.backgroundColor = "#4CAF50";
    applyButton.style.color = "white";
    applyButton.style.border = "none";
    applyButton.addEventListener("click", function() {
      // Validate categories
      const rows = document.querySelectorAll('.category-row');
      let emptyFound = false;
      let total = 0;
      const newCategories = [];
      
      rows.forEach(row => {
        const name = row.querySelector('.category-name').value.trim();
        const valueStr = row.querySelector('.category-value').value.trim();
        const color = row.querySelector('.category-color').value;
        
        if (!name || !valueStr) {
          emptyFound = true;
          return;
        }
        
        // Don't validate numerical value here if it's a variable like #a#
        let value = valueStr;
        if (!valueStr.includes('#')) {
          // Only validate as number if it's not a variable
          value = parseFloat(valueStr);
          if (isNaN(value)) {
            emptyFound = true;
            return;
          }
          
          if (value < 0.0000001 || value > 100000000) {
            showError("Values must be between 0.0000001 and 100,000,000");
            return;
          }
          
          total += value;
        }
        
        newCategories.push({ name, value, color });
      });
      
      if (emptyFound) {
        showError("Please fill in all category names and values");
        return;
      }
      
      // Check total for percentage input type - only if not using variables
      if (container.chartData.inputType === "percentage" && 
          !newCategories.some(cat => typeof cat.value === 'string' && cat.value.includes('#')) && 
          Math.abs(total - 100) > 0.5) {
        showError("Percentages must sum to 100%");
        return;
      }
      
      // Update categories
      container.chartData.categories = newCategories;
      
      // For total input type with numeric values, convert to percentages
      if (container.chartData.inputType === "total") {
        // Only convert numeric values, leave variables as is
        const numericCategories = container.chartData.categories.filter(
          cat => typeof cat.value === 'number'
        );
        
        if (numericCategories.length > 0) {
          const numericTotal = numericCategories.reduce((sum, cat) => sum + parseFloat(cat.value), 0);
          
          container.chartData.categories.forEach(cat => {
            if (typeof cat.value === 'number') {
              cat.value = cat.value / numericTotal * 100;
            }
          });
        }
    }
      
      // Apply rounding to numeric values
      container.chartData.categories.forEach(cat => {
        if (typeof cat.value === 'number') {
          cat.value = container.chartData.roundingType === "whole" 
            ? Math.round(cat.value) 
            : Math.round(cat.value * 10) / 10;
        }
      });
      // Update separator color
      container.chartData.lineColor = lineColorSelect.value;


      // Redraw the chart
      drawPieChart();
      
      // Close dialog
      document.body.removeChild(dialogBackdrop);
    });
    buttonsContainer.appendChild(applyButton);
    
    dialogBox.appendChild(buttonsContainer);
    dialogBackdrop.appendChild(dialogBox);
    document.body.appendChild(dialogBackdrop);
  }

  function activatePieChart() {
    // Deactivate the previously active element if any
    if (window.activePieElement && window.activePieElement !== container) {
      window.activePieElement.style.border = "none";
      
      const prevToolbar = window.activePieElement.querySelector(".pie-toolbar");
      const prevResizeHandle = window.activePieElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activePieElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
  }

  function deactivatePieChart() {
    if (window.activePieElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activePieElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deletePieChart() {
    if (window.activePieElement === container) {
      window.activePieElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activatePieChart();
    }
  });

  // Deletion: add both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePieChart();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePieChart();
  });

  // Resize handle functionality - Modified to maintain aspect ratio
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    const aspectRatio = startWidth / startHeight;
    
    function onMouseMove(e) {
      // Calculate new width based on mouse movement
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      
      // Calculate new height based on aspect ratio
      const newHeight = Math.max(200, Math.round(newWidth / aspectRatio));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      
      container.chartData.lineColor = lineColorSelect.value;
      // Redraw chart after resize
      drawPieChart();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activePieElement === container) {
      deactivatePieChart();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Draw initial pie chart
  drawPieChart();
  
  // Activate the pie chart
  activatePieChart();
}


function addOval() {
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeOvalElement) {
    window.activeOvalElement = null;
  }
  // Global counter for oval IDs
  if (!window.globalOvalCounter) {
    window.globalOvalCounter = 1;
  } else {
    window.globalOvalCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element oval-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "150px";
  container.style.height = (toolbarHeight + 100) + "px";
  container.style.cursor = "pointer";
  nextElementOffset += 10;
  container.isDragging = false;
  // Assign an ID for this oval
  container.ovalID = window.globalOvalCounter;

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "oval-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete.
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "oval-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.style.width = "100%";
  svg.style.height = "100%";
  svg.setAttribute("viewBox", "0 0 150 100");
  content.appendChild(svg);

  // Create ellipse
  const ellipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
  ellipse.setAttribute("cx", "75");
  ellipse.setAttribute("cy", "50");
  ellipse.setAttribute("rx", "70");
  ellipse.setAttribute("ry", "40");
  ellipse.setAttribute("stroke", "#000000");
  ellipse.setAttribute("stroke-width", "2");
  ellipse.setAttribute("fill", "#ffffff");
  svg.appendChild(ellipse);

  // Create markers (start hidden)
  const markerRx = document.createElement("div");
  markerRx.className = "oval-marker rx-marker";
  markerRx.style.position = "absolute";
  markerRx.style.width = "10px";
  markerRx.style.height = "10px";
  markerRx.style.backgroundColor = "#0000ff";
  markerRx.style.borderRadius = "50%";
  markerRx.style.cursor = "move";
  markerRx.style.zIndex = "100";
  markerRx.style.display = "none"; // Start hidden
  markerRx.dataset.type = "rx";
  content.appendChild(markerRx);

  const markerRy = document.createElement("div");
  markerRy.className = "oval-marker ry-marker";
  markerRy.style.position = "absolute";
  markerRy.style.width = "10px";
  markerRy.style.height = "10px";
  markerRy.style.backgroundColor = "#0000ff";
  markerRy.style.borderRadius = "50%";
  markerRy.style.cursor = "move";
  markerRy.style.zIndex = "100";
  markerRy.style.display = "none"; // Start hidden
  markerRy.dataset.type = "ry";
  content.appendChild(markerRy);

  const markers = [markerRx, markerRy];

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Key functions
  function updateMarkerPositions() {
    const contentWidth = content.clientWidth;
    const contentHeight = content.clientHeight;
    const cx = parseFloat(ellipse.getAttribute("cx"));
    const cy = parseFloat(ellipse.getAttribute("cy"));
    const rx = parseFloat(ellipse.getAttribute("rx"));
    const ry = parseFloat(ellipse.getAttribute("ry"));

    markerRx.style.left = ((cx + rx) / 150 * contentWidth - 5) + "px";
    markerRx.style.top = (cy / 100 * contentHeight - 5) + "px";

    markerRy.style.left = (cx / 150 * contentWidth - 5) + "px";
    markerRy.style.top = ((cy + ry) / 100 * contentHeight - 5) + "px";
  }

  // Update global toolbar and include an identity label
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;

    globalToolbar.innerHTML = "";
    
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Oval " + container.ovalID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    controls.appendChild(identityLabel);

    // Line thickness control - FIRST
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Thickness:";
    thicknessLabel.style.fontSize = "12px";
    controls.appendChild(thicknessLabel);
    
    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = ellipse.getAttribute("stroke-width");
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.addEventListener("input", function() {
      ellipse.setAttribute("stroke-width", this.value);
    });
    controls.appendChild(thicknessInput);

    // Line color control - SECOND
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    lineLabel.style.marginLeft = "10px";
    controls.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = ellipse.getAttribute("stroke");
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.addEventListener("input", function() {
      ellipse.setAttribute("stroke", this.value);
    });
    controls.appendChild(lineColorInput);

    // Fill color control with custom dialog
    const shadeLabel = document.createElement("span");
    shadeLabel.textContent = "Shade:";
    shadeLabel.style.fontSize = "12px";
    shadeLabel.style.marginLeft = "10px";
    controls.appendChild(shadeLabel);

    // Create a color preview button instead of a standard color input
    const shadeColorPreview = document.createElement("div");
    shadeColorPreview.style.width = "20px";
    shadeColorPreview.style.height = "20px";
    shadeColorPreview.style.border = "1px solid #ccc";
    shadeColorPreview.style.backgroundColor = ellipse.getAttribute("fill");
    shadeColorPreview.style.marginLeft = "5px";
    shadeColorPreview.style.cursor = "pointer";
    controls.appendChild(shadeColorPreview);
    
    function showColorPickerDialog() {
      const dialogBackdrop = document.createElement("div");
      dialogBackdrop.style.position = "fixed";
      dialogBackdrop.style.top = "0";
      dialogBackdrop.style.left = "0";
      dialogBackdrop.style.width = "100%";
      dialogBackdrop.style.height = "100%";
      dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
      dialogBackdrop.style.zIndex = "1000";
      dialogBackdrop.style.display = "flex";
      dialogBackdrop.style.justifyContent = "center";
      dialogBackdrop.style.alignItems = "center";
      
      const dialogBox = document.createElement("div");
      dialogBox.style.backgroundColor = "white";
      dialogBox.style.padding = "15px";
      dialogBox.style.borderRadius = "5px";
      dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
      dialogBox.style.display = "flex";
      dialogBox.style.flexDirection = "column";
      dialogBox.style.alignItems = "center";
      dialogBox.style.width = "220px";
      
      const dialogTitle = document.createElement("div");
      dialogTitle.textContent = "Choose Fill Color";
      dialogTitle.style.fontWeight = "bold";
      dialogTitle.style.marginBottom = "10px";
      dialogBox.appendChild(dialogTitle);
      
      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.value = ellipse.getAttribute("fill");
      colorInput.style.width = "100%";
      colorInput.style.marginBottom = "10px";
      dialogBox.appendChild(colorInput);
      
      const buttonsContainer = document.createElement("div");
      buttonsContainer.style.display = "flex";
      buttonsContainer.style.justifyContent = "space-between";
      buttonsContainer.style.width = "100%";
      
      const noneButton = document.createElement("button");
      noneButton.textContent = "None";
      noneButton.style.padding = "5px 10px";
      noneButton.addEventListener("click", function() {
        ellipse.setAttribute("fill", "none");
        shadeColorPreview.style.backgroundColor = "transparent";
        shadeColorPreview.style.backgroundImage = "linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd)";
        shadeColorPreview.style.backgroundSize = "10px 10px";
        shadeColorPreview.style.backgroundPosition = "0 0, 5px 5px";
        document.body.removeChild(dialogBackdrop);
      });
      buttonsContainer.appendChild(noneButton);
      
      const okButton = document.createElement("button");
      okButton.textContent = "OK";
      okButton.style.padding = "5px 10px";
      okButton.addEventListener("click", function() {
        ellipse.setAttribute("fill", colorInput.value);
        shadeColorPreview.style.backgroundColor = colorInput.value;
        shadeColorPreview.style.backgroundImage = "none";
        document.body.removeChild(dialogBackdrop);
      });
      buttonsContainer.appendChild(okButton);
      
      const cancelButton = document.createElement("button");
      cancelButton.textContent = "Cancel";
      cancelButton.style.padding = "5px 10px";
      cancelButton.addEventListener("click", function() {
        document.body.removeChild(dialogBackdrop);
      });
      buttonsContainer.appendChild(cancelButton);
      
      dialogBox.appendChild(buttonsContainer);
      dialogBackdrop.appendChild(dialogBox);
      document.body.appendChild(dialogBackdrop);
    }
    
    shadeColorPreview.addEventListener("click", showColorPickerDialog);

    globalToolbar.appendChild(controls);
  }

  function activateOval() {
    // Deactivate the previously active element if any
    if (window.activeOvalElement && window.activeOvalElement !== container) {
      window.activeOvalElement.style.border = "none";
      
      const prevToolbar = window.activeOvalElement.querySelector(".oval-toolbar");
      const prevMarkers = window.activeOvalElement.querySelectorAll(".oval-marker");
      const prevResizeHandle = window.activeOvalElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      prevMarkers.forEach(m => m.style.display = "none");
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeOvalElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    markers.forEach(m => m.style.display = "block");
    resizeHandle.style.display = "block";
    
    updateMarkerPositions();
    updateGlobalToolbar();
  }

  function deactivateOval() {
    if (window.activeOvalElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      markers.forEach(m => m.style.display = "none");
      resizeHandle.style.display = "none";
      window.activeOvalElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteOval() {
    if (window.activeOvalElement === container) {
      window.activeOvalElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Event listeners
  
  // Activate on mousedown (unless target is drag/resize/marker)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle && !markers.includes(e.target)) {
      activateOval();
    }
  });

  // Deletion: add both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteOval();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteOval();
  });

  // Marker drag functionality
  markerRx.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const origRx = parseFloat(ellipse.getAttribute("rx"));
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const newRx = Math.max(5, origRx + dx * (150 / content.clientWidth));
      ellipse.setAttribute("rx", newRx);
      updateMarkerPositions();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  markerRy.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startY = e.clientY;
    const origRy = parseFloat(ellipse.getAttribute("ry"));
    
    function onMouseMove(e) {
      const dy = e.clientY - startY;
      const newRy = Math.max(5, origRy + dy * (100 / content.clientHeight));
      ellipse.setAttribute("ry", newRy);
      updateMarkerPositions();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(50, startWidth + (e.clientX - startX));
      const newHeight = Math.max(50, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      updateMarkerPositions();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target) && window.activeOvalElement === container) {
      deactivateOval();
    }
  });

  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Initialize marker positions and activate
  updateMarkerPositions();
  activateOval();
}


function addRegularPolygon() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  const defaultWidth = 200;
  const defaultHeight = 220; // includes toolbar + drawing area
  let nextElementOffset = 10;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("polygon") ? "Polygon " : "Triangle ") + element.polygonID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeRegularPolygonElement) {
    window.activeRegularPolygonElement = null;
  }
  
  // Global counter for polygon IDs
  if (!window.globalRegularPolygonCounter) {
    window.globalRegularPolygonCounter = 1;
  } else {
    window.globalRegularPolygonCounter++;
  }

  // The SVG drawing area will be (width x height) below the toolbar.
  const drawingWidth = defaultWidth;
  const drawingHeight = defaultHeight - toolbarHeight;

  // Create the outer container.
  const container = document.createElement("div");
  container.className = "draggable-element regular-polygon-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = defaultWidth + "px";
  container.style.height = defaultHeight + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Use a dataset property for fill so we can later switch to "transparent" for no fill.
  container.dataset.fillColor = "#ffffff";
  
  // Assign an ID for this polygon
  container.polygonID = window.globalRegularPolygonCounter;
  
  // Initialize state properties
  container.numSides = 5;
  container.showRadius = false;
  container.showApothem = false;
  container.showCenter = true;
  container.strokeColor = "#000000";
  
  nextElementOffset += 10;

  // Create the local toolbar (visible by default)
  const localToolbar = document.createElement("div");
  localToolbar.className = "regular-polygon-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const contentDiv = document.createElement("div");
  contentDiv.className = "polygon-content";
  contentDiv.style.position = "absolute";
  contentDiv.style.top = toolbarHeight + "px";
  contentDiv.style.left = "0";
  contentDiv.style.width = drawingWidth + "px";
  contentDiv.style.height = drawingHeight + "px";
  contentDiv.style.overflow = "hidden";
  container.appendChild(contentDiv);

  // Create SVG
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", drawingWidth);
  svg.setAttribute("height", drawingHeight);
  svg.setAttribute("viewBox", "0 0 " + drawingWidth + " " + drawingHeight);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  contentDiv.appendChild(svg);

  // Create SVG elements
  const polygon = document.createElementNS(svgNS, "polygon");
  polygon.setAttribute("fill", container.dataset.fillColor);
  polygon.setAttribute("stroke", container.strokeColor);
  polygon.setAttribute("stroke-width", "2");
  svg.appendChild(polygon);

  // Radius line
  const radiusLine = document.createElementNS(svgNS, "line");
  radiusLine.setAttribute("stroke", container.strokeColor);
  radiusLine.setAttribute("stroke-width", "2");
  svg.appendChild(radiusLine);

  // Apothem line
  const apothemLine = document.createElementNS(svgNS, "line");
  apothemLine.setAttribute("stroke", container.strokeColor);
  apothemLine.setAttribute("stroke-width", "2");
  svg.appendChild(apothemLine);

  // Center marker
  const centerMarker = document.createElementNS(svgNS, "circle");
  centerMarker.setAttribute("r", "3");
  centerMarker.setAttribute("fill", container.strokeColor);
  svg.appendChild(centerMarker);

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.dataset.fillColor === "transparent" ? "transparent" : container.dataset.fillColor;
  }
  
  function getNumberOfSides() {
    return container.numSides;
  }
  
  function getShowRadius() {
    return container.showRadius;
  }
  
  function getShowApothem() {
    return container.showApothem;
  }
  
  function getShowCenter() {
    return container.showCenter;
  }

  // Create resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  // Update function for the regular polygon
  function updateRegularPolygon() {
    // Determine center point.
    const cx = (contentDiv.clientWidth || drawingWidth) / 2;
    const cy = (contentDiv.clientHeight || drawingHeight) / 2;
    centerMarker.setAttribute("cx", cx);
    centerMarker.setAttribute("cy", cy);
    centerMarker.setAttribute("fill", container.strokeColor);
    centerMarker.style.display = container.showCenter ? "block" : "none";

    const sides = Math.max(3, parseInt(container.numSides) || 5);
    const R = 0.9 * Math.min(cx, cy);
    let vertices = [];

    if (sides === 3) {
      // Special triangle logic: an equilateral triangle with base at the bottom.
      const angleTop = -90 * (Math.PI / 180);
      const angleLeft = 150 * (Math.PI / 180);
      const angleRight = 30 * (Math.PI / 180);
      vertices = [
        { x: cx + R * Math.cos(angleTop),  y: cy + R * Math.sin(angleTop) },
        { x: cx + R * Math.cos(angleLeft), y: cy + R * Math.sin(angleLeft) },
        { x: cx + R * Math.cos(angleRight),y: cy + R * Math.sin(angleRight) }
      ];
      // For triangle, define radius from center to right vertex.
      radiusLine.setAttribute("x1", cx);
      radiusLine.setAttribute("y1", cy);
      radiusLine.setAttribute("x2", vertices[2].x);
      radiusLine.setAttribute("y2", vertices[2].y);
    } else {
      // Regular polygon for sides >= 4.
      const angleStep = (2 * Math.PI) / sides;
      const offset = Math.PI / 2 - Math.PI / sides;
      for (let i = 0; i < sides; i++) {
        const angle = offset + i * angleStep;
        const x = cx + R * Math.cos(angle);
        const y = cy + R * Math.sin(angle);
        vertices.push({ x, y });
      }
      // Pick the bottom-most vertex (if tied, pick the right-most).
      const bottomVertex = vertices.slice().sort((a, b) => {
        if (b.y !== a.y) return b.y - a.y;
        return b.x - a.x;
      })[0];
      radiusLine.setAttribute("x1", cx);
      radiusLine.setAttribute("y1", cy);
      radiusLine.setAttribute("x2", bottomVertex.x);
      radiusLine.setAttribute("y2", bottomVertex.y);
    }

    // Draw polygon.
    const pointsStr = vertices.map(v => `${v.x},${v.y}`).join(" ");
    polygon.setAttribute("points", pointsStr);
    polygon.setAttribute("stroke", container.strokeColor);
    polygon.setAttribute("fill", container.dataset.fillColor === "transparent" ? "none" : container.dataset.fillColor);

    // Update radius line.
    radiusLine.setAttribute("stroke", container.strokeColor);
    radiusLine.setAttribute("stroke-width", "2");
    radiusLine.style.display = container.showRadius ? "block" : "none";

    // Draw apothem line (vertical from center down by R * cos(π/sides)).
    const apothemLength = R * Math.cos(Math.PI / sides);
    apothemLine.setAttribute("x1", cx);
    apothemLine.setAttribute("y1", cy);
    apothemLine.setAttribute("x2", cx);
    apothemLine.setAttribute("y2", cy + apothemLength);
    apothemLine.setAttribute("stroke", container.strokeColor);
    apothemLine.setAttribute("stroke-width", "2");
    apothemLine.style.display = container.showApothem ? "block" : "none";

    // Right-angle bracket for apothem
    const existingBracket = svg.querySelector("path.apothem-bracket");
    if (existingBracket) {
      existingBracket.remove();
    }
    if (container.showApothem && vertices.length >= 2) {
      // Sort vertices by descending y to get the two bottom-most.
      const sorted = vertices.slice().sort((a, b) => b.y - a.y);
      const vA = sorted[0];
      const vB = sorted[1];
      const dx = vB.x - vA.x;
      const dy = vB.y - vA.y;
      let t = 0.5;
      if (Math.abs(dx) > 0.00001) {
        t = (cx - vA.x) / dx;
      }
      const interY = vA.y + t * dy;
      const bracketSize = 8;
      const bracketPath = `
        M ${cx} ${interY}
        l 0 -${bracketSize}
        l ${bracketSize} 0
        l 0 ${bracketSize}
        Z
      `;
      const bracket = document.createElementNS(svgNS, "path");
      bracket.classList.add("apothem-bracket");
      bracket.setAttribute("d", bracketPath);
      bracket.setAttribute("fill", "none");
      bracket.setAttribute("stroke", container.strokeColor);
      bracket.setAttribute("stroke-width", "2");
      svg.appendChild(bracket);
    }
  }

  // Update global toolbar with polygon controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Regular Polygon " + container.polygonID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      updateRegularPolygon();
    });
    row1.appendChild(lineColorInput);

    // Fill color control
    const fillLabel = document.createElement("span");
    fillLabel.textContent = "Fill:";
    fillLabel.style.fontSize = "12px";
    row1.appendChild(fillLabel);

    const fillDisplay = document.createElement("div");
    fillDisplay.className = "fill-display";
    fillDisplay.style.width = "20px";
    fillDisplay.style.height = "20px";
    fillDisplay.style.backgroundColor = getFillColor() === "transparent" ? "#ffffff" : getFillColor();
    fillDisplay.style.cursor = "pointer";
    fillDisplay.style.border = "1px solid #ccc";
    fillDisplay.style.marginLeft = "5px";
    fillDisplay.style.marginRight = "10px";
    fillDisplay.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillDisplay.addEventListener("click", function(e) {
      e.stopPropagation();
      
      const overlay = document.createElement("div");
      overlay.style.position = "fixed";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
      overlay.style.zIndex = "10000";
      overlay.style.display = "flex";
      overlay.style.justifyContent = "center";
      overlay.style.alignItems = "center";

      const modal = document.createElement("div");
      modal.style.background = "#fff";
      modal.style.padding = "10px";
      modal.style.border = "1px solid #ccc";
      modal.style.fontSize = "14px";
      modal.innerHTML = `<div style="margin-bottom:10px;">Choose Fill Color</div>`;

      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.value = container.dataset.fillColor === "transparent" ? "#ffffff" : container.dataset.fillColor || "#ffffff";
      modal.appendChild(colorInput);

      // "None" option for no fill.
      const noneBtn = document.createElement("button");
      noneBtn.textContent = "None";
      noneBtn.style.marginLeft = "10px";
      modal.appendChild(noneBtn);

      const okBtn = document.createElement("button");
      okBtn.textContent = "OK";
      okBtn.style.marginLeft = "10px";
      modal.appendChild(okBtn);
      
      const cancelBtn = document.createElement("button");
      cancelBtn.textContent = "Cancel";
      cancelBtn.style.marginLeft = "10px";
      modal.appendChild(cancelBtn);

      overlay.appendChild(modal);
      document.body.appendChild(overlay);

      function cleanup() {
        document.body.removeChild(overlay);
      }

      okBtn.addEventListener("click", function() {
        const selectedColor = colorInput.value;
        fillDisplay.style.backgroundColor = selectedColor;
        container.dataset.fillColor = selectedColor;
        updateRegularPolygon();
        cleanup();
      });
      
      noneBtn.addEventListener("click", function() {
        fillDisplay.style.backgroundColor = "#ffffff";
        container.dataset.fillColor = "transparent";
        updateRegularPolygon();
        cleanup();
      });
      
      cancelBtn.addEventListener("click", cleanup);
      
      overlay.addEventListener("click", function(e) {
        if (e.target === overlay) cleanup();
      });
    });
    row1.appendChild(fillDisplay);

    // Number of sides control
    const sidesLabel = document.createElement("span");
    sidesLabel.textContent = "Sides:";
    sidesLabel.style.fontSize = "12px";
    row1.appendChild(sidesLabel);

    const sidesInput = document.createElement("input");
    sidesInput.type = "number";
    sidesInput.min = "3";
    sidesInput.max = "20";
    sidesInput.value = getNumberOfSides();
    sidesInput.style.width = "40px";
    sidesInput.style.marginLeft = "5px";
    sidesInput.style.marginRight = "10px";
    sidesInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    sidesInput.addEventListener("click", function(e) { e.stopPropagation(); });
    sidesInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.numSides = parseInt(this.value);
      updateRegularPolygon();
    });
    row1.appendChild(sidesInput);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Show radius control
    const radiusLabel = document.createElement("span");
    radiusLabel.textContent = "Show Radius:";
    radiusLabel.style.fontSize = "12px";
    row2.appendChild(radiusLabel);

    const radiusSelect = document.createElement("select");
    radiusSelect.style.marginLeft = "5px";
    radiusSelect.style.marginRight = "10px";
    const radiusYes = document.createElement("option");
    radiusYes.value = "yes";
    radiusYes.textContent = "Yes";
    const radiusNo = document.createElement("option");
    radiusNo.value = "no";
    radiusNo.textContent = "No";
    radiusSelect.appendChild(radiusNo);
    radiusSelect.appendChild(radiusYes);
    radiusSelect.value = getShowRadius() ? "yes" : "no";
    radiusSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    radiusSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    radiusSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.showRadius = this.value === "yes";
      updateRegularPolygon();
    });
    row2.appendChild(radiusSelect);

    // Show apothem control
    const apothemLabel = document.createElement("span");
    apothemLabel.textContent = "Show Apothem:";
    apothemLabel.style.fontSize = "12px";
    row2.appendChild(apothemLabel);

    const apothemSelect = document.createElement("select");
    apothemSelect.style.marginLeft = "5px";
    apothemSelect.style.marginRight = "10px";
    const apothemYes = document.createElement("option");
    apothemYes.value = "yes";
    apothemYes.textContent = "Yes";
    const apothemNo = document.createElement("option");
    apothemNo.value = "no";
    apothemNo.textContent = "No";
    apothemSelect.appendChild(apothemNo);
    apothemSelect.appendChild(apothemYes);
    apothemSelect.value = getShowApothem() ? "yes" : "no";
    apothemSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    apothemSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    apothemSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.showApothem = this.value === "yes";
      updateRegularPolygon();
    });
    row2.appendChild(apothemSelect);

    // Show center control
    const centerLabel = document.createElement("span");
    centerLabel.textContent = "Show Center:";
    centerLabel.style.fontSize = "12px";
    row2.appendChild(centerLabel);

    const centerSelect = document.createElement("select");
    centerSelect.style.marginLeft = "5px";
    centerSelect.style.marginRight = "10px";
    const centerYes = document.createElement("option");
    centerYes.value = "yes";
    centerYes.textContent = "Yes";
    const centerNo = document.createElement("option");
    centerNo.value = "no";
    centerNo.textContent = "No";
    centerSelect.appendChild(centerYes);
    centerSelect.appendChild(centerNo);
    centerSelect.value = getShowCenter() ? "yes" : "no";
    centerSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    centerSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    centerSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.showCenter = this.value === "yes";
      updateRegularPolygon();
    });
    row2.appendChild(centerSelect);

    // Add some spacing
    const spacer = document.createElement("div");
    spacer.style.width = "20px";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.marginLeft = "10px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  function activatePolygon() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    if (window.activeRegularPolygonElement && window.activeRegularPolygonElement !== container) {
      // Reset previous element's appearance
      window.activeRegularPolygonElement.style.border = "none";
      const prevToolbar = window.activeRegularPolygonElement.querySelector(".regular-polygon-toolbar");
      const prevResizeHandle = window.activeRegularPolygonElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeRegularPolygonElement = container;
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    updateGlobalToolbar();
  }

  function deactivatePolygon() {
    // Don't deactivate if this element has focus lock
    if (window.activeRegularPolygonElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeRegularPolygonElement = null;
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deletePolygon() {
    if (window.activeRegularPolygonElement === container) {
      window.activeRegularPolygonElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX, startY = e.clientY;
    const startWidth = container.offsetWidth, startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      let newWidth = startWidth + (e.clientX - startX);
      let newHeight = startHeight + (e.clientY - startY);
      
      if (newWidth > 100) {
        container.style.width = newWidth + "px";
        contentDiv.style.width = newWidth + "px";
        svg.setAttribute("width", newWidth);
        svg.setAttribute("viewBox", "0 0 " + newWidth + " " + (newHeight - toolbarHeight));
      }
      if (newHeight > toolbarHeight + 50) {
        container.style.height = newHeight + "px";
        contentDiv.style.height = (newHeight - toolbarHeight) + "px";
        svg.setAttribute("height", newHeight - toolbarHeight);
        svg.setAttribute("viewBox", "0 0 " + container.offsetWidth + " " + (newHeight - toolbarHeight));
      }
      updateRegularPolygon();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Delete button events
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePolygon();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePolygon();
  });
  
  // Activate on mousedown (unless target is drag/resize)
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activatePolygon();
    }
  });
  
  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeRegularPolygonElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivatePolygon();
    }
  });
  
  // Initial update and activation
  updateRegularPolygon();
  activatePolygon();
  
  // Append container to the canvas.
  canvas.appendChild(container);
}

function addParallelogram() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("parallelogram") ? "Parallelogram " : element.className.includes("polygon") ? "Polygon " : "Triangle ") + element.polygonID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeParallelogramElement) {
    window.activeParallelogramElement = null;
  }
  
  // Global counter for parallelogram IDs
  if (!window.globalParallelogramCounter) {
    window.globalParallelogramCounter = 1;
  } else {
    window.globalParallelogramCounter++;
  }

  // Create the outer container with fixed initial size
  const container = document.createElement("div");
  container.className = "draggable-element parallelogram-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "250px";  // Larger initial size
  container.style.height = toolbarHeight + 200 + "px";  // Larger initial size
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  // Assign an ID for this parallelogram
  container.polygonID = window.globalParallelogramCounter;
  
  // Initialize state properties
  container.vertexVisibility = true;
  container.vertexColor = "#0000ff";
  container.vertexSize = 5;
  container.strokeColor = "#000000";
  container.fillColor = "#ffffff";
  container.lineThickness = 2; // Default line thickness
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;

  // Create the local toolbar (visible by default)
  const localToolbar = document.createElement("div");
  localToolbar.className = "parallelogram-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div for the SVG.
  const content = document.createElement("div");
  content.className = "parallelogram-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden"; // Clip overflow
  container.appendChild(content);

  // Create the SVG element with initial viewBox.
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
  const initialViewBox = { x: 0, y: 0, width: 200, height: 150 };
  svg.setAttribute("viewBox", `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Create the polygon element.
  const polygon = document.createElementNS(svgNS, "polygon");
  polygon.setAttribute("stroke", container.strokeColor);
  polygon.setAttribute("stroke-width", "2");
  polygon.setAttribute("fill", container.fillColor);
  svg.appendChild(polygon);

  // Define points for parallelogram with initial positioning.
  const points = {
    topLeft: { x: 50, y: 30 },
    topRight: { x: 150, y: 30 },
    bottomRight: { x: 120, y: 120 },
    bottomLeft: { x: 20, y: 120 }
  };

  // Store initial horizontal distances – CRITICAL for correct movement.
  const initialTopDX = points.topRight.x - points.topLeft.x;
  const initialBottomDX = points.bottomRight.x - points.bottomLeft.x;

  // Helper function to update the polygon.
  function updatePolygon() {
    polygon.setAttribute("points", 
      `${points.topLeft.x},${points.topLeft.y} ` +
      `${points.topRight.x},${points.topRight.y} ` +
      `${points.bottomRight.x},${points.bottomRight.y} ` +
      `${points.bottomLeft.x},${points.bottomLeft.y}`);
  }
  updatePolygon();

  function getLineThickness() {
  return container.lineThickness;
}

function updateLineThickness() {
  // Update the line thickness for all SVG elements
  polygon.setAttribute("stroke-width", container.lineThickness);
  radiusLine.setAttribute("stroke-width", container.lineThickness);
  apothemLine.setAttribute("stroke-width", container.lineThickness);
  
  // Update any right-angle bracket
  const bracket = svg.querySelector("path.apothem-bracket");
  if (bracket) {
    bracket.setAttribute("stroke-width", container.lineThickness);
  }
}

  // Create draggable points.
  function createDraggablePoint(x, y, type) {
    const circle = document.createElementNS(svgNS, "circle");
    circle.setAttribute("cx", x);
    circle.setAttribute("cy", y);
    circle.setAttribute("r", container.vertexSize);
    circle.setAttribute("fill", container.vertexColor);
    circle.setAttribute("stroke", "black");
    circle.setAttribute("stroke-width", "1");
    circle.className = `parallelogram-point ${type}`;
    circle.style.cursor = "move";
    circle.style.pointerEvents = "all";
    circle.style.display = container.vertexVisibility ? "block" : "none";
    return circle;
  }

  const topLeftPoint = createDraggablePoint(points.topLeft.x, points.topLeft.y, "top-left");
  const topRightPoint = createDraggablePoint(points.topRight.x, points.topRight.y, "top-right");
  const bottomLeftPoint = createDraggablePoint(points.bottomLeft.x, points.bottomLeft.y, "bottom-left");
  const bottomRightPoint = createDraggablePoint(points.bottomRight.x, points.bottomRight.y, "bottom-right");

  svg.appendChild(topLeftPoint);
  svg.appendChild(topRightPoint);
  svg.appendChild(bottomLeftPoint);
  svg.appendChild(bottomRightPoint);

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getVertexColor() {
    return container.vertexColor;
  }
  
  function getVertexSize() {
    return container.vertexSize;
  }
  
  function getShowVertices() {
    return container.vertexVisibility;
  }

  // Function to update vertex appearance.
  function updateVertexAppearance() {
    [topLeftPoint, topRightPoint, bottomLeftPoint, bottomRightPoint].forEach(pt => {
      pt.setAttribute("fill", container.vertexColor);
      pt.setAttribute("r", container.vertexSize);
    });
  }

  // Function to get current viewBox dimensions.
  function getCurrentViewBox() {
    const vb = svg.viewBox.baseVal;
    return { x: vb.x, y: vb.y, width: vb.width, height: vb.height };
  }

  // Helper: Check if a coordinate is out-of-bounds.
  function isOutOfBounds(x, y) {
    const padding = 2;
    const vb = getCurrentViewBox();
    return (x < vb.x + padding ||
            x > vb.x + vb.width - padding ||
            y < vb.y + padding ||
            y > vb.y + vb.height - padding);
  }

  // Create resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  // Apply vertex visibility
  function applyVertexVisibility() {
    const showVertices = getShowVertices();
    [topLeftPoint, topRightPoint, bottomLeftPoint, bottomRightPoint].forEach(pt => {
      pt.style.display = showVertices ? "block" : "none";
    });
  }

  // Update global toolbar with parallelogram controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Parallelogram " + container.polygonID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      polygon.setAttribute("stroke", this.value);
      [topLeftPoint, topRightPoint, bottomLeftPoint, bottomRightPoint].forEach(pt => {
        pt.setAttribute("stroke", this.value);
      });
    });
    row1.appendChild(lineColorInput);


    
    // Fill color control
    const fillLabel = document.createElement("span");
    fillLabel.textContent = "Fill:";
    fillLabel.style.fontSize = "12px";
    row1.appendChild(fillLabel);

    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor();
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.fillColor = this.value;
      polygon.setAttribute("fill", this.value);
    });
    row1.appendChild(fillColorInput);

    // Vertex color control
    const vertexColorLabel = document.createElement("span");
    vertexColorLabel.textContent = "Vertex:";
    vertexColorLabel.style.fontSize = "12px";
    row1.appendChild(vertexColorLabel);

    const vertexColorInput = document.createElement("input");
    vertexColorInput.type = "color";
    vertexColorInput.value = getVertexColor();
    vertexColorInput.style.marginLeft = "5px";
    vertexColorInput.style.marginRight = "10px";
    vertexColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.vertexColor = this.value;
      updateVertexAppearance();
    });
    row1.appendChild(vertexColorInput);

    // Vertex visibility control
    const vertexVisLabel = document.createElement("span");
    vertexVisLabel.textContent = "Show Vertices:";
    vertexVisLabel.style.fontSize = "12px";
    row1.appendChild(vertexVisLabel);

    const vertexSelect = document.createElement("select");
    vertexSelect.id = "vertex-visibility-" + container.polygonID;
    vertexSelect.style.marginLeft = "5px";
    vertexSelect.style.marginRight = "10px";
    vertexSelect.style.fontSize = "12px";
    
    const optYes = document.createElement("option");
    optYes.value = "yes";
    optYes.textContent = "Yes";
    const optNo = document.createElement("option");
    optNo.value = "no";
    optNo.textContent = "No";
    
    vertexSelect.appendChild(optYes);
    vertexSelect.appendChild(optNo);
    vertexSelect.value = container.vertexVisibility ? "yes" : "no";
    vertexSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.vertexVisibility = this.value === "yes";
      applyVertexVisibility();
    });
    row1.appendChild(vertexSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Vertex size control
    const vertexSizeLabel = document.createElement("span");
    vertexSizeLabel.textContent = "Vertex Size:";
    vertexSizeLabel.style.fontSize = "12px";
    row2.appendChild(vertexSizeLabel);

    const vertexSizeInput = document.createElement("input");
    vertexSizeInput.type = "number";
    vertexSizeInput.min = "1";
    vertexSizeInput.max = "20";
    vertexSizeInput.value = getVertexSize();
    vertexSizeInput.style.width = "40px";
    vertexSizeInput.style.marginLeft = "5px";
    vertexSizeInput.style.marginRight = "20px";
    vertexSizeInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexSizeInput.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexSizeInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.vertexSize = parseInt(this.value);
      updateVertexAppearance();
    });
    row2.appendChild(vertexSizeInput);

// Add this inside row2 creation in updateGlobalToolbar() function
// Line thickness control
const thicknessLabel = document.createElement("span");
thicknessLabel.textContent = "Line Thickness:";
thicknessLabel.style.fontSize = "12px";
row2.appendChild(thicknessLabel);

const thicknessInput = document.createElement("input");
thicknessInput.type = "number";
thicknessInput.min = "1";
thicknessInput.max = "10";
thicknessInput.value = getLineThickness();
thicknessInput.style.width = "40px";
thicknessInput.style.marginLeft = "5px";
thicknessInput.style.marginRight = "20px";
thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
thicknessInput.addEventListener("input", function(e) {
  e.stopPropagation();
  container.lineThickness = parseInt(this.value);
  updateLineThickness();
});
row2.appendChild(thicknessInput);

    // Add some spacing
    const spacer = document.createElement("div");
    spacer.style.width = "20px";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.marginLeft = "10px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  function activateParallelogram() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Store reference to the previously active element if it exists
    if (typeof activeElement !== 'undefined' && activeElement && activeElement !== container) {
      // If using the temporary raise function from the original code
      if (typeof restoreElementZIndex === 'function' && activeElement.dataset.tempRaised) {
        restoreElementZIndex(activeElement);
      }
      
      // Handle toolbar of the previous element
      if (activeElement.querySelector(".element-controls")) {
        activeElement.querySelector(".element-controls").style.display = "none";
      }
    }
    
    if (window.activeParallelogramElement && window.activeParallelogramElement !== container) {
      // Reset previous element's appearance
      window.activeParallelogramElement.style.border = "none";
      const prevToolbar = window.activeParallelogramElement.querySelector(".parallelogram-toolbar");
      const prevResizeHandle = window.activeParallelogramElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeParallelogramElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    
    // Use the raise function from the original code if available
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  function deactivateParallelogram() {
    // Don't deactivate if this element has focus lock
    if (window.activeParallelogramElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeParallelogramElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteParallelogram() {
    if (window.activeParallelogramElement === container) {
      window.activeParallelogramElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // ---------------------------
  // Top-Left Point Handler
  // ---------------------------

  topLeftPoint.addEventListener("mousedown", function(e) {
  e.stopPropagation();
  e.preventDefault(); // Prevent text selection during drag
  
  // Get initial coordinates from the points data structure rather than attributes
  // This ensures consistency across all calculations
  const startX = points.topLeft.x;
  const startY = points.topLeft.y;
  const startMouseX = e.clientX;
  const startMouseY = e.clientY;
  
  // Get the initial positions of all vertices for reference
  const initialPositions = {
    topLeft: { x: points.topLeft.x, y: points.topLeft.y },
    topRight: { x: points.topRight.x, y: points.topRight.y },
    bottomLeft: { x: points.bottomLeft.x, y: points.bottomLeft.y },
    bottomRight: { x: points.bottomRight.x, y: points.bottomRight.y }
  };
  
  // Use the initial distances for more stable calculations
  const topWidth = initialPositions.topRight.x - initialPositions.topLeft.x;
  const bottomWidth = initialPositions.bottomRight.x - initialPositions.bottomLeft.x;
  
  // Get accurate SVG scaling factors once at the start of the drag
  const svgRect = svg.getBoundingClientRect();
  const viewBox = getCurrentViewBox();
  const scaleX = viewBox.width / svgRect.width;
  const scaleY = viewBox.height / svgRect.height;
  
  let hasDragged = false;
  
  function onMouseMove(e) {
    hasDragged = true;
    
    // Calculate the raw delta in screen pixels
    const rawDeltaX = e.clientX - startMouseX;
    const rawDeltaY = e.clientY - startMouseY;
    
    // Apply scaling to get SVG-space delta
    const deltaX = rawDeltaX * scaleX;
    const deltaY = rawDeltaY * scaleY;
    
    // Calculate new positions relative to initial positions (not cumulative)
    // This reduces rounding errors that can cause jumping
    const newTopLeftX = startX + deltaX;
    const newTopLeftY = startY + deltaY;
    
    // Calculate other points based on fixed relationships
    const newTopRightX = newTopLeftX + topWidth;
    const newTopRightY = newTopLeftY;
    
    // Calculate bottom vertices maintaining parallelogram constraints
    const newBottomLeftX = newTopLeftX - (newTopRightX - initialPositions.bottomRight.x);
    const newBottomLeftY = initialPositions.bottomLeft.y;
    const newBottomRightX = newBottomLeftX + bottomWidth;
    const newBottomRightY = initialPositions.bottomRight.y;
    
    // Check boundaries for all computed positions
    if (isOutOfBounds(newTopLeftX, newTopLeftY) ||
        isOutOfBounds(newTopRightX, newTopRightY) ||
        isOutOfBounds(newBottomLeftX, newBottomLeftY) ||
        isOutOfBounds(newBottomRightX, newBottomRightY)) {
      return;
    }
    
    // Update all positions consistently
    // First update the data model
    points.topLeft.x = newTopLeftX;
    points.topLeft.y = newTopLeftY;
    points.topRight.x = newTopRightX;
    points.topRight.y = newTopRightY;
    points.bottomLeft.x = newBottomLeftX;
    points.bottomLeft.y = newBottomLeftY;
    points.bottomRight.x = newBottomRightX;
    points.bottomRight.y = newBottomRightY;
    
    // Then update the visual elements
    topLeftPoint.setAttribute("cx", newTopLeftX);
    topLeftPoint.setAttribute("cy", newTopLeftY);
    topRightPoint.setAttribute("cx", newTopRightX);
    topRightPoint.setAttribute("cy", newTopRightY);
    bottomLeftPoint.setAttribute("cx", newBottomLeftX);
    bottomLeftPoint.setAttribute("cy", newBottomLeftY);
    bottomRightPoint.setAttribute("cx", newBottomRightX);
    bottomRightPoint.setAttribute("cy", newBottomRightY);
    
    // Update the polygon last
    updatePolygon();
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if (hasDragged && typeof ignoreNextClick !== 'undefined') { 
      ignoreNextClick = true;
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// ---------------------------
// Top-Right Point Handler (improved)
// ---------------------------
topRightPoint.addEventListener("mousedown", function(e) {
  e.stopPropagation();
  e.preventDefault();
  
  // Get initial coordinates and positions
  const startX = points.topRight.x;
  const startY = points.topRight.y;
  const startMouseX = e.clientX;
  const startMouseY = e.clientY;
  
  // Get the initial positions of all vertices
  const initialPositions = {
    topLeft: { x: points.topLeft.x, y: points.topLeft.y },
    topRight: { x: points.topRight.x, y: points.topRight.y },
    bottomLeft: { x: points.bottomLeft.x, y: points.bottomLeft.y },
    bottomRight: { x: points.bottomRight.x, y: points.bottomRight.y }
  };
  
  // Get scaling factors
  const svgRect = svg.getBoundingClientRect();
  const viewBox = getCurrentViewBox();
  const scaleX = viewBox.width / svgRect.width;
  const scaleY = viewBox.height / svgRect.height;
  
  let hasDragged = false;
  
  function onMouseMove(e) {
    hasDragged = true;
    
    // Calculate deltas
    const rawDeltaX = e.clientX - startMouseX;
    const rawDeltaY = e.clientY - startMouseY;
    const deltaX = rawDeltaX * scaleX;
    const deltaY = rawDeltaY * scaleY;
    
    // Calculate new positions
    const newTopRightX = startX + deltaX;
    const newTopRightY = startY + deltaY;
    const newTopLeftY = newTopRightY; // Y coordinates stay aligned
    
    // Calculate bottom-right position maintaining parallelogram
    const newBottomRightX = newTopRightX - (initialPositions.topLeft.x - initialPositions.bottomLeft.x);
    const newBottomRightY = initialPositions.bottomRight.y;
    
    // Check boundaries
    if (isOutOfBounds(newTopRightX, newTopRightY) ||
        isOutOfBounds(initialPositions.topLeft.x, newTopLeftY) ||
        isOutOfBounds(newBottomRightX, newBottomRightY)) {
      return;
    }
    
    // Update data model
    points.topRight.x = newTopRightX;
    points.topRight.y = newTopRightY;
    points.topLeft.y = newTopLeftY;
    points.bottomRight.x = newBottomRightX;
    
    // Update DOM elements
    topRightPoint.setAttribute("cx", newTopRightX);
    topRightPoint.setAttribute("cy", newTopRightY);
    topLeftPoint.setAttribute("cy", newTopLeftY);
    bottomRightPoint.setAttribute("cx", newBottomRightX);
    
    updatePolygon();
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if (hasDragged && typeof ignoreNextClick !== 'undefined') { 
      ignoreNextClick = true;
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// ---------------------------
// Bottom-Left Point Handler (improved)
// ---------------------------
bottomLeftPoint.addEventListener("mousedown", function(e) {
  e.stopPropagation();
  e.preventDefault();
  
  // Get initial coordinates and positions
  const startX = points.bottomLeft.x;
  const startY = points.bottomLeft.y;
  const startMouseX = e.clientX;
  const startMouseY = e.clientY;
  
  // Get the initial positions of all vertices
  const initialPositions = {
    topLeft: { x: points.topLeft.x, y: points.topLeft.y },
    topRight: { x: points.topRight.x, y: points.topRight.y },
    bottomLeft: { x: points.bottomLeft.x, y: points.bottomLeft.y },
    bottomRight: { x: points.bottomRight.x, y: points.bottomRight.y }
  };
  
  // Calculate stable distance relationships
  const bottomWidth = initialPositions.bottomRight.x - initialPositions.bottomLeft.x;
  
  // Get scaling factors
  const svgRect = svg.getBoundingClientRect();
  const viewBox = getCurrentViewBox();
  const scaleX = viewBox.width / svgRect.width;
  const scaleY = viewBox.height / svgRect.height;
  
  let hasDragged = false;
  
  function onMouseMove(e) {
    hasDragged = true;
    
    // Calculate deltas
    const rawDeltaX = e.clientX - startMouseX;
    const rawDeltaY = e.clientY - startMouseY;
    const deltaX = rawDeltaX * scaleX;
    const deltaY = rawDeltaY * scaleY;
    
    // Calculate new positions
    const newBottomLeftX = startX + deltaX;
    const newBottomLeftY = startY + deltaY;
    const newBottomRightX = newBottomLeftX + bottomWidth;
    const newBottomRightY = newBottomLeftY;
    
    // Update top-left x to maintain parallelogram
    const newTopLeftX = newBottomLeftX - (newBottomRightX - initialPositions.topRight.x);
    
    // Calculate new top-right x
    const newTopRightX = newTopLeftX + (initialPositions.topRight.x - initialPositions.topLeft.x);
    
    // Check boundaries
    if (isOutOfBounds(newBottomLeftX, newBottomLeftY) ||
        isOutOfBounds(newBottomRightX, newBottomRightY) ||
        isOutOfBounds(newTopLeftX, initialPositions.topLeft.y) ||
        isOutOfBounds(newTopRightX, initialPositions.topRight.y)) {
      return;
    }
    
    // Update data model
    points.bottomLeft.x = newBottomLeftX;
    points.bottomLeft.y = newBottomLeftY;
    points.bottomRight.x = newBottomRightX;
    points.bottomRight.y = newBottomRightY;
    points.topLeft.x = newTopLeftX;
    points.topRight.x = newTopRightX;
    
    // Update DOM elements
    bottomLeftPoint.setAttribute("cx", newBottomLeftX);
    bottomLeftPoint.setAttribute("cy", newBottomLeftY);
    bottomRightPoint.setAttribute("cx", newBottomRightX);
    bottomRightPoint.setAttribute("cy", newBottomRightY);
    topLeftPoint.setAttribute("cx", newTopLeftX);
    topRightPoint.setAttribute("cx", newTopRightX);
    
    updatePolygon();
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if (hasDragged && typeof ignoreNextClick !== 'undefined') { 
      ignoreNextClick = true;
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// ---------------------------
// Bottom-Right Point Handler (improved)
// ---------------------------
bottomRightPoint.addEventListener("mousedown", function(e) {
  e.stopPropagation();
  e.preventDefault();
  
  // Get initial coordinates and positions
  const startX = points.bottomRight.x;
  const startY = points.bottomRight.y;
  const startMouseX = e.clientX;
  const startMouseY = e.clientY;
  
  // Get the initial positions of all vertices
  const initialPositions = {
    topLeft: { x: points.topLeft.x, y: points.topLeft.y },
    topRight: { x: points.topRight.x, y: points.topRight.y },
    bottomLeft: { x: points.bottomLeft.x, y: points.bottomLeft.y },
    bottomRight: { x: points.bottomRight.x, y: points.bottomRight.y }
  };
  
  // Get scaling factors
  const svgRect = svg.getBoundingClientRect();
  const viewBox = getCurrentViewBox();
  const scaleX = viewBox.width / svgRect.width;
  const scaleY = viewBox.height / svgRect.height;
  
  let hasDragged = false;
  
  function onMouseMove(e) {
    hasDragged = true;
    
    // Calculate deltas
    const rawDeltaX = e.clientX - startMouseX;
    const rawDeltaY = e.clientY - startMouseY;
    const deltaX = rawDeltaX * scaleX;
    const deltaY = rawDeltaY * scaleY;
    
    // Calculate new positions
    const newBottomRightX = startX + deltaX;
    const newBottomRightY = startY + deltaY;
    const newBottomLeftY = newBottomRightY; // Keep y-coordinates aligned
    
    // Calculate top-right x to maintain parallelogram
    const newTopRightX = newBottomRightX - (initialPositions.bottomLeft.x - initialPositions.topLeft.x);
    
    // Check boundaries
    if (isOutOfBounds(newBottomRightX, newBottomRightY) ||
        isOutOfBounds(initialPositions.bottomLeft.x, newBottomLeftY) ||
        isOutOfBounds(newTopRightX, initialPositions.topRight.y)) {
      return;
    }
    
    // Update data model
    points.bottomRight.x = newBottomRightX;
    points.bottomRight.y = newBottomRightY;
    points.bottomLeft.y = newBottomLeftY;
    points.topRight.x = newTopRightX;
    
    // Update DOM elements
    bottomRightPoint.setAttribute("cx", newBottomRightX);
    bottomRightPoint.setAttribute("cy", newBottomRightY);
    bottomLeftPoint.setAttribute("cy", newBottomLeftY);
    topRightPoint.setAttribute("cx", newTopRightX);
    
    updatePolygon();
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if (hasDragged && typeof ignoreNextClick !== 'undefined') { 
      ignoreNextClick = true;
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// Improved resize handle functionality
resizeHandle.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  const startX = e.clientX;
  const startY = e.clientY;
  const startWidth = container.offsetWidth;
  const startHeight = container.offsetHeight;
  const contentHeight = startHeight - toolbarHeight;
  const originalViewBox = getCurrentViewBox();
  
  function onMouseMove(e) {
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    const newWidth = Math.max(150, startWidth + dx);
    const newHeight = Math.max(100, startHeight + dy);
    const newContentHeight = newHeight - toolbarHeight;
    
    // Update container dimensions
    container.style.width = newWidth + "px";
    container.style.height = newHeight + "px";
    content.style.height = newContentHeight + "px";
    
    // Update viewBox while maintaining aspect ratio
    const widthRatio = newWidth / startWidth;
    const heightRatio = newContentHeight / contentHeight;
    const newViewBoxWidth = originalViewBox.width * widthRatio;
    const newViewBoxHeight = originalViewBox.height * heightRatio;
    
    svg.setAttribute("viewBox", `${originalViewBox.x} ${originalViewBox.y} ${newViewBoxWidth} ${newViewBoxHeight}`);
    
    // Ensure the SVG dimensions match
    svg.setAttribute("width", newWidth);
    svg.setAttribute("height", newContentHeight);
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// Improved drag handle functionality
dragHandle.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  // Get canvas and container dimensions
  const canvasRect = canvas.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  
  // Calculate the offset of the mouse cursor relative to the container
  const offsetX = e.clientX - containerRect.left;
  const offsetY = e.clientY - containerRect.top;
  
  let isDragging = false;
  
  function onMouseMove(e) {
    isDragging = true;
    
    // Calculate the new position relative to the canvas
    let newLeft = e.clientX - offsetX - canvasRect.left;
    let newTop = e.clientY - offsetY - canvasRect.top;
    
    // Apply boundaries
    const minLeft = 0;
    const maxLeft = canvasRect.width - containerRect.width;
    const minTop = -10; // Allow small overlap at top
    const maxTop = canvasRect.height - containerRect.height;
    
    newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
    newTop = Math.min(Math.max(newTop, minTop), maxTop);
    
    // Apply the new position directly
    container.style.left = newLeft + "px";
    container.style.top = newTop + "px";
  }
  
  function onMouseUp() {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    
    if (isDragging && typeof ignoreNextClick !== 'undefined') {
      ignoreNextClick = true;
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// Delete button events
deleteButton.addEventListener("mousedown", function(e) {
  e.preventDefault();
  e.stopPropagation();
  deleteParallelogram();
});

deleteButton.addEventListener("click", function(e) {
  e.preventDefault();
  e.stopPropagation();
  deleteParallelogram();
});

// Activate on mousedown (unless target is drag/resize or a vertex point)
container.addEventListener("mousedown", function(e) {
  // If there's a locked element that's not this one, do nothing
  if (window.focusLockManager.isLocked() && 
      !window.focusLockManager.isLockedElement(container)) {
    // Let the global event handler handle this
    return;
  }
  
  // Don't activate if clicking on specific interactive elements
  const isVertex = e.target === topLeftPoint || e.target === topRightPoint || 
                  e.target === bottomLeftPoint || e.target === bottomRightPoint;
  
  if (e.target !== dragHandle && e.target !== resizeHandle && !isVertex) {
    activateParallelogram();
  }
});

// Handle hiding of controls globally if this was in the original code
if (typeof hideAllControls === 'function') {
  document.addEventListener("click", function(e) {
    if (!container.contains(e.target)) {
      hideAllControls();
    }
  });
}

// Document click for deactivation
document.addEventListener("click", function(e) {
  const globalToolbar = document.getElementById("global-toolbar");
  const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
  
  // Only deactivate if not focus-locked and clicked outside
  if (!container.contains(e.target) && 
      !clickedInGlobalToolbar && 
      window.activeParallelogramElement === container && 
      !window.focusLockManager.isLockedElement(container)) {
    deactivateParallelogram();
  }
});

// Initial update and activation
updateVertexAppearance();
activateParallelogram();

// Store original z-index if using z-index management from original code
if (container.style.zIndex) {
  container.dataset.originalZ = container.style.zIndex;
}

// Append container to the canvas
canvas.appendChild(container);
}

// --- addSemicircle function ---
function addSemicircle() {
  // Get the canvas element (problem image container)
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;
  let svgSize = 150;         // initial width of the semicircle container
  let drawSize = svgSize * 0.5; // drawing area height

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("semicircle") ? "Semicircle " : element.className.includes("polygon") ? "Polygon " : "Triangle ") + element.semicircleID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeSemicircleElement) {
    window.activeSemicircleElement = null;
  }
  
  // Global counter for semicircle IDs
  if (!window.globalSemicircleCounter) {
    window.globalSemicircleCounter = 1;
  } else {
    window.globalSemicircleCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element semicircle-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = svgSize + "px";
  container.style.height = (toolbarHeight + drawSize) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;
  container.isDragging = false;
  
  // Assign an ID for this semicircle
  container.semicircleID = window.globalSemicircleCounter;
  
  // Initialize state properties
  container.centerVisibility = true;
  container.strokeColor = "#000000";
  container.fillColor = "transparent";
  container.lineThickness = 2;

  // Create the toolbar (visible by default)
  const localToolbar = document.createElement("div");
  localToolbar.className = "semicircle-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "semicircle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = drawSize + "px";
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create SVG
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", svgSize);
  svg.setAttribute("height", drawSize);
  svg.setAttribute("viewBox", `0 0 ${svgSize} ${drawSize}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // We'll add a small top offset so the stroke isn't clipped.
  const topOffset = 2;

  // Create the semicircular path
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  // Initial drawing
  const initialInnerMargin = drawSize * 0.1;
  const initialXStart = initialInnerMargin;
  const initialXEnd = svgSize - initialInnerMargin;
  const initialArcRadius = (svgSize - 2 * initialInnerMargin) / 2;
  const initialYFlat = drawSize - initialInnerMargin + topOffset;
  const initialD = `M ${initialXStart},${initialYFlat} A ${initialArcRadius},${initialArcRadius} 0 0,1 ${initialXEnd},${initialYFlat} L ${initialXStart},${initialYFlat} Z`;
  path.setAttribute("d", initialD);
  path.setAttribute("stroke", container.strokeColor);
  path.setAttribute("stroke-width", container.lineThickness);
  path.setAttribute("fill", container.fillColor);
  svg.appendChild(path);

  // Create a center marker
  const centerMarker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  centerMarker.setAttribute("cx", (initialXStart + initialXEnd) / 2);
  centerMarker.setAttribute("cy", initialYFlat);
  centerMarker.setAttribute("r", 5);
  centerMarker.setAttribute("fill", container.strokeColor);
  svg.appendChild(centerMarker);

  // Create radius line (optional additional feature)
  const radiusLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  radiusLine.setAttribute("x1", (initialXStart + initialXEnd) / 2);
  radiusLine.setAttribute("y1", initialYFlat);
  radiusLine.setAttribute("x2", (initialXStart + initialXEnd) / 2);
  radiusLine.setAttribute("y2", initialYFlat - initialArcRadius);
  radiusLine.setAttribute("stroke", container.strokeColor);
  radiusLine.setAttribute("stroke-width", container.lineThickness);
  radiusLine.setAttribute("stroke-dasharray", "4,4");
  radiusLine.style.display = "none"; // Hidden by default
  svg.appendChild(radiusLine);

  // Create apothem line (optional additional feature)
  const apothemLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  apothemLine.setAttribute("x1", (initialXStart + initialXEnd) / 2);
  apothemLine.setAttribute("y1", initialYFlat);
  apothemLine.setAttribute("x2", (initialXStart + initialXEnd) / 2);
  apothemLine.setAttribute("y2", initialYFlat - initialArcRadius);
  apothemLine.setAttribute("stroke", container.strokeColor);
  apothemLine.setAttribute("stroke-width", container.lineThickness);
  apothemLine.style.display = "none"; // Hidden by default
  svg.appendChild(apothemLine);

  // Function to draw the semicircle with extra inner margin
  function drawSemicircle() {
    const currentWidth = parseFloat(svg.getAttribute("width"));
    const currentHeight = parseFloat(svg.getAttribute("height")); // equals drawSize
    const innerMargin = currentHeight * 0.1;
    const xStart = innerMargin;
    const xEnd = currentWidth - innerMargin;
    const arcRadius = (currentWidth - 2 * innerMargin) / 2;
    // Shift the arc downward by topOffset
    const yFlat = currentHeight - innerMargin + topOffset;
    const d = `M ${xStart},${yFlat} A ${arcRadius},${arcRadius} 0 0,1 ${xEnd},${yFlat} L ${xStart},${yFlat} Z`;
    path.setAttribute("d", d);
    
    // Place the center marker at the horizontal center and at yFlat
    const centerX = (xStart + xEnd) / 2;
    centerMarker.setAttribute("cx", centerX);
    centerMarker.setAttribute("cy", yFlat);
    
    // Update radius line
    radiusLine.setAttribute("x1", centerX);
    radiusLine.setAttribute("y1", yFlat);
    radiusLine.setAttribute("x2", centerX);
    radiusLine.setAttribute("y2", yFlat - arcRadius);
    
    // Update apothem line
    apothemLine.setAttribute("x1", centerX);
    apothemLine.setAttribute("y1", yFlat);
    apothemLine.setAttribute("x2", centerX);
    apothemLine.setAttribute("y2", yFlat - arcRadius);
  }

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }
  
  function getShowCenter() {
    return container.centerVisibility;
  }

  // Update line thickness for all stroke elements
  function updateLineThickness() {
    path.setAttribute("stroke-width", container.lineThickness);
    radiusLine.setAttribute("stroke-width", container.lineThickness);
    apothemLine.setAttribute("stroke-width", container.lineThickness);
  }

  // Utility to apply center marker visibility
  function applyCenterVisibility() {
    const showCenter = getShowCenter();
    centerMarker.style.display = showCenter ? "block" : "none";
  }

  // Update global toolbar with semicircle controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Semicircle " + container.semicircleID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      path.setAttribute("stroke", this.value);
      centerMarker.setAttribute("fill", this.value);
      radiusLine.setAttribute("stroke", this.value);
      apothemLine.setAttribute("stroke", this.value);
    });
    row1.appendChild(lineColorInput);

    // Fill color control
    const fillLabel = document.createElement("span");
    fillLabel.textContent = "Fill:";
    fillLabel.style.fontSize = "12px";
    row1.appendChild(fillLabel);

    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor() === "transparent" ? "#ffffff" : getFillColor();
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.fillColor = this.value;
      path.setAttribute("fill", this.value);
    });
    row1.appendChild(fillColorInput);

    // Center visibility control
    const centerVisLabel = document.createElement("span");
    centerVisLabel.textContent = "Show Center:";
    centerVisLabel.style.fontSize = "12px";
    row1.appendChild(centerVisLabel);

    const centerSelect = document.createElement("select");
    centerSelect.id = "center-visibility-" + container.semicircleID;
    centerSelect.style.marginLeft = "5px";
    centerSelect.style.fontSize = "12px";
    
    const optYes = document.createElement("option");
    optYes.value = "yes";
    optYes.textContent = "Yes";
    const optNo = document.createElement("option");
    optNo.value = "no";
    optNo.textContent = "No";
    
    centerSelect.appendChild(optYes);
    centerSelect.appendChild(optNo);
    centerSelect.value = container.centerVisibility ? "yes" : "no";
    centerSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    centerSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    centerSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      const showCenter = this.value === "yes";
      container.centerVisibility = showCenter;
      applyCenterVisibility();
    });
    row1.appendChild(centerSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "20px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.lineThickness = parseInt(this.value);
      updateLineThickness();
    });
    row2.appendChild(thicknessInput);

    // Spacer
    const spacer = document.createElement("div");
    spacer.style.width = "20px";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.marginLeft = "10px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  function activateSemicircle() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Store reference to the previously active element if it exists
    if (typeof activeElement !== 'undefined' && activeElement && activeElement !== container) {
      // If using the temporary raise function from the original code
      if (typeof restoreElementZIndex === 'function' && activeElement.dataset.tempRaised) {
        restoreElementZIndex(activeElement);
      }
      
      // Handle toolbar of the previous element
      if (activeElement.querySelector(".element-controls")) {
        activeElement.querySelector(".element-controls").style.display = "none";
      }
    }
    
    if (window.activeSemicircleElement && window.activeSemicircleElement !== container) {
      // Reset previous element's appearance
      window.activeSemicircleElement.style.border = "none";
      const prevToolbar = window.activeSemicircleElement.querySelector(".semicircle-toolbar");
      const prevResizeHandle = window.activeSemicircleElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeSemicircleElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    
    // Use the raise function from the original code if available
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  function deactivateSemicircle() {
    // Don't deactivate if this element has focus lock
    if (window.activeSemicircleElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeSemicircleElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteSemicircle() {
    if (window.activeSemicircleElement === container) {
      window.activeSemicircleElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Create resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  // Resize handler
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = parseFloat(container.style.width) || svgSize;
    
    function onMouseMove(e) {
      let newWidth = startWidth + (e.clientX - startX);
      if (newWidth < 50) newWidth = 50;
      let newDrawSize = newWidth * 0.5;
      
      container.style.width = newWidth + "px";
      container.style.height = (toolbarHeight + newDrawSize) + "px";
      content.style.width = newWidth + "px";
      content.style.height = newDrawSize + "px";
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newDrawSize);
      svg.setAttribute("viewBox", `0 0 ${newWidth} ${newDrawSize}`);
      drawSemicircle();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries:
      // The container's left edge should not go left of the canvas (minLeft = 0)
      // The container's right edge should not exceed the canvas's right side
      // The container's top edge cannot go more than 10px above the canvas (minTop = -10)
      // The container's bottom edge should not go below the canvas.
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      
      if (container.isDragging && typeof ignoreNextClick !== 'undefined') {
        ignoreNextClick = true;
      }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Delete: both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteSemicircle();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteSemicircle();
  });

  // Activate on mousedown
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateSemicircle();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeSemicircleElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivateSemicircle();
    }
  });
  
  // Initial setup
  container.style.border = "1px dashed #ccc";
  applyCenterVisibility();

  // Store original z-index if using z-index management
  if (container.style.zIndex) {
    container.dataset.originalZ = container.style.zIndex;
  }

  // Append to canvas and set as active
  canvas.appendChild(container);
  activateSemicircle();
}

// If the fill color is the snippet's default (#add8e6), use the snippet's three-face colors.
// Otherwise, use a single uniform color for all faces.
function getPrismFillColors(baseFill) {
  if (baseFill.toLowerCase() === "#add8e6") {
    return {
      front: "#add8e6",
      top: "#87cefa",
      side: "#6495ed"
    };
  } else {
    return {
      front: baseFill,
      top: baseFill,
      side: baseFill
    };
  }
}


function addTriangularPrism() {
  // --- Local helper functions for color manipulation ---
  function lightenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r + (255 - r) * percent);
    g = Math.floor(g + (255 - g) * percent);
    b = Math.floor(b + (255 - b) * percent);
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }
  
  function darkenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r * (1 - percent));
    g = Math.floor(g * (1 - percent));
    b = Math.floor(b * (1 - percent));
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }

  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let logicalWidth = 300, logicalHeight = 200;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("prism") ? "Prism " : element.className.includes("sphere") ? "Sphere " : "Element ") + element.prismID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeTriangularPrismElement) {
    window.activeTriangularPrismElement = null;
  }
  
  // Global counter for triangular prism IDs
  if (!window.globalTriangularPrismCounter) {
    window.globalTriangularPrismCounter = 1;
  } else {
    window.globalTriangularPrismCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element prism-container triangular-prism";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = logicalWidth + "px";
  container.style.height = (toolbarHeight + logicalHeight) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;
  container.isDragging = false;
  
  // Assign an ID for this triangular prism
  container.prismID = window.globalTriangularPrismCounter;
  
  // Initialize state properties
  container.strokeColor = "#000000";
  container.fillColor = "#add8e6";
  container.fillType = "color"; // "none" or "color"
  container.fillStyle = "gradient"; // "solid" or "gradient"
  container.prismType = "solid"; // "solid" or "xray"
  container.lineThickness = 2;
  container.showAltitude = "no"; // Initialize altitude state to "no"

  // Create the local toolbar (simplified with only move handle and delete button)
  const localToolbar = document.createElement("div");
  localToolbar.className = "prism-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px"; // Single row toolbar
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Initially hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle (left side)
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button (right side)
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Content area.
  const content = document.createElement("div");
  content.className = "prism-content";
  content.style.position = "relative";
  content.style.width = "100%";
  content.style.height = logicalHeight + "px";
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG element.
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", logicalWidth);
  svg.setAttribute("height", logicalHeight);
  svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // --- Define initial geometry.
  // Front face triangle: points a, b, and c.
  // a: bottom left, b: top, c: bottom right.
  let frontTriangle = {
    a: { x: 50, y: 150 },  // Moved up from y: 200
    b: { x: 100, y: 50 },  // Moved up from y: 100
    c: { x: 150, y: 150 }, // Moved up from y: 200
    // c₁: back position for vertex c (depth control marker)
    c1: { x: 190, y: 110 } // Moved up from y: 160
  };

  // --- Create SVG elements for the faces.
  // Front face: triangle (a, b, c)
  const frontFace = document.createElementNS(svgNS, "polygon");
  frontFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(frontFace);
  
  // Side face: parallelogram (b, c, c₁, b₂)
  const sideFace = document.createElementNS(svgNS, "polygon");
  sideFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(sideFace);

  // X-ray mode dotted lines
  let dottedLine_a_a2, dottedLine_a2_c1, dottedLine_a2_b2;
  
  // Altitude line and right angle symbol
  let altitudeLine, rightAngleSymbol;

  // Create markers for front triangle vertices
  const markers = [];
  const vertexKeys = ["a", "b", "c"];
  
  // Create markers for a, b, and c
  for (let i = 0; i < 3; i++) {
    const marker = document.createElement("div");
    marker.className = "prism-marker";
    marker.style.position = "absolute";
    marker.style.width = "10px";
    marker.style.height = "10px";
    marker.style.backgroundColor = container.strokeColor;
    marker.style.borderRadius = "50%";
    marker.style.cursor = "move";
    marker.style.zIndex = "100";
    marker.style.display = "none"; // Initially hidden
    marker.dataset.index = i.toString();
    content.appendChild(marker);
    markers.push(marker);
  }

  // Create marker for depth control: c₁
  const markerC1 = document.createElement("div");
  markerC1.className = "prism-marker depth-marker";
  markerC1.style.position = "absolute";
  markerC1.style.width = "10px";
  markerC1.style.height = "10px";
  markerC1.style.backgroundColor = container.strokeColor;
  markerC1.style.borderRadius = "50%";
  markerC1.style.cursor = "move";
  markerC1.style.zIndex = "100";
  markerC1.style.display = "none"; // Initially hidden
  content.appendChild(markerC1);
  markers.push(markerC1);

  // Create resize handle
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Initially hidden
  container.appendChild(resizeHandle);

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getFillType() {
    return container.fillType;
  }
  
  function getFillStyle() {
    return container.fillStyle;
  }
  
  function getPrismType() {
    return container.prismType;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }
  
  function getShowAltitude() {
    return container.showAltitude;
  }

  // Helper functions for triangle geometry
  function getOffset() {
    return {
      dx: frontTriangle.c1.x - frontTriangle.c.x,
      dy: frontTriangle.c1.y - frontTriangle.c.y
    };
  }
  
  function getBackPoints() {
    const offset = getOffset();
    return {
      a2: { x: frontTriangle.a.x + offset.dx, y: frontTriangle.a.y + offset.dy },
      b2: { x: frontTriangle.b.x + offset.dx, y: frontTriangle.b.y + offset.dy }
    };
  }
  
  function clampFrontTriangle() {
    for (let key of ["a", "b", "c", "c1"]) {
      frontTriangle[key].x = Math.max(0, Math.min(frontTriangle[key].x, logicalWidth));
      frontTriangle[key].y = Math.max(0, Math.min(frontTriangle[key].y, logicalHeight));
    }
  }
  
  // Calculate the position of the altitude base
  function calculateAltitudeBase() {
    const a = frontTriangle.a;
    const c = frontTriangle.c;
    const b = frontTriangle.b;
    
    // Calculate the base position
    const baseX = a.x + ((c.x - a.x) * ((b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y))) / 
                ((c.x - a.x) * (c.x - a.x) + (c.y - a.y) * (c.y - a.y));
    
    const baseY = a.y + ((c.y - a.y) * ((b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y))) / 
                ((c.x - a.x) * (c.x - a.x) + (c.y - a.y) * (c.y - a.y));
    
    return { x: baseX, y: baseY };
  }

  // Function to update the triangular prism drawing
  function updatePrismDrawing() {
    clampFrontTriangle();
    const back = getBackPoints();
    
    let fills;
    // Check if "No Fill" is selected
    if (getFillType() === "none") {
      fills = { front: "none", side: "none" };
    } else if (getFillStyle() === "gradient") {
      fills = {
        front: getFillColor(),
        side: darkenColor(getFillColor(), 0.2)
      };
    } else {
      fills = { 
        front: getFillColor(), 
        side: getFillColor() 
      };
    }
    
    const strokeCol = getStrokeColor();
    const lineThickness = getLineThickness();
    
    // Draw front face (triangle a, b, c)
    frontFace.setAttribute("points", `${frontTriangle.a.x},${frontTriangle.a.y} ${frontTriangle.b.x},${frontTriangle.b.y} ${frontTriangle.c.x},${frontTriangle.c.y}`);
    frontFace.setAttribute("fill", fills.front);
    frontFace.setAttribute("stroke", strokeCol);
    frontFace.setAttribute("stroke-width", lineThickness);
    
    // Draw side face (parallelogram: b, c, c₁, b₂)
    sideFace.setAttribute("points", `${frontTriangle.b.x},${frontTriangle.b.y} ${frontTriangle.c.x},${frontTriangle.c.y} ${frontTriangle.c1.x},${frontTriangle.c1.y} ${back.b2.x},${back.b2.y}`);
    sideFace.setAttribute("fill", fills.side);
    sideFace.setAttribute("stroke", strokeCol);
    sideFace.setAttribute("stroke-width", lineThickness);
    
    // In x‑ray mode, add dotted edges
    if (getPrismType() === "xray") {
      // Edge from a to a₂
      if (!dottedLine_a_a2) {
        dottedLine_a_a2 = document.createElementNS(svgNS, "line");
        dottedLine_a_a2.classList.add("dotted-edge");
        svg.appendChild(dottedLine_a_a2);
      }
      dottedLine_a_a2.setAttribute("x1", frontTriangle.a.x);
      dottedLine_a_a2.setAttribute("y1", frontTriangle.a.y);
      dottedLine_a_a2.setAttribute("x2", back.a2.x);
      dottedLine_a_a2.setAttribute("y2", back.a2.y);
      dottedLine_a_a2.setAttribute("stroke", strokeCol);
      dottedLine_a_a2.setAttribute("stroke-width", lineThickness);
      dottedLine_a_a2.setAttribute("stroke-dasharray", "4,2");
      dottedLine_a_a2.style.display = "inline";
      
      // Edge from a₂ to c₁
      if (!dottedLine_a2_c1) {
        dottedLine_a2_c1 = document.createElementNS(svgNS, "line");
        dottedLine_a2_c1.classList.add("dotted-edge");
        svg.appendChild(dottedLine_a2_c1);
      }
      dottedLine_a2_c1.setAttribute("x1", back.a2.x);
      dottedLine_a2_c1.setAttribute("y1", back.a2.y);
      dottedLine_a2_c1.setAttribute("x2", frontTriangle.c1.x);
      dottedLine_a2_c1.setAttribute("y2", frontTriangle.c1.y);
      dottedLine_a2_c1.setAttribute("stroke", strokeCol);
      dottedLine_a2_c1.setAttribute("stroke-width", lineThickness);
      dottedLine_a2_c1.setAttribute("stroke-dasharray", "4,2");
      dottedLine_a2_c1.style.display = "inline";
      
      // Edge from a₂ to b₂
      if (!dottedLine_a2_b2) {
        dottedLine_a2_b2 = document.createElementNS(svgNS, "line");
        dottedLine_a2_b2.classList.add("dotted-edge");
        svg.appendChild(dottedLine_a2_b2);
      }
      dottedLine_a2_b2.setAttribute("x1", back.a2.x);
      dottedLine_a2_b2.setAttribute("y1", back.a2.y);
      dottedLine_a2_b2.setAttribute("x2", back.b2.x);
      dottedLine_a2_b2.setAttribute("y2", back.b2.y);
      dottedLine_a2_b2.setAttribute("stroke", strokeCol);
      dottedLine_a2_b2.setAttribute("stroke-width", lineThickness);
      dottedLine_a2_b2.setAttribute("stroke-dasharray", "4,2");
      dottedLine_a2_b2.style.display = "inline";
    } else {
      // Remove extra dashed lines if not in x‑ray mode
      if (dottedLine_a_a2) dottedLine_a_a2.style.display = "none";
      if (dottedLine_a2_c1) dottedLine_a2_c1.style.display = "none";
      if (dottedLine_a2_b2) dottedLine_a2_b2.style.display = "none";
    }
    
    // Update altitude drawing based on showAltitude state
    if (getShowAltitude() === "yes") {
      const basePoint = calculateAltitudeBase();
      
      // Create altitude line if not exists
      if (!altitudeLine) {
        altitudeLine = document.createElementNS(svgNS, "line");
        altitudeLine.classList.add("altitude-line");
        svg.appendChild(altitudeLine);
      }
      
      // Set altitude line attributes
      altitudeLine.setAttribute("x1", frontTriangle.b.x);
      altitudeLine.setAttribute("y1", frontTriangle.b.y);
      altitudeLine.setAttribute("x2", basePoint.x);
      altitudeLine.setAttribute("y2", basePoint.y);
      altitudeLine.setAttribute("stroke", strokeCol);
      altitudeLine.setAttribute("stroke-width", lineThickness);
      altitudeLine.setAttribute("stroke-dasharray", "3,3");
      altitudeLine.style.display = "inline";
      
      // Create right angle symbol if not exists
      if (!rightAngleSymbol) {
        rightAngleSymbol = document.createElementNS(svgNS, "path");
        rightAngleSymbol.classList.add("right-angle-symbol");
        svg.appendChild(rightAngleSymbol);
      }
      
      // Calculate right angle symbol size (about 10% of the altitude length)
      const symbolSize = Math.max(8, Math.sqrt(
        Math.pow(frontTriangle.b.x - basePoint.x, 2) + 
        Math.pow(frontTriangle.b.y - basePoint.y, 2)
      ) * 0.1);
      
      // Calculate direction along base line
      const baseDir = {
        x: frontTriangle.c.x - frontTriangle.a.x,
        y: frontTriangle.c.y - frontTriangle.a.y
      };
      const baseDirLength = Math.sqrt(baseDir.x * baseDir.x + baseDir.y * baseDir.y);
      const baseDirNorm = {
        x: baseDir.x / baseDirLength,
        y: baseDir.y / baseDirLength
      };
      
      // Calculate direction along altitude
      const altDir = {
        x: frontTriangle.b.x - basePoint.x,
        y: frontTriangle.b.y - basePoint.y
      };
      const altDirLength = Math.sqrt(altDir.x * altDir.x + altDir.y * altDir.y);
      const altDirNorm = {
        x: altDir.x / altDirLength,
        y: altDir.y / altDirLength
      };
      
      // Calculate right angle symbol points
      const ra1 = {
        x: basePoint.x + baseDirNorm.x * symbolSize,
        y: basePoint.y + baseDirNorm.y * symbolSize
      };
      const ra2 = {
        x: basePoint.x + baseDirNorm.x * symbolSize + altDirNorm.x * symbolSize,
        y: basePoint.y + baseDirNorm.y * symbolSize + altDirNorm.y * symbolSize
      };
      const ra3 = {
        x: basePoint.x + altDirNorm.x * symbolSize,
        y: basePoint.y + altDirNorm.y * symbolSize
      };
      
      // Draw right angle symbol
      rightAngleSymbol.setAttribute("d", `M${basePoint.x},${basePoint.y} L${ra1.x},${ra1.y} L${ra2.x},${ra2.y} L${ra3.x},${ra3.y} Z`);
      rightAngleSymbol.setAttribute("fill", "none");
      rightAngleSymbol.setAttribute("stroke", strokeCol);
      rightAngleSymbol.setAttribute("stroke-width", lineThickness * 0.75);
      rightAngleSymbol.style.display = "inline";
    } else {
      // Hide altitude elements if not needed
      if (altitudeLine) altitudeLine.style.display = "none";
      if (rightAngleSymbol) rightAngleSymbol.style.display = "none";
    }
    
    // Update marker colors
    markers.forEach(marker => marker.style.backgroundColor = strokeCol);
    updateMarkers();
  }

  // Function to update marker positions
  function updateMarkers() {
    const actualWidth = svg.clientWidth;
    const actualHeight = svg.clientHeight;
    
    // Update markers for a, b, c
    for (let i = 0; i < 3; i++) {
      const pt = frontTriangle[vertexKeys[i]];
      const pixelX = (pt.x / logicalWidth) * actualWidth;
      const pixelY = (pt.y / logicalHeight) * actualHeight;
      markers[i].style.left = (pixelX - 5) + "px";
      markers[i].style.top = (pixelY - 5) + "px";
    }
    
    // Update marker for c1 (depth control)
    const c1PixelX = (frontTriangle.c1.x / logicalWidth) * actualWidth;
    const c1PixelY = (frontTriangle.c1.y / logicalHeight) * actualHeight;
    markers[3].style.left = (c1PixelX - 5) + "px";
    markers[3].style.top = (c1PixelY - 5) + "px";
  }
  
  // Update global toolbar with triangular prism controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Triangular Prism " + container.prismID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      updatePrismDrawing();
    });
    row1.appendChild(lineColorInput);

    // Fill type control
    const fillTypeLabel = document.createElement("span");
    fillTypeLabel.textContent = "Fill:";
    fillTypeLabel.style.fontSize = "12px";
    row1.appendChild(fillTypeLabel);

    const fillTypeSelect = document.createElement("select");
    fillTypeSelect.style.marginLeft = "5px";
    fillTypeSelect.style.marginRight = "10px";
    
    const noneOpt = document.createElement("option");
    noneOpt.value = "none";
    noneOpt.textContent = "No Fill";
    
    const colorOpt = document.createElement("option");
    colorOpt.value = "color";
    colorOpt.textContent = "Color";
    
    fillTypeSelect.appendChild(noneOpt);
    fillTypeSelect.appendChild(colorOpt);
    fillTypeSelect.value = getFillType();
    
    fillTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.fillType = this.value;
      if (this.value === "none") {
        fillColorInput.disabled = true;
        fillStyleSelect.disabled = true;
      } else {
        fillColorInput.disabled = false;
        fillStyleSelect.disabled = false;
      }
      updatePrismDrawing();
    });
    row1.appendChild(fillTypeSelect);

    // Fill color control
    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor();
    fillColorInput.disabled = getFillType() === "none";
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.fillColor = this.value;
      updatePrismDrawing();
    });
    row1.appendChild(fillColorInput);

    // Fill style control 
    const fillStyleLabel = document.createElement("span");
    fillStyleLabel.textContent = "Fill Style:";
    fillStyleLabel.style.fontSize = "12px";
    row1.appendChild(fillStyleLabel);

    const fillStyleSelect = document.createElement("select");
    fillStyleSelect.style.marginLeft = "5px";
    fillStyleSelect.disabled = getFillType() === "none";
    
    const solidOpt = document.createElement("option");
    solidOpt.value = "solid";
    solidOpt.textContent = "Solid";
    
    const gradientOpt = document.createElement("option");
    gradientOpt.value = "gradient";
    gradientOpt.textContent = "Gradient";
    
    fillStyleSelect.appendChild(solidOpt);
    fillStyleSelect.appendChild(gradientOpt);
    fillStyleSelect.value = getFillStyle();
    
    fillStyleSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillStyleSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    fillStyleSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.fillStyle = this.value;
      updatePrismDrawing();
    });
    row1.appendChild(fillStyleSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "10px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.lineThickness = parseInt(this.value);
      updatePrismDrawing();
    });
    row2.appendChild(thicknessInput);
    
    // Prism type control
    const prismTypeLabel = document.createElement("span");
    prismTypeLabel.textContent = "Prism Type:";
    prismTypeLabel.style.fontSize = "12px";
    row2.appendChild(prismTypeLabel);

    const prismTypeSelect = document.createElement("select");
    prismTypeSelect.style.marginLeft = "5px";
    prismTypeSelect.style.marginRight = "10px";
    
    const solidPrismOpt = document.createElement("option");
    solidPrismOpt.value = "solid";
    solidPrismOpt.textContent = "Solid";
    
    const xrayOpt = document.createElement("option");
    xrayOpt.value = "xray";
    xrayOpt.textContent = "X-ray";
    
    prismTypeSelect.appendChild(solidPrismOpt);
    prismTypeSelect.appendChild(xrayOpt);
    prismTypeSelect.value = getPrismType();
    
    prismTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    prismTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    prismTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.prismType = this.value;
      updatePrismDrawing();
    });
    row2.appendChild(prismTypeSelect);
    
    // Add Draw Altitude control
    const altitudeLabel = document.createElement("span");
    altitudeLabel.textContent = "Draw Altitude:";
    altitudeLabel.style.fontSize = "12px";
    altitudeLabel.style.marginLeft = "10px";
    row2.appendChild(altitudeLabel);
    
    const altitudeSelect = document.createElement("select");
    altitudeSelect.style.marginLeft = "5px";
    altitudeSelect.style.marginRight = "10px";
    
    const noOpt = document.createElement("option");
    noOpt.value = "no";
    noOpt.textContent = "No";
    
    const yesOpt = document.createElement("option");
    yesOpt.value = "yes";
    yesOpt.textContent = "Yes";
    
    altitudeSelect.appendChild(noOpt);
    altitudeSelect.appendChild(yesOpt);
    altitudeSelect.value = getShowAltitude();
    
    altitudeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    altitudeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    altitudeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.showAltitude = this.value;
      updatePrismDrawing();
    });
    row2.appendChild(altitudeSelect);

    // Add spacer
    const spacer = document.createElement("div");
    spacer.style.flexGrow = "1";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  // Function to activate the triangular prism (make it the currently selected element)
  function activateTriangularPrism() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Reset previous active element if it exists
    if (window.activeTriangularPrismElement && window.activeTriangularPrismElement !== container) {
      // Reset previous element's appearance
      window.activeTriangularPrismElement.style.border = "none";
      const prevToolbar = window.activeTriangularPrismElement.querySelector(".prism-toolbar");
      const prevResizeHandle = window.activeTriangularPrismElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
      
      // Hide previous element's markers
      const prevMarkers = window.activeTriangularPrismElement.querySelectorAll(".prism-marker");
      prevMarkers.forEach(marker => marker.style.display = "none");
    }
    
    window.activeTriangularPrismElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    // Show all markers
    markers.forEach(marker => marker.style.display = "block");
    
    // Raise Z-index if that function exists
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  // Function to deactivate the triangular prism
  function deactivateTriangularPrism() {
    // Don't deactivate if this element has focus lock
    if (window.activeTriangularPrismElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      markers.forEach(marker => marker.style.display = "none");
      
      window.activeTriangularPrismElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteTriangularPrism() {
    if (window.activeTriangularPrismElement === container) {
      window.activeTriangularPrismElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // --- Event Handlers for Markers ---
  // Front triangle vertex markers dragging (a, b, c)
  for (let i = 0; i < 3; i++) {
    markers[i].addEventListener("mousedown", function(e) {
      e.stopPropagation();
      e.preventDefault();
      
      const index = parseInt(this.dataset.index);
      const markerRect = this.getBoundingClientRect();
      const offsetX = e.clientX - markerRect.left;
      const offsetY = e.clientY - markerRect.top;
      
      function onMouseMove(e) {
        const svgRect = svg.getBoundingClientRect();
        const scaleX = logicalWidth / svgRect.width;
        const scaleY = logicalHeight / svgRect.height;
        let newX = (e.clientX - offsetX - svgRect.left) * scaleX;
        let newY = (e.clientY - offsetY - svgRect.top) * scaleY;
        
        // Apply constraints for specific vertices
        if (index === 0) { // Vertex A
          newX = Math.min(newX, frontTriangle.b.x);
        }
        if (index === 1) { // Vertex B
          newX = Math.max(newX, frontTriangle.a.x);
        }
        
        frontTriangle[vertexKeys[index]].x = newX;
        frontTriangle[vertexKeys[index]].y = newY;
        
        updatePrismDrawing();
      }
      
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
  }

  // Depth control marker (c1) dragging
  markers[3].addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const markerRect = this.getBoundingClientRect();
    const offsetX = e.clientX - markerRect.left;
    const offsetY = e.clientY - markerRect.top;
    
    function onMouseMove(e) {
      const svgRect = svg.getBoundingClientRect();
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = logicalHeight / svgRect.height;
      let newX = (e.clientX - offsetX - svgRect.left) * scaleX;
      let newY = (e.clientY - offsetY - svgRect.top) * scaleY;
      
      // Apply constraints
      newX = Math.max(0, Math.min(newX, logicalWidth));
      newX = Math.max(newX, frontTriangle.c.x + (frontTriangle.b.x - frontTriangle.a.x));
      newX = Math.max(newX, frontTriangle.c.x);
      newY = Math.max(0, Math.min(newY, logicalHeight));
      newY = Math.min(newY, frontTriangle.c.y);
      
      frontTriangle.c1.x = newX;
      frontTriangle.c1.y = newY;
      
      updatePrismDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(150, startWidth + (e.clientX - startX));
      const newHeight = Math.max(100, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      content.style.width = newWidth + "px";
      content.style.height = (newHeight - toolbarHeight) + "px";
      
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newHeight - toolbarHeight);
      svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
      
      updatePrismDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Activate on mousedown
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle && 
        !markers.includes(e.target)) {
      activateTriangularPrism();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeTriangularPrismElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivateTriangularPrism();
    }
  });

  // Delete button handlers (both mousedown and click for reliability)
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteTriangularPrism();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteTriangularPrism();
  });
  
  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Initial setup
  container.style.border = "1px dashed #ccc";
  
  // Append to canvas and set as active
  canvas.appendChild(container);
  updatePrismDrawing();
  activateTriangularPrism();
}


function addSphere() {
  // --- Local helper functions for color manipulation ---
  function lightenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r + (255 - r) * percent);
    g = Math.floor(g + (255 - g) * percent);
    b = Math.floor(b + (255 - b) * percent);
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }

  function darkenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r * (1 - percent));
    g = Math.floor(g * (1 - percent));
    b = Math.floor(b * (1 - percent));
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }

  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let logicalWidth = 300, logicalHeight = 200;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("sphere") ? "Sphere " : element.className.includes("cylinder") ? "Cylinder " : "Element ") + element.sphereID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeSphereElement) {
    window.activeSphereElement = null;
  }
  
  // Global counter for sphere IDs
  if (!window.globalSphereCounter) {
    window.globalSphereCounter = 1;
  } else {
    window.globalSphereCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element sphere-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = logicalWidth + "px";
  container.style.height = logicalHeight + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;
  container.isDragging = false;
  
  // Assign an ID for this sphere
  container.sphereID = window.globalSphereCounter;
  
  // Initialize state properties
  container.centerVisibility = false;
  container.radiusVisibility = false;
  container.diameterVisibility = false;
  container.strokeColor = "#000000";
  container.fillColor = "#add8e6";
  container.fillType = "color"; // "none" or "color"
  container.shadingType = "gradient"; // "flat" or "gradient"
  container.sphereType = "solid"; // "solid" or "xray"
  container.lineThickness = 2;
  container.centerSize = 3;

  // Create the local toolbar (simplified with only move handle and delete button)
  const localToolbar = document.createElement("div");
  localToolbar.className = "sphere-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px"; // Single row toolbar
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Initially hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle (left side)
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button (right side)
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "sphere-content";
  content.style.position = "relative";
  content.style.width = "100%";
  content.style.height = (logicalHeight - toolbarHeight) + "px";
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", logicalWidth);
  svg.setAttribute("height", logicalHeight - toolbarHeight);
  svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight - toolbarHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Define sphere parameters
  let sphereParams = {
    centerX: logicalWidth / 2,
    centerY: (logicalHeight - toolbarHeight) / 2,
    radius: 60
  };

  // Create the sphere elements
  const sphereCircle = document.createElementNS(svgNS, "circle");
  sphereCircle.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(sphereCircle);

  // Create <defs> for gradients
  const defs = document.createElementNS(svgNS, "defs");
  svg.appendChild(defs);

  // Additional elements for visual features
  const radiusLine = document.createElementNS(svgNS, "line");
  radiusLine.setAttribute("stroke-width", container.lineThickness);
  radiusLine.setAttribute("stroke-dasharray", "4,2");
  radiusLine.style.display = "none";
  svg.appendChild(radiusLine);

  const diameterLine = document.createElementNS(svgNS, "line");
  diameterLine.setAttribute("stroke-width", container.lineThickness);
  diameterLine.setAttribute("stroke-dasharray", "4,2");
  diameterLine.style.display = "none";
  svg.appendChild(diameterLine);

  const centerPoint = document.createElementNS(svgNS, "circle");
  centerPoint.setAttribute("r", "3");
  centerPoint.style.display = "none";
  svg.appendChild(centerPoint);

  // X-ray outline split into two arcs
  const xrayOutlineTop = document.createElementNS(svgNS, "path");
  xrayOutlineTop.setAttribute("stroke-width", container.lineThickness);
  xrayOutlineTop.setAttribute("fill", "none");
  xrayOutlineTop.style.display = "none";
  svg.appendChild(xrayOutlineTop);

  const xrayOutlineBottom = document.createElementNS(svgNS, "path");
  xrayOutlineBottom.setAttribute("stroke-width", container.lineThickness);
  xrayOutlineBottom.setAttribute("fill", "none");
  xrayOutlineBottom.setAttribute("stroke-dasharray", "4,2");
  xrayOutlineBottom.style.display = "none";
  svg.appendChild(xrayOutlineBottom);

  // Create draggable markers
  const markers = [];

  // Marker for the center
  const centerMarker = document.createElement("div");
  centerMarker.className = "sphere-marker center-marker";
  centerMarker.style.position = "absolute";
  centerMarker.style.width = "10px";
  centerMarker.style.height = "10px";
  centerMarker.style.backgroundColor = container.strokeColor;
  centerMarker.style.borderRadius = "50%";
  centerMarker.style.cursor = "move";
  centerMarker.style.zIndex = "100";
  centerMarker.style.display = "none"; // Initially hidden
  content.appendChild(centerMarker);
  markers.push(centerMarker);

  // Marker for the radius
  const radiusMarker = document.createElement("div");
  radiusMarker.className = "sphere-marker radius-marker";
  radiusMarker.style.position = "absolute";
  radiusMarker.style.width = "10px";
  radiusMarker.style.height = "10px";
  radiusMarker.style.backgroundColor = container.strokeColor;
  radiusMarker.style.borderRadius = "50%";
  radiusMarker.style.cursor = "move";
  radiusMarker.style.zIndex = "100";
  radiusMarker.style.display = "none"; // Initially hidden
  content.appendChild(radiusMarker);
  markers.push(radiusMarker);

  // Create resize handle
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Initially hidden
  container.appendChild(resizeHandle);

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getFillType() {
    return container.fillType;
  }

  function getCenterSize() {
  return container.centerSize;
}
  
  function getShadingType() {
    return container.shadingType;
  }
  
  function getSphereType() {
    return container.sphereType;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }
  
  function getShowRadius() {
    return container.radiusVisibility;
  }
  
  function getShowDiameter() {
    return container.diameterVisibility;
  }
  
  function getShowCenter() {
    return container.centerVisibility;
  }

  // Helper function to clamp sphere parameters
  function clampSphereParams() {
    const minRadius = 10;
    const maxRadius = Math.min(logicalWidth, logicalHeight - toolbarHeight) / 2 - 10;
    
    sphereParams.centerX = Math.max(sphereParams.radius, Math.min(sphereParams.centerX, logicalWidth - sphereParams.radius));
    sphereParams.centerY = Math.max(sphereParams.radius, Math.min(sphereParams.centerY, (logicalHeight - toolbarHeight) - sphereParams.radius));
    sphereParams.radius = Math.max(minRadius, Math.min(sphereParams.radius, maxRadius));
  }

  // Function to update the sphere drawing
  function updateSphereDrawing() {
    clampSphereParams();
    
    const fillType = getFillType();
    const fill = fillType === "none" ? "none" : getFillColor();
    const strokeCol = getStrokeColor();
    const lineThickness = getLineThickness();
    
    // Main sphere circle
    sphereCircle.setAttribute("cx", sphereParams.centerX);
    sphereCircle.setAttribute("cy", sphereParams.centerY);
    sphereCircle.setAttribute("r", sphereParams.radius);
    sphereCircle.setAttribute("stroke", strokeCol);
    sphereCircle.setAttribute("stroke-width", lineThickness);
    
    // Apply fill and shading
    if (getShadingType() === "gradient" && fillType !== "none") {
      const gradientId = "sphereGradient" + container.sphereID;
      let gradient = document.getElementById(gradientId);
      
      if (!gradient) {
        gradient = document.createElementNS(svgNS, "radialGradient");
        gradient.setAttribute("id", gradientId);
        gradient.setAttribute("cx", "40%");
        gradient.setAttribute("cy", "40%");
        gradient.setAttribute("r", "70%");
        gradient.setAttribute("fx", "25%");
        gradient.setAttribute("fy", "25%");
        defs.appendChild(gradient);
      }
      
      gradient.innerHTML = "";
      
      const stopHighlight = document.createElementNS(svgNS, "stop");
      stopHighlight.setAttribute("offset", "0%");
      stopHighlight.setAttribute("stop-color", "#ffffff");
      gradient.appendChild(stopHighlight);
      
      const stopTransition = document.createElementNS(svgNS, "stop");
      stopTransition.setAttribute("offset", "20%");
      stopTransition.setAttribute("stop-color", lightenColor(fill, 0.7));
      gradient.appendChild(stopTransition);
      
      const stopMid = document.createElementNS(svgNS, "stop");
      stopMid.setAttribute("offset", "40%");
      stopMid.setAttribute("stop-color", fill);
      gradient.appendChild(stopMid);
      
      const stopDark = document.createElementNS(svgNS, "stop");
      stopDark.setAttribute("offset", "75%");
      stopDark.setAttribute("stop-color", darkenColor(fill, 0.3));
      gradient.appendChild(stopDark);
      
      const stopEdge = document.createElementNS(svgNS, "stop");
      stopEdge.setAttribute("offset", "95%");
      stopEdge.setAttribute("stop-color", darkenColor(fill, 0.6));
      gradient.appendChild(stopEdge);
      
      sphereCircle.setAttribute("fill", `url(#${gradientId})`);
    } else {
      sphereCircle.setAttribute("fill", fill);
    }
    
    // Update X-ray view if enabled
  // Update X-ray view if enabled - using original drawing approach
  if (getSphereType() === "xray") {
      // For X-ray mode, show BOTH the full circle AND the elliptical outline
      sphereCircle.style.display = "inline"; // Keep the main circle visible
      
      const rx = sphereParams.radius;
      const ry = sphereParams.radius * 0.3; // Vertical compression for ellipse effect
      const cx = sphereParams.centerX;
      const cy = sphereParams.centerY;
      
      // Top half of ellipse (now dashed line)
      xrayOutlineTop.setAttribute("d", `M ${cx - rx},${cy} A ${rx} ${ry} 0 0 1 ${cx + rx},${cy}`);
      xrayOutlineTop.setAttribute("stroke", strokeCol);
      xrayOutlineTop.setAttribute("stroke-width", lineThickness);
      xrayOutlineTop.setAttribute("stroke-dasharray", "4,2"); // Changed to dashed line for top half
      xrayOutlineTop.style.display = "inline";
      
      // Bottom half of ellipse (now solid line)
      xrayOutlineBottom.setAttribute("d", `M ${cx - rx},${cy} A ${rx} ${ry} 0 0 0 ${cx + rx},${cy}`);
      xrayOutlineBottom.setAttribute("stroke", strokeCol);
      xrayOutlineBottom.setAttribute("stroke-width", lineThickness);
      xrayOutlineBottom.removeAttribute("stroke-dasharray"); // Changed to solid line for bottom half
      xrayOutlineBottom.style.display = "inline";
    } else {
      // For regular solid sphere, just use the circle and hide the ellipse
      sphereCircle.style.display = "inline";
      xrayOutlineTop.style.display = "none";
      xrayOutlineBottom.style.display = "none";
    }
    // Draw toggles
    centerPoint.setAttribute("cx", sphereParams.centerX);
centerPoint.setAttribute("cy", sphereParams.centerY);
centerPoint.setAttribute("r", getCenterSize()); // Use the center size property
centerPoint.setAttribute("fill", strokeCol);
centerPoint.style.display = getShowCenter() ? "inline" : "none";
    
    radiusLine.setAttribute("x1", sphereParams.centerX);
    radiusLine.setAttribute("y1", sphereParams.centerY);
    radiusLine.setAttribute("x2", sphereParams.centerX + sphereParams.radius);
    radiusLine.setAttribute("y2", sphereParams.centerY);
    radiusLine.setAttribute("stroke", strokeCol);
    radiusLine.setAttribute("stroke-width", lineThickness);
    radiusLine.style.display = getShowRadius() ? "inline" : "none";
    
    diameterLine.setAttribute("x1", sphereParams.centerX - sphereParams.radius);
    diameterLine.setAttribute("y1", sphereParams.centerY);
    diameterLine.setAttribute("x2", sphereParams.centerX + sphereParams.radius);
    diameterLine.setAttribute("y2", sphereParams.centerY);
    diameterLine.setAttribute("stroke", strokeCol);
    diameterLine.setAttribute("stroke-width", lineThickness);
    diameterLine.style.display = getShowDiameter() ? "inline" : "none";
    
    // Update marker colors
    markers.forEach(marker => marker.style.backgroundColor = strokeCol);
    updateMarkers();
  }

  // Function to update marker positions
  function updateMarkers() {
    const actualWidth = content.clientWidth;
    const actualHeight = content.clientHeight;
    
    // Center marker
    const centerPixelX = (sphereParams.centerX / logicalWidth) * actualWidth;
    const centerPixelY = (sphereParams.centerY / (logicalHeight - toolbarHeight)) * actualHeight;
    centerMarker.style.left = (centerPixelX - 5) + "px";
    centerMarker.style.top = (centerPixelY - 5) + "px";
    
    // Radius marker
    const radiusPixelX = ((sphereParams.centerX + sphereParams.radius) / logicalWidth) * actualWidth;
    const radiusPixelY = (sphereParams.centerY / (logicalHeight - toolbarHeight)) * actualHeight;
    radiusMarker.style.left = (radiusPixelX - 5) + "px";
    radiusMarker.style.top = (radiusPixelY - 5) + "px";
  }
  
  // Update global toolbar with sphere controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Sphere " + container.sphereID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      updateSphereDrawing();
    });
    row1.appendChild(lineColorInput);

    // Fill type control
    const fillTypeLabel = document.createElement("span");
    fillTypeLabel.textContent = "Fill:";
    fillTypeLabel.style.fontSize = "12px";
    row1.appendChild(fillTypeLabel);

    const fillTypeSelect = document.createElement("select");
    fillTypeSelect.style.marginLeft = "5px";
    fillTypeSelect.style.marginRight = "10px";
    
    const noneOpt = document.createElement("option");
    noneOpt.value = "none";
    noneOpt.textContent = "No Fill";
    
    const colorOpt = document.createElement("option");
    colorOpt.value = "color";
    colorOpt.textContent = "Color";
    
    fillTypeSelect.appendChild(noneOpt);
    fillTypeSelect.appendChild(colorOpt);
    fillTypeSelect.value = getFillType();
    
    fillTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.fillType = this.value;
      if (this.value === "none") {
        fillColorInput.disabled = true;
        shadingSelect.disabled = true;
      } else {
        fillColorInput.disabled = false;
        shadingSelect.disabled = false;
      }
      updateSphereDrawing();
    });
    row1.appendChild(fillTypeSelect);

    // Fill color control
    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor();
    fillColorInput.disabled = getFillType() === "none";
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.fillColor = this.value;
      updateSphereDrawing();
    });
    row1.appendChild(fillColorInput);

    // Shading type control
    const shadingLabel = document.createElement("span");
    shadingLabel.textContent = "Shading:";
    shadingLabel.style.fontSize = "12px";
    row1.appendChild(shadingLabel);

    const shadingSelect = document.createElement("select");
    shadingSelect.style.marginLeft = "5px";
    shadingSelect.disabled = getFillType() === "none";
    
    const flatOpt = document.createElement("option");
    flatOpt.value = "flat";
    flatOpt.textContent = "Flat";
    
    const gradientOpt = document.createElement("option");
    gradientOpt.value = "gradient";
    gradientOpt.textContent = "Gradient";
    
    shadingSelect.appendChild(flatOpt);
    shadingSelect.appendChild(gradientOpt);
    shadingSelect.value = getShadingType();
    
    shadingSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    shadingSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    shadingSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.shadingType = this.value;
      updateSphereDrawing();
    });
    row1.appendChild(shadingSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "10px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.lineThickness = parseInt(this.value);
      updateSphereDrawing();
    });
    row2.appendChild(thicknessInput);

    const centerSizeLabel = document.createElement("span");
centerSizeLabel.textContent = "Center Size:";
centerSizeLabel.style.fontSize = "12px";
row2.appendChild(centerSizeLabel);

const centerSizeInput = document.createElement("input");
centerSizeInput.type = "number";
centerSizeInput.min = "1";
centerSizeInput.max = "20";
centerSizeInput.value = getCenterSize();
centerSizeInput.style.width = "40px";
centerSizeInput.style.marginLeft = "5px";
centerSizeInput.style.marginRight = "10px";
centerSizeInput.disabled = !getShowCenter(); // Disable if center is not shown
centerSizeInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
centerSizeInput.addEventListener("click", function(e) { e.stopPropagation(); });
centerSizeInput.addEventListener("input", function(e) {
  e.stopPropagation();
  container.centerSize = parseInt(this.value);
  updateSphereDrawing();
});
row2.appendChild(centerSizeInput);
    
    // Sphere type control
    const sphereTypeLabel = document.createElement("span");
    sphereTypeLabel.textContent = "Sphere Type:";
    sphereTypeLabel.style.fontSize = "12px";
    row2.appendChild(sphereTypeLabel);

    const sphereTypeSelect = document.createElement("select");
    sphereTypeSelect.style.marginLeft = "5px";
    sphereTypeSelect.style.marginRight = "10px";
    
    const solidOpt = document.createElement("option");
    solidOpt.value = "solid";
    solidOpt.textContent = "Solid";
    
    const xrayOpt = document.createElement("option");
    xrayOpt.value = "xray";
    xrayOpt.textContent = "X-ray";
    
    sphereTypeSelect.appendChild(solidOpt);
    sphereTypeSelect.appendChild(xrayOpt);
    sphereTypeSelect.value = getSphereType();
    
    sphereTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    sphereTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    sphereTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.sphereType = this.value;
      updateSphereDrawing();
    });
    row2.appendChild(sphereTypeSelect);
    
    // Features section: Radius, Diameter, Center
    // Radius visibility control
    const radiusVisLabel = document.createElement("span");
    radiusVisLabel.textContent = "Show Radius:";
    radiusVisLabel.style.fontSize = "12px";
    row2.appendChild(radiusVisLabel);

    const radiusVisSelect = document.createElement("select");
    radiusVisSelect.style.marginLeft = "5px";
    radiusVisSelect.style.marginRight = "10px";
    
    const radiusHideOpt = document.createElement("option");
    radiusHideOpt.value = "false";
    radiusHideOpt.textContent = "No";
    
    const radiusShowOpt = document.createElement("option");
    radiusShowOpt.value = "true";
    radiusShowOpt.textContent = "Yes";
    
    radiusVisSelect.appendChild(radiusHideOpt);
    radiusVisSelect.appendChild(radiusShowOpt);
    radiusVisSelect.value = getShowRadius() ? "true" : "false";
    
    radiusVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    radiusVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    radiusVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.radiusVisibility = this.value === "true";
      updateSphereDrawing();
    });
    row2.appendChild(radiusVisSelect);
    
    // Diameter visibility control
    const diameterVisLabel = document.createElement("span");
    diameterVisLabel.textContent = "Show Diameter:";
    diameterVisLabel.style.fontSize = "12px";
    row2.appendChild(diameterVisLabel);

    const diameterVisSelect = document.createElement("select");
    diameterVisSelect.style.marginLeft = "5px";
    diameterVisSelect.style.marginRight = "10px";
    
    const diameterHideOpt = document.createElement("option");
    diameterHideOpt.value = "false";
    diameterHideOpt.textContent = "No";
    
    const diameterShowOpt = document.createElement("option");
    diameterShowOpt.value = "true";
    diameterShowOpt.textContent = "Yes";
    
    diameterVisSelect.appendChild(diameterHideOpt);
    diameterVisSelect.appendChild(diameterShowOpt);
    diameterVisSelect.value = getShowDiameter() ? "true" : "false";
    
    diameterVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    diameterVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    diameterVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.diameterVisibility = this.value === "true";
      updateSphereDrawing();
    });
    row2.appendChild(diameterVisSelect);

    // Center visibility control
    const centerVisLabel = document.createElement("span");
    centerVisLabel.textContent = "Show Center:";
    centerVisLabel.style.fontSize = "12px";
    row2.appendChild(centerVisLabel);

    const centerVisSelect = document.createElement("select");
    centerVisSelect.style.marginLeft = "5px";
    centerVisSelect.style.marginRight = "10px";
    
    const centerHideOpt = document.createElement("option");
    centerHideOpt.value = "false";
    centerHideOpt.textContent = "No";
    
    const centerShowOpt = document.createElement("option");
    centerShowOpt.value = "true";
    centerShowOpt.textContent = "Yes";
    
    centerVisSelect.appendChild(centerHideOpt);
    centerVisSelect.appendChild(centerShowOpt);
    centerVisSelect.value = getShowCenter() ? "true" : "false";
    
    centerVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    centerVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    centerVisSelect.addEventListener("change", function(e) {
  e.stopPropagation();
  container.centerVisibility = this.value === "true";
  centerSizeInput.disabled = !container.centerVisibility; // Enable/disable size input based on visibility
  updateSphereDrawing();
});
    row2.appendChild(centerVisSelect);

    // Add spacer
    const spacer = document.createElement("div");
    spacer.style.flexGrow = "1";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  // Function to activate the sphere (make it the currently selected element)
  function activateSphere() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Reset previous active element if it exists
    if (window.activeSphereElement && window.activeSphereElement !== container) {
      // Reset previous element's appearance
      window.activeSphereElement.style.border = "none";
      const prevToolbar = window.activeSphereElement.querySelector(".sphere-toolbar");
      const prevResizeHandle = window.activeSphereElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
      
      // Hide previous element's markers
      const prevMarkers = window.activeSphereElement.querySelectorAll(".sphere-marker");
      prevMarkers.forEach(marker => marker.style.display = "none");
    }
    
    window.activeSphereElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    // Show all markers
    markers.forEach(marker => marker.style.display = "block");
    
    // Raise Z-index if that function exists
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  // Function to deactivate the sphere
  function deactivateSphere() {
    // Don't deactivate if this element has focus lock
    if (window.activeSphereElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      markers.forEach(marker => marker.style.display = "none");
      
      window.activeSphereElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteSphere() {
    if (window.activeSphereElement === container) {
      window.activeSphereElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // --- Event Handlers for Markers ---
  // Center marker drag
  centerMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const startCenterX = sphereParams.centerX;
    const startCenterY = sphereParams.centerY;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = (logicalHeight - toolbarHeight) / svgRect.height;
      const deltaX = (e.clientX - startX) * scaleX;
      const deltaY = (e.clientY - startY) * scaleY;
      
      sphereParams.centerX = startCenterX + deltaX;
      sphereParams.centerY = startCenterY + deltaY;
      
      updateSphereDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Radius marker drag
  radiusMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startRadius = sphereParams.radius;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const deltaX = (e.clientX - startX) * scaleX;
      
      const newRadius = Math.max(10, startRadius + deltaX);
      sphereParams.radius = newRadius;
      
      updateSphereDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(150, startWidth + (e.clientX - startX));
      const newHeight = Math.max(100, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      content.style.width = newWidth + "px";
      content.style.height = (newHeight - toolbarHeight) + "px";
      
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newHeight - toolbarHeight);
      svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight - toolbarHeight}`);
      
      updateSphereDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Activate on mousedown
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle && 
        !markers.includes(e.target)) {
      activateSphere();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeSphereElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivateSphere();
    }
  });

  // Delete button handlers (both mousedown and click for reliability)
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteSphere();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteSphere();
  });
  
  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Initial setup
  container.style.border = "1px dashed #ccc";
  
  // Append to canvas and set as active
  canvas.appendChild(container);
  updateSphereDrawing();
  activateSphere();
}


function addCylinder() {
  // --- Local helper functions for color manipulation ---
  function lightenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r + (255 - r) * percent);
    g = Math.floor(g + (255 - g) * percent);
    b = Math.floor(b + (255 - b) * percent);
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }
  
  function darkenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r * (1 - percent));
    g = Math.floor(g * (1 - percent));
    b = Math.floor(b * (1 - percent));
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }

  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;
  let logicalWidth = 300, logicalHeight = 200; // Logical coordinate space

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("cylinder") ? "Cylinder " : element.className.includes("polygon") ? "Polygon " : "Triangle ") + element.cylinderID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeCylinderElement) {
    window.activeCylinderElement = null;
  }
  
  // Global counter for cylinder IDs
  if (!window.globalCylinderCounter) {
    window.globalCylinderCounter = 1;
  } else {
    window.globalCylinderCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element cylinder-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = logicalWidth + "px";
  container.style.height = (toolbarHeight + logicalHeight) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;
  container.isDragging = false;
  
  // Assign an ID for this cylinder
  container.cylinderID = window.globalCylinderCounter;
  
  // Initialize state properties
  container.centerVisibility = false;
  container.radiusVisibility = false;
  container.diameterVisibility = false;
  container.strokeColor = "#000000";
  container.fillColor = "#add8e6";
  container.fillType = "color"; // "none" or "color"
  container.shadingType = "gradient"; // "flat" or "gradient"
  container.lineThickness = 2;

  // Create the local toolbar (simplified with only move handle and delete button)
  const localToolbar = document.createElement("div");
  localToolbar.className = "cylinder-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px"; // Single row toolbar
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle (left side)
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button (right side)
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "cylinder-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = logicalHeight + "px";
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", logicalWidth);
  svg.setAttribute("height", logicalHeight);
  svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Define cylinder default parameters
  let cylinderParams = {
    bottomX: logicalWidth / 2,
    topX: logicalWidth / 2,
    topY: 40,
    bottomY: logicalHeight - 40,
    radius: 60,
    ry: 18
  };

  // Create cylinder elements
  const sidePath = document.createElementNS(svgNS, "path");
  sidePath.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(sidePath);

  const topEllipse = document.createElementNS(svgNS, "ellipse");
  topEllipse.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(topEllipse);

  const bottomEllipse = document.createElementNS(svgNS, "ellipse");
  bottomEllipse.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(bottomEllipse);

  // Create <defs> for gradients
  const defs = document.createElementNS(svgNS, "defs");
  svg.appendChild(defs);

  // Additional features
  const radiusLine = document.createElementNS(svgNS, "line");
  radiusLine.setAttribute("stroke-width", container.lineThickness);
  radiusLine.setAttribute("stroke-dasharray", "4,2");
  radiusLine.style.display = "none";
  svg.appendChild(radiusLine);

  const diameterLine = document.createElementNS(svgNS, "line");
  diameterLine.setAttribute("stroke-width", container.lineThickness);
  diameterLine.setAttribute("stroke-dasharray", "4,2");
  diameterLine.style.display = "none";
  svg.appendChild(diameterLine);

  const centerPoint = document.createElementNS(svgNS, "circle");
  centerPoint.setAttribute("r", "3");
  centerPoint.style.display = "none";
  svg.appendChild(centerPoint);

  // Create draggable markers
  const markers = [];

  // Marker for the top ellipse center
  const topMarker = document.createElement("div");
  topMarker.className = "cylinder-marker top-marker";
  topMarker.style.position = "absolute";
  topMarker.style.width = "10px";
  topMarker.style.height = "10px";
  topMarker.style.backgroundColor = container.strokeColor;
  topMarker.style.borderRadius = "50%";
  topMarker.style.cursor = "move";
  topMarker.style.zIndex = "100";
  content.appendChild(topMarker);
  markers.push(topMarker);

  // Marker for the bottom ellipse center
  const bottomMarker = document.createElement("div");
  bottomMarker.className = "cylinder-marker bottom-marker";
  bottomMarker.style.position = "absolute";
  bottomMarker.style.width = "10px";
  bottomMarker.style.height = "10px";
  bottomMarker.style.backgroundColor = container.strokeColor;
  bottomMarker.style.borderRadius = "50%";
  bottomMarker.style.cursor = "move";
  bottomMarker.style.zIndex = "100";
  content.appendChild(bottomMarker);
  markers.push(bottomMarker);

  // Marker for the radius (attached to the top ellipse)
  const radiusMarker = document.createElement("div");
  radiusMarker.className = "cylinder-marker radius-marker";
  radiusMarker.style.position = "absolute";
  radiusMarker.style.width = "10px";
  radiusMarker.style.height = "10px";
  radiusMarker.style.backgroundColor = container.strokeColor;
  radiusMarker.style.borderRadius = "50%";
  radiusMarker.style.cursor = "move";
  radiusMarker.style.zIndex = "100";
  content.appendChild(radiusMarker);
  markers.push(radiusMarker);

  // Marker for adjusting the ellipse vertical radius
  const heightMarker = document.createElement("div");
  heightMarker.className = "cylinder-marker height-marker";
  heightMarker.style.position = "absolute";
  heightMarker.style.width = "10px";
  heightMarker.style.height = "10px";
  heightMarker.style.backgroundColor = container.strokeColor;
  heightMarker.style.borderRadius = "50%";
  heightMarker.style.cursor = "move";
  heightMarker.style.zIndex = "100";
  content.appendChild(heightMarker);
  markers.push(heightMarker);

  // Create resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getFillType() {
    return container.fillType;
  }
  
  function getShadingType() {
    return container.shadingType;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }
  
  function getShowRadius() {
    return container.radiusVisibility;
  }
  
  function getShowDiameter() {
    return container.diameterVisibility;
  }
  
  function getShowCenter() {
    return container.centerVisibility;
  }

  // Helper function to clamp cylinder parameters
  function clampCylinderParams() {
    const minRadius = 10;
    const maxRadius = Math.min(logicalWidth / 2, logicalHeight / 2);
    const minRy = 5;
    const maxRy = Math.max(cylinderParams.radius * 0.8, cylinderParams.radius * 2);
    
    cylinderParams.topX = Math.max(cylinderParams.radius, Math.min(cylinderParams.topX, logicalWidth - cylinderParams.radius));
    cylinderParams.bottomX = Math.max(cylinderParams.radius, Math.min(cylinderParams.bottomX, logicalWidth - cylinderParams.radius));
    cylinderParams.topY = Math.max(20, Math.min(cylinderParams.topY, cylinderParams.bottomY - 20));
    cylinderParams.bottomY = Math.max(cylinderParams.topY + 20, Math.min(cylinderParams.bottomY, logicalHeight - 20));
    cylinderParams.radius = Math.max(minRadius, Math.min(cylinderParams.radius, maxRadius));
    cylinderParams.ry = Math.max(minRy, Math.min(cylinderParams.ry, maxRy));
  }

  // Function to update the cylinder drawing
  function updateCylinderDrawing() {
    clampCylinderParams();
    
    const fillType = getFillType();
    const fill = fillType === "none" ? "none" : getFillColor();
    const strokeCol = getStrokeColor();
    const lineThickness = getLineThickness();
    
    // Draw side as a quadrilateral connecting the left edges and right edges of the two ellipses
    let sideD = `M ${cylinderParams.topX - cylinderParams.radius},${cylinderParams.topY} 
                 L ${cylinderParams.bottomX - cylinderParams.radius},${cylinderParams.bottomY} 
                 L ${cylinderParams.bottomX + cylinderParams.radius},${cylinderParams.bottomY} 
                 L ${cylinderParams.topX + cylinderParams.radius},${cylinderParams.topY} Z`;
    sidePath.setAttribute("d", sideD);
    sidePath.setAttribute("stroke", strokeCol);
    sidePath.setAttribute("stroke-width", lineThickness);
    
    // Top ellipse
    topEllipse.setAttribute("cx", cylinderParams.topX);
    topEllipse.setAttribute("cy", cylinderParams.topY);
    topEllipse.setAttribute("rx", cylinderParams.radius);
    topEllipse.setAttribute("ry", cylinderParams.ry);
    topEllipse.setAttribute("stroke", strokeCol);
    topEllipse.setAttribute("stroke-width", lineThickness);
    
    // Bottom ellipse
    bottomEllipse.setAttribute("cx", cylinderParams.bottomX);
    bottomEllipse.setAttribute("cy", cylinderParams.bottomY);
    bottomEllipse.setAttribute("rx", cylinderParams.radius);
    bottomEllipse.setAttribute("ry", cylinderParams.ry);
    bottomEllipse.setAttribute("stroke", strokeCol);
    bottomEllipse.setAttribute("stroke-width", lineThickness);
    
    // Apply fill and shading
    if (getShadingType() === "gradient" && fillType !== "none") {
      let gradientId = "cylinderGradient" + container.cylinderID;
      let gradient = document.getElementById(gradientId);
      if (!gradient) {
        gradient = document.createElementNS(svgNS, "linearGradient");
        gradient.setAttribute("id", gradientId);
        defs.appendChild(gradient);
      }
      gradient.innerHTML = "";
      gradient.setAttribute("x1", "0%");
      gradient.setAttribute("y1", "0%");
      gradient.setAttribute("x2", "100%");
      gradient.setAttribute("y2", "0%");
      
      const stop1 = document.createElementNS(svgNS, "stop");
      stop1.setAttribute("offset", "0%");
      stop1.setAttribute("stop-color", darkenColor(getFillColor(), 0.3));
      gradient.appendChild(stop1);
      
      const stop2 = document.createElementNS(svgNS, "stop");
      stop2.setAttribute("offset", "50%");
      stop2.setAttribute("stop-color", getFillColor());
      gradient.appendChild(stop2);
      
      const stop3 = document.createElementNS(svgNS, "stop");
      stop3.setAttribute("offset", "100%");
      stop3.setAttribute("stop-color", lightenColor(getFillColor(), 0.2));
      gradient.appendChild(stop3);
      
      sidePath.setAttribute("fill", `url(#${gradientId})`);
      topEllipse.setAttribute("fill", fill);
      bottomEllipse.setAttribute("fill", fill);
    } else {
      sidePath.setAttribute("fill", fill);
      topEllipse.setAttribute("fill", fill);
      bottomEllipse.setAttribute("fill", fill);
    }
    
    // Draw toggles on the top ellipse
    centerPoint.setAttribute("cx", cylinderParams.topX);
    centerPoint.setAttribute("cy", cylinderParams.topY);
    centerPoint.setAttribute("fill", strokeCol);
    centerPoint.style.display = getShowCenter() ? "inline" : "none";
    
    radiusLine.setAttribute("x1", cylinderParams.topX);
    radiusLine.setAttribute("y1", cylinderParams.topY);
    radiusLine.setAttribute("x2", cylinderParams.topX + cylinderParams.radius);
    radiusLine.setAttribute("y2", cylinderParams.topY);
    radiusLine.setAttribute("stroke", strokeCol);
    radiusLine.setAttribute("stroke-width", lineThickness);
    radiusLine.style.display = getShowRadius() ? "inline" : "none";
    
    diameterLine.setAttribute("x1", cylinderParams.topX - cylinderParams.radius);
    diameterLine.setAttribute("y1", cylinderParams.topY);
    diameterLine.setAttribute("x2", cylinderParams.topX + cylinderParams.radius);
    diameterLine.setAttribute("y2", cylinderParams.topY);
    diameterLine.setAttribute("stroke", strokeCol);
    diameterLine.setAttribute("stroke-width", lineThickness);
    diameterLine.style.display = getShowDiameter() ? "inline" : "none";
    
    markers.forEach(marker => marker.style.backgroundColor = strokeCol);
    updateMarkers();
  }

  // Function to update marker positions
  function updateMarkers() {
    const actualWidth = content.clientWidth;
    const actualHeight = content.clientHeight;
    
    // Top marker
    const topPixelX = (cylinderParams.topX / logicalWidth) * actualWidth;
    const topPixelY = (cylinderParams.topY / logicalHeight) * actualHeight;
    topMarker.style.left = (topPixelX - 5) + "px";
    topMarker.style.top = (topPixelY - 5) + "px";
    
    // Bottom marker
    const bottomPixelX = (cylinderParams.bottomX / logicalWidth) * actualWidth;
    const bottomPixelY = (cylinderParams.bottomY / logicalHeight) * actualHeight;
    bottomMarker.style.left = (bottomPixelX - 5) + "px";
    bottomMarker.style.top = (bottomPixelY - 5) + "px";
    
    // Radius marker at top ellipse right edge
    const radiusPixelX = ((cylinderParams.topX + cylinderParams.radius) / logicalWidth) * actualWidth;
    const radiusPixelY = (cylinderParams.topY / logicalHeight) * actualHeight;
    radiusMarker.style.left = (radiusPixelX - 5) + "px";
    radiusMarker.style.top = (radiusPixelY - 5) + "px";
    
    // Height marker at top ellipse bottom edge
    const heightPixelX = (cylinderParams.topX / logicalWidth) * actualWidth;
    const heightPixelY = ((cylinderParams.topY + cylinderParams.ry) / logicalHeight) * actualHeight;
    heightMarker.style.left = (heightPixelX - 5) + "px";
    heightMarker.style.top = (heightPixelY - 5) + "px";
  }
  
  // Update global toolbar with cylinder controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Cylinder " + container.cylinderID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      updateCylinderDrawing();
    });
    row1.appendChild(lineColorInput);

    // Fill type control
    const fillTypeLabel = document.createElement("span");
    fillTypeLabel.textContent = "Fill:";
    fillTypeLabel.style.fontSize = "12px";
    row1.appendChild(fillTypeLabel);

    const fillTypeSelect = document.createElement("select");
    fillTypeSelect.style.marginLeft = "5px";
    fillTypeSelect.style.marginRight = "10px";
    
    const noneOpt = document.createElement("option");
    noneOpt.value = "none";
    noneOpt.textContent = "No Fill";
    
    const colorOpt = document.createElement("option");
    colorOpt.value = "color";
    colorOpt.textContent = "Color";
    
    fillTypeSelect.appendChild(noneOpt);
    fillTypeSelect.appendChild(colorOpt);
    fillTypeSelect.value = getFillType();
    
    fillTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.fillType = this.value;
      if (this.value === "none") {
        fillColorInput.disabled = true;
        shadingSelect.disabled = true;
      } else {
        fillColorInput.disabled = false;
        shadingSelect.disabled = false;
      }
      updateCylinderDrawing();
    });
    row1.appendChild(fillTypeSelect);

    // Fill color control
    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor();
    fillColorInput.disabled = getFillType() === "none";
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.fillColor = this.value;
      updateCylinderDrawing();
    });
    row1.appendChild(fillColorInput);

    // Shading type control
    const shadingLabel = document.createElement("span");
    shadingLabel.textContent = "Shading:";
    shadingLabel.style.fontSize = "12px";
    row1.appendChild(shadingLabel);

    const shadingSelect = document.createElement("select");
    shadingSelect.style.marginLeft = "5px";
    shadingSelect.disabled = getFillType() === "none";
    
    const flatOpt = document.createElement("option");
    flatOpt.value = "flat";
    flatOpt.textContent = "Flat";
    
    const gradientOpt = document.createElement("option");
    gradientOpt.value = "gradient";
    gradientOpt.textContent = "Gradient";
    
    shadingSelect.appendChild(flatOpt);
    shadingSelect.appendChild(gradientOpt);
    shadingSelect.value = getShadingType();
    
    shadingSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    shadingSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    shadingSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.shadingType = this.value;
      updateCylinderDrawing();
    });
    row1.appendChild(shadingSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "10px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.lineThickness = parseInt(this.value);
      updateCylinderDrawing();
    });
    row2.appendChild(thicknessInput);
    
    // Features section: Radius, Diameter, Center
    // Radius visibility control
    const radiusVisLabel = document.createElement("span");
    radiusVisLabel.textContent = "Show Radius:";
    radiusVisLabel.style.fontSize = "12px";
    row2.appendChild(radiusVisLabel);

    const radiusVisSelect = document.createElement("select");
    radiusVisSelect.style.marginLeft = "5px";
    radiusVisSelect.style.marginRight = "10px";
    
    const radiusHideOpt = document.createElement("option");
    radiusHideOpt.value = "false";
    radiusHideOpt.textContent = "No";
    
    const radiusShowOpt = document.createElement("option");
    radiusShowOpt.value = "true";
    radiusShowOpt.textContent = "Yes";
    
    radiusVisSelect.appendChild(radiusHideOpt);
    radiusVisSelect.appendChild(radiusShowOpt);
    radiusVisSelect.value = getShowRadius() ? "true" : "false";
    
    radiusVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    radiusVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    radiusVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.radiusVisibility = this.value === "true";
      updateCylinderDrawing();
    });
    row2.appendChild(radiusVisSelect);
    
    // Diameter visibility control
    const diameterVisLabel = document.createElement("span");
    diameterVisLabel.textContent = "Show Diameter:";
    diameterVisLabel.style.fontSize = "12px";
    row2.appendChild(diameterVisLabel);

    const diameterVisSelect = document.createElement("select");
    diameterVisSelect.style.marginLeft = "5px";
    diameterVisSelect.style.marginRight = "10px";
    
    const diameterHideOpt = document.createElement("option");
    diameterHideOpt.value = "false";
    diameterHideOpt.textContent = "No";
    
    const diameterShowOpt = document.createElement("option");
    diameterShowOpt.value = "true";
    diameterShowOpt.textContent = "Yes";
    
    diameterVisSelect.appendChild(diameterHideOpt);
    diameterVisSelect.appendChild(diameterShowOpt);
    diameterVisSelect.value = getShowDiameter() ? "true" : "false";
    
    diameterVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    diameterVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    diameterVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.diameterVisibility = this.value === "true";
      updateCylinderDrawing();
    });
    row2.appendChild(diameterVisSelect);

    // Center visibility control
    const centerVisLabel = document.createElement("span");
    centerVisLabel.textContent = "Show Center:";
    centerVisLabel.style.fontSize = "12px";
    row2.appendChild(centerVisLabel);

    const centerVisSelect = document.createElement("select");
    centerVisSelect.style.marginLeft = "5px";
    centerVisSelect.style.marginRight = "10px";
    
    const centerHideOpt = document.createElement("option");
    centerHideOpt.value = "false";
    centerHideOpt.textContent = "No";
    
    const centerShowOpt = document.createElement("option");
    centerShowOpt.value = "true";
    centerShowOpt.textContent = "Yes";
    
    centerVisSelect.appendChild(centerHideOpt);
    centerVisSelect.appendChild(centerShowOpt);
    centerVisSelect.value = getShowCenter() ? "true" : "false";
    
    centerVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    centerVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    centerVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.centerVisibility = this.value === "true";
      updateCylinderDrawing();
    });
    row2.appendChild(centerVisSelect);

    // Add spacer
    const spacer = document.createElement("div");
    spacer.style.flexGrow = "1";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  function activateCylinder() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Store reference to the previously active element if it exists
    if (typeof activeElement !== 'undefined' && activeElement && activeElement !== container) {
      // If using the temporary raise function from the original code
      if (typeof restoreElementZIndex === 'function' && activeElement.dataset.tempRaised) {
        restoreElementZIndex(activeElement);
      }
      
      // Handle toolbar of the previous element
      if (activeElement.querySelector(".element-controls")) {
        activeElement.querySelector(".element-controls").style.display = "none";
      }
    }
    
    if (window.activeCylinderElement && window.activeCylinderElement !== container) {
      // Reset previous element's appearance
      window.activeCylinderElement.style.border = "none";
      const prevToolbar = window.activeCylinderElement.querySelector(".cylinder-toolbar");
      const prevResizeHandle = window.activeCylinderElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
      
      // Hide previous element's markers
      const prevMarkers = window.activeCylinderElement.querySelectorAll(".cylinder-marker");
      prevMarkers.forEach(marker => marker.style.display = "none");
    }
    
    window.activeCylinderElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    
    // Show all markers
    markers.forEach(marker => marker.style.display = "block");
    
    // Use the raise function from the original code if available
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  function deactivateCylinder() {
    // Don't deactivate if this element has focus lock
    if (window.activeCylinderElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      markers.forEach(marker => marker.style.display = "none");
      
      window.activeCylinderElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteCylinder() {
    if (window.activeCylinderElement === container) {
      window.activeCylinderElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // --- Top marker drag: update topX and topY (allows slanting) ---
  topMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const startTopX = cylinderParams.topX;
    const startTopY = cylinderParams.topY;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = logicalHeight / svgRect.height;
      const deltaX = (e.clientX - startX) * scaleX;
      const deltaY = (e.clientY - startY) * scaleY;
      
      cylinderParams.topX = Math.max(cylinderParams.radius, 
                               Math.min(startTopX + deltaX, logicalWidth - cylinderParams.radius));
      cylinderParams.topY = Math.max(20, 
                               Math.min(startTopY + deltaY, cylinderParams.bottomY - 20));
      
      updateCylinderDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Bottom marker drag: update bottomX and bottomY ---
  bottomMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const startBottomX = cylinderParams.bottomX;
    const startBottomY = cylinderParams.bottomY;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = logicalHeight / svgRect.height;
      const deltaX = (e.clientX - startX) * scaleX;
      const deltaY = (e.clientY - startY) * scaleY;
      
      cylinderParams.bottomX = Math.max(cylinderParams.radius, 
                                  Math.min(startBottomX + deltaX, logicalWidth - cylinderParams.radius));
      cylinderParams.bottomY = Math.max(cylinderParams.topY + 20, 
                                  Math.min(startBottomY + deltaY, logicalHeight - 20));
      
      updateCylinderDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Radius marker drag: update radius using top marker as reference ---
  radiusMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startRadius = cylinderParams.radius;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const deltaX = (e.clientX - startX) * scaleX;
      
      const newRadius = Math.max(10, Math.min(startRadius + deltaX, Math.min(logicalWidth / 2, logicalHeight / 2)));
      cylinderParams.radius = newRadius;
      
      updateCylinderDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Height marker drag: update ry using top marker as reference ---
  heightMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startY = e.clientY;
    const startRy = cylinderParams.ry;
    
    function onMouseMove(e) {
      const scaleY = logicalHeight / svgRect.height;
      const deltaY = (e.clientY - startY) * scaleY;
      
      const newRy = Math.max(5, Math.min(startRy + deltaY, cylinderParams.radius * 0.8));
      cylinderParams.ry = newRy;
      
      updateCylinderDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(150, startWidth + (e.clientX - startX));
      const newHeight = Math.max(100, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      content.style.width = newWidth + "px";
      content.style.height = (newHeight - toolbarHeight) + "px";
      
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newHeight - toolbarHeight);
      svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
      
      updateCylinderDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Activate on mousedown
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle && 
        !markers.includes(e.target)) {
      activateCylinder();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeCylinderElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivateCylinder();
    }
  });

  // Delete: both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteCylinder();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteCylinder();
  });
  
  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Initial setup
  container.style.border = "1px dashed #ccc";
  
  // Append to canvas and set as active
  canvas.appendChild(container);
  updateCylinderDrawing();
  activateCylinder();
}


function addCone() {
  // --- Local helper functions for color manipulation ---
  function lightenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r + (255 - r) * percent);
    g = Math.floor(g + (255 - g) * percent);
    b = Math.floor(b + (255 - b) * percent);
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }
  
  function darkenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r * (1 - percent));
    g = Math.floor(g * (1 - percent));
    b = Math.floor(b * (1 - percent));
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }

  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;
  let logicalWidth = 300, logicalHeight = 200; // Logical coordinate space

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("cone") ? "Cone " : element.className.includes("polygon") ? "Polygon " : "Triangle ") + element.coneID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeConeElement) {
    window.activeConeElement = null;
  }
  
  // Global counter for cone IDs
  if (!window.globalConeCounter) {
    window.globalConeCounter = 1;
  } else {
    window.globalConeCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element cone-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = logicalWidth + "px";
  container.style.height = (toolbarHeight + logicalHeight) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;
  container.isDragging = false;
  
  // Assign an ID for this cone
  container.coneID = window.globalConeCounter;
  
  // Initialize state properties
  container.centerVisibility = false;
  container.radiusVisibility = false;
  container.diameterVisibility = false;
  container.strokeColor = "#000000";
  container.fillColor = "#add8e6";
  container.fillType = "color"; // "none" or "color"
  container.shadingType = "gradient"; // "flat" or "gradient"
  container.lineThickness = 2;

  // Create the local toolbar (simplified with only move handle and delete button)
  const localToolbar = document.createElement("div");
  localToolbar.className = "cone-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px"; // Single row toolbar
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle (left side)
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button (right side)
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "cone-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = logicalHeight + "px";
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", logicalWidth);
  svg.setAttribute("height", logicalHeight);
  svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Define cone default parameters
  let coneParams = {
    cx: logicalWidth / 2,
    cy: logicalHeight - 40,
    radius: 60,
    ry: 18,
    apexX: logicalWidth / 2,
    apexY: 40
  };

  // Create the cone elements
  const conePath = document.createElementNS(svgNS, "path");
  conePath.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(conePath);

  const baseEllipse = document.createElementNS(svgNS, "ellipse");
  baseEllipse.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(baseEllipse);

  // Create <defs> for gradients
  const defs = document.createElementNS(svgNS, "defs");
  svg.appendChild(defs);

  // Additional features
  const radiusLine = document.createElementNS(svgNS, "line");
  radiusLine.setAttribute("stroke-width", container.lineThickness);
  radiusLine.setAttribute("stroke-dasharray", "4,2");
  radiusLine.style.display = "none";
  svg.appendChild(radiusLine);

  const diameterLine = document.createElementNS(svgNS, "line");
  diameterLine.setAttribute("stroke-width", container.lineThickness);
  diameterLine.setAttribute("stroke-dasharray", "4,2");
  diameterLine.style.display = "none";
  svg.appendChild(diameterLine);

  const centerPoint = document.createElementNS(svgNS, "circle");
  centerPoint.setAttribute("r", "3");
  centerPoint.style.display = "none";
  svg.appendChild(centerPoint);

  // Create draggable markers
  const markers = [];

  const apexMarker = document.createElement("div");
  apexMarker.className = "cone-marker apex-marker";
  apexMarker.style.position = "absolute";
  apexMarker.style.width = "10px";
  apexMarker.style.height = "10px";
  apexMarker.style.backgroundColor = container.strokeColor;
  apexMarker.style.borderRadius = "50%";
  apexMarker.style.cursor = "move";
  apexMarker.style.zIndex = "100";
  content.appendChild(apexMarker);
  markers.push(apexMarker);

  const baseCenterMarker = document.createElement("div");
  baseCenterMarker.className = "cone-marker base-center-marker";
  baseCenterMarker.style.position = "absolute";
  baseCenterMarker.style.width = "10px";
  baseCenterMarker.style.height = "10px";
  baseCenterMarker.style.backgroundColor = container.strokeColor;
  baseCenterMarker.style.borderRadius = "50%";
  baseCenterMarker.style.cursor = "move";
  baseCenterMarker.style.zIndex = "100";
  content.appendChild(baseCenterMarker);
  markers.push(baseCenterMarker);

  const radiusMarker = document.createElement("div");
  radiusMarker.className = "cone-marker radius-marker";
  radiusMarker.style.position = "absolute";
  radiusMarker.style.width = "10px";
  radiusMarker.style.height = "10px";
  radiusMarker.style.backgroundColor = container.strokeColor;
  radiusMarker.style.borderRadius = "50%";
  radiusMarker.style.cursor = "move";
  radiusMarker.style.zIndex = "100";
  content.appendChild(radiusMarker);
  markers.push(radiusMarker);

  const heightMarker = document.createElement("div");
  heightMarker.className = "cone-marker height-marker";
  heightMarker.style.position = "absolute";
  heightMarker.style.width = "10px";
  heightMarker.style.height = "10px";
  heightMarker.style.backgroundColor = container.strokeColor;
  heightMarker.style.borderRadius = "50%";
  heightMarker.style.cursor = "move";
  heightMarker.style.zIndex = "100";
  content.appendChild(heightMarker);
  markers.push(heightMarker);

  // Create resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);// Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getFillType() {
    return container.fillType;
  }
  
  function getShadingType() {
    return container.shadingType;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }
  
  function getShowRadius() {
    return container.radiusVisibility;
  }
  
  function getShowDiameter() {
    return container.diameterVisibility;
  }
  
  function getShowCenter() {
    return container.centerVisibility;
  }

  // Helper function to clamp cone parameters
  function clampConeParams() {
    const minRadius = 10;
    const maxRadius = Math.min(logicalWidth / 2, logicalHeight / 2);
    const minRy = 5;
    const maxRy = Math.max(coneParams.radius * 0.8, coneParams.radius * 2);
    
    coneParams.cx = Math.max(coneParams.radius, Math.min(coneParams.cx, logicalWidth - coneParams.radius));
    coneParams.cy = Math.max(coneParams.radius, Math.min(coneParams.cy, logicalHeight - 10));
    coneParams.apexX = Math.max(0, Math.min(coneParams.apexX, logicalWidth));
    coneParams.apexY = Math.max(10, Math.min(coneParams.apexY, coneParams.cy - 10));
    
    coneParams.radius = Math.max(minRadius, Math.min(coneParams.radius, maxRadius));
    coneParams.ry = Math.max(minRy, Math.min(coneParams.ry, maxRy));
  }

  // Function to update the cone drawing
  function updateConeDrawing() {
    clampConeParams();
    
    const fillType = getFillType();
    const fill = fillType === "none" ? "none" : getFillColor();
    const strokeCol = getStrokeColor();
    const lineThickness = getLineThickness();
    
    baseEllipse.setAttribute("cx", coneParams.cx);
    baseEllipse.setAttribute("cy", coneParams.cy);
    baseEllipse.setAttribute("rx", coneParams.radius);
    baseEllipse.setAttribute("ry", coneParams.ry);
    baseEllipse.setAttribute("fill", fill);
    baseEllipse.setAttribute("stroke", strokeCol);
    baseEllipse.setAttribute("stroke-width", lineThickness);
    
    const frontPoint = { x: coneParams.cx + coneParams.radius, y: coneParams.cy };
    const backPoint = { x: coneParams.cx - coneParams.radius, y: coneParams.cy };
    let pathData = `M${coneParams.apexX},${coneParams.apexY} L${frontPoint.x},${frontPoint.y}`;
    pathData += ` A${coneParams.radius},${coneParams.ry} 0 1 1 ${backPoint.x},${backPoint.y}`;
    pathData += ` L${coneParams.apexX},${coneParams.apexY}`;
    conePath.setAttribute("d", pathData);
    conePath.setAttribute("stroke", strokeCol);
    conePath.setAttribute("stroke-width", lineThickness);
    
    if (getShadingType() === "gradient" && fillType !== "none") {
      let gradientId = "coneGradient" + container.coneID;
      let gradient = document.getElementById(gradientId);
      if (!gradient) {
        gradient = document.createElementNS(svgNS, "linearGradient");
        gradient.setAttribute("id", gradientId);
        defs.appendChild(gradient);
      }
      gradient.innerHTML = "";
      gradient.setAttribute("x1", "0%");
      gradient.setAttribute("y1", "0%");
      gradient.setAttribute("x2", "100%");
      gradient.setAttribute("y2", "0%");
      
      const stop1 = document.createElementNS(svgNS, "stop");
      stop1.setAttribute("offset", "0%");
      stop1.setAttribute("stop-color", darkenColor(getFillColor(), 0.3));
      gradient.appendChild(stop1);
      
      const stop2 = document.createElementNS(svgNS, "stop");
      stop2.setAttribute("offset", "50%");
      stop2.setAttribute("stop-color", getFillColor());
      gradient.appendChild(stop2);
      
      const stop3 = document.createElementNS(svgNS, "stop");
      stop3.setAttribute("offset", "100%");
      stop3.setAttribute("stop-color", lightenColor(getFillColor(), 0.2));
      gradient.appendChild(stop3);
      
      conePath.setAttribute("fill", `url(#${gradientId})`);
    } else {
      conePath.setAttribute("fill", fill);
    }
    
    centerPoint.setAttribute("cx", coneParams.cx);
    centerPoint.setAttribute("cy", coneParams.cy);
    centerPoint.setAttribute("fill", strokeCol);
    centerPoint.style.display = getShowCenter() ? "inline" : "none";
    
    radiusLine.setAttribute("x1", coneParams.cx);
    radiusLine.setAttribute("y1", coneParams.cy);
    radiusLine.setAttribute("x2", coneParams.cx + coneParams.radius);
    radiusLine.setAttribute("y2", coneParams.cy);
    radiusLine.setAttribute("stroke", strokeCol);
    radiusLine.setAttribute("stroke-width", lineThickness);
    radiusLine.style.display = getShowRadius() ? "inline" : "none";
    
    diameterLine.setAttribute("x1", coneParams.cx - coneParams.radius);
    diameterLine.setAttribute("y1", coneParams.cy);
    diameterLine.setAttribute("x2", coneParams.cx + coneParams.radius);
    diameterLine.setAttribute("y2", coneParams.cy);
    diameterLine.setAttribute("stroke", strokeCol);
    diameterLine.setAttribute("stroke-width", lineThickness);
    diameterLine.style.display = getShowDiameter() ? "inline" : "none";
    
    markers.forEach(marker => marker.style.backgroundColor = strokeCol);
    updateMarkers();
  }

  // Function to update marker positions
  function updateMarkers() {
    const actualWidth = content.clientWidth;
    const actualHeight = content.clientHeight;
    
    const apexPixelX = (coneParams.apexX / logicalWidth) * actualWidth;
    const apexPixelY = (coneParams.apexY / logicalHeight) * actualHeight;
    apexMarker.style.left = (apexPixelX - 5) + "px";
    apexMarker.style.top = (apexPixelY - 5) + "px";
    
    const centerPixelX = (coneParams.cx / logicalWidth) * actualWidth;
    const centerPixelY = (coneParams.cy / logicalHeight) * actualHeight;
    baseCenterMarker.style.left = (centerPixelX - 5) + "px";
    baseCenterMarker.style.top = (centerPixelY - 5) + "px";
    
    const radiusPixelX = ((coneParams.cx + coneParams.radius) / logicalWidth) * actualWidth;
    const radiusPixelY = (coneParams.cy / logicalHeight) * actualHeight;
    radiusMarker.style.left = (radiusPixelX - 5) + "px";
    radiusMarker.style.top = (radiusPixelY - 5) + "px";
    
    const heightPixelX = (coneParams.cx / logicalWidth) * actualWidth;
    const heightPixelY = ((coneParams.cy + coneParams.ry) / logicalHeight) * actualHeight;
    heightMarker.style.left = (heightPixelX - 5) + "px";
    heightMarker.style.top = (heightPixelY - 5) + "px";
  }
  
  // Update global toolbar with cone controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Cone " + container.coneID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      updateConeDrawing();
    });
    row1.appendChild(lineColorInput);

    // Fill type control
    const fillTypeLabel = document.createElement("span");
    fillTypeLabel.textContent = "Fill:";
    fillTypeLabel.style.fontSize = "12px";
    row1.appendChild(fillTypeLabel);

    const fillTypeSelect = document.createElement("select");
    fillTypeSelect.style.marginLeft = "5px";
    fillTypeSelect.style.marginRight = "10px";
    
    const noneOpt = document.createElement("option");
    noneOpt.value = "none";
    noneOpt.textContent = "No Fill";
    
    const colorOpt = document.createElement("option");
    colorOpt.value = "color";
    colorOpt.textContent = "Color";
    
    fillTypeSelect.appendChild(noneOpt);
    fillTypeSelect.appendChild(colorOpt);
    fillTypeSelect.value = getFillType();
    
    fillTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.fillType = this.value;
      if (this.value === "none") {
        fillColorInput.disabled = true;
        shadingSelect.disabled = true;
      } else {
        fillColorInput.disabled = false;
        shadingSelect.disabled = false;
      }
      updateConeDrawing();
    });
    row1.appendChild(fillTypeSelect);

    // Fill color control
    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor();
    fillColorInput.disabled = getFillType() === "none";
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.fillColor = this.value;
      updateConeDrawing();
    });
    row1.appendChild(fillColorInput);

    // Shading type control
    const shadingLabel = document.createElement("span");
    shadingLabel.textContent = "Shading:";
    shadingLabel.style.fontSize = "12px";
    row1.appendChild(shadingLabel);

    const shadingSelect = document.createElement("select");
    shadingSelect.style.marginLeft = "5px";
    shadingSelect.disabled = getFillType() === "none";
    
    const flatOpt = document.createElement("option");
    flatOpt.value = "flat";
    flatOpt.textContent = "Flat";
    
    const gradientOpt = document.createElement("option");
    gradientOpt.value = "gradient";
    gradientOpt.textContent = "Gradient";
    
    shadingSelect.appendChild(flatOpt);
    shadingSelect.appendChild(gradientOpt);
    shadingSelect.value = getShadingType();
    
    shadingSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    shadingSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    shadingSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.shadingType = this.value;
      updateConeDrawing();
    });
    row1.appendChild(shadingSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "10px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.lineThickness = parseInt(this.value);
      updateConeDrawing();
    });
    row2.appendChild(thicknessInput);
    
    // Features section: Radius, Diameter, Center
    // Radius visibility control
    const radiusVisLabel = document.createElement("span");
    radiusVisLabel.textContent = "Show Radius:";
    radiusVisLabel.style.fontSize = "12px";
    row2.appendChild(radiusVisLabel);

    const radiusVisSelect = document.createElement("select");
    radiusVisSelect.style.marginLeft = "5px";
    radiusVisSelect.style.marginRight = "10px";
    
    const radiusHideOpt = document.createElement("option");
    radiusHideOpt.value = "false";
    radiusHideOpt.textContent = "No";
    
    const radiusShowOpt = document.createElement("option");
    radiusShowOpt.value = "true";
    radiusShowOpt.textContent = "Yes";
    
    radiusVisSelect.appendChild(radiusHideOpt);
    radiusVisSelect.appendChild(radiusShowOpt);
    radiusVisSelect.value = getShowRadius() ? "true" : "false";
    
    radiusVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    radiusVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    radiusVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.radiusVisibility = this.value === "true";
      updateConeDrawing();
    });
    row2.appendChild(radiusVisSelect);
    
    // Diameter visibility control
    const diameterVisLabel = document.createElement("span");
    diameterVisLabel.textContent = "Show Diameter:";
    diameterVisLabel.style.fontSize = "12px";
    row2.appendChild(diameterVisLabel);

    const diameterVisSelect = document.createElement("select");
    diameterVisSelect.style.marginLeft = "5px";
    diameterVisSelect.style.marginRight = "10px";
    
    const diameterHideOpt = document.createElement("option");
    diameterHideOpt.value = "false";
    diameterHideOpt.textContent = "No";
    
    const diameterShowOpt = document.createElement("option");
    diameterShowOpt.value = "true";
    diameterShowOpt.textContent = "Yes";
    
    diameterVisSelect.appendChild(diameterHideOpt);
    diameterVisSelect.appendChild(diameterShowOpt);
    diameterVisSelect.value = getShowDiameter() ? "true" : "false";
    
    diameterVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    diameterVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    diameterVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.diameterVisibility = this.value === "true";
      updateConeDrawing();
    });
    row2.appendChild(diameterVisSelect);

    // Center visibility control
    const centerVisLabel = document.createElement("span");
    centerVisLabel.textContent = "Show Center:";
    centerVisLabel.style.fontSize = "12px";
    row2.appendChild(centerVisLabel);

    const centerVisSelect = document.createElement("select");
    centerVisSelect.style.marginLeft = "5px";
    centerVisSelect.style.marginRight = "10px";
    
    const centerHideOpt = document.createElement("option");
    centerHideOpt.value = "false";
    centerHideOpt.textContent = "No";
    
    const centerShowOpt = document.createElement("option");
    centerShowOpt.value = "true";
    centerShowOpt.textContent = "Yes";
    
    centerVisSelect.appendChild(centerHideOpt);
    centerVisSelect.appendChild(centerShowOpt);
    centerVisSelect.value = getShowCenter() ? "true" : "false";
    
    centerVisSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    centerVisSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    centerVisSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.centerVisibility = this.value === "true";
      updateConeDrawing();
    });
    row2.appendChild(centerVisSelect);

    // Add spacer
    const spacer = document.createElement("div");
    spacer.style.flexGrow = "1";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  function activateCone() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Store reference to the previously active element if it exists
    if (typeof activeElement !== 'undefined' && activeElement && activeElement !== container) {
      // If using the temporary raise function from the original code
      if (typeof restoreElementZIndex === 'function' && activeElement.dataset.tempRaised) {
        restoreElementZIndex(activeElement);
      }
      
      // Handle toolbar of the previous element
      if (activeElement.querySelector(".element-controls")) {
        activeElement.querySelector(".element-controls").style.display = "none";
      }
    }
    
    if (window.activeConeElement && window.activeConeElement !== container) {
      // Reset previous element's appearance
      window.activeConeElement.style.border = "none";
      const prevToolbar = window.activeConeElement.querySelector(".cone-toolbar");
      const prevResizeHandle = window.activeConeElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
      
      // Hide previous element's markers
      const prevMarkers = window.activeConeElement.querySelectorAll(".cone-marker");
      prevMarkers.forEach(marker => marker.style.display = "none");
    }
    
    window.activeConeElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    
    // Show all markers
    markers.forEach(marker => marker.style.display = "block");
    
    // Use the raise function from the original code if available
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  function deactivateCone() {
    // Don't deactivate if this element has focus lock
    if (window.activeConeElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      markers.forEach(marker => marker.style.display = "none");
      
      window.activeConeElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteCone() {
    if (window.activeConeElement === container) {
      window.activeConeElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // --- Apex marker: Only update cone apex without changing container dimensions ---
  apexMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const startApexX = coneParams.apexX;
    const startApexY = coneParams.apexY;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = logicalHeight / svgRect.height;
      const deltaX = (e.clientX - startX) * scaleX;
      const deltaY = (e.clientY - startY) * scaleY;
      
      coneParams.apexX = Math.max(0, Math.min(startApexX + deltaX, logicalWidth));
      coneParams.apexY = Math.max(10, Math.min(startApexY + deltaY, coneParams.cy - 10));
      
      updateConeDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Base center marker drag ---
  baseCenterMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const startCX = coneParams.cx;
    const startCY = coneParams.cy;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = logicalHeight / svgRect.height;
      const deltaX = (e.clientX - startX) * scaleX;
      const deltaY = (e.clientY - startY) * scaleY;
      
      coneParams.cx = Math.max(coneParams.radius, Math.min(startCX + deltaX, logicalWidth - coneParams.radius));
      coneParams.cy = Math.max(coneParams.radius, Math.min(startCY + deltaY, logicalHeight - 10));
      
      if (coneParams.apexY >= coneParams.cy - 10) {
        coneParams.apexY = coneParams.cy - 10;
      }
      
      updateConeDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Radius marker drag ---
  radiusMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startX = e.clientX;
    const startRadius = coneParams.radius;
    
    function onMouseMove(e) {
      const scaleX = logicalWidth / svgRect.width;
      const deltaX = (e.clientX - startX) * scaleX;
      
      const newRadius = Math.max(10, Math.min(startRadius + deltaX, Math.min(logicalWidth / 2, logicalHeight / 2)));
      coneParams.radius = newRadius;
      
      if (coneParams.ry > coneParams.radius * 0.8) {
        coneParams.ry = coneParams.radius * 0.8;
      }
      
      updateConeDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Height marker drag ---
  heightMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    const svgRect = svg.getBoundingClientRect();
    const startY = e.clientY;
    const startRy = coneParams.ry;
    
    function onMouseMove(e) {
      const scaleY = logicalHeight / svgRect.height;
      const deltaY = (e.clientY - startY) * scaleY;
      
      const newRy = Math.max(5, Math.min(startRy + deltaY, coneParams.radius * 0.8));
      coneParams.ry = newRy;
      
      updateConeDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(150, startWidth + (e.clientX - startX));
      const newHeight = Math.max(100, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      content.style.width = newWidth + "px";
      content.style.height = (newHeight - toolbarHeight) + "px";
      
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newHeight - toolbarHeight);
      svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
      
      updateConeDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Activate on mousedown
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle && 
        !markers.includes(e.target)) {
      activateCone();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeConeElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivateCone();
    }
  });

  // Delete: both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteCone();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteCone();
  });
  
  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Initial setup
  container.style.border = "1px dashed #ccc";
  
  // Append to canvas and set as active
  canvas.appendChild(container);
  updateConeDrawing();
  activateCone();
}

function addRectangularPrism() {
  // --- Local helper functions for color manipulation ---
  function lightenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r + (255 - r) * percent);
    g = Math.floor(g + (255 - g) * percent);
    b = Math.floor(b + (255 - b) * percent);
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }
  
  function darkenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r * (1 - percent));
    g = Math.floor(g * (1 - percent));
    b = Math.floor(b * (1 - percent));
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }

  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let logicalWidth = 300, logicalHeight = 200;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("prism") ? "Prism " : element.className.includes("sphere") ? "Sphere " : "Element ") + element.prismID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activePrismElement) {
    window.activePrismElement = null;
  }
  
  // Global counter for prism IDs
  if (!window.globalPrismCounter) {
    window.globalPrismCounter = 1;
  } else {
    window.globalPrismCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element prism-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = logicalWidth + "px";
  container.style.height = (toolbarHeight + logicalHeight) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;
  container.isDragging = false;
  
  // Assign an ID for this prism
  container.prismID = window.globalPrismCounter;
  
  // Initialize state properties
  container.strokeColor = "#000000";
  container.fillColor = "#add8e6";
  container.fillType = "color"; // "none" or "color"
  container.fillStyle = "gradient"; // "solid" or "gradient"
  container.prismType = "solid"; // "solid" or "xray"
  container.lineThickness = 2;

  // Create the local toolbar (simplified with only move handle and delete button)
  const localToolbar = document.createElement("div");
  localToolbar.className = "prism-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px"; // Single row toolbar
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Initially hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle (left side)
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button (right side)
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "prism-content";
  content.style.position = "relative";
  content.style.width = "100%";
  content.style.height = logicalHeight + "px";
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", logicalWidth);
  svg.setAttribute("height", logicalHeight);
  svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Define front face rectangle and offset
  let frontRect = { x1: 50, y1: 70, x2: 150, y2: 150 };
  let offset = { dx: 40, dy: -40 };

  // Create polygons for the three visible faces
  const frontFace = document.createElementNS(svgNS, "polygon");
  frontFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(frontFace);
  
  const topFace = document.createElementNS(svgNS, "polygon");
  topFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(topFace);
  
  const sideFace = document.createElementNS(svgNS, "polygon");
  sideFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(sideFace);

  // Create additional elements for x-ray view
  const backFace = document.createElementNS(svgNS, "polygon");
  backFace.style.display = "none";
  backFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(backFace);
  
  const leftFace = document.createElementNS(svgNS, "polygon");
  leftFace.style.display = "none";
  leftFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(leftFace);
  
  const bottomFace = document.createElementNS(svgNS, "polygon");
  bottomFace.style.display = "none";
  bottomFace.setAttribute("stroke-width", container.lineThickness);
  svg.appendChild(bottomFace);

  // Create draggable markers for front face vertices
  const markers = [];
  for (let i = 0; i < 4; i++) {
    const marker = document.createElement("div");
    marker.className = "prism-marker";
    marker.style.position = "absolute";
    marker.style.width = "10px";
    marker.style.height = "10px";
    marker.style.backgroundColor = container.strokeColor;
    marker.style.borderRadius = "50%";
    marker.style.cursor = "move";
    marker.style.zIndex = "100";
    marker.style.display = "none"; // Initially hidden
    marker.dataset.index = i.toString();
    content.appendChild(marker);
    markers.push(marker);
  }

  // Create marker for the back corner
  const backMarker = document.createElement("div");
  backMarker.className = "prism-marker back-marker";
  backMarker.style.position = "absolute";
  backMarker.style.width = "10px";
  backMarker.style.height = "10px";
  backMarker.style.backgroundColor = container.strokeColor;
  backMarker.style.borderRadius = "50%";
  backMarker.style.cursor = "move";
  backMarker.style.zIndex = "100";
  backMarker.style.display = "none"; // Initially hidden
  content.appendChild(backMarker);

  // Create resize handle
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Initially hidden
  container.appendChild(resizeHandle);

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getFillType() {
    return container.fillType;
  }
  
  function getFillStyle() {
    return container.fillStyle;
  }
  
  function getPrismType() {
    return container.prismType;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }

  // Helper functions to clamp geometry
  function clampFrontRect() {
    frontRect.x1 = Math.max(0, Math.min(frontRect.x1, logicalWidth));
    frontRect.x2 = Math.max(0, Math.min(frontRect.x2, logicalWidth));
    frontRect.y1 = Math.max(0, Math.min(frontRect.y1, logicalHeight));
    frontRect.y2 = Math.max(0, Math.min(frontRect.y2, logicalHeight));
    if (frontRect.x1 > frontRect.x2) [frontRect.x1, frontRect.x2] = [frontRect.x2, frontRect.x1];
    if (frontRect.y1 > frontRect.y2) [frontRect.y1, frontRect.y2] = [frontRect.y2, frontRect.y1];
  }
  
  function clampOffset() {
    const B = { x: frontRect.x2, y: frontRect.y1 };
    let bx = B.x + offset.dx;
    let by = B.y + offset.dy;
    if (bx < B.x) bx = B.x;
    if (bx > logicalWidth) bx = logicalWidth;
    if (by < 0) by = 0;
    if (by > B.y) by = B.y;
    offset.dx = bx - B.x;
    offset.dy = by - B.y;
  }

  // Function to update the prism drawing
  function updatePrismDrawing() {
    clampFrontRect();
    clampOffset();
    
    let fills;
    // Check if "No Fill" is selected
    if (getFillType() === "none") {
      fills = { front: "none", top: "none", side: "none" };
    } else if (getFillStyle() === "gradient") {
      fills = {
        front: getFillColor(),
        top: lightenColor(getFillColor(), 0.2),
        side: darkenColor(getFillColor(), 0.2)
      };
    } else {
      fills = { 
        front: getFillColor(), 
        top: getFillColor(), 
        side: getFillColor() 
      };
    }
    
    const strokeCol = getStrokeColor();
    const lineThickness = getLineThickness();
    
    // Compute front face vertices
    let A = { x: frontRect.x1, y: frontRect.y1 };
    let B = { x: frontRect.x2, y: frontRect.y1 };
    let C = { x: frontRect.x2, y: frontRect.y2 };
    let D = { x: frontRect.x1, y: frontRect.y2 };
    
    // Compute back face vertices
    let A_back = { x: A.x + offset.dx, y: A.y + offset.dy };
    let B_back = { x: B.x + offset.dx, y: B.y + offset.dy };
    let C_back = { x: C.x + offset.dx, y: C.y + offset.dy };
    let D_back = { x: D.x + offset.dx, y: D.y + offset.dy };
    
    // Draw visible faces (front, top, right)
    frontFace.setAttribute("points", `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`);
    frontFace.setAttribute("fill", fills.front);
    frontFace.setAttribute("stroke", strokeCol);
    frontFace.setAttribute("stroke-width", lineThickness);
    
    topFace.setAttribute("points", `${A.x},${A.y} ${A_back.x},${A_back.y} ${B_back.x},${B_back.y} ${B.x},${B.y}`);
    topFace.setAttribute("fill", fills.top);
    topFace.setAttribute("stroke", strokeCol);
    topFace.setAttribute("stroke-width", lineThickness);
    topFace.removeAttribute("stroke-dasharray");
    
    sideFace.setAttribute("points", `${B.x},${B.y} ${B_back.x},${B_back.y} ${C_back.x},${C_back.y} ${C.x},${C.y}`);
    sideFace.setAttribute("fill", fills.side);
    sideFace.setAttribute("stroke", strokeCol);
    sideFace.setAttribute("stroke-width", lineThickness);
    sideFace.removeAttribute("stroke-dasharray");
    
    // For X-Ray mode, add dashed lines for the hidden edges
    if (getPrismType() === "xray") {
      // Extra dashed line for back top edge (from A_back to B_back)
      let extraBackTopLine = svg.querySelector('.extra-back-top-line');
      if (!extraBackTopLine) {
        extraBackTopLine = document.createElementNS(svgNS, "line");
        extraBackTopLine.classList.add("extra-back-top-line");
        svg.appendChild(extraBackTopLine);
      }
      extraBackTopLine.setAttribute("x1", A_back.x);
      extraBackTopLine.setAttribute("y1", A_back.y);
      extraBackTopLine.setAttribute("x2", B_back.x);
      extraBackTopLine.setAttribute("y2", B_back.y);
      extraBackTopLine.setAttribute("stroke", strokeCol);
      extraBackTopLine.setAttribute("stroke-width", lineThickness);
      extraBackTopLine.setAttribute("stroke-dasharray", "4,2");
      extraBackTopLine.style.display = "inline";
      
      // Extra dashed line for back bottom edge (from D_back to C_back)
      let extraBackBottomLine = svg.querySelector('.extra-back-bottom-line');
      if (!extraBackBottomLine) {
        extraBackBottomLine = document.createElementNS(svgNS, "line");
        extraBackBottomLine.classList.add("extra-back-bottom-line");
        svg.appendChild(extraBackBottomLine);
      }
      extraBackBottomLine.setAttribute("x1", D_back.x);
      extraBackBottomLine.setAttribute("y1", D_back.y);
      extraBackBottomLine.setAttribute("x2", C_back.x);
      extraBackBottomLine.setAttribute("y2", C_back.y);
      extraBackBottomLine.setAttribute("stroke", strokeCol);
      extraBackBottomLine.setAttribute("stroke-width", lineThickness);
      extraBackBottomLine.setAttribute("stroke-dasharray", "4,2");
      extraBackBottomLine.style.display = "inline";
      
      // Extra dashed line for back left edge (from A_back to D_back)
      let extraBackLeftLine = svg.querySelector('.extra-back-left-line');
      if (!extraBackLeftLine) {
        extraBackLeftLine = document.createElementNS(svgNS, "line");
        extraBackLeftLine.classList.add("extra-back-left-line");
        svg.appendChild(extraBackLeftLine);
      }
      extraBackLeftLine.setAttribute("x1", A_back.x);
      extraBackLeftLine.setAttribute("y1", A_back.y);
      extraBackLeftLine.setAttribute("x2", D_back.x);
      extraBackLeftLine.setAttribute("y2", D_back.y);
      extraBackLeftLine.setAttribute("stroke", strokeCol);
      extraBackLeftLine.setAttribute("stroke-width", lineThickness);
      extraBackLeftLine.setAttribute("stroke-dasharray", "4,2");
      extraBackLeftLine.style.display = "inline";
      
      // Extra dashed line connecting front D to back D_back
      let extraLeftConnectingLine = svg.querySelector('.extra-left-connecting-line');
      if (!extraLeftConnectingLine) {
        extraLeftConnectingLine = document.createElementNS(svgNS, "line");
        extraLeftConnectingLine.classList.add("extra-left-connecting-line");
        svg.appendChild(extraLeftConnectingLine);
      }
      extraLeftConnectingLine.setAttribute("x1", D.x);
      extraLeftConnectingLine.setAttribute("y1", D.y);
      extraLeftConnectingLine.setAttribute("x2", D_back.x);
      extraLeftConnectingLine.setAttribute("y2", D_back.y);
      extraLeftConnectingLine.setAttribute("stroke", strokeCol);
      extraLeftConnectingLine.setAttribute("stroke-width", lineThickness);
      extraLeftConnectingLine.setAttribute("stroke-dasharray", "4,2");
      extraLeftConnectingLine.style.display = "inline";
    } else {
      // Remove extra dashed lines if not in x‑ray mode
      let extraBackTopLine = svg.querySelector('.extra-back-top-line');
      if (extraBackTopLine) extraBackTopLine.style.display = "none";
      
      let extraBackBottomLine = svg.querySelector('.extra-back-bottom-line');
      if (extraBackBottomLine) extraBackBottomLine.style.display = "none";
      
      let extraBackLeftLine = svg.querySelector('.extra-back-left-line');
      if (extraBackLeftLine) extraBackLeftLine.style.display = "none";
      
      let extraLeftConnectingLine = svg.querySelector('.extra-left-connecting-line');
      if (extraLeftConnectingLine) extraLeftConnectingLine.style.display = "none";
    }
    
    // Update marker colors
    markers.forEach(marker => marker.style.backgroundColor = strokeCol);
    backMarker.style.backgroundColor = strokeCol;
    updateMarkers();
  }

  // Function to update marker positions
  function updateMarkers() {
    const actualWidth = svg.clientWidth;
    const actualHeight = svg.clientHeight;
    
    const frontPoints = [
      { x: frontRect.x1, y: frontRect.y1 },
      { x: frontRect.x2, y: frontRect.y1 },
      { x: frontRect.x2, y: frontRect.y2 },
      { x: frontRect.x1, y: frontRect.y2 }
    ];
    
    frontPoints.forEach((pt, i) => {
      const pixelX = (pt.x / logicalWidth) * actualWidth;
      const pixelY = (pt.y / logicalHeight) * actualHeight;
      markers[i].style.left = (pixelX - 5) + "px";
      markers[i].style.top = (pixelY - 5) + "px";
    });
    
    let B_back = { x: frontRect.x2 + offset.dx, y: frontRect.y1 + offset.dy };
    const backPixelX = (B_back.x / logicalWidth) * actualWidth;
    const backPixelY = (B_back.y / logicalHeight) * actualHeight;
    backMarker.style.left = (backPixelX - 5) + "px";
    backMarker.style.top = (backPixelY - 5) + "px";
  }
  
  // Update global toolbar with prism controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Prism " + container.prismID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.strokeColor = this.value;
      updatePrismDrawing();
    });
    row1.appendChild(lineColorInput);

    // Fill type control
    const fillTypeLabel = document.createElement("span");
    fillTypeLabel.textContent = "Fill:";
    fillTypeLabel.style.fontSize = "12px";
    row1.appendChild(fillTypeLabel);

    const fillTypeSelect = document.createElement("select");
    fillTypeSelect.style.marginLeft = "5px";
    fillTypeSelect.style.marginRight = "10px";
    
    const noneOpt = document.createElement("option");
    noneOpt.value = "none";
    noneOpt.textContent = "No Fill";
    
    const colorOpt = document.createElement("option");
    colorOpt.value = "color";
    colorOpt.textContent = "Color";
    
    fillTypeSelect.appendChild(noneOpt);
    fillTypeSelect.appendChild(colorOpt);
    fillTypeSelect.value = getFillType();
    
    fillTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    fillTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.fillType = this.value;
      if (this.value === "none") {
        fillColorInput.disabled = true;
        fillStyleSelect.disabled = true;
      } else {
        fillColorInput.disabled = false;
        fillStyleSelect.disabled = false;
      }
      updatePrismDrawing();
    });
    row1.appendChild(fillTypeSelect);

    // Fill color control
    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor();
    fillColorInput.disabled = getFillType() === "none";
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.fillColor = this.value;
      updatePrismDrawing();
    });
    row1.appendChild(fillColorInput);

    // Fill style control 
    const fillStyleLabel = document.createElement("span");
    fillStyleLabel.textContent = "Fill Style:";
    fillStyleLabel.style.fontSize = "12px";
    row1.appendChild(fillStyleLabel);

    const fillStyleSelect = document.createElement("select");
    fillStyleSelect.style.marginLeft = "5px";
    fillStyleSelect.disabled = getFillType() === "none";
    
    const solidOpt = document.createElement("option");
    solidOpt.value = "solid";
    solidOpt.textContent = "Solid";
    
    const gradientOpt = document.createElement("option");
    gradientOpt.value = "gradient";
    gradientOpt.textContent = "Gradient";
    
    fillStyleSelect.appendChild(solidOpt);
    fillStyleSelect.appendChild(gradientOpt);
    fillStyleSelect.value = getFillStyle();
    
    fillStyleSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillStyleSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    fillStyleSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.fillStyle = this.value;
      updatePrismDrawing();
    });
    row1.appendChild(fillStyleSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "10px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.lineThickness = parseInt(this.value);
      updatePrismDrawing();
    });
    row2.appendChild(thicknessInput);
    
    // Prism type control
    const prismTypeLabel = document.createElement("span");
    prismTypeLabel.textContent = "Prism Type:";
    prismTypeLabel.style.fontSize = "12px";
    row2.appendChild(prismTypeLabel);

    const prismTypeSelect = document.createElement("select");
    prismTypeSelect.style.marginLeft = "5px";
    prismTypeSelect.style.marginRight = "10px";
    
    const solidPrismOpt = document.createElement("option");
    solidPrismOpt.value = "solid";
    solidPrismOpt.textContent = "Solid";
    
    const xrayOpt = document.createElement("option");
    xrayOpt.value = "xray";
    xrayOpt.textContent = "X-ray";
    
    prismTypeSelect.appendChild(solidPrismOpt);
    prismTypeSelect.appendChild(xrayOpt);
    prismTypeSelect.value = getPrismType();
    
    prismTypeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    prismTypeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    prismTypeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.prismType = this.value;
      updatePrismDrawing();
    });
    row2.appendChild(prismTypeSelect);

    // Add spacer
    const spacer = document.createElement("div");
    spacer.style.flexGrow = "1";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  // Function to activate the prism (make it the currently selected element)
  function activatePrism() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Reset previous active element if it exists
    if (window.activePrismElement && window.activePrismElement !== container) {
      // Reset previous element's appearance
      window.activePrismElement.style.border = "none";
      const prevToolbar = window.activePrismElement.querySelector(".prism-toolbar");
      const prevResizeHandle = window.activePrismElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
      
      // Hide previous element's markers
      const prevMarkers = window.activePrismElement.querySelectorAll(".prism-marker");
      prevMarkers.forEach(marker => marker.style.display = "none");
    }
    
    window.activePrismElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    // Show all markers
    markers.forEach(marker => marker.style.display = "block");
    backMarker.style.display = "block";
    
    // Raise Z-index if that function exists
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  // Function to deactivate the prism
  function deactivatePrism() {
    // Don't deactivate if this element has focus lock
    if (window.activePrismElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      markers.forEach(marker => marker.style.display = "none");
      backMarker.style.display = "none";
      
      window.activePrismElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deletePrism() {
    if (window.activePrismElement === container) {
      window.activePrismElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // --- Event Handlers for Markers ---
  // Front face markers dragging
  markers.forEach(marker => {
    marker.addEventListener("mousedown", function(e) {
      e.stopPropagation();
      e.preventDefault();
      
      const index = parseInt(marker.dataset.index);
      
      function onMouseMove(e) {
        const svgRect = svg.getBoundingClientRect();
        const scaleX = logicalWidth / svgRect.width;
        const scaleY = logicalHeight / svgRect.height;
        const newX = (e.clientX - svgRect.left) * scaleX;
        const newY = (e.clientY - svgRect.top) * scaleY;
        
        if (index === 0) { frontRect.x1 = newX; frontRect.y1 = newY; }
        else if (index === 1) { frontRect.x2 = newX; frontRect.y1 = newY; }
        else if (index === 2) { frontRect.x2 = newX; frontRect.y2 = newY; }
        else if (index === 3) { frontRect.x1 = newX; frontRect.y2 = newY; }
        
        updatePrismDrawing();
      }
      
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
  });

  // Back marker dragging for depth adjustment
  backMarker.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    
    function onMouseMove(e) {
      const svgRect = svg.getBoundingClientRect();
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = logicalHeight / svgRect.height;
      let newX = (e.clientX - svgRect.left) * scaleX;
      let newY = (e.clientY - svgRect.top) * scaleY;
      
      const B = { x: frontRect.x2, y: frontRect.y1 };
      newX = Math.max(B.x, Math.min(newX, logicalWidth));
      newY = Math.max(0, Math.min(newY, B.y));
      offset.dx = newX - B.x;
      offset.dy = newY - B.y;
      
      updatePrismDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(150, startWidth + (e.clientX - startX));
      const newHeight = Math.max(100, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      content.style.width = newWidth + "px";
      content.style.height = (newHeight - toolbarHeight) + "px";
      
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newHeight - toolbarHeight);
      svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
      
      updatePrismDrawing();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Activate on mousedown
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle && 
        !markers.includes(e.target) && e.target !== backMarker) {
      activatePrism();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activePrismElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivatePrism();
    }
  });

  // Delete button handlers (both mousedown and click for reliability)
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePrism();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePrism();
  });
  
  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Initial setup
  container.style.border = "1px dashed #ccc";
  
  // Append to canvas and set as active
  canvas.appendChild(container);
  updatePrismDrawing();
  activatePrism();
}


function addGriddedRectangularPrism() {
  // --- Local helper functions if needed ---
  // None required for this component
  
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let logicalWidth = 220, logicalHeight = 200;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("gridded") ? "Gridded Prism " : element.className.includes("prism") ? "Prism " : "Element ") + element.prismID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activeGriddedPrismElement) {
    window.activeGriddedPrismElement = null;
  }
  
  // Global counter for gridded prism IDs
  if (!window.globalGriddedPrismCounter) {
    window.globalGriddedPrismCounter = 1;
  } else {
    window.globalGriddedPrismCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element prism-container gridded-rectangular-prism";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = logicalWidth + "px";
  container.style.height = (toolbarHeight + logicalHeight) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  
  // Set z-index if global variable exists
  if (typeof globalTopZ !== 'undefined') {
    container.style.zIndex = globalTopZ++;
  }
  
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;
  container.isDragging = false;
  
  // Assign an ID for this gridded prism
  container.prismID = window.globalGriddedPrismCounter;
  
  // Initialize state properties
  container.strokeColor = "#000000";
  container.fillColor = "#ffffff";
  container.length = 3;
  container.width = 4;
  container.height = 2;
  container.lineThickness = 1;

  // Create the local toolbar (simplified with only move handle and delete button)
  const localToolbar = document.createElement("div");
  localToolbar.className = "prism-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px"; // Single row toolbar
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Initially hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle (left side)
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button (right side)
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const contentDiv = document.createElement("div");
  contentDiv.className = "prism-content";
  contentDiv.style.position = "relative";
  contentDiv.style.width = "100%";
  contentDiv.style.height = logicalHeight + "px";
  contentDiv.style.overflow = "hidden";
  container.appendChild(contentDiv);

  // Create SVG
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", logicalWidth);
  svg.setAttribute("height", logicalHeight);
  svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  contentDiv.appendChild(svg);

  // Create groups for the three faces
  const frontFaceGroup = document.createElementNS(svgNS, "g");
  frontFaceGroup.setAttribute("class", "front-face");
  svg.appendChild(frontFaceGroup);

  const topFaceGroup = document.createElementNS(svgNS, "g");
  topFaceGroup.setAttribute("class", "top-face");
  svg.appendChild(topFaceGroup);

  const rightFaceGroup = document.createElementNS(svgNS, "g");
  rightFaceGroup.setAttribute("class", "right-face");
  svg.appendChild(rightFaceGroup);

  // Create resize handle
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Initially hidden
  container.appendChild(resizeHandle);

  // Helper functions to get current values
  function getStrokeColor() {
    return container.strokeColor;
  }
  
  function getFillColor() {
    return container.fillColor;
  }
  
  function getLength() {
    return container.length;
  }
  
  function getWidth() {
    return container.width;
  }
  
  function getHeight() {
    return container.height;
  }
  
  function getLineThickness() {
    return container.lineThickness;
  }

  // Helper for variable substitution if using expressions
 
  function substituteValue(original, computedVars) {
  if (!original || typeof original !== 'string') return original;
  
  // Replace #variable# patterns
  let result = original.replace(/#([^#\s]+)#/g, (match, variableName) => {
    const normalizedName = normalizeVariable('#' + variableName + '#');
    if (computedVars[normalizedName] !== undefined) {
      return computedVars[normalizedName];
    }
    return match;
  });
  
  // For backward compatibility, also replace {variable} patterns
  result = result.replace(/\{([^}]+)\}/g, (match, variableName) => {
    const normalizedName = normalizeVariable(variableName.trim());
    if (computedVars[normalizedName] !== undefined) {
      return computedVars[normalizedName];
    }
    return match;
  });
  
  return result;
}

  // Function to update the gridded rectangular prism drawing
  function updateGriddedRectangularPrism() {
    // Clear existing grid lines
    frontFaceGroup.innerHTML = '';
    topFaceGroup.innerHTML = '';
    rightFaceGroup.innerHTML = '';

    // Get dimensions from container properties or compute from expressions
    let length, width, height;
    
    // Check if we're in preview mode (when computeAllVariables has been called)
    const computedVars = window.currentComputedVars || {};
    
    // Get expressions from data attributes
    const lengthExpr = container.getAttribute("data-length-expr");
    const widthExpr = container.getAttribute("data-width-expr");
    const heightExpr = container.getAttribute("data-height-expr");
    
    // If expressions exist and we have computed variables, use them
    if (computedVars && Object.keys(computedVars).length > 0) {
      if (lengthExpr && lengthExpr.includes("{")) {
        try {
          length = Math.max(1, parseInt(substituteValue(lengthExpr, computedVars)) || getLength());
        } catch (e) {
          length = Math.max(1, getLength());
        }
      } else {
        length = Math.max(1, getLength());
      }
      
      if (widthExpr && widthExpr.includes("{")) {
        try {
          width = Math.max(1, parseInt(substituteValue(widthExpr, computedVars)) || getWidth());
        } catch (e) {
          width = Math.max(1, getWidth());
        }
      } else {
        width = Math.max(1, getWidth());
      }
      
      if (heightExpr && heightExpr.includes("{")) {
        try {
          height = Math.max(1, parseInt(substituteValue(heightExpr, computedVars)) || getHeight());
        } catch (e) {
          height = Math.max(1, getHeight());
        }
      } else {
        height = Math.max(1, getHeight());
      }
    } else {
      // Use container properties directly if not in preview mode
      length = Math.max(1, getLength());
      width = Math.max(1, getWidth());
      height = Math.max(1, getHeight());
    }

    // Get container drawing dimensions
    const containerWidth = contentDiv.clientWidth || logicalWidth;
    const containerHeight = contentDiv.clientHeight || logicalHeight;

    // Cabinet projection parameters (45° angle for consistent projection)
    const depthRatio = 0.5;
    const angle = Math.PI / 4; // 45 degrees

    // Compute unitSize so that the entire prism fits
    const possibleUnitSizeX = containerWidth / (length + depthRatio * Math.cos(angle) * height);
    const possibleUnitSizeY = containerHeight / (width + depthRatio * Math.sin(angle) * height);
    const scaleMargin = 0.9; // to add some padding
    const unitSize = Math.min(possibleUnitSizeX, possibleUnitSizeY) * scaleMargin;

    // Compute depth offsets
    const depthOffsetX = unitSize * depthRatio * Math.cos(angle);
    const depthOffsetY = -unitSize * depthRatio * Math.sin(angle);

    // Compute overall drawn dimensions
    const totalWidth = length * unitSize + depthOffsetX * height;
    const totalHeight = width * unitSize - depthOffsetY * height;  // subtract because depthOffsetY is negative

    // Center the drawing inside the container
    const startX = (containerWidth - totalWidth) / 2;
    // For Y, adjust so that the top face (which extends upward) is visible
    const startY = (containerHeight - totalHeight) / 2 - depthOffsetY * height;

    const strokeCol = getStrokeColor();
    const fillCol = getFillColor();
    const lineThickness = getLineThickness();
    
    // --- FRONT FACE (x, y) ---
    const frontFace = document.createElementNS(svgNS, "polygon");
    const frontFacePoints = [
      `${startX},${startY + width * unitSize}`,                        // bottom-left
      `${startX},${startY}`,                                           // top-left
      `${startX + length * unitSize},${startY}`,                       // top-right
      `${startX + length * unitSize},${startY + width * unitSize}`     // bottom-right
    ].join(" ");
    frontFace.setAttribute("points", frontFacePoints);
    frontFace.setAttribute("fill", fillCol === "transparent" ? "none" : fillCol);
    frontFace.setAttribute("stroke", strokeCol);
    frontFace.setAttribute("stroke-width", lineThickness);
    frontFaceGroup.appendChild(frontFace);

    // Vertical grid lines for front face
    for (let x = 0; x <= length; x++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + x * unitSize);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", startX + x * unitSize);
      line.setAttribute("y2", startY + width * unitSize);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      frontFaceGroup.appendChild(line);
    }

    // Horizontal grid lines for front face
    for (let y = 0; y <= width; y++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX);
      line.setAttribute("y1", startY + y * unitSize);
      line.setAttribute("x2", startX + length * unitSize);
      line.setAttribute("y2", startY + y * unitSize);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      frontFaceGroup.appendChild(line);
    }

    // --- TOP FACE (x, z) ---
    const topFace = document.createElementNS(svgNS, "polygon");
    const topFacePoints = [
      `${startX},${startY}`,                                                   // bottom-left
      `${startX + depthOffsetX * height},${startY + depthOffsetY * height}`,   // top-left
      `${startX + depthOffsetX * height + length * unitSize},${startY + depthOffsetY * height}`,  // top-right
      `${startX + length * unitSize},${startY}`                                // bottom-right
    ].join(" ");
    topFace.setAttribute("points", topFacePoints);
    topFace.setAttribute("fill", fillCol === "transparent" ? "none" : fillCol);
    topFace.setAttribute("stroke", strokeCol);
    topFace.setAttribute("stroke-width", lineThickness);
    topFaceGroup.appendChild(topFace);

    // Horizontal grid lines for top face
    for (let x = 0; x <= length; x++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + x * unitSize);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", startX + depthOffsetX * height + x * unitSize);
      line.setAttribute("y2", startY + depthOffsetY * height);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      topFaceGroup.appendChild(line);
    }

    // Vertical grid lines for top face
    for (let z = 0; z <= height; z++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + depthOffsetX * z);
      line.setAttribute("y1", startY + depthOffsetY * z);
      line.setAttribute("x2", startX + depthOffsetX * z + length * unitSize);
      line.setAttribute("y2", startY + depthOffsetY * z);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      topFaceGroup.appendChild(line);
    }

    // --- RIGHT FACE (z, y) ---
    const rightFace = document.createElementNS(svgNS, "polygon");
    const rightFacePoints = [
      `${startX + length * unitSize},${startY}`,                                        // top-left
      `${startX + length * unitSize + depthOffsetX * height},${startY + depthOffsetY * height}`,    // top-right
      `${startX + length * unitSize + depthOffsetX * height},${startY + width * unitSize + depthOffsetY * height}`, // bottom-right
      `${startX + length * unitSize},${startY + width * unitSize}`                      // bottom-left
    ].join(" ");
    rightFace.setAttribute("points", rightFacePoints);
    rightFace.setAttribute("fill", fillCol === "transparent" ? "none" : fillCol);
    rightFace.setAttribute("stroke", strokeCol);
    rightFace.setAttribute("stroke-width", lineThickness);
    rightFaceGroup.appendChild(rightFace);

    // Horizontal grid lines for right face
    for (let y = 0; y <= width; y++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + length * unitSize);
      line.setAttribute("y1", startY + y * unitSize);
      line.setAttribute("x2", startX + length * unitSize + depthOffsetX * height);
      line.setAttribute("y2", startY + y * unitSize + depthOffsetY * height);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      rightFaceGroup.appendChild(line);
    }

    // Vertical grid lines for right face
    for (let z = 0; z <= height; z++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + length * unitSize + depthOffsetX * z);
      line.setAttribute("y1", startY + depthOffsetY * z);
      line.setAttribute("x2", startX + length * unitSize + depthOffsetX * z);
      line.setAttribute("y2", startY + depthOffsetY * z + width * unitSize);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      rightFaceGroup.appendChild(line);
    }
  }
  
  // Update global toolbar with gridded rectangular prism controls
// Update global toolbar with gridded rectangular prism controls
// Update global toolbar with gridded rectangular prism controls
function updateGlobalToolbar() {
  const globalToolbar = document.getElementById("global-toolbar");
  if (!globalToolbar) return;
  globalToolbar.innerHTML = "";

  // Create first row container for the main controls
  const row1 = document.createElement("div");
  row1.style.display = "flex";
  row1.style.alignItems = "center";
  row1.style.flexWrap = "wrap";

  // Identity label
  const identityLabel = document.createElement("span");
  identityLabel.textContent = "Gridded Prism " + container.prismID;
  identityLabel.style.fontSize = "12px";
  identityLabel.style.fontWeight = "bold";
  identityLabel.style.marginRight = "10px";
  row1.appendChild(identityLabel);

  // Line color control
  const lineLabel = document.createElement("span");
  lineLabel.textContent = "Line:";
  lineLabel.style.fontSize = "12px";
  row1.appendChild(lineLabel);

  const lineColorInput = document.createElement("input");
  lineColorInput.type = "color";
  lineColorInput.value = getStrokeColor();
  lineColorInput.style.marginLeft = "5px";
  lineColorInput.style.marginRight = "10px";
  lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
  lineColorInput.addEventListener("input", function(e) {
    e.stopPropagation();
    container.strokeColor = this.value;
    updateGriddedRectangularPrism();
  });
  row1.appendChild(lineColorInput);

  // Line thickness control
  const thicknessLabel = document.createElement("span");
  thicknessLabel.textContent = "Line Thickness:";
  thicknessLabel.style.fontSize = "12px";
  row1.appendChild(thicknessLabel);

  const thicknessInput = document.createElement("input");
  thicknessInput.type = "number";
  thicknessInput.min = "1";
  thicknessInput.max = "5";
  thicknessInput.value = getLineThickness();
  thicknessInput.style.width = "40px";
  thicknessInput.style.marginLeft = "5px";
  thicknessInput.style.marginRight = "10px";
  thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
  thicknessInput.addEventListener("input", function(e) {
    e.stopPropagation();
    container.lineThickness = parseInt(this.value);
    updateGriddedRectangularPrism();
  });
  row1.appendChild(thicknessInput);
  
  // Fill color control
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Fill:";
  fillLabel.style.fontSize = "12px";
  row1.appendChild(fillLabel);

  const fillColorDisplay = document.createElement("div");
  fillColorDisplay.style.width = "20px";
  fillColorDisplay.style.height = "20px";
  fillColorDisplay.style.backgroundColor = getFillColor() === "transparent" ? "#ffffff" : getFillColor();
  fillColorDisplay.style.cursor = "pointer";
  fillColorDisplay.style.border = "1px solid #ccc";
  fillColorDisplay.style.marginLeft = "5px";
  fillColorDisplay.style.marginRight = "10px";
  fillColorDisplay.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  fillColorDisplay.addEventListener("click", function(e) {
    e.stopPropagation();
    
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
    overlay.style.zIndex = "10000";
    overlay.style.display = "flex";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";

    const modal = document.createElement("div");
    modal.style.background = "#fff";
    modal.style.padding = "10px";
    modal.style.border = "1px solid #ccc";
    modal.style.fontSize = "14px";
    modal.innerHTML = `<div style="margin-bottom:10px;">Choose Fill Color</div>`;

    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = getFillColor() === "transparent" ? "#ffffff" : getFillColor();
    modal.appendChild(colorInput);

    // "None" option for no fill
    const noneBtn = document.createElement("button");
    noneBtn.textContent = "None";
    noneBtn.style.marginLeft = "10px";
    modal.appendChild(noneBtn);

    const okBtn = document.createElement("button");
    okBtn.textContent = "OK";
    okBtn.style.marginLeft = "10px";
    modal.appendChild(okBtn);
    
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancel";
    cancelBtn.style.marginLeft = "10px";
    modal.appendChild(cancelBtn);

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    function cleanup() {
      document.body.removeChild(overlay);
    }

    okBtn.addEventListener("click", function() {
      const selectedColor = colorInput.value;
      fillColorDisplay.style.backgroundColor = selectedColor;
      container.fillColor = selectedColor;
      updateGriddedRectangularPrism();
      cleanup();
    });
    
    noneBtn.addEventListener("click", function() {
      fillColorDisplay.style.backgroundColor = "#ffffff";
      container.fillColor = "transparent";
      updateGriddedRectangularPrism();
      cleanup();
    });
    
    cancelBtn.addEventListener("click", cleanup);
    
    overlay.addEventListener("click", function(e) {
      if (e.target === overlay) cleanup();
    });
  });
  row1.appendChild(fillColorDisplay);

  globalToolbar.appendChild(row1);

  // Create second row container for dimension controls
  const row2 = document.createElement("div");
  row2.style.display = "flex";
  row2.style.alignItems = "center";
  row2.style.marginTop = "5px";

  // Length control
  const lengthLabel = document.createElement("span");
  lengthLabel.textContent = "Length:";
  lengthLabel.style.fontSize = "12px";
  row2.appendChild(lengthLabel);

  const lengthInput = document.createElement("input");
  lengthInput.type = "text";
  const lengthExpr = container.getAttribute("data-length-expr");
  lengthInput.value = lengthExpr || getLength().toString();
  lengthInput.style.width = "60px";
  lengthInput.style.marginLeft = "5px";
  lengthInput.style.marginRight = "10px";
  lengthInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  lengthInput.addEventListener("click", function(e) { e.stopPropagation(); });
  row2.appendChild(lengthInput);
  
  // Width control
  const widthLabel = document.createElement("span");
  widthLabel.textContent = "Width:";
  widthLabel.style.fontSize = "12px";
  row2.appendChild(widthLabel);

  const widthInput = document.createElement("input");
  widthInput.type = "text";
  const widthExpr = container.getAttribute("data-width-expr");
  widthInput.value = widthExpr || getWidth().toString();
  widthInput.style.width = "60px";
  widthInput.style.marginLeft = "5px";
  widthInput.style.marginRight = "10px";
  widthInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  widthInput.addEventListener("click", function(e) { e.stopPropagation(); });
  row2.appendChild(widthInput);
  
  // Height control
  const heightLabel = document.createElement("span");
  heightLabel.textContent = "Height:";
  heightLabel.style.fontSize = "12px";
  row2.appendChild(heightLabel);

  const heightInput = document.createElement("input");
  heightInput.type = "text";
  const heightExpr = container.getAttribute("data-height-expr");
  heightInput.value = heightExpr || getHeight().toString();
  heightInput.style.width = "60px";
  heightInput.style.marginLeft = "5px";
  heightInput.style.marginRight = "10px";
  heightInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  heightInput.addEventListener("click", function(e) { e.stopPropagation(); });
  row2.appendChild(heightInput);

  // Add Update button
  const updateButton = document.createElement("button");
  updateButton.textContent = "Update";
  updateButton.style.fontSize = "12px";
  updateButton.style.marginLeft = "10px";
  updateButton.style.marginRight = "10px";
  updateButton.style.padding = "2px 8px";
  updateButton.style.cursor = "pointer";
  updateButton.style.backgroundColor = "#4CAF50";
  updateButton.style.color = "white";
  updateButton.style.border = "none";
  updateButton.style.borderRadius = "4px";

// Modified update button click handler
updateButton.addEventListener("click", function(e) {
  e.stopPropagation();
  
  // Save current style values to container properties
  container.strokeColor = lineColorInput.value;
  container.lineThickness = parseInt(thicknessInput.value);
  // fillColor is already updated by the fill color modal

  container.setAttribute("data-stroke-color", container.strokeColor);
container.setAttribute("data-line-thickness", container.lineThickness);
container.setAttribute("data-fill-color", container.fillColor);
  
  // Validate and update length
  const lengthValue = lengthInput.value.trim();
  if (lengthValue) {
    if (/^#[^#]+#$/.test(lengthValue)) {
      container.setAttribute("data-length-expr", lengthValue);
    } else {
      const numVal = parseInt(lengthValue);
  if (!isNaN(numVal) && numVal > 0 && Number.isInteger(Number(lengthValue))) {
    // ← instead of removing, reset the expr to the literal number
    container.setAttribute("data-length-expr", lengthValue);
    container.length = numVal;
  } else {
    alert("Length must be a positive integer or a variable pattern like #a#");
    return;
  }
}
  }
  
  // Validate and update width
  const widthValue = widthInput.value.trim();
  if (widthValue) {
    if (/^#[^#]+#$/.test(widthValue)) {
      container.setAttribute("data-width-expr", widthValue);
    } else {
        const numVal = parseInt(widthValue);
  if (!isNaN(numVal) && numVal > 0 && Number.isInteger(Number(widthValue))) {
    container.setAttribute("data-width-expr", widthValue);
    container.width = numVal;
  } else {
    alert("Width must be …");
    return;
  }
}
  }
  
  // Validate and update height
  const heightValue = heightInput.value.trim();
  if (heightValue) {
    if (/^#[^#]+#$/.test(heightValue)) {
      container.setAttribute("data-height-expr", heightValue);
    } else {
        const numVal = parseInt(heightValue);
  if (!isNaN(numVal) && numVal > 0 && Number.isInteger(Number(heightValue))) {
    // ← keep the data-attribute even for a literal number
    container.setAttribute("data-height-expr", heightValue);
    container.height = numVal;
  } else {
    alert("Height must be a positive integer or a variable pattern like #a#");
    return;
  }
}
  }
  
  // Update the prism after all validations pass
  updateGriddedRectangularPrism();
});

  updateButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  row2.appendChild(updateButton);

  // Add Enter key handling for all inputs
  [lengthInput, widthInput, heightInput].forEach(input => {
    input.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        updateButton.click(); // Trigger the update button
      }
    });
  });

  // Add spacer
  const spacer = document.createElement("div");
  spacer.style.flexGrow = "1";
  row2.appendChild(spacer);

  // Focus Lock button
  const lockFocusButton = document.createElement("button");
  lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
  lockFocusButton.style.fontSize = "12px";
  lockFocusButton.style.padding = "2px 8px";
  lockFocusButton.style.cursor = "pointer";
  lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
  lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
  lockFocusButton.addEventListener("click", function(e) {
    e.stopPropagation();
    
    if (window.focusLockManager.isLockedElement(container)) {
      // Unlock this element
      window.focusLockManager.unlock();
      this.textContent = "Lock Focus";
      this.style.backgroundColor = "#ccffcc";
    } else {
      // First unlock any currently locked element
      window.focusLockManager.unlock();
      
      // Then lock this element
      window.focusLockManager.lock(container);
      this.textContent = "Unlock Focus";
      this.style.backgroundColor = "#ffcccc";
    }
  });
  row2.appendChild(lockFocusButton);

  globalToolbar.appendChild(row2);
}

  // Function to activate the gridded rectangular prism
  function activateGriddedPrism() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    // Reset previous active element if it exists
    if (window.activeGriddedPrismElement && window.activeGriddedPrismElement !== container) {
      // Reset previous element's appearance
      window.activeGriddedPrismElement.style.border = "none";
      const prevToolbar = window.activeGriddedPrismElement.querySelector(".prism-toolbar");
      const prevResizeHandle = window.activeGriddedPrismElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeGriddedPrismElement = container;
    if (typeof activeElement !== 'undefined') {
      activeElement = container;
    }
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    // Raise Z-index if that function exists
    if (typeof raiseElementTemporarily === 'function') {
      raiseElementTemporarily(container);
    }
    
    updateGlobalToolbar();
  }

  // Function to deactivate the gridded rectangular prism
  function deactivateGriddedPrism() {
    // Don't deactivate if this element has focus lock
    if (window.activeGriddedPrismElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      
      window.activeGriddedPrismElement = null;
      if (typeof activeElement !== 'undefined' && activeElement === container) {
        activeElement = null;
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteGriddedPrism() {
    if (window.activeGriddedPrismElement === container) {
      window.activeGriddedPrismElement = null;
    }
    
    if (typeof activeElement !== 'undefined' && activeElement === container) {
      activeElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(150, startWidth + (e.clientX - startX));
      const newHeight = Math.max(100, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      contentDiv.style.width = newWidth + "px";
      contentDiv.style.height = (newHeight - toolbarHeight) + "px";
      
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newHeight - toolbarHeight);
      svg.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight - toolbarHeight}`);
      
      updateGriddedRectangularPrism();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Activate on mousedown
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateGriddedPrism();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activeGriddedPrismElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivateGriddedPrism();
    }
  });

  // Delete button handlers (both mousedown and click for reliability)
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteGriddedPrism();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteGriddedPrism();
  });
  
  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Initial setup
  container.style.border = "1px dashed #ccc";
  
  // Append to canvas and set as active
  canvas.appendChild(container);
  updateGriddedRectangularPrism();
  activateGriddedPrism();
}

// Function to show the gridded rectangular prism automation modal
// Complete modified showGriddedPrismModal function
function showGriddedPrismModal(container) {
  const modal = document.createElement("div");
  modal.style.position = "fixed";
  modal.style.top = "50%";
  modal.style.left = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  modal.style.zIndex = "1000";
  modal.style.background = "white";
  modal.style.border = "1px solid #ccc";
  modal.style.padding = "10px";
  modal.style.boxShadow = "2px 2px 8px rgba(0,0,0,0.3)";

  // Create overlay for the modal
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  overlay.style.zIndex = "900";
  
  // Create modal header
  const header = document.createElement("h3");
  header.textContent = "Gridded Rectangular Prism Settings";
  header.style.margin = "0 0 10px 0";
  modal.appendChild(header);

  // Get current values from container
  const lengthValue = container.getAttribute("data-length-expr") || "";
  const widthValue = container.getAttribute("data-width-expr") || "";
  const heightValue = container.getAttribute("data-height-expr") || "";

  // Create input fields for length, width, and height
  const lengthDiv = document.createElement("div");
  lengthDiv.style.marginBottom = "8px";
  const lengthLabel = document.createElement("label");
  lengthLabel.textContent = "Length: ";
  lengthLabel.style.display = "inline-block";
  lengthLabel.style.width = "80px";
  const lengthInput = document.createElement("input");
  lengthInput.type = "text";
  lengthInput.value = lengthValue;
  lengthInput.placeholder = "e.g., 3 or {a}";
  lengthInput.style.width = "150px";
  lengthDiv.appendChild(lengthLabel);
  lengthDiv.appendChild(lengthInput);
  modal.appendChild(lengthDiv);

  const widthDiv = document.createElement("div");
  widthDiv.style.marginBottom = "8px";
  const widthLabel = document.createElement("label");
  widthLabel.textContent = "Width: ";
  widthLabel.style.display = "inline-block";
  widthLabel.style.width = "80px";
  const widthInput = document.createElement("input");
  widthInput.type = "text";
  widthInput.value = widthValue;
  widthInput.placeholder = "e.g., 4 or {b}";
  widthInput.style.width = "150px";
  widthDiv.appendChild(widthLabel);
  widthDiv.appendChild(widthInput);
  modal.appendChild(widthDiv);

  const heightDiv = document.createElement("div");
  heightDiv.style.marginBottom = "8px";
  const heightLabel = document.createElement("label");
  heightLabel.textContent = "Height: ";
  heightLabel.style.display = "inline-block";
  heightLabel.style.width = "80px";
  const heightInput = document.createElement("input");
  heightInput.type = "text";
  heightInput.value = heightValue;
  heightInput.placeholder = "e.g., 2 or {c}";
  heightInput.style.width = "150px";
  heightDiv.appendChild(heightLabel);
  heightDiv.appendChild(heightInput);
  modal.appendChild(heightDiv);
  
  // ⭐ NEW: Add enable/disable checkbox for automation
  const autoDiv = document.createElement("div");
  autoDiv.style.marginBottom = "8px";
  autoDiv.style.marginTop = "10px";
  const autoLabel = document.createElement("label");
  autoLabel.textContent = "Use Automate (Variables): ";
  autoLabel.style.display = "inline-block";
  autoLabel.style.width = "80px";
  const autoCheckbox = document.createElement("input");
  autoCheckbox.type = "checkbox";
  // Check if automation is currently enabled
  autoCheckbox.checked = container.hasAttribute("data-automate-enabled") && 
                          container.getAttribute("data-automate-enabled") === "true";
  autoDiv.appendChild(autoLabel);
  autoDiv.appendChild(autoCheckbox);
  modal.appendChild(autoDiv);

  // Add buttons
  const buttonDiv = document.createElement("div");
  buttonDiv.style.marginTop = "12px";
  buttonDiv.style.textAlign = "right";
  
  const okButton = document.createElement("button");
  okButton.textContent = "OK";
  okButton.style.marginRight = "5px";
  
  const cancelButton = document.createElement("button");
  cancelButton.textContent = "Cancel";
  
  buttonDiv.appendChild(okButton);
  buttonDiv.appendChild(cancelButton);
  modal.appendChild(buttonDiv);

  // ⭐ MODIFIED: OK button handler with automation flag  
  okButton.addEventListener("click", function() {
    // Save the expressions
    container.setAttribute("data-length-expr", lengthInput.value);
    container.setAttribute("data-width-expr", widthInput.value);
    container.setAttribute("data-height-expr", heightInput.value);
    
    // Set automation flag based on checkbox state
    container.setAttribute("data-automate-enabled", autoCheckbox.checked ? "true" : "false");
    
    cleanup();
  });

  cancelButton.addEventListener("click", cleanup);

  // Function to remove modal and overlay
  function cleanup() {
    document.body.removeChild(modal);
    document.body.removeChild(overlay);
  }

  // Add modal and overlay to the body
  document.body.appendChild(overlay);
  document.body.appendChild(modal);
}

function addTriangle() {
  // Get the canvas element (problem image container)
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeTriangleElement) {
    window.activeTriangleElement = null;
  }
  
  // Global counter for triangle IDs
  if (!window.globalTriangleCounter) {
    window.globalTriangleCounter = 1;
  } else {
    window.globalTriangleCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element triangle-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "150px";
  container.style.height = (toolbarHeight + 150) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  nextElementOffset += 10;
  container.isDragging = false;
  
  // Assign an ID for this triangle
  container.triangleID = window.globalTriangleCounter;
  
  // Initialize vertex visibility to true by default
  container.vertexVisibility = true;
  
  // Initialize vertex color
  container.vertexColor = "#0000ff";
  
  // Initialize altitude properties
  container.showAltitude = "no"; // Options: "no", "0", "1", "2" (vertex index)
  container.altitudeColor = "#000000";
  container.altitudeDashArray = "3,3";

  // Create the toolbar (visible by default)
  const localToolbar = document.createElement("div");
  localToolbar.className = "triangle-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "triangle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.style.width = "100%";
  svg.style.height = "100%";
  svg.setAttribute("viewBox", "0 0 150 150");
  content.appendChild(svg);

  // Create an SVG group
  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svg.appendChild(g);

  // Define initial vertices
  let vertices = [
    { x: 75, y: 15 },
    { x: 30, y: 135 },
    { x: 120, y: 135 }
  ];

  // Create the triangle polygon
  const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  polygon.setAttribute("stroke", "#000000");
  polygon.setAttribute("stroke-width", "2");
  polygon.setAttribute("fill", "transparent");
  g.appendChild(polygon);
  
  // Create altitude line and right angle symbol (initially hidden)
  const altitudeLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  altitudeLine.setAttribute("stroke", container.altitudeColor);
  altitudeLine.setAttribute("stroke-width", "2");
  altitudeLine.setAttribute("stroke-dasharray", container.altitudeDashArray);
  altitudeLine.style.display = "none";
  g.appendChild(altitudeLine);
  
  const rightAngleSymbol = document.createElementNS("http://www.w3.org/2000/svg", "path");
  rightAngleSymbol.setAttribute("fill", "none");
  rightAngleSymbol.setAttribute("stroke", container.altitudeColor);
  rightAngleSymbol.setAttribute("stroke-width", "1.5");
  rightAngleSymbol.style.display = "none";
  g.appendChild(rightAngleSymbol);

  function updatePolygon() {
    const pointsStr = vertices.map(v => `${v.x},${v.y}`).join(" ");
    polygon.setAttribute("points", pointsStr);
    
    // Update altitude if it's enabled
    updateAltitude();
  }
  updatePolygon();
  
  // Function to calculate and update the altitude
  function updateAltitude() {
    const showAltitude = container.showAltitude;
    
    if (showAltitude === "no") {
      // Hide altitude elements
      altitudeLine.style.display = "none";
      rightAngleSymbol.style.display = "none";
      return;
    }
    
    // Get vertex index (0, 1, or 2)
    const vertexIndex = parseInt(showAltitude);
    
    // Calculate the indices of the other two vertices
    const nextIndex = (vertexIndex + 1) % 3;
    const prevIndex = (vertexIndex + 2) % 3;
    
    // The vertex from which we're drawing the altitude
    const vertex = vertices[vertexIndex];
    
    // The other two vertices forming the opposite side
    const sidePoint1 = vertices[nextIndex];
    const sidePoint2 = vertices[prevIndex];
    
    // Calculate the base point of the altitude (projection onto the opposite side)
    // Formula for projecting a point onto a line segment
    const dx = sidePoint2.x - sidePoint1.x;
    const dy = sidePoint2.y - sidePoint1.y;
    
    // If the line is zero length, avoid division by zero
    if (dx === 0 && dy === 0) {
      altitudeLine.style.display = "none";
      rightAngleSymbol.style.display = "none";
      return;
    }
    
    // Calculate the projection parameter t
    const t = ((vertex.x - sidePoint1.x) * dx + (vertex.y - sidePoint1.y) * dy) / 
              (dx * dx + dy * dy);
    
    // Clamp t to [0,1] to ensure the base point is on the segment
    const clampedT = Math.max(0, Math.min(1, t));
    
    // Calculate the base point coordinates
    const baseX = sidePoint1.x + clampedT * dx;
    const baseY = sidePoint1.y + clampedT * dy;
    
    // Draw the altitude line
    altitudeLine.setAttribute("x1", vertex.x);
    altitudeLine.setAttribute("y1", vertex.y);
    altitudeLine.setAttribute("x2", baseX);
    altitudeLine.setAttribute("y2", baseY);
    altitudeLine.setAttribute("stroke", container.altitudeColor);
    altitudeLine.setAttribute("stroke-dasharray", container.altitudeDashArray);
    altitudeLine.style.display = "inline";
    
    // Draw the right angle symbol
    // Calculate size of the right angle symbol (proportional to the altitude length)
    const altitudeLength = Math.sqrt(
      Math.pow(vertex.x - baseX, 2) + Math.pow(vertex.y - baseY, 2)
    );
    const symbolSize = Math.max(8, altitudeLength * 0.08);
    
    // Calculate the direction vectors
    // Direction along the side line
    const sideDir = {
      x: dx / Math.sqrt(dx * dx + dy * dy),
      y: dy / Math.sqrt(dx * dx + dy * dy)
    };
    
    // Direction from base to vertex (perpendicular to side)
    const perpDir = {
      x: vertex.x - baseX,
      y: vertex.y - baseY
    };
    const perpLength = Math.sqrt(perpDir.x * perpDir.x + perpDir.y * perpDir.y);
    if (perpLength > 0) {
      perpDir.x /= perpLength;
      perpDir.y /= perpLength;
    }
    
    // Calculate the points for the right angle symbol
    const ra1 = {
      x: baseX + sideDir.x * symbolSize,
      y: baseY + sideDir.y * symbolSize
    };
    const ra2 = {
      x: baseX + sideDir.x * symbolSize + perpDir.x * symbolSize,
      y: baseY + sideDir.y * symbolSize + perpDir.y * symbolSize
    };
    const ra3 = {
      x: baseX + perpDir.x * symbolSize,
      y: baseY + perpDir.y * symbolSize
    };
    
    // Draw the right angle symbol
    rightAngleSymbol.setAttribute("d", `M${baseX},${baseY} L${ra1.x},${ra1.y} L${ra2.x},${ra2.y} L${ra3.x},${ra3.y} Z`);
    rightAngleSymbol.setAttribute("stroke", container.altitudeColor);
    rightAngleSymbol.style.display = "inline";
  }

  // Create vertex markers using the original marker positioning method
  let markers = [];
  function createMarkers() {
    markers.forEach(m => m.remove());
    markers = [];
    
    const vertexSize = 10; // Default size
    const vertexColor = "#0000ff"; // Default blue
    
    vertices.forEach((v, i) => {
      const marker = document.createElement("div");
      marker.className = "triangle-point";
      marker.style.position = "absolute";
      marker.style.width = vertexSize + "px";
      marker.style.height = vertexSize + "px";
      marker.style.background = vertexColor;
      marker.style.borderRadius = "50%";
      marker.style.cursor = "move";
      marker.style.zIndex = "100";
      
      marker.style.display = container.vertexVisibility ? "block" : "none";
      
      marker.dataset.index = i;
      markers.push(marker);
      content.appendChild(marker);
    });
  }

  // Create resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  // Helper functions to get current values
  function getStrokeColor() {
    return polygon.getAttribute("stroke");
  }
  
  function getFillColor() {
    return polygon.getAttribute("fill");
  }
  
  function getVertexColor() {
    if (container.vertexColor) {
      return container.vertexColor;
    }
    return markers.length > 0 ? markers[0].style.background : "#0000ff";
  }
  
  function getVertexSize() {
    return markers.length > 0 ? parseInt(markers[0].style.width) : 10;
  }
  
  function getLineThickness() {
    return parseFloat(polygon.getAttribute("stroke-width")) || 2;
  }

  function getShowVertices() {
    return container.vertexVisibility;
  }
  
  function getShowAltitude() {
    return container.showAltitude;
  }
  
  function getAltitudeColor() {
    return container.altitudeColor;
  }

  // Original marker positioning logic
  function updateMarkerPositions() {
    const viewBoxArr = svg.getAttribute("viewBox").split(" ").map(Number);
    const [vx, vy, vw, vh] = viewBoxArr;
    const svgRect = svg.getBoundingClientRect();
    const contentRect = content.getBoundingClientRect();
    const markerSize = getVertexSize();
    const halfSize = markerSize / 2;
    
    const scaleX = contentRect.width / vw;
    const scaleY = contentRect.height / vh;
    
    markers.forEach((marker, i) => {
      const relX = (vertices[i].x - vx) * scaleX;
      const relY = (vertices[i].y - vy) * scaleY;
      marker.style.left = (relX - halfSize) + "px";
      marker.style.top = (relY - halfSize) + "px";
      marker.style.width = markerSize + "px";
      marker.style.height = markerSize + "px";
      marker.style.background = getVertexColor();
    });
  }

  // Update container & SVG dimensions based on polygon bounding box,
  // but do not let the container go below minimum dimensions.
  function updateContainer() {
    const padding = 20; // extra padding around the triangle
    const bbox = polygon.getBBox();
    const newWidth = bbox.width + 2 * padding;
    const newHeight = bbox.height + 2 * padding;
    
    // Define minimum sizes for the container/triangle
    const minWidth = 150;
    const minHeight = 150;
    
    // Use the larger value between the calculated size and the minimum size.
    const finalWidth = Math.max(newWidth, minWidth);
    const finalHeight = Math.max(newHeight, minHeight);
    
    // Update the viewBox to always wrap the triangle based on its bounding box and padding
    const newViewX = bbox.x - padding;
    const newViewY = bbox.y - padding;
    svg.setAttribute("viewBox", `${newViewX} ${newViewY} ${finalWidth} ${finalHeight}`);
    
    container.style.width = finalWidth + "px";
    container.style.height = (toolbarHeight + finalHeight) + "px";
    updateMarkerPositions();
  }

  // Utility to apply vertex visibility
  function applyVertexVisibility() {
    const showVertices = getShowVertices();
    markers.forEach(marker => {
      marker.style.display = showVertices ? "block" : "none";
    });
  }

  // Update global toolbar with triangle controls (two rows)
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Triangle " + container.triangleID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      polygon.setAttribute("stroke", this.value);
    });
    row1.appendChild(lineColorInput);

    // Fill color control
    const fillLabel = document.createElement("span");
    fillLabel.textContent = "Fill:";
    fillLabel.style.fontSize = "12px";
    row1.appendChild(fillLabel);

    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor() === "transparent" ? "#ffffff" : getFillColor();
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      polygon.setAttribute("fill", this.value);
    });
    row1.appendChild(fillColorInput);

    // Vertex color control
    const vertexColorLabel = document.createElement("span");
    vertexColorLabel.textContent = "Vertex:";
    vertexColorLabel.style.fontSize = "12px";
    row1.appendChild(vertexColorLabel);

    const vertexColorInput = document.createElement("input");
    vertexColorInput.type = "color";
    vertexColorInput.value = getVertexColor();
    vertexColorInput.style.marginLeft = "5px";
    vertexColorInput.style.marginRight = "10px";
    vertexColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      const newColor = this.value;
      markers.forEach(marker => marker.style.background = newColor);
      container.vertexColor = newColor;
    });
    row1.appendChild(vertexColorInput);

    // Vertex visibility control
    const vertexVisLabel = document.createElement("span");
    vertexVisLabel.textContent = "Show Vertices:";
    vertexVisLabel.style.fontSize = "12px";
    row1.appendChild(vertexVisLabel);

    const vertexSelect = document.createElement("select");
    vertexSelect.id = "vertex-visibility-" + container.triangleID;
    vertexSelect.style.marginLeft = "5px";
    vertexSelect.style.fontSize = "12px";
    
    const optYes = document.createElement("option");
    optYes.value = "yes";
    optYes.textContent = "Yes";
    const optNo = document.createElement("option");
    optNo.value = "no";
    optNo.textContent = "No";
    
    vertexSelect.appendChild(optYes);
    vertexSelect.appendChild(optNo);
    vertexSelect.value = container.vertexVisibility ? "yes" : "no";
    vertexSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      const showVertices = this.value === "yes";
      container.vertexVisibility = showVertices;
      applyVertexVisibility();
      console.log("Vertex visibility changed to:", showVertices, "for triangle", container.triangleID);
    });
    row1.appendChild(vertexSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "20px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      polygon.setAttribute("stroke-width", this.value);
    });
    row2.appendChild(thicknessInput);

    // Vertex size control
    const vertexSizeLabel = document.createElement("span");
    vertexSizeLabel.textContent = "Vertex Size:";
    vertexSizeLabel.style.fontSize = "12px";
    row2.appendChild(vertexSizeLabel);

    const vertexSizeInput = document.createElement("input");
    vertexSizeInput.type = "number";
    vertexSizeInput.min = "1";
    vertexSizeInput.max = "20";
    vertexSizeInput.value = getVertexSize();
    vertexSizeInput.style.width = "40px";
    vertexSizeInput.style.marginLeft = "5px";
    vertexSizeInput.style.marginRight = "20px";
    vertexSizeInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexSizeInput.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexSizeInput.addEventListener("input", function(e) {
      e.stopPropagation();
      // Update marker sizes based on new vertex size
      markers.forEach(marker => {
        marker.style.width = this.value + "px";
        marker.style.height = this.value + "px";
      });
      updateMarkerPositions();
    });
    row2.appendChild(vertexSizeInput);
    
    // Draw Altitude control
    const altitudeLabel = document.createElement("span");
    altitudeLabel.textContent = "Draw Altitude:";
    altitudeLabel.style.fontSize = "12px";
    row2.appendChild(altitudeLabel);
    
    const altitudeSelect = document.createElement("select");
    altitudeSelect.style.marginLeft = "5px";
    altitudeSelect.style.marginRight = "10px";
    
    const noAltOpt = document.createElement("option");
    noAltOpt.value = "no";
    noAltOpt.textContent = "No";
    
    const vert0Opt = document.createElement("option");
    vert0Opt.value = "0";
    vert0Opt.textContent = "From Top";
    
    const vert1Opt = document.createElement("option");
    vert1Opt.value = "1";
    vert1Opt.textContent = "From Left";
    
    const vert2Opt = document.createElement("option");
    vert2Opt.value = "2";
    vert2Opt.textContent = "From Right";
    
    altitudeSelect.appendChild(noAltOpt);
    altitudeSelect.appendChild(vert0Opt);
    altitudeSelect.appendChild(vert1Opt);
    altitudeSelect.appendChild(vert2Opt);
    altitudeSelect.value = getShowAltitude();
    
    altitudeSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    altitudeSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    altitudeSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.showAltitude = this.value;
      updateAltitude();
    });
    row2.appendChild(altitudeSelect);
    
    // Altitude color control
    const altitudeColorLabel = document.createElement("span");
    altitudeColorLabel.textContent = "Altitude Color:";
    altitudeColorLabel.style.fontSize = "12px";
    altitudeColorLabel.style.marginLeft = "10px";
    row2.appendChild(altitudeColorLabel);
    
    const altitudeColorInput = document.createElement("input");
    altitudeColorInput.type = "color";
    altitudeColorInput.value = getAltitudeColor();
    altitudeColorInput.style.marginLeft = "5px";
    altitudeColorInput.style.marginRight = "10px";
    altitudeColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    altitudeColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    altitudeColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.altitudeColor = this.value;
      altitudeLine.setAttribute("stroke", this.value);
      rightAngleSymbol.setAttribute("stroke", this.value);
    });
    row2.appendChild(altitudeColorInput);

    globalToolbar.appendChild(row2);
  }

  function activateTriangle() {
    if (window.activeTriangleElement && window.activeTriangleElement !== container) {
      window.activeTriangleElement.style.border = "none";
      const prevToolbar = window.activeTriangleElement.querySelector(".triangle-toolbar");
      const prevResizeHandle = window.activeTriangleElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    window.activeTriangleElement = container;
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    updateMarkerPositions();
    updateGlobalToolbar();
  }

  function deactivateTriangle() {
    if (window.activeTriangleElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeTriangleElement = null;
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Delete function
  function deleteTriangle() {
    if (window.activeTriangleElement === container) {
      window.activeTriangleElement = null;
    }
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Marker drag functionality
  function setupMarkerDrag(marker, index) {
    marker.addEventListener("mousedown", function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      const svgRect = svg.getBoundingClientRect();
      const viewBoxArr = svg.getAttribute("viewBox").split(" ").map(Number);
      const [vx, vy, vw, vh] = viewBoxArr;
      const scaleX = vw / svgRect.width;
      const scaleY = vh / svgRect.height;
      
      let startX = e.clientX;
      let startY = e.clientY;
      
      function onMouseMove(e) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const scaledDx = dx * scaleX;
        const scaledDy = dy * scaleY;
        vertices[index].x += scaledDx;
        vertices[index].y += scaledDy;
        startX = e.clientX;
        startY = e.clientY;
        updatePolygon();
        updateContainer();
      }
      
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
  }

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const svgRect = svg.getBoundingClientRect();
    const viewBoxArr = svg.getAttribute("viewBox").split(" ").map(Number);
    const [vx, vy, vw, vh] = viewBoxArr;
    
    const startX = e.clientX;
    const startY = e.clientY;
    
    const centroid = {
      x: (vertices[0].x + vertices[1].x + vertices[2].x) / 3,
      y: (vertices[0].y + vertices[1].y + vertices[2].y) / 3
    };
    
    const origVertices = vertices.map(v => ({ x: v.x, y: v.y }));
    const initDistances = origVertices.map(v =>
      Math.sqrt(Math.pow(v.x - centroid.x, 2) + Math.pow(v.y - centroid.y, 2))
    );
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const scale = 1 + Math.max(dx, dy) / 100;
      vertices = origVertices.map((v, i) => {
        const angle = Math.atan2(v.y - centroid.y, v.x - centroid.x);
        const distance = initDistances[i] * scale;
        return {
          x: centroid.x + distance * Math.cos(angle),
          y: centroid.y + distance * Math.sin(angle)
        };
      });
      updatePolygon();
      updateContainer();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries:
      // The container's left edge should not go left of the canvas (minLeft = 0)
      // The container's right edge should not exceed the canvas's right side
      // The container's top edge cannot go more than 10px above the canvas (minTop = -10)
      // The container's bottom edge should not go below the canvas.
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Delete: both mousedown and click for reliability
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteTriangle();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteTriangle();
  });

  // Activate on mousedown (unless target is drag/resize/marker)
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle && !markers.includes(e.target)) {
      activateTriangle();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    if (!container.contains(e.target) && !clickedInGlobalToolbar && window.activeTriangleElement === container) {
      deactivateTriangle();
    }
  });

  // Create initial markers and setup dragging for them
  createMarkers();
  markers.forEach((marker, i) => {
    setupMarkerDrag(marker, i);
  });

  container.style.border = "1px dashed #ccc";
  updateMarkerPositions();

  // Append to canvas and set as active
  canvas.appendChild(container);
  window.activeTriangleElement = container;
  updateGlobalToolbar();
  applyVertexVisibility();

  // Set up ResizeObserver after container and content are created
  const resizeObserver = new ResizeObserver(() => {
    updateMarkerPositions();
  });
  resizeObserver.observe(container);
  resizeObserver.observe(content);
}
// NEW: Add Polygon – similar to addTriangle but with a “Number of sides” control.

function addPolygon() {
  // Get the canvas element - avoiding variable redeclaration
  const problemCanvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let nextElementOffset = 10;

  // Create global focus lock manager if it doesn't exist
  if (!window.focusLockManager) {
    window.focusLockManager = {
      lockedElement: null,
      
      lock: function(element) {
        this.lockedElement = element;
        element.style.border = "2px solid #ff6666";
        
        // Add visual notification
        const notification = document.createElement("div");
        notification.textContent = "Focus locked on " + (element.className.includes("polygon") ? "Polygon " : "Triangle ") + element.polygonID;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor = "rgba(255, 102, 102, 0.8)";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = "0";
          notification.style.transition = "opacity 0.5s";
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 500);
        }, 2000);
      },
      
      unlock: function() {
        if (this.lockedElement) {
          this.lockedElement.style.border = "1px dashed #ccc";
          this.lockedElement = null;
        }
      },
      
      isLocked: function() {
        return this.lockedElement !== null;
      },
      
      isLockedElement: function(element) {
        return this.lockedElement === element;
      },
      
      flashLockedElement: function() {
        if (!this.lockedElement) return;
        
        const originalBorder = this.lockedElement.style.border;
        this.lockedElement.style.border = "3px solid red";
        setTimeout(() => {
          this.lockedElement.style.border = originalBorder;
        }, 300);
      }
    };
    
    // Add global event interceptor
    document.addEventListener("mousedown", function(e) {
      if (window.focusLockManager.isLocked()) {
        const lockedElement = window.focusLockManager.lockedElement;
        
        // Allow interaction with the locked element and the global toolbar
        const globalToolbar = document.getElementById("global-toolbar");
        const isClickInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
        
        // If click is not on locked element or global toolbar, block it
        if (!lockedElement.contains(e.target) && !isClickInGlobalToolbar) {
          e.stopPropagation();
          e.preventDefault();
          window.focusLockManager.flashLockedElement();
          return false;
        }
      }
    }, true);
  }

  // Keep track of the currently active element globally
  if (!window.activePolygonElement) {
    window.activePolygonElement = null;
  }
  
  // Global counter for polygon IDs
  if (!window.globalPolygonCounter) {
    window.globalPolygonCounter = 1;
  } else {
    window.globalPolygonCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element polygon-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "200px";
  container.style.height = (toolbarHeight + 200) + "px";
  container.style.cursor = "pointer";
  container.style.border = "1px dashed #ccc"; // Start with visible border
  nextElementOffset += 10;
  container.isDragging = false;
  
  // Assign an ID for this polygon
  container.polygonID = window.globalPolygonCounter;
  
  // Initialize state properties
  container.vertexVisibility = true;
  container.vertexColor = "#0000ff";
  container.vertexSize = 5;
  container.numSides = 5;
  container.showExtAngles = "no"; // Initialize exterior angles state to "no"
  container.extAngleLength = 50; // Length of the extended line segments

  // Create the local toolbar (visible by default)
  const localToolbar = document.createElement("div");
  localToolbar.className = "polygon-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "flex"; // Start visible
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);

  // Create content div
  const content = document.createElement("div");
  content.className = "polygon-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG
  const svgWidth = 200, svgHeight = 200;
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Create an SVG group
  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svg.appendChild(g);

  // Create the polygon element
  const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  polygon.setAttribute("stroke", "#000000");
  polygon.setAttribute("stroke-width", "2");
  polygon.setAttribute("fill", "#ffffff");
  g.appendChild(polygon);
  
  // Create a group for exterior angle lines
  const extAnglesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
  extAnglesGroup.classList.add("ext-angles-group");
  extAnglesGroup.style.display = "none"; // Initially hidden
  g.appendChild(extAnglesGroup);

  // Compute initial vertices for a regular polygon
  let center = { x: svgWidth / 2, y: svgHeight / 2 };
  let radius = Math.min(svgWidth, svgHeight) * 0.4;
  let vertices = [];

  function updateVertices() {
    const numSides = container.numSides;
    vertices = [];
    const angleOffset = -Math.PI / 2; // so the polygon points upward
    for (let i = 0; i < numSides; i++) {
      const angle = angleOffset + (2 * Math.PI * i) / numSides;
      const x = center.x + radius * Math.cos(angle);
      const y = center.y + radius * Math.sin(angle);
      vertices.push({ x: x, y: y });
    }
  }
  updateVertices();

  function updatePolygon() {
    const pointsStr = vertices.map(v => `${v.x},${v.y}`).join(" ");
    polygon.setAttribute("points", pointsStr);
    
    // Update exterior angles if enabled
    updateExteriorAngles();
  }
  
  // Function to update the exterior angles
  function updateExteriorAngles() {
    // Remove any existing exterior angle lines
    while (extAnglesGroup.firstChild) {
      extAnglesGroup.removeChild(extAnglesGroup.firstChild);
    }
    
    // If exterior angles are not enabled, hide the group and return
    if (container.showExtAngles === "no") {
      extAnglesGroup.style.display = "none";
      return;
    }
    
    // Show the exterior angles group
    extAnglesGroup.style.display = "inline";
    
    // Get line properties
    const lineColor = getStrokeColor();
    const lineThickness = getLineThickness();
    const extLength = container.extAngleLength;
    
    // For each vertex of the polygon, create one extended line
    for (let i = 0; i < vertices.length; i++) {
      const currentVertex = vertices[i];
      const nextVertex = vertices[(i + 1) % vertices.length];
      
      // Calculate the direction vector for the current side
      const dirX = nextVertex.x - currentVertex.x;
      const dirY = nextVertex.y - currentVertex.y;
      const dirLength = Math.sqrt(dirX * dirX + dirY * dirY);
      
      if (dirLength > 0) {  // Prevent division by zero
        // Calculate the normalized direction vector
        const normDirX = dirX / dirLength;
        const normDirY = dirY / dirLength;
        
        // Calculate the extension point (extending in the opposite direction)
        const extX = currentVertex.x - normDirX * extLength;
        const extY = currentVertex.y - normDirY * extLength;
        
        // Create a line element for the extension
        const extLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        extLine.setAttribute("x1", currentVertex.x);
        extLine.setAttribute("y1", currentVertex.y);
        extLine.setAttribute("x2", extX);
        extLine.setAttribute("y2", extY);
        extLine.setAttribute("stroke", lineColor);
        extLine.setAttribute("stroke-width", lineThickness);
        extAnglesGroup.appendChild(extLine);
      }
    }
  }
  
  updatePolygon();
  // Create draggable markers for each vertex
  let markers = [];
  function createMarkers() {
    markers.forEach(m => m.remove());
    markers = [];
    for (let i = 0; i < vertices.length; i++) {
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      marker.setAttribute("cx", vertices[i].x);
      marker.setAttribute("cy", vertices[i].y);
      marker.setAttribute("r", container.vertexSize);
      marker.setAttribute("fill", container.vertexColor);
      marker.setAttribute("stroke", "black");
      marker.setAttribute("stroke-width", "1");
      marker.style.cursor = "move";
      marker.dataset.index = i;
      marker.style.display = container.vertexVisibility ? "block" : "none";
      markers.push(marker);
      svg.appendChild(marker);
      
      // Add dragging functionality for marker
      setupMarkerDrag(marker, i);
    }
  }

  // Helper functions to get current values
  function getStrokeColor() {
    return polygon.getAttribute("stroke");
  }
  
  function getFillColor() {
    return polygon.getAttribute("fill");
  }
  
  function getVertexColor() {
    return container.vertexColor || "#0000ff";
  }
  
  function getVertexSize() {
    return container.vertexSize || 5;
  }
  
  function getLineThickness() {
    return parseFloat(polygon.getAttribute("stroke-width")) || 2;
  }

  function getShowVertices() {
    return container.vertexVisibility;
  }
  
  function getNumberOfSides() {
    return container.numSides;
  }
  
  function getShowExtAngles() {
    return container.showExtAngles;
  }

  // Create the resize handle (visible by default)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "block";
  container.appendChild(resizeHandle);

  // Apply vertex visibility
  function applyVertexVisibility() {
    const showVertices = getShowVertices();
    markers.forEach(marker => {
      marker.style.display = showVertices ? "block" : "none";
    });
  }

  // Setup marker drag functionality
  function setupMarkerDrag(marker, index) {
    marker.addEventListener("mousedown", function(e) {
      e.stopPropagation();
      const startX = e.clientX, startY = e.clientY;
      const origX = vertices[index].x, origY = vertices[index].y;
      
      function onMouseMove(e) {
        const dx = e.clientX - startX, dy = e.clientY - startY;
        vertices[index].x = origX + dx;
        vertices[index].y = origY + dy;
        updatePolygon();
        marker.setAttribute("cx", vertices[index].x);
        marker.setAttribute("cy", vertices[index].y);
      }
      
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
  }

  // Initialize focus lock state if not existing
  if (container.focusLocked === undefined) {
    container.focusLocked = false;
  }

  // Update global toolbar with polygon controls
  function updateGlobalToolbar() {
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) return;
    globalToolbar.innerHTML = "";

    // Create first row container for the main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";

    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Polygon " + container.polygonID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "10px";
    row1.appendChild(identityLabel);

    // Line color control
    const lineLabel = document.createElement("span");
    lineLabel.textContent = "Line:";
    lineLabel.style.fontSize = "12px";
    row1.appendChild(lineLabel);

    const lineColorInput = document.createElement("input");
    lineColorInput.type = "color";
    lineColorInput.value = getStrokeColor();
    lineColorInput.style.marginLeft = "5px";
    lineColorInput.style.marginRight = "10px";
    lineColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    lineColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      polygon.setAttribute("stroke", this.value);
      // Also update exterior angle lines if they exist
      updateExteriorAngles();
    });
    row1.appendChild(lineColorInput);

    // Fill color control
    const fillLabel = document.createElement("span");
    fillLabel.textContent = "Fill:";
    fillLabel.style.fontSize = "12px";
    row1.appendChild(fillLabel);

    const fillColorInput = document.createElement("input");
    fillColorInput.type = "color";
    fillColorInput.value = getFillColor();
    fillColorInput.style.marginLeft = "5px";
    fillColorInput.style.marginRight = "10px";
    fillColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    fillColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      polygon.setAttribute("fill", this.value);
    });
    row1.appendChild(fillColorInput);

    // Vertex color control
    const vertexColorLabel = document.createElement("span");
    vertexColorLabel.textContent = "Vertex:";
    vertexColorLabel.style.fontSize = "12px";
    row1.appendChild(vertexColorLabel);

    const vertexColorInput = document.createElement("input");
    vertexColorInput.type = "color";
    vertexColorInput.value = getVertexColor();
    vertexColorInput.style.marginLeft = "5px";
    vertexColorInput.style.marginRight = "10px";
    vertexColorInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexColorInput.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexColorInput.addEventListener("input", function(e) {
      e.stopPropagation();
      const newColor = this.value;
      markers.forEach(marker => marker.setAttribute("fill", newColor));
      container.vertexColor = newColor;
    });
    row1.appendChild(vertexColorInput);

    // Vertex visibility control
    const vertexVisLabel = document.createElement("span");
    vertexVisLabel.textContent = "Show Vertices:";
    vertexVisLabel.style.fontSize = "12px";
    row1.appendChild(vertexVisLabel);

    const vertexSelect = document.createElement("select");
    vertexSelect.id = "vertex-visibility-" + container.polygonID;
    vertexSelect.style.marginLeft = "5px";
    vertexSelect.style.marginRight = "10px";
    vertexSelect.style.fontSize = "12px";
    
    const optYes = document.createElement("option");
    optYes.value = "yes";
    optYes.textContent = "Yes";
    const optNo = document.createElement("option");
    optNo.value = "no";
    optNo.textContent = "No";
    
    vertexSelect.appendChild(optYes);
    vertexSelect.appendChild(optNo);
    vertexSelect.value = container.vertexVisibility ? "yes" : "no";
    vertexSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      const showVertices = this.value === "yes";
      container.vertexVisibility = showVertices;
      applyVertexVisibility();
    });
    row1.appendChild(vertexSelect);

    globalToolbar.appendChild(row1);

    // Create second row container for additional controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.marginTop = "5px";

    // Line thickness control
    const thicknessLabel = document.createElement("span");
    thicknessLabel.textContent = "Line Thickness:";
    thicknessLabel.style.fontSize = "12px";
    row2.appendChild(thicknessLabel);

    const thicknessInput = document.createElement("input");
    thicknessInput.type = "number";
    thicknessInput.min = "1";
    thicknessInput.max = "10";
    thicknessInput.value = getLineThickness();
    thicknessInput.style.width = "40px";
    thicknessInput.style.marginLeft = "5px";
    thicknessInput.style.marginRight = "20px";
    thicknessInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("click", function(e) { e.stopPropagation(); });
    thicknessInput.addEventListener("input", function(e) {
      e.stopPropagation();
      polygon.setAttribute("stroke-width", this.value);
      // Also update exterior angle lines
      updateExteriorAngles();
    });
    row2.appendChild(thicknessInput);

    // Vertex size control
    const vertexSizeLabel = document.createElement("span");
    vertexSizeLabel.textContent = "Vertex Size:";
    vertexSizeLabel.style.fontSize = "12px";
    row2.appendChild(vertexSizeLabel);

    const vertexSizeInput = document.createElement("input");
    vertexSizeInput.type = "number";
    vertexSizeInput.min = "1";
    vertexSizeInput.max = "20";
    vertexSizeInput.value = getVertexSize();
    vertexSizeInput.style.width = "40px";
    vertexSizeInput.style.marginLeft = "5px";
    vertexSizeInput.style.marginRight = "20px";
    vertexSizeInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    vertexSizeInput.addEventListener("click", function(e) { e.stopPropagation(); });
    vertexSizeInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.vertexSize = parseInt(this.value);
      markers.forEach(marker => marker.setAttribute("r", this.value));
    });
    row2.appendChild(vertexSizeInput);

    // Number of sides control
    const sidesLabel = document.createElement("span");
    sidesLabel.textContent = "Number of Sides:";
    sidesLabel.style.fontSize = "12px";
    row2.appendChild(sidesLabel);

    const sidesInput = document.createElement("input");
    sidesInput.type = "number";
    sidesInput.min = "3";
    sidesInput.max = "20";
    sidesInput.value = getNumberOfSides();
    sidesInput.style.width = "40px";
    sidesInput.style.marginLeft = "5px";
    sidesInput.style.marginRight = "20px";
    sidesInput.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    sidesInput.addEventListener("click", function(e) { e.stopPropagation(); });
    sidesInput.addEventListener("input", function(e) {
      e.stopPropagation();
      container.numSides = parseInt(this.value);
      updateVertices();
      updatePolygon();
      createMarkers();
      applyVertexVisibility();
    });
    row2.appendChild(sidesInput);
    
    // Exterior Angles control
    const extAnglesLabel = document.createElement("span");
    extAnglesLabel.textContent = "Ext. Angles:";
    extAnglesLabel.style.fontSize = "12px";
    row2.appendChild(extAnglesLabel);
    
    const extAnglesSelect = document.createElement("select");
    extAnglesSelect.style.marginLeft = "5px";
    extAnglesSelect.style.marginRight = "10px";
    
    const noExtOpt = document.createElement("option");
    noExtOpt.value = "no";
    noExtOpt.textContent = "No";
    
    const yesExtOpt = document.createElement("option");
    yesExtOpt.value = "yes";
    yesExtOpt.textContent = "Yes";
    
    extAnglesSelect.appendChild(noExtOpt);
    extAnglesSelect.appendChild(yesExtOpt);
    extAnglesSelect.value = getShowExtAngles();
    
    extAnglesSelect.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    extAnglesSelect.addEventListener("click", function(e) { e.stopPropagation(); });
    extAnglesSelect.addEventListener("change", function(e) {
      e.stopPropagation();
      container.showExtAngles = this.value;
      updateExteriorAngles();
    });
    row2.appendChild(extAnglesSelect);

    // Add some spacing
    const spacer = document.createElement("div");
    spacer.style.width = "10px";
    row2.appendChild(spacer);

    // Focus Lock button
    const lockFocusButton = document.createElement("button");
    lockFocusButton.textContent = window.focusLockManager.isLockedElement(container) ? "Unlock Focus" : "Lock Focus";
    lockFocusButton.style.fontSize = "12px";
    lockFocusButton.style.padding = "2px 8px";
    lockFocusButton.style.cursor = "pointer";
    lockFocusButton.style.backgroundColor = window.focusLockManager.isLockedElement(container) ? "#ffcccc" : "#ccffcc";
    lockFocusButton.addEventListener("mousedown", function(e) { e.stopPropagation(); });
    lockFocusButton.addEventListener("click", function(e) {
      e.stopPropagation();
      
      if (window.focusLockManager.isLockedElement(container)) {
        // Unlock this element
        window.focusLockManager.unlock();
        this.textContent = "Lock Focus";
        this.style.backgroundColor = "#ccffcc";
      } else {
        // First unlock any currently locked element
        window.focusLockManager.unlock();
        
        // Then lock this element
        window.focusLockManager.lock(container);
        this.textContent = "Unlock Focus";
        this.style.backgroundColor = "#ffcccc";
      }
    });
    row2.appendChild(lockFocusButton);

    globalToolbar.appendChild(row2);
  }

  function activatePolygon() {
    // If there's a locked element that's not this container, don't activate
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      return;
    }
    
    if (window.activePolygonElement && window.activePolygonElement !== container) {
      // Reset previous element's appearance
      window.activePolygonElement.style.border = "none";
      const prevToolbar = window.activePolygonElement.querySelector(".polygon-toolbar");
      const prevResizeHandle = window.activePolygonElement.querySelector(".resize-handle");
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activePolygonElement = container;
    
    // Set border based on focus lock state
    if (window.focusLockManager.isLockedElement(container)) {
      container.style.border = "2px solid #ff6666";
    } else {
      container.style.border = "1px dashed #ccc";
    }
    
    localToolbar.style.display = "flex";
    localToolbar.style.position = "absolute";
    localToolbar.style.top = "0";
    localToolbar.style.left = "0";
    localToolbar.style.width = "100%";
    resizeHandle.style.display = "block";
    updateGlobalToolbar();
  }

  function deactivatePolygon() {
    // Don't deactivate if this element has focus lock
    if (window.activePolygonElement === container && !window.focusLockManager.isLockedElement(container)) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activePolygonElement = null;
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) {
        globalToolbar.innerHTML = "";
      }
    }
  }

  // Cleanup any references when deleted
  function deletePolygon() {
    if (window.activePolygonElement === container) {
      window.activePolygonElement = null;
    }
    
    // If this element has focus lock, unlock it
    if (window.focusLockManager.isLockedElement(container)) {
      window.focusLockManager.unlock();
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar) globalToolbar.innerHTML = "";
    } catch (err) {
      console.error("Error removing container:", err);
    }
  }

  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX, startY = e.clientY;
    const startWidth = container.offsetWidth, startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = startWidth + (e.clientX - startX);
      const newHeight = startHeight + (e.clientY - startY);
      
      if (newWidth > 50) {
        container.style.width = newWidth + "px";
        content.style.width = newWidth + "px";
        svg.setAttribute("width", newWidth);
        svg.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight - toolbarHeight}`);
      }
      if (newHeight > toolbarHeight + 50) {
        container.style.height = newHeight + "px";
        content.style.height = (newHeight - toolbarHeight) + "px";
        svg.setAttribute("height", newHeight - toolbarHeight);
        svg.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight - toolbarHeight}`);
      }
      
      // Update center and recalculate vertices
      center = { 
        x: parseFloat(svg.getAttribute("width")) / 2,
        y: parseFloat(svg.getAttribute("height")) / 2
      };
      radius = Math.min(parseFloat(svg.getAttribute("width")), parseFloat(svg.getAttribute("height"))) * 0.4;
      updateVertices();
      updatePolygon();
      
      // Update marker positions
      markers.forEach((marker, i) => {
        marker.setAttribute("cx", vertices[i].x);
        marker.setAttribute("cy", vertices[i].y);
      });
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Drag handle functionality with boundaries
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = problemCanvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      // Calculate the new position relative to the canvas
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      
      // Set boundaries
      const minLeft = 0;
      const maxLeft = canvasRect.width - container.offsetWidth;
      const minTop = -10;
      const maxTop = canvasRect.height - container.offsetHeight;
      
      newLeft = Math.min(Math.max(newLeft, minLeft), maxLeft);
      newTop = Math.min(Math.max(newTop, minTop), maxTop);
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Delete button events
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePolygon();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deletePolygon();
  });

  // Activate on mousedown (unless target is drag/resize/marker)
  container.addEventListener("mousedown", function(e) {
    // If there's a locked element that's not this one, do nothing
    if (window.focusLockManager.isLocked() && 
        !window.focusLockManager.isLockedElement(container)) {
      // Let the global event handler handle this
      return;
    }
    
    if (e.target !== dragHandle && e.target !== resizeHandle && !markers.includes(e.target)) {
      activatePolygon();
    }
  });

  // Document click for deactivation
  document.addEventListener("click", function(e) {
    const globalToolbar = document.getElementById("global-toolbar");
    const clickedInGlobalToolbar = globalToolbar && globalToolbar.contains(e.target);
    
    // Only deactivate if not focus-locked and clicked outside
    if (!container.contains(e.target) && 
        !clickedInGlobalToolbar && 
        window.activePolygonElement === container && 
        !window.focusLockManager.isLockedElement(container)) {
      deactivatePolygon();
    }
  });

  // Create initial markers
  createMarkers();

  // Append to canvas and set as active
  problemCanvas.appendChild(container);
  window.activePolygonElement = container;
  updateGlobalToolbar();

  // Set up ResizeObserver after container and content are created
  const resizeObserver = new ResizeObserver(() => {
    markers.forEach((marker, i) => {
      marker.setAttribute("cx", vertices[i].x);
      marker.setAttribute("cy", vertices[i].y);
    });
  });
  resizeObserver.observe(container);
  resizeObserver.observe(content);
}

function addTable() {
  console.log("Initializing new table...");
  // Get the canvas element
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 30;
  let nextElementOffset = 10;

  // Keep track of the currently active element globally
  if (!window.activeTableElement) {
    window.activeTableElement = null;
  }
  
  // Global counter for table IDs
  if (!window.globalTableCounter) {
    window.globalTableCounter = 1;
  } else {
    window.globalTableCounter++;
  }

  // Create the container
  const container = document.createElement("div");
  container.className = "draggable-element table-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "600px";
  container.style.backgroundColor = "#fff";
  container.style.boxSizing = "border-box";
  container.style.cursor = "pointer";
  container.style.overflow = "auto";
  nextElementOffset += 10;
  container.isDragging = false;
  
  // Assign an ID for this table
  container.tableID = window.globalTableCounter;
  // Also store it as a data-attribute so cloneNode will copy it:
  container.setAttribute('data-table-id', container.tableID);
  console.log(`Created table with ID: ${container.tableID}`);

  // Create the toolbar (start hidden)
  const localToolbar = document.createElement("div");
  localToolbar.className = "table-toolbar element-controls";
  localToolbar.style.width = "100%";
  localToolbar.style.height = toolbarHeight + "px";
  localToolbar.style.boxSizing = "border-box";
  localToolbar.style.backgroundColor = "#f0f0f0";
  localToolbar.style.display = "none"; // Start hidden
  localToolbar.style.alignItems = "center";
  localToolbar.style.justifyContent = "space-between";
  localToolbar.style.padding = "0 5px";
  localToolbar.style.zIndex = "10";

  // Create drag handle
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  
  const leftSide = document.createElement("div");
  leftSide.style.display = "flex";
  leftSide.style.alignItems = "center";
  leftSide.appendChild(dragHandle);
  localToolbar.appendChild(leftSide);

  // Create delete button
  const deleteButton = document.createElement("button");
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  deleteButton.style.padding = "2px 8px";
  deleteButton.style.cursor = "pointer";
  
  // Prevent activation when clicking delete
  deleteButton.addEventListener("mousedown", function(e) {
    e.stopPropagation();
  });

  const rightSide = document.createElement("div");
  rightSide.style.display = "flex";
  rightSide.style.alignItems = "center";
  rightSide.appendChild(deleteButton);
  localToolbar.appendChild(rightSide);

  container.appendChild(localToolbar);
  
  // Create content div
  const content = document.createElement("div");
  content.className = "table-content";
  content.style.position = "relative";
  content.style.width = "100%";
  content.style.paddingTop = toolbarHeight + "px";
  content.style.boxSizing = "border-box";
  container.appendChild(content);

  // Store the table data
  container.tableData = {
    rows: 4,
    cols: 3,
    hasHeader: true,
    fontSize: 14,
    fontFamily: "Arial,Helvetica,sans-serif",
    align: "center",
    showTitle: true,
    titleText: "Table 1",
    showFooter: true,
    footerText: "Note: sample.",
    cellData: [], // Will hold all the cell data
    highlightColor: "#ffeb3b", // Default highlight color
    // NEW: Store highlighted elements and their colors
    highlights: {
      rows: {},   // Format: {rowIndex: colorHex}
      columns: {}, // Format: {colIndex: colorHex}
      cells: {}   // Format: {rowIndex-colIndex: colorHex}
    }
  };

  // Create the table container to match the original HTML structure
  const tableWrapper = document.createElement("div");
  tableWrapper.className = "table-container-inner";
  tableWrapper.style.position = "relative";
  tableWrapper.style.display = "inline-block";
  tableWrapper.style.border = "none"; // No outer border
  tableWrapper.style.padding = "15px";
  tableWrapper.style.borderRadius = "5px";
  tableWrapper.style.overflow = "auto";
  tableWrapper.style.verticalAlign = "top";
  tableWrapper.style.width = "100%";
  tableWrapper.style.boxSizing = "border-box";
  content.appendChild(tableWrapper);
  
  // Create title element
  const titleElem = document.createElement("div");
  titleElem.className = "table-title";
  titleElem.style.textAlign = "center";
  titleElem.style.fontWeight = "bold";
  titleElem.style.padding = "4px 0";
  tableWrapper.appendChild(titleElem);
  
  // Create table element
  const tableElem = document.createElement("table");
  tableElem.id = `table-${container.tableID}`;
  tableElem.style.borderCollapse = "collapse";
  tableElem.style.width = "100%";
  tableElem.setAttribute("role", "grid");
  tableWrapper.appendChild(tableElem);
  
  // Create footer element
  const footerElem = document.createElement("div");
  footerElem.className = "table-footer";
  footerElem.style.textAlign = "center";
  footerElem.style.fontStyle = "italic";
  footerElem.style.padding = "4px 0";
  tableWrapper.appendChild(footerElem);
  
  // Create resize handle for the table
  const tableResizeHandle = document.createElement("div");
  tableResizeHandle.className = "table-resize-handle";
  tableResizeHandle.style.position = "absolute";
  tableResizeHandle.style.top = "0";
  tableResizeHandle.style.right = "0";
  tableResizeHandle.style.bottom = "0";
  tableResizeHandle.style.width = "6px";
  tableResizeHandle.style.cursor = "ew-resize";
  tableResizeHandle.style.zIndex = "50";
  tableResizeHandle.setAttribute("role", "slider");
  tableResizeHandle.setAttribute("aria-label", "Resize table");
  tableResizeHandle.tabIndex = 0;
  tableWrapper.appendChild(tableResizeHandle);

  // Create resize handle (start hidden)
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "101";
  resizeHandle.style.display = "none"; // Start hidden
  container.appendChild(resizeHandle);

  // Initialize the table cell data
  initCellData();

  // Initialize the cell data
  function initCellData() {
    const { rows, cols, hasHeader } = container.tableData;
    container.tableData.cellData = [];
    
    for (let i = 0; i < rows; i++) {
      const rowData = [];
      for (let j = 0; j < cols; j++) {
        if (i === 0 && hasHeader) {
          rowData.push(`Header ${j + 1}`);
        } else {
          rowData.push("Data");
        }
      }
      container.tableData.cellData.push(rowData);
    }
  }

  // IMPROVED: Cell selection function for better selection management
  function selectCell(rowIndex, colIndex) {
    console.log(`Selecting cell at row ${rowIndex}, col ${colIndex}`);
    
    // Get the table element
    const tableElem = tableWrapper.querySelector('table');
    if (!tableElem) {
      console.warn("Table element not found");
      return;
    }
    
    // First remove selection from all cells
    const allCells = tableElem.querySelectorAll('td, th');
    allCells.forEach(cell => {
      cell.classList.remove('cell-selected');
    });
    
    // Make sure row and column indices are valid
    if (rowIndex < 0 || rowIndex >= tableElem.rows.length) {
      console.warn(`Invalid row index: ${rowIndex}`);
      return;
    }
    
    const row = tableElem.rows[rowIndex];
    if (colIndex < 0 || colIndex >= row.cells.length) {
      console.warn(`Invalid column index: ${colIndex}`);
      return;
    }
    
    // Select the new cell
    const cell = row.cells[colIndex];
    cell.classList.add('cell-selected');
    
    // Update the lastSelectedCell reference - IMPORTANT: do this BEFORE updating toolbar
    container.lastSelectedCell = {
      element: cell,
      row: rowIndex,
      col: colIndex
    };
    
    console.log(`Cell selected: Row ${rowIndex+1}, Col ${colIndex+1}`);
    
    // Update global toolbar to show selected cell
    updateGlobalToolbar();
  }

  // Function to build the table based on current data
  function buildTable() {
    console.log("Building table based on current data...");
    const { rows, cols, hasHeader, cellData, showTitle, titleText, showFooter, footerText, fontSize, fontFamily, align } = container.tableData;
    const tableElem = tableWrapper.querySelector('table');
    const titleElem = tableWrapper.querySelector('.table-title');
    const footerElem = tableWrapper.querySelector('.table-footer');
    
    // Update title and footer
    titleElem.textContent = showTitle ? titleText : '';
    footerElem.textContent = showFooter ? footerText : '';
    
    // Clear table
    tableElem.innerHTML = '';
    
    // Apply styles
    tableElem.style.fontSize = `${fontSize}px`;
    tableElem.style.fontFamily = fontFamily;
    
    // Build table rows and cells
    for (let i = 0; i < rows; i++) {
      const tr = document.createElement('tr');
      tr.setAttribute('role', 'row');
      tr.dataset.rowIndex = i; // Store row index for easy reference
      
      // NEW: Add data attribute for row highlighting
      if (container.tableData.highlights.rows[i]) {
        tr.classList.add('highlighted-row');
        tr.dataset.highlightColor = container.tableData.highlights.rows[i];
      }
      
      for (let j = 0; j < cols; j++) {
        // Use th for header row, td for others
        const cellType = (i === 0 && hasHeader) ? 'th' : 'td';
        const cell = document.createElement(cellType);
        cell.textContent = cellData[i]?.[j] || (i === 0 && hasHeader ? `Header ${j + 1}` : "Data");
        cell.setAttribute('role', cellType === 'th' ? 'columnheader' : 'gridcell');
        cell.dataset.rowIndex = i; // Store row index for easy reference
        cell.dataset.colIndex = j; // Store column index for easy reference
        cell.tabIndex = 0;
        cell.style.border = '1px solid #000'; // Darker border
        cell.style.padding = '10px';
        cell.style.position = 'relative';
        cell.style.textAlign = align;
        cell.style.fontFamily = 'inherit';
        
        if (cellType === 'th') {
          cell.style.backgroundColor = '#f2f2f2';
          cell.style.fontWeight = '700';
        }
        
        // NEW: Add data attributes for column and cell highlighting
        if (container.tableData.highlights.columns[j]) {
          cell.classList.add('highlighted-column');
          cell.dataset.highlightColor = container.tableData.highlights.columns[j];
        }
        
        const cellKey = `${i}-${j}`;
        if (container.tableData.highlights.cells[cellKey]) {
          cell.classList.add('highlighted-cell');
          cell.dataset.highlightColor = container.tableData.highlights.cells[cellKey];
        }
        
        // Double-click to edit
        cell.addEventListener('dblclick', function(e) {
          editCell(e, i, j);
        });
        
        // Cell click for selecting - using dataset to get correct indices
        cell.addEventListener('click', function(e) {
          // Get the row and column indices from the dataset attributes
          const row = parseInt(this.dataset.rowIndex);
          const col = parseInt(this.dataset.colIndex);
          
          // Select this cell
          selectCell(row, col);
          
          // Stop the event from propagating further
          e.stopPropagation();
        });
        
        // Column resize handle
        const colResizeHandle = document.createElement('div');
        colResizeHandle.className = 'col-resize-handle';
        colResizeHandle.setAttribute('role', 'slider');
        colResizeHandle.setAttribute('aria-label', 'Resize column');
        colResizeHandle.tabIndex = 0;
        colResizeHandle.style.position = 'absolute';
        colResizeHandle.style.top = '0';
        colResizeHandle.style.right = '0';
        colResizeHandle.style.bottom = '0';
        colResizeHandle.style.width = '5px';
        colResizeHandle.style.cursor = 'col-resize';
        colResizeHandle.style.zIndex = '20';
        colResizeHandle.style.background = 'transparent';
        
        colResizeHandle.addEventListener('mousedown', function(e) {
          startColumnDrag(e, cell, j);
        });
        
        cell.appendChild(colResizeHandle);
        tr.appendChild(cell);
      }
      
      // Add row resize handle to first cell of each row
      if (tr.firstChild) {
        const rowGrip = document.createElement('div');
        rowGrip.className = 'row-grip';
        rowGrip.setAttribute('role', 'slider');
        rowGrip.setAttribute('aria-label', 'Resize row');
        rowGrip.tabIndex = 0;
        rowGrip.style.position = 'absolute';
        rowGrip.style.left = '0';
        rowGrip.style.right = '0';
        rowGrip.style.height = '6px';
        rowGrip.style.bottom = '-3px';
        rowGrip.style.cursor = 'row-resize';
        rowGrip.style.zIndex = '20';
        rowGrip.style.background = 'transparent';
        
        rowGrip.addEventListener('mousedown', function(e) {
          startRowDrag(e, tr, i);
        });
        
        tr.firstChild.style.position = 'relative';
        tr.firstChild.appendChild(rowGrip);
      }
      
      tableElem.appendChild(tr);
    }
    
    // Select the first cell by default after building
    if (tableElem.rows.length > 0 && tableElem.rows[0].cells.length > 0) {
      selectCell(0, 0); // Use our new selection function
    }
    
    // Update highlight styles
    updateHighlightStyle();
    console.log("Table build completed.");
  }
  
  // Function to edit a cell
  function editCell(e, rowIndex, colIndex) {
    const cell = e.currentTarget;
    if (cell.querySelector('input')) return;
    
    const oldText = cell.textContent;
    cell.textContent = '';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.value = oldText;
    input.style.width = '100%';
    input.style.padding = '5px';
    input.style.boxSizing = 'border-box';
    input.style.font = 'inherit';
    
    cell.appendChild(input);
input.focus();

// prevent backspace/delete bubbling & add Ctrl+B bold
input.addEventListener('keydown', function(e) {
  if (e.key === 'Backspace' || e.key === 'Delete') {
    e.stopPropagation();
    return;
  }
  if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='b') {
    document.execCommand('bold');
    e.preventDefault();
    e.stopPropagation();
  }
});

input.addEventListener('blur', finishEdit);
input.addEventListener('keydown', function(e) {
  if (e.key === 'Enter') finishEdit();
});

    function finishEdit() {
      const newValue = input.value;
      cell.textContent = newValue;
      
      // Update the cell data
      if (container.tableData.cellData[rowIndex]) {
        container.tableData.cellData[rowIndex][colIndex] = newValue;
      }
      
      // Reselect the cell after editing
      selectCell(rowIndex, colIndex);
    }
  }
  
  // Function to update rows and columns
  function updateRowsAndCols(newRows, newCols) {
    console.log(`Updating table dimensions: Rows=${newRows}, Cols=${newCols}`);
    // Validate inputs
    newRows = Math.min(Math.max(parseInt(newRows) || 1, 1), 100);
    newCols = Math.min(Math.max(parseInt(newCols) || 1, 1), 50);
    

    
    const currentRows = container.tableData.rows;
    const currentCols = container.tableData.cols;
    
    // If we're reducing rows, remove the excess rows
    if (newRows < currentRows) {
      container.tableData.cellData.splice(newRows);
      
      // NEW: Clean up highlights for removed rows
      for (let i = newRows; i < currentRows; i++) {
        delete container.tableData.highlights.rows[i];
        
        // Remove cell highlights for removed rows
        for (let j = 0; j < currentCols; j++) {
          delete container.tableData.highlights.cells[`${i}-${j}`];
        }
      }
    }
    // If we're adding rows, add new rows
    else if (newRows > currentRows) {
      for (let i = currentRows; i < newRows; i++) {
        const newRow = [];
        for (let j = 0; j < currentCols; j++) {
          newRow.push("Data");
        }
        container.tableData.cellData.push(newRow);
      }
    }
    
    // Adjust columns in each row
    for (let i = 0; i < newRows; i++) {
      // Create this row if it doesn't exist (shouldn't happen, but just in case)
      if (!container.tableData.cellData[i]) {
        container.tableData.cellData[i] = [];
      }
      
      // If we're reducing columns, remove the excess columns
      if (newCols < currentCols) {
        container.tableData.cellData[i].splice(newCols);
        
        // NEW: Clean up highlights for removed columns
        for (let j = newCols; j < currentCols; j++) {
          delete container.tableData.highlights.columns[j];
          
          // Remove cell highlights for removed columns
          for (let i = 0; i < newRows; i++) {
            delete container.tableData.highlights.cells[`${i}-${j}`];
          }
        }
      }
      // If we're adding columns, add new columns
      else if (newCols > currentCols) {
        for (let j = currentCols; j < newCols; j++) {
          const isHeader = i === 0 && container.tableData.hasHeader;
          container.tableData.cellData[i].push(isHeader ? `Header ${j + 1}` : "Data");
        }
      }
    }
    
    // Update the table data
    container.tableData.rows = newRows;
    container.tableData.cols = newCols;
    
    // Reset lastSelectedCell if necessary
    if (container.lastSelectedCell) {
      if (container.lastSelectedCell.row >= newRows || container.lastSelectedCell.col >= newCols) {
        container.lastSelectedCell = null;
      }
    }
    
    // Rebuild the table
    buildTable();
    
    // Don't call updateGlobalToolbar() here, as it would reset the inputs
    // Instead, update the active element to ensure proper highlighting
    if (window.activeTableElement === container) {
      activateTable();
    }
  }
  
  // Function to toggle header
  function toggleHeader(hasHeader) {
    console.log(`Toggling header: ${hasHeader ? 'On' : 'Off'}`);
    container.tableData.hasHeader = hasHeader;
    buildTable();
    
    // Don't call updateGlobalToolbar() to avoid resetting the inputs
    if (window.activeTableElement === container) {
      activateTable();
    }
  }
  
  // IMPROVED: Update highlight style with multicolor support
  function updateHighlightStyle() {

    const safeColor = sanitizeHex(container.tableData.highlightColor);
    console.log("Updating highlight styles with multicolor support...");
    
    // Remove existing style for this table if it exists
    const existingStyle = document.querySelector(`style[data-table-id="${container.tableID}"]`);
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Create new style element
    const styleTag = document.createElement('style');
    styleTag.setAttribute('data-table-id', container.tableID);
    
    let styleRules = `
      #table-${container.tableID} td.cell-selected,
      #table-${container.tableID} th.cell-selected {
        outline: 2px solid #4472C4 !important;
        position: relative;
        z-index: 5;
      }
      
      .resizing {
        outline: 2px dashed #4472C4;
      }`;
      
    // Add default highlight styles (for backward compatibility)
    styleRules += `
      #table-${container.tableID} tr.highlighted-row:not([data-highlight-color]) td,
      #table-${container.tableID} tr.highlighted-row:not([data-highlight-color]) th {
       background-color: ${safeColor} !important;
        border: 2px solid #333 !important;
      }
      
      #table-${container.tableID} td.highlighted-column:not([data-highlight-color]),
      #table-${container.tableID} th.highlighted-column:not([data-highlight-color]) {
       background-color: ${safeColor} !important;
        border: 2px solid #333 !important;
      }
      
      #table-${container.tableID} td.highlighted-cell:not([data-highlight-color]),
      #table-${container.tableID} th.highlighted-cell:not([data-highlight-color]) {
        background-color: ${safeColor} !important;
        border: 2px solid #333 !important;
      }`;
    
    // Add highlighted rows with specific colors
    for (const [rowIndex, rawColor] of Object.entries(container.tableData.highlights.rows)) {
  const c = sanitizeHex(rawColor);
  styleRules += `
    #table-${container.tableID} tr[data-row-index="${rowIndex}"].highlighted-row td,
    #table-${container.tableID} tr[data-row-index="${rowIndex}"].highlighted-row th {
      background-color: ${c} !important;
      border: 2px solid #333 !important;
    }`;
}

    
    // Add highlighted columns with specific colors
// Add highlighted columns with specific colors (sanitized)
for (const [colIndex, rawColor] of Object.entries(container.tableData.highlights.columns)) {
  const c = sanitizeHex(rawColor);
  styleRules += `
    #table-${container.tableID} td[data-col-index="${colIndex}"].highlighted-column,
    #table-${container.tableID} th[data-col-index="${colIndex}"].highlighted-column {
      background-color: ${c} !important;
      border: 2px solid #333 !important;
    }`;
}

    
    // Add highlighted cells with specific colors
 // Add highlighted cells with specific colors (sanitized)
for (const [cellKey, rawColor] of Object.entries(container.tableData.highlights.cells)) {
  const [rowIndex, colIndex] = cellKey.split('-');
  const c = sanitizeHex(rawColor);
  styleRules += `
    #table-${container.tableID} tr[data-row-index="${rowIndex}"] td[data-col-index="${colIndex}"].highlighted-cell,
    #table-${container.tableID} tr[data-row-index="${rowIndex}"] th[data-col-index="${colIndex}"].highlighted-cell {
      background-color: ${c} !important;
      border: 2px solid #333 !important;
    }`;
}

    
    styleTag.textContent = styleRules;
    document.head.appendChild(styleTag);
    console.log("Multicolor highlight styles updated");
  }
  
  // IMPROVED: Default to selecting the first cell if none is selected
  function getDefaultCell() {
    // If a cell is already selected, return it
    if (container.lastSelectedCell) {
      return container.lastSelectedCell;
    }
    
    // Get the table element
    const tableElem = tableWrapper.querySelector('table');
    if (!tableElem || !tableElem.rows || tableElem.rows.length === 0) {
      return null;
    }
    
    // Select the first cell
    selectCell(0, 0);
    
    return container.lastSelectedCell;
  }
  
  // IMPROVED: Highlight row function with color support
  function highlightRow(rowIndex) {
    console.log("Highlighting row...");
    
    // Get the table element
    const tableElem = tableWrapper.querySelector('table');
    if (!tableElem) {
      console.warn("Table element not found");
      return;
    }
    
    // Get rowIndex from last selected cell if not provided or auto-select first cell
    if (rowIndex === undefined) {
      const selectedCell = getDefaultCell();
      if (selectedCell) {
        rowIndex = selectedCell.row;
        console.log(`Using row index from selected cell: ${rowIndex}`);
      } else {
        console.warn("No row to highlight and couldn't select default cell");
        return;
      }
    }
    
    // Make sure row index is valid
    const rows = tableElem.rows;
    if (!rows || rowIndex < 0 || rowIndex >= rows.length) {
      console.warn(`Invalid row index: ${rowIndex}`);
      return;
    }
    
    // Get the row and toggle highlight
    const row = rows[rowIndex];
    
    // NEW: Toggle highlight with color support
    if (row.classList.contains('highlighted-row')) {
      row.classList.remove('highlighted-row');
      delete container.tableData.highlights.rows[rowIndex];
      console.log(`Removed highlight from row ${rowIndex}`);
    } else {
      row.classList.add('highlighted-row');
      // Store the current highlight color for this row
      container.tableData.highlights.rows[rowIndex] = container.tableData.highlightColor;
      console.log(`Added highlight to row ${rowIndex} with color ${container.tableData.highlightColor}`);
    }
    
    // Update styles to reflect the changes
    updateHighlightStyle();
  }
  
  // IMPROVED: Highlight column function with color support
  function highlightColumn(colIndex) {
    console.log("Highlighting column...");
    
    // Get the table element
    const tableElem = tableWrapper.querySelector('table');
    if (!tableElem) {
      console.warn("Table element not found");
      return;
    }
    
    // Get colIndex from last selected cell if not provided or auto-select first cell
    if (colIndex === undefined) {
      const selectedCell = getDefaultCell();
      if (selectedCell) {
        colIndex = selectedCell.col;
        console.log(`Using column index from selected cell: ${colIndex}`);
      } else {
        console.warn("No column to highlight and couldn't select default cell");
        return;
      }
    }
    
    // Get all rows
    const rows = tableElem.rows;
    if (!rows || rows.length === 0) {
      console.warn("No rows found in table");
      return;
    }
    
    // Check if column is already highlighted
    let isHighlighted = colIndex in container.tableData.highlights.columns;
    
    // Toggle highlight state with color
    if (isHighlighted) {
      // Remove highlight
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (colIndex >= 0 && colIndex < row.cells.length) {
          row.cells[colIndex].classList.remove('highlighted-column');
        }
      }
      delete container.tableData.highlights.columns[colIndex];
      console.log(`Removed highlight from column ${colIndex}`);
    } else {
      // Add highlight with current color
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (colIndex >= 0 && colIndex < row.cells.length) {
          row.cells[colIndex].classList.add('highlighted-column');
        }
      }
      container.tableData.highlights.columns[colIndex] = container.tableData.highlightColor;
      console.log(`Added highlight to column ${colIndex} with color ${container.tableData.highlightColor}`);
    }
    
    // Update styles to reflect the changes
    updateHighlightStyle();
  }
  
  // IMPROVED: Highlight cell function with color support
  function highlightCell(rowIndex, colIndex) {
    console.log("Highlighting cell...");
    
    // Get the table element
    const tableElem = tableWrapper.querySelector('table');
    if (!tableElem) {
      console.warn("Table element not found");
      return;
    }
    
    // Get indices from last selected cell if not provided or auto-select first cell
    if (rowIndex === undefined || colIndex === undefined) {
      const selectedCell = getDefaultCell();
      if (selectedCell) {
        rowIndex = selectedCell.row;
        colIndex = selectedCell.col;
        console.log(`Using indices from selected cell: Row=${rowIndex}, Col=${colIndex}`);
      } else {
        console.warn("No cell to highlight and couldn't select default cell");
        return;
      }
    }
    
    // Make sure row index is valid
    const rows = tableElem.rows;
    if (!rows || rowIndex < 0 || rowIndex >= rows.length) {
      console.warn(`Invalid row index: ${rowIndex}`);
      return;
    }
    
    // Get the row
    const row = rows[rowIndex];
    
    // Make sure column index is valid
    if (colIndex < 0 || colIndex >= row.cells.length) {
      console.warn(`Invalid column index: ${colIndex}`);
      return;
    }
    
    // Get the cell and toggle highlight with color
    const cell = row.cells[colIndex];
    const cellKey = `${rowIndex}-${colIndex}`;
    
    if (cell.classList.contains('highlighted-cell')) {
      cell.classList.remove('highlighted-cell');
      delete container.tableData.highlights.cells[cellKey];
      console.log(`Removed highlight from cell at Row=${rowIndex}, Col=${colIndex}`);
    } else {
      cell.classList.add('highlighted-cell');
      container.tableData.highlights.cells[cellKey] = container.tableData.highlightColor;
      console.log(`Added highlight to cell at Row=${rowIndex}, Col=${colIndex} with color ${container.tableData.highlightColor}`);
    }
    
    // Update styles to reflect the changes
    updateHighlightStyle();
  }
  
  // IMPROVED: Clear all highlights including color data
  function clearHighlights() {
    console.log("Clearing all highlights...");
    
    // Get the table element
    const tableElem = tableWrapper.querySelector('table');
    if (!tableElem) {
      console.warn("Table element not found");
      return;
    }
    
    // Clear row highlights
    const highlightedRows = tableElem.querySelectorAll('tr.highlighted-row');
    highlightedRows.forEach(row => row.classList.remove('highlighted-row'));
    
    // Clear column highlights
    const highlightedColumns = tableElem.querySelectorAll('.highlighted-column');
    highlightedColumns.forEach(cell => cell.classList.remove('highlighted-column'));
    
    // Clear cell highlights
    const highlightedCells = tableElem.querySelectorAll('.highlighted-cell');
    highlightedCells.forEach(cell => cell.classList.remove('highlighted-cell'));
    
    // NEW: Clear all highlight data
    container.tableData.highlights = {
      rows: {},
      columns: {},
      cells: {}
    };
    
    console.log("All highlights cleared");
    
    // Update styles to reflect the changes
    updateHighlightStyle();
  }
  
  // Column resize functionality
  let dragTarget = null, startX, startY, startW, startH, colCells;
  let dragging = false;
  
  function startColumnDrag(e, cell, colIndex) {
    e.stopPropagation();
    dragging = true;
    startX = e.pageX;
    startW = cell.offsetWidth;
    
    // Get all cells in this column
    const table = tableWrapper.querySelector('table');
    colCells = Array.from(table.rows).map(row => row.cells[colIndex]);
    
    // Add a visual indicator class
    colCells.forEach(c => c.classList.add('resizing'));
    
    // Show size indicator
    showSizeIndicator(startW, e.pageX + 8, e.pageY);
    
    document.addEventListener('mousemove', dragColumn);
    document.addEventListener('mouseup', stopDrag);
  }
  
  function dragColumn(e) {
    if (!dragging) return;
    
    const w = Math.max(50, startW + (e.pageX - startX));
    colCells.forEach(c => c.style.width = w + 'px');
    
    // Update size indicator
    showSizeIndicator(w, e.pageX + 8, e.pageY);
  }
  
  // Row resize functionality
  let rowTarget;
  
  function startRowDrag(e, tr, rowIndex) {
    e.stopPropagation();
    dragging = true;
    rowTarget = tr;
    startY = e.pageY;
    startH = tr.offsetHeight;
    
    // Add a visual indicator class
    tr.classList.add('resizing');
    
    // Show size indicator
    showSizeIndicator(startH, e.pageX, e.pageY - 12);
    
    document.addEventListener('mousemove', dragRow);
    document.addEventListener('mouseup', stopDrag);
  }
  
  function dragRow(e) {
    if (!dragging) return;
    
    const h = Math.max(20, startH + (e.pageY - startY));
    rowTarget.style.height = h + 'px';
    
    // Update size indicator
    showSizeIndicator(h, e.pageX, e.pageY - 12);
  }
  
  // Table resize functionality
  let draggingTable = false;
  
  function startTableDrag(e) {
    e.stopPropagation();
    draggingTable = true;
    startX = e.pageX;
    startW = tableWrapper.offsetWidth;
    
    // Show size indicator
    showSizeIndicator(startW, e.pageX, e.pageY);
    
    document.addEventListener('mousemove', dragTable);
    document.addEventListener('mouseup', stopTableDrag);
  }
  
  function dragTable(e) {
    if (!draggingTable) return;
    
    const w = Math.max(100, startW + (e.pageX - startX));
    tableWrapper.style.width = w + 'px';
    
    // Update size indicator
    showSizeIndicator(w, e.pageX, e.pageY);
  }
  
  function stopTableDrag() {
    draggingTable = false;
    removeSizeIndicator();
    
    document.removeEventListener('mousemove', dragTable);
    document.removeEventListener('mouseup', stopTableDrag);
  }
  
  function stopDrag() {
    dragging = false;
    
    // Remove visual indicators
    const allResizing = document.querySelectorAll('.resizing');
    allResizing.forEach(el => el.classList.remove('resizing'));
    
    removeSizeIndicator();
    
    document.removeEventListener('mousemove', dragColumn);
    document.removeEventListener('mousemove', dragRow);
    document.removeEventListener('mouseup', stopDrag);
  }
  
  // Size indicator
  function showSizeIndicator(value, x, y) {
    let indicator = document.getElementById('size-indicator');
    
    if (!indicator) {
      indicator = document.createElement('div');
      indicator.id = 'size-indicator';
      indicator.className = 'size-indicator';
      indicator.style.position = 'absolute';
      indicator.style.background = 'rgba(68,114,196,0.85)';
      indicator.style.color = '#fff';
      indicator.style.padding = '2px 5px';
      indicator.style.borderRadius = '3px';
      indicator.style.fontSize = '11px';
      indicator.style.pointerEvents = 'none';
      indicator.style.zIndex = '40';
      document.body.appendChild(indicator);
    }
    
    indicator.textContent = value + 'px';
    indicator.style.left = x + 'px';
    indicator.style.top = y + 'px';
  }
  
  function removeSizeIndicator() {
    const indicator = document.getElementById('size-indicator');
    if (indicator) indicator.remove();
  }
  
  // Function to update the global toolbar
  function updateGlobalToolbar() {
    console.log("Updating global toolbar...");
    const globalToolbar = document.getElementById("global-toolbar");
    if (!globalToolbar) {
      console.warn("Global toolbar element not found");
      return;
    }
    
    // Store a reference to the global toolbar in the container
    container.globalToolbar = globalToolbar;
    
    globalToolbar.innerHTML = "";
    
    // Mark the toolbar as belonging to this table
    globalToolbar.setAttribute('data-for-table', container.tableID);
    
    // Create main toolbar container with flex-column
    const toolbarContainer = document.createElement("div");
    toolbarContainer.style.display = "flex";
    toolbarContainer.style.flexDirection = "column";
    toolbarContainer.style.width = "100%";
    toolbarContainer.style.gap = "5px";
    toolbarContainer.className = "table-toolbar-container";
    
    // First row - main controls
    const row1 = document.createElement("div");
    row1.style.display = "flex";
    row1.style.alignItems = "center";
    row1.style.flexWrap = "wrap";
    row1.style.gap = "10px";
    row1.className = "table-toolbar-row";
    
    // Identity label
    const identityLabel = document.createElement("span");
    identityLabel.textContent = "Table " + container.tableID;
    identityLabel.style.fontSize = "12px";
    identityLabel.style.fontWeight = "bold";
    identityLabel.style.marginRight = "15px";
    row1.appendChild(identityLabel);
    
    // Show selected cell info if available
    if (container.lastSelectedCell) {
      const cellInfo = document.createElement("span");
      cellInfo.textContent = `Selected: Row ${container.lastSelectedCell.row + 1}, Col ${container.lastSelectedCell.col + 1}`;
      cellInfo.style.fontSize = "12px";
      cellInfo.style.marginRight = "15px";
      cellInfo.style.color = "#555";
      row1.appendChild(cellInfo);
    }
    
    // Row and Column inputs
    const rowsLabel = document.createElement("label");
    rowsLabel.textContent = "Rows:";
    rowsLabel.style.fontSize = "12px";
    rowsLabel.style.marginRight = "5px";
    row1.appendChild(rowsLabel);
    
    const rowsInput = document.createElement("input");
    rowsInput.type = "number";
    rowsInput.min = "1";
    rowsInput.max = "100";
    rowsInput.value = container.tableData.rows;
    rowsInput.style.width = "40px";
    rowsInput.style.marginRight = "15px";
    // Prevent clicks from bubbling up and deactivating the table
    rowsInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    row1.appendChild(rowsInput);
    
    const colsLabel = document.createElement("label");
    colsLabel.textContent = "Cols:";
    colsLabel.style.fontSize = "12px";
    colsLabel.style.marginRight = "5px";
    row1.appendChild(colsLabel);
    
    const colsInput = document.createElement("input");
    colsInput.type = "number";
    colsInput.min = "1";
    colsInput.max = "100";
    colsInput.value = container.tableData.cols;
    colsInput.style.width = "40px";
    colsInput.style.marginRight = "15px";
    // Prevent clicks from bubbling up and deactivating the table
    colsInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    row1.appendChild(colsInput);
    
    // Update button
    const updateDimsBtn = createButton("Update", function() {
      updateRowsAndCols(rowsInput.value, colsInput.value);
    });
    updateDimsBtn.title = "Update table dimensions";
    updateDimsBtn.style.backgroundColor = "#e3f2fd";
    row1.appendChild(updateDimsBtn);
    
    // Header checkbox
    const headerContainer = document.createElement("div");
    headerContainer.style.display = "flex";
    headerContainer.style.alignItems = "center";
    headerContainer.style.marginLeft = "10px";
    
    const hasHeaderInput = document.createElement("input");
    hasHeaderInput.id = `table-header-${container.tableID}`;
    hasHeaderInput.type = "checkbox";
    hasHeaderInput.checked = container.tableData.hasHeader;
    // Prevent clicks from bubbling up and deactivating the table
    hasHeaderInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    const hasHeaderLabel = document.createElement("label");
    hasHeaderLabel.textContent = "Header";
    hasHeaderLabel.htmlFor = `table-header-${container.tableID}`;
    hasHeaderLabel.style.fontSize = "12px";
    hasHeaderLabel.style.marginLeft = "5px";
    
    headerContainer.appendChild(hasHeaderInput);
    headerContainer.appendChild(hasHeaderLabel);
    
    // Apply header change without refreshing toolbar
    hasHeaderInput.addEventListener("change", function() {
      toggleHeader(hasHeaderInput.checked);
    });
    
    row1.appendChild(headerContainer);
    
    // Separator
    const separator = document.createElement("div");
    separator.style.height = "20px";
    separator.style.width = "1px";
    separator.style.backgroundColor = "#ccc";
    separator.style.margin = "0 5px";
    row1.appendChild(separator);
    
    // Structure Button
    const styleBtn = createButton("Style", openStyleDialog);
    styleBtn.style.backgroundColor = "#e8f5e9";
    row1.appendChild(styleBtn);
    
  // Title & Footer Button
  const titleFooterBtn = createButton("Title & Footer", openTitleFooterDialog);
    titleFooterBtn.style.backgroundColor = "#f3e5f5";
    row1.appendChild(titleFooterBtn);

    // Toggle bold on entire cell
const boldCellBtn = createButton("Bold Cell", function(e) {
  e.stopPropagation();
  const sel = container.lastSelectedCell && container.lastSelectedCell.element;
  if (!sel) return;
  sel.style.fontWeight = (sel.style.fontWeight === 'bold') ? 'normal' : 'bold';
});
boldCellBtn.title = "Toggle bold on selected cell";
boldCellBtn.style.backgroundColor = "#fff0f5";
row1.appendChild(boldCellBtn);

    
    // Add first row to toolbar
    toolbarContainer.appendChild(row1);
    
    // Second row - highlight controls
    const row2 = document.createElement("div");
    row2.style.display = "flex";
    row2.style.alignItems = "center";
    row2.style.flexWrap = "wrap";
    row2.style.gap = "10px";
    row2.style.paddingTop = "5px";
    row2.style.borderTop = "1px solid #eee";
    row2.className = "table-toolbar-row";
    
    // Highlight label
    const hlTitleLabel = document.createElement("span");
    hlTitleLabel.textContent = "Highlighting:";
    hlTitleLabel.style.fontSize = "12px";
    hlTitleLabel.style.fontWeight = "bold";
    hlTitleLabel.style.marginRight = "10px";
    row2.appendChild(hlTitleLabel);
    
    // Highlight color input
    const hlLabel = document.createElement("label");
    hlLabel.textContent = "Color:";
    hlLabel.style.fontSize = "12px";
    hlLabel.style.marginRight = "5px";
    row2.appendChild(hlLabel);
    
    const hlColor = document.createElement("input");
    hlColor.type = "color";
    hlColor.value = container.tableData.highlightColor;
    hlColor.style.width = "25px";
    hlColor.style.height = "25px";
    hlColor.style.padding = "0";
    hlColor.style.border = "1px solid #ccc";
    hlColor.style.marginRight = "15px";
    
    // Prevent clicks from bubbling up and deactivating the table
    hlColor.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    // Update highlight color when changed
    hlColor.addEventListener("input", function(e) {
      e.stopPropagation(); // Prevent deactivation
      container.tableData.highlightColor = hlColor.value;
      // Note: We don't update existing highlights, just set the color for new ones
      console.log(`Highlight color changed to ${hlColor.value}`);
    });
    
    row2.appendChild(hlColor);
    
    // Highlight buttons with IMMEDIATE feedback
    const hlRowBtn = createButton("Highlight Row", function(e) {
      e.stopPropagation();
      // Get the currently selected cell's row immediately
      if (container.lastSelectedCell) {
        // Call highlight function directly with the row index
        highlightRow(container.lastSelectedCell.row);
      } else {
        console.warn("No cell selected for highlighting");
        // Try to select the first cell automatically
        getDefaultCell();
        if (container.lastSelectedCell) {
          highlightRow(container.lastSelectedCell.row);
        }
      }
    });
    hlRowBtn.title = "Highlight selected row with current color";
    hlRowBtn.style.padding = "4px 8px";
    hlRowBtn.style.backgroundColor = "#fff8e1";
    row2.appendChild(hlRowBtn);
    
    const hlColBtn = createButton("Highlight Column", function(e) {
      e.stopPropagation();
      // Get the currently selected cell's column immediately
      if (container.lastSelectedCell) {
        // Call highlight function directly with the column index
        highlightColumn(container.lastSelectedCell.col);
      } else {
        console.warn("No cell selected for highlighting");
        // Try to select the first cell automatically
        getDefaultCell();
        if (container.lastSelectedCell) {
          highlightColumn(container.lastSelectedCell.col);
        }
      }
    });
    hlColBtn.title = "Highlight selected column with current color";
    hlColBtn.style.padding = "4px 8px";
    hlColBtn.style.backgroundColor = "#fff8e1";
    row2.appendChild(hlColBtn);
    
    const hlCellBtn = createButton("Highlight Cell", function(e) {
      e.stopPropagation();
      // Get the currently selected cell immediately
      if (container.lastSelectedCell) {
        // Call highlight function directly with both indices
        highlightCell(container.lastSelectedCell.row, container.lastSelectedCell.col);
      } else {
        console.warn("No cell selected for highlighting");
        // Try to select the first cell automatically
        getDefaultCell();
        if (container.lastSelectedCell) {
          highlightCell(container.lastSelectedCell.row, container.lastSelectedCell.col);
        }
      }
    });
    hlCellBtn.title = "Highlight selected cell with current color";
    hlCellBtn.style.padding = "4px 8px";
    hlCellBtn.style.backgroundColor = "#fff8e1";
    row2.appendChild(hlCellBtn);
    
    const clearHlBtn = createButton("Clear Highlights", function(e) {
      e.stopPropagation();
      clearHighlights();
    });
    clearHlBtn.title = "Clear all highlights";
    clearHlBtn.style.padding = "4px 8px";
    clearHlBtn.style.backgroundColor = "#ffebee";
    row2.appendChild(clearHlBtn);
    
    // Add second row to toolbar
    toolbarContainer.appendChild(row2);
    
    // Add the whole toolbar container to the global toolbar
    globalToolbar.appendChild(toolbarContainer);
    
    // Prevent all clicks in the global toolbar from deactivating the table
    globalToolbar.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    console.log("Global toolbar updated successfully");
  }
  
  // Helper function to create a button
  function createButton(text, onClick) {
    const button = document.createElement("button");
    button.textContent = text;
    button.style.marginRight = "5px";
    button.style.padding = "4px 8px";
    button.style.cursor = "pointer";
    button.style.border = "1px solid #ccc";
    button.style.borderRadius = "4px";
    
    // Stop event propagation to prevent table deactivation
    button.addEventListener('click', function(e) {
      e.stopPropagation();
      
      // Call the provided click handler
      if (typeof onClick === 'function') {
        onClick(e);
      }
    });
    
    return button;
  }
  
  // Dialog Helper Functions
 function createDialog(title) {
  // Create backdrop
  const dialogBackdrop = document.createElement("div");
  dialogBackdrop.style.position = "fixed";
  dialogBackdrop.style.top = "0";
  dialogBackdrop.style.left = "0";
  dialogBackdrop.style.width = "100%";
  dialogBackdrop.style.height = "100%";
  dialogBackdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
  dialogBackdrop.style.zIndex = "9999"; // INCREASED from 1000 to 9999 to ensure it's above everything
  dialogBackdrop.style.display = "flex";
  dialogBackdrop.style.justifyContent = "center";
  dialogBackdrop.style.alignItems = "center";
  
  // Create dialog box
  const dialogBox = document.createElement("div");
  dialogBox.style.backgroundColor = "white";
  dialogBox.style.padding = "20px";
  dialogBox.style.borderRadius = "5px";
  dialogBox.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
  dialogBox.style.minWidth = "400px";
  dialogBox.style.maxWidth = "80%";
  dialogBox.style.maxHeight = "80vh";
  dialogBox.style.overflowY = "auto";
  dialogBox.style.position = "relative"; // Add relative positioning
  dialogBox.style.zIndex = "10000"; // Even higher z-index for the actual dialog
    
    // Create title
    const dialogTitle = document.createElement("h3");
    dialogTitle.textContent = title;
    dialogTitle.style.marginTop = "0";
    dialogTitle.style.marginBottom = "15px";
    dialogBox.appendChild(dialogTitle);
    
    // Create content container
    const contentContainer = document.createElement("div");
    contentContainer.style.marginBottom = "20px";
    dialogBox.appendChild(contentContainer);
    
    // Create buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.justifyContent = "flex-end";
    buttonsContainer.style.marginTop = "20px";
    dialogBox.appendChild(buttonsContainer);
    
    // Add close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Cancel";
    closeButton.style.padding = "8px 16px";
    closeButton.style.marginRight = "10px";
    closeButton.style.cursor = "pointer";
    closeButton.style.backgroundColor = "#f0f0f0";
    closeButton.style.border = "1px solid #ccc";
    closeButton.style.borderRadius = "4px";
    
    closeButton.addEventListener("click", function() {
      document.body.removeChild(dialogBackdrop);
    });
    
    buttonsContainer.appendChild(closeButton);
    
    dialogBackdrop.appendChild(dialogBox);
    
    // Prevent the dialog from deactivating the table
    dialogBackdrop.addEventListener('click', function(e) {
      if (e.target === dialogBackdrop) {
        e.stopPropagation();
        document.body.removeChild(dialogBackdrop);
      }
    });
    
    // Prevent clicks inside the dialog from propagating up
    dialogBox.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    return {
      backdrop: dialogBackdrop,
      dialog: dialogBox,
      content: contentContainer,
      buttons: buttonsContainer,
      addButton: function(text, onClick, isPrimary = false) {
        const button = document.createElement("button");
        button.textContent = text;
        button.style.padding = "8px 16px";
        button.style.cursor = "pointer";
        button.style.borderRadius = "4px";
        
        if (isPrimary) {
          button.style.backgroundColor = "#4CAF50";
          button.style.color = "white";
          button.style.border = "none";
        } else {
          button.style.backgroundColor = "#f0f0f0";
          button.style.border = "1px solid #ccc";
        }
        
        button.addEventListener("click", function(e) {
          e.stopPropagation(); // Prevent the click from deactivating the table
          if (typeof onClick === 'function') {
            onClick();
          }
          document.body.removeChild(dialogBackdrop);
        });
        
        buttonsContainer.appendChild(button);
        return button;
      },
      open: function() {
        document.body.appendChild(dialogBackdrop);
      }
    };
  }
  
  // Create form row helper
  function createFormRow() {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "10px";
    return row;
  }
  
  // Create label helper
  function createLabel(text, forId) {
    const label = document.createElement("label");
    label.textContent = text;
    if (forId) label.htmlFor = forId;
    label.style.marginRight = "10px";
    label.style.width = "100px";
    
    // Stop propagation to prevent deactivation
    label.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    return label;
  }
  
  // Dialog for Style settings
  function openStyleDialog() {
    const dialog = createDialog("Table Style");
    
    // Font size input
    const fontSizeRow = createFormRow();
    fontSizeRow.appendChild(createLabel("Font Size:", "style-font-size"));
    
    const fontSizeInput = document.createElement("input");
    fontSizeInput.id = "style-font-size";
    fontSizeInput.type = "number";
    fontSizeInput.min = "8";
    fontSizeInput.max = "72";
    fontSizeInput.value = container.tableData.fontSize;
    fontSizeInput.style.width = "60px";
    
    // Prevent propagation
    fontSizeInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    fontSizeRow.appendChild(fontSizeInput);
    dialog.content.appendChild(fontSizeRow);
    
    // Font family select
    const fontFamilyRow = createFormRow();
    fontFamilyRow.appendChild(createLabel("Font Family:", "style-font-family"));
    
    const fontFamilySelect = document.createElement("select");
    fontFamilySelect.id = "style-font-family";
    
    // Prevent propagation
    fontFamilySelect.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    const fontOptions = [
      { value: "Arial,Helvetica,sans-serif", text: "Arial" },
      { value: "'Times New Roman',Times,serif", text: "Times New Roman" },
      { value: "Georgia,serif", text: "Georgia" },
      { value: "Courier New,monospace", text: "Courier New" }
    ];
    
    fontOptions.forEach(option => {
      const optionElem = document.createElement("option");
      optionElem.value = option.value;
      optionElem.textContent = option.text;
      if (option.value === container.tableData.fontFamily) {
        optionElem.selected = true;
      }
      fontFamilySelect.appendChild(optionElem);
    });
    
    fontFamilyRow.appendChild(fontFamilySelect);
    dialog.content.appendChild(fontFamilyRow);
    
    // Alignment select
    const alignRow = createFormRow();
    alignRow.appendChild(createLabel("Align:", "style-align"));
    
    const alignSelect = document.createElement("select");
    alignSelect.id = "style-align";
    
    // Prevent propagation
    alignSelect.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    const alignOptions = [
      { value: "left", text: "Left" },
      { value: "center", text: "Center" },
      { value: "right", text: "Right" }
    ];
    
    alignOptions.forEach(option => {
      const optionElem = document.createElement("option");
      optionElem.value = option.value;
      optionElem.textContent = option.text;
      if (option.value === container.tableData.align) {
        optionElem.selected = true;
      }
      alignSelect.appendChild(optionElem);
    });
    
    alignRow.appendChild(alignSelect);
    dialog.content.appendChild(alignRow);
    
    // Apply button
    dialog.addButton("Apply", function() {
      container.tableData.fontSize = parseInt(fontSizeInput.value) || 14;
      container.tableData.fontFamily = fontFamilySelect.value;
      container.tableData.align = alignSelect.value;
      buildTable();
    }, true);
    
    dialog.open();
  }
  
  // Dialog for Title & Footer settings
  function openTitleFooterDialog() {
    const dialog = createDialog("Title & Footer");
    
    // Show title checkbox
    const titleCheckRow = createFormRow();
    
    const showTitleInput = document.createElement("input");
    showTitleInput.id = "title-footer-show-title";
    showTitleInput.type = "checkbox";
    showTitleInput.checked = container.tableData.showTitle;
    showTitleInput.style.marginRight = "5px";
    
    // Prevent propagation
    showTitleInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    const showTitleLabel = document.createElement("label");
    showTitleLabel.textContent = "Show Title";
    showTitleLabel.htmlFor = "title-footer-show-title";
    
    titleCheckRow.appendChild(showTitleInput);
    titleCheckRow.appendChild(showTitleLabel);
    
    dialog.content.appendChild(titleCheckRow);
    
    // Title text input
    const titleTextRow = createFormRow();
    titleTextRow.appendChild(createLabel("Title Text:", "title-footer-title-text"));
    
    const titleTextInput = document.createElement("input");
    titleTextInput.id = "title-footer-title-text";
    titleTextInput.type = "text";
    titleTextInput.value = container.tableData.titleText;
    titleTextInput.style.width = "100%";
    
    // Prevent propagation
    titleTextInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    titleTextRow.appendChild(titleTextInput);
    
    dialog.content.appendChild(titleTextRow);
    
    // Show footer checkbox
    const footerCheckRow = createFormRow();
    
    const showFooterInput = document.createElement("input");
    showFooterInput.id = "title-footer-show-footer";
    showFooterInput.type = "checkbox";
    showFooterInput.checked = container.tableData.showFooter;
    showFooterInput.style.marginRight = "5px";
    
    // Prevent propagation
    showFooterInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    const showFooterLabel = document.createElement("label");
    showFooterLabel.textContent = "Show Footer";
    showFooterLabel.htmlFor = "title-footer-show-footer";
    
    footerCheckRow.appendChild(showFooterInput);
    footerCheckRow.appendChild(showFooterLabel);
    
    dialog.content.appendChild(footerCheckRow);
    
    // Footer text input
    const footerTextRow = createFormRow();
    footerTextRow.appendChild(createLabel("Footer Text:", "title-footer-footer-text"));
    
    const footerTextInput = document.createElement("input");
    footerTextInput.id = "title-footer-footer-text";
    footerTextInput.type = "text";
    footerTextInput.value = container.tableData.footerText;
    footerTextInput.style.width = "100%";
    
    // Prevent propagation
    footerTextInput.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    footerTextRow.appendChild(footerTextInput);
    
    dialog.content.appendChild(footerTextRow);
    
    // Apply button
    dialog.addButton("Apply", function() {
      container.tableData.showTitle = showTitleInput.checked;
      container.tableData.titleText = titleTextInput.value;
      container.tableData.showFooter = showFooterInput.checked;
      container.tableData.footerText = footerTextInput.value;
      buildTable();
    }, true);
    
    dialog.open();
  }
  
  // Functions for element activation and deactivation
  function activateTable() {
    console.log("Activating table...");
    // Deactivate the previously active element if any
    if (window.activeTableElement && window.activeTableElement !== container) {
      window.activeTableElement.style.border = "none";
      
      const prevToolbar = window.activeTableElement.querySelector(".table-toolbar");
      const prevResizeHandle = window.activeTableElement.querySelector(".resize-handle");
      
      if (prevToolbar) prevToolbar.style.display = "none";
      if (prevResizeHandle) prevResizeHandle.style.display = "none";
    }
    
    window.activeTableElement = container;
    
    container.style.border = "1px dashed #ccc";
    localToolbar.style.display = "flex";
    resizeHandle.style.display = "block";
    
    updateGlobalToolbar();
    console.log("Table activated.");
  }
  
  function deactivateTable() {
    console.log("Deactivating table...");
    if (window.activeTableElement === container) {
      container.style.border = "none";
      localToolbar.style.display = "none";
      resizeHandle.style.display = "none";
      window.activeTableElement = null;
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar && globalToolbar.getAttribute('data-for-table') === container.tableID.toString()) {
        globalToolbar.innerHTML = "";
        globalToolbar.removeAttribute('data-for-table');
      }
      console.log("Table deactivated.");
    }
  }
  
  function deleteTable() {
    console.log("Deleting table...");
    if (window.activeTableElement === container) {
      window.activeTableElement = null;
    }
    
    try {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      
      const globalToolbar = document.getElementById("global-toolbar");
      if (globalToolbar && globalToolbar.getAttribute('data-for-table') === container.tableID.toString()) {
        globalToolbar.innerHTML = "";
        globalToolbar.removeAttribute('data-for-table');
      }
      console.log("Table deleted successfully.");
    } catch (err) {
      console.error("Error removing table container:", err);
    }
  }
  
  // Event listeners
  container.addEventListener("mousedown", function(e) {
    if (e.target !== dragHandle && e.target !== resizeHandle) {
      activateTable();
    }
  });
  
  deleteButton.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteTable();
  });
  
  deleteButton.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    deleteTable();
  });
  
  // Resize handle functionality
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    
    function onMouseMove(e) {
      const newWidth = Math.max(300, startWidth + (e.clientX - startX));
      const newHeight = Math.max(100, startHeight + (e.clientY - startY));
      
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Table resize handle
  tableResizeHandle.addEventListener("mousedown", startTableDrag);
  tableResizeHandle.addEventListener("keydown", function(e) {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      const delta = e.key === 'ArrowRight' ? 10 : -10;
      const w = Math.max(100, tableWrapper.offsetWidth + delta);
      tableWrapper.style.width = w + 'px';
      showSizeIndicator(w, e.pageX, e.pageY);
      setTimeout(removeSizeIndicator, 300);
    }
  });
  
  // Drag handle functionality
  dragHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    container.isDragging = false;
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      
      if (Math.sqrt(dx * dx + dy * dy) > 5) {
        container.isDragging = true;
      }
      
      const newLeft = e.clientX - shiftX - canvasRect.left;
      const newTop = e.clientY - shiftY - canvasRect.top;
      
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  // Modify document click for deactivation to avoid conflicts with toolbar
  document.addEventListener("click", function(e) {
    // Ignore clicks in the global toolbar
    const globalToolbar = document.getElementById("global-toolbar");
    if (globalToolbar && (globalToolbar.contains(e.target) || e.target === globalToolbar)) {
      return;
    }
    
    // Only deactivate if clicked outside the table AND outside dialogs
    if (!container.contains(e.target) && 
        window.activeTableElement === container && 
        !e.target.closest('.dialog-backdrop')) {
      deactivateTable();
    }
  });
  
  // Initialize highlight styles
  updateHighlightStyle();
  
  // Append to canvas and activate
  canvas.appendChild(container);
  
  // Build the initial table
  buildTable();
  
  // Activate the table
  activateTable();
  
  return container;
}

/******** Edit Graph ********/
function editGraph(container) {
  let currentXInterval = container.dataset.xInterval || "1";
  let currentYInterval = container.dataset.yInterval || "1";
  let currentXLabel = container.dataset.xLabel || "X";
  let currentYLabel = container.dataset.yLabel || "Y";
  let currentFontSize = container.dataset.fontSize || "12";
  let currentEquation = container.dataset.equation || "";
   
  let newXInterval = prompt("Enter x-axis interval:", currentXInterval);
  let newYInterval = prompt("Enter y-axis interval:", currentYInterval);
  let newXLabel = prompt("Enter x-axis label:", currentXLabel);
  let newYLabel = prompt("Enter y-axis label:", currentYLabel);
  let newFontSize = prompt("Enter graph font size in px:", currentFontSize);
  let newEquation = prompt("Enter equation to graph (e.g., y = {a}*x + 10), or leave blank:", currentEquation);
   
  container.dataset.xInterval = newXInterval;
  container.dataset.yInterval = newYInterval;
  container.dataset.xLabel = newXLabel;
  container.dataset.yLabel = newYLabel;
  container.dataset.fontSize = newFontSize;
  // IMPORTANT: Save the new unswapped equation.
  container.dataset.equation = newEquation;
  container.dataset.originalEquation = newEquation;
   
  let computedVars = computeAllVariables();
  if (newEquation && newEquation.trim() !== "") {
    newEquation = newEquation.replace(/\{([^}]+)\}/g, (match, p1) => {
      let key = p1.trim();
      return computedVars[key] !== undefined ? computedVars[key] : match;
    });
  }
   
  let newSVG = generateGraphSVG(newXInterval, newYInterval, newXLabel, newYLabel, newFontSize, newEquation);
  container.querySelector('.element-content').innerHTML = newSVG;
}

/******** Add Graph ********/
function addGraph() {
  let xInterval = prompt("Enter x-axis interval:", "1");
  let yInterval = prompt("Enter y-axis interval:", "1");
  let xLabel = prompt("Enter x-axis label:", "X");
  let yLabel = prompt("Enter y-axis label:", "Y");
  let fontSizeInput = prompt("Enter graph font size in px (default 12):", "12");
  let graphFontSize = parseInt(fontSizeInput);
  if (isNaN(graphFontSize)) graphFontSize = 12;
  xInterval = parseFloat(xInterval);
  yInterval = parseFloat(yInterval);
  if (isNaN(xInterval) || isNaN(yInterval)) {
    alert("Invalid interval value.");
    return;
  }
  
  let eq = prompt("Enter equation to graph (e.g., y = {a}*x + 10), or leave blank:");
  // (Do not substitute variables here – keep the raw equation.)
  
  let svgContent = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, graphFontSize, eq);
  const canvas = document.getElementById('problem-canvas');
  const graphElement = createDraggableElement(svgContent, false);
  graphElement.dataset.xInterval = xInterval;
  graphElement.dataset.yInterval = yInterval;
  graphElement.dataset.xLabel = xLabel;
  graphElement.dataset.yLabel = yLabel;
  graphElement.dataset.fontSize = graphFontSize;
  // IMPORTANT: Store both the current equation and the original equation
  graphElement.dataset.equation = eq;
  graphElement.dataset.originalEquation = eq;
  
  canvas.appendChild(graphElement);
}

/******** Generate Graph SVG ********/
function generateGraphSVG(xInterval, yInterval, xLabel, yLabel, graphFontSize, eq) {
  xInterval = parseFloat(xInterval);
  yInterval = parseFloat(yInterval);
  graphFontSize = parseInt(graphFontSize);
  if (isNaN(graphFontSize)) graphFontSize = 12;
  let f = null;
  if (eq && eq.trim() !== "") { f = parseEquation(eq); }
  
  let svgWidth = 400, svgHeight = 400;
  let marginLeft = 50, marginRight = 20, marginTop = 20, marginBottom = 50;
  let graphWidth = svgWidth - marginLeft - marginRight;
  let graphHeight = svgHeight - marginTop - marginBottom;
  
  let xAxisY = svgHeight - marginBottom;
  let yAxisX = marginLeft;
  
  let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;
  svgContent += `<rect x="0" y="0" width="${svgWidth}" height="${svgHeight}" fill="white" stroke="black" />`;
  
  svgContent += `<clipPath id="graphClip"><rect x="${marginLeft}" y="${marginTop}" width="${graphWidth}" height="${graphHeight}" /></clipPath>`;
  
  for (let i = 1; i < 10; i++) {
    let xPos = marginLeft + (i / 10) * graphWidth;
    svgContent += `<line x1="${xPos}" y1="${marginTop}" x2="${xPos}" y2="${xAxisY}" stroke="#ddd" />`;
  }
  for (let j = 1; j < 10; j++) {
    let yPos = marginTop + (j / 10) * graphHeight;
    svgContent += `<line x1="${marginLeft}" y1="${yPos}" x2="${svgWidth - marginRight}" y2="${yPos}" stroke="#ddd" />`;
  }
  
  svgContent += `<line x1="${marginLeft}" y1="${xAxisY}" x2="${svgWidth - marginRight}" y2="${xAxisY}" stroke="black" />`;
  svgContent += `<line x1="${yAxisX}" y1="${marginTop}" x2="${yAxisX}" y2="${xAxisY}" stroke="black" />`;
  
  for (let i = 0; i <= 10; i++) {
    let xPos = marginLeft + (i / 10) * graphWidth;
    svgContent += `<line x1="${xPos}" y1="${xAxisY}" x2="${xPos}" y2="${xAxisY + 5}" stroke="black" />`;
    let value = i * xInterval;
    let tickVal = (value % 1 === 0) ? value.toString() : value.toFixed(2);
    svgContent += `<text x="${xPos}" y="${xAxisY + 20}" font-size="${graphFontSize}" text-anchor="middle">${tickVal}</text>`;
  }
  
  for (let j = 0; j <= 10; j++) {
    let yPos = marginTop + graphHeight - (j / 10) * graphHeight;
    svgContent += `<line x1="${yAxisX - 5}" y1="${yPos}" x2="${yAxisX}" y2="${yPos}" stroke="black" />`;
    let value = j * yInterval;
    let tickVal = (value % 1 === 0) ? value.toString() : value.toFixed(2);
    svgContent += `<text x="${yAxisX - 10}" y="${yPos + 3}" font-size="${graphFontSize}" text-anchor="end">${tickVal}</text>`;
  }
  
  let xLabelX = marginLeft + graphWidth / 2;
  let xLabelY = svgHeight - 10;
  svgContent += `<text x="${xLabelX}" y="${xLabelY}" font-size="${graphFontSize+2}" text-anchor="middle">${xLabel}</text>`;
  
  let yLabelX = 30;
  let yLabelY = marginTop + graphHeight / 2;
  svgContent += `<text x="${yLabelX}" y="${yLabelY}" font-size="${graphFontSize+2}" text-anchor="middle" transform="rotate(-90, ${yLabelX}, ${yLabelY})">${yLabel}</text>`;
  
  if (f !== null) {
    let points = "";
    let numSamples = 100;
    for (let i = 0; i <= numSamples; i++) {
      let xVal = (10 * xInterval) * (i / numSamples);
      let yVal = f(xVal);
      let xSVG = marginLeft + (xVal / (10 * xInterval)) * graphWidth;
      let ySVG = marginTop + graphHeight - (yVal / (10 * yInterval)) * graphHeight;
      points += xSVG + "," + ySVG + " ";
    }
    svgContent += `<polyline points="${points.trim()}" fill="none" stroke="red" stroke-width="2" clip-path="url(#graphClip)" />`;
  }
  
  svgContent += `</svg>`;
  return svgContent;
}




/******** Text Formatting Commands ********/
function execCmd(command) {
  if (activeTextBox) {
    activeTextBox.focus();
    document.execCommand(command, false, null);
  } else {
    alert("Please click inside a text box to format its text.");
  }
}

/******** Variable Computation ********/
// Computes variables from the defined variable list.
function computeAllVariables() {
  if (getVariableMode() === "code") {
    // Code mode: read the entire code block from the textarea.
    let computed = {};
    let code = document.getElementById("variable-code").value;
    if (code.trim() !== "") {
      try {
        new Function("computed", "with(computed){ " + code + " }")(computed);
      } catch (e) {
        console.error("Error evaluating variable code:", e);
      }
    }
    console.log("Computed values in code mode:", computed);
    return computed;
  } else {
    // UI mode: clear previous definitions and computed values.
    varDefinitions = {};
    computedValues = {};

    // Build variable definitions from the DOM.
    document.querySelectorAll("#variable-list .variable-item").forEach(item => {
      const varName = item.querySelector("strong").innerText.trim();
      const typeSelect = item.querySelector("select");
      let expr = "";

      if (typeSelect) {
        const selectedType = typeSelect.value;
        if (selectedType === "rand-int") {
          // Expect inputs with IDs like "x-min" and "x-max"
          const minInput = item.querySelector(`#${varName}-min`);
          const maxInput = item.querySelector(`#${varName}-max`);
          const minVal = minInput ? minInput.value.trim() : "";
          const maxVal = maxInput ? maxInput.value.trim() : "";
          if (minVal !== "" && maxVal !== "") {
            expr = `randomInt(${minVal}, ${maxVal})`;
          }
        } else if (selectedType === "simp-frac") {
          const numInput = item.querySelector(`#${varName}-num`);
          const denInput = item.querySelector(`#${varName}-den`);
          const numVal = numInput ? numInput.value.trim() : "";
          const denVal = denInput ? denInput.value.trim() : "";
          if (numVal !== "" && denVal !== "") {
            expr = `reduceFraction(${numVal}, ${denVal})`;
          }
        } else if (selectedType === "unsimp-frac") {
          const numInput = item.querySelector(`#${varName}-num`);
          const denInput = item.querySelector(`#${varName}-den`);
          const numVal = numInput ? numInput.value.trim() : "";
          const denVal = denInput ? denInput.value.trim() : "";
          if (numVal !== "" && denVal !== "") {
            expr = `unreducedfraction(${numVal}, ${denVal})`;
          }
        } else if (selectedType === "rounded") {
          const valueInput = item.querySelector(`#${varName}-value`);
          const roundInput = item.querySelector(`#${varName}-round`);
          const valueVal = valueInput ? valueInput.value.trim() : "";
          const roundVal = roundInput ? roundInput.value.trim() : "";
          if (valueVal !== "" && roundVal !== "") {
            expr = `round(${valueVal}, ${roundVal})`;
          }
        } else if (selectedType === "formula") {
          const formulaInput = item.querySelector(`#${varName}-formula`);
          if (formulaInput) {
            expr = formulaInput.value.trim();
          }
        }
      }
      // Fallback: if no expression was built from type-specific inputs,
      // then use any plain text input within the variable item.
      if (!expr) {
        const fallbackInput = item.querySelector("input[type='text']");
        if (fallbackInput) {
          expr = fallbackInput.value.trim();
        }
      }
      console.log("Variable", varName, "expression:", expr);
      varDefinitions[varName] = expr;
    });

    // Build the dependency graph using your existing buildDependencyGraph() function.
    buildDependencyGraph();

    // Perform a topological sort of the variable names.
    let order = [];
    let tempMark = {};
    let permMark = {};

    function visit(n) {
      if (permMark[n]) return;
      if (tempMark[n]) {
        console.error("Cyclic dependency detected for variable", n);
        return;
      }
      tempMark[n] = true;
      // Extract dependencies from the expression.
      let deps = extractDependencies(varDefinitions[n]);
      deps.forEach(dep => {
        if (varDefinitions.hasOwnProperty(dep)) {
          visit(dep);
        }
      });
      permMark[n] = true;
      order.push(n);
    }

    Object.keys(varDefinitions).forEach(n => {
      visit(n);
    });

    console.log("Evaluation order:", order);

    // Evaluate variables in sorted order.
    order.forEach(varName => {
      let expr = varDefinitions[varName];
      let val = evaluateExpression(expr);
      computedValues[varName] = val;
    });

    console.log("Computed values in UI mode:", computedValues);
    return Object.assign({}, computedValues);
  }
}

/******** Update Variables and Answer Image ********/
function removeStylingCommands(s) {
  // Remove common LaTeX styling commands (e.g. \mathit, \textit, \mathbf, etc.)
  // Recursively remove them if they are nested.
  let prev = "";
  while (s !== prev) {
    prev = s;
    s = s.replace(/^\\(?:mathit|textit|mathbf|mathnormal)\{([\s\S]+)\}$/, "$1").trim();
  }
  return s;
}


function normalizeVariable(varStr) {
  let s = varStr.trim();

  // Check if this is in #variable# format
  if (s.startsWith('#') && s.endsWith('#')) {
    // Just remove the # symbols and return the variable name
    return s.substring(1, s.length - 1).trim();
  }

  // Handle the old {variable} format for backward compatibility
  // Remove outer math-mode delimiters
  s = s.replace(/^\\\(|^\\\[|^\$\$/g, "").replace(/\\\)$|\\\]$|\$\$$/g, "").trim();

  // Recursively remove common LaTeX styling commands
  let prev = "";
  while (s !== prev) {
    prev = s;
    s = s.replace(/\\(?:mathit|textit|mathbf|mathnormal)\{([^}]+)\}/g, "$1").trim();
  }

  // Normalize Unicode: This converts mathematical alphanumerics (like italic 𝑥) to their standard forms
  s = s.normalize("NFKC");

  // Remove any remaining backslashes
  s = s.replace(/\\/g, "");

  return s.trim();
}

function updateVariables() {
  const detected = new Set();

  // Use the new text box elements (class "textbox-content")
  const boxes = document.querySelectorAll("#problem-canvas .textbox-content, #problem-canvas .textbox-content-container");

  boxes.forEach(box => {
    // Skip LaTeX mode boxes.
    if (box.getAttribute("data-mode") === "latex") return;
    
    // Use stored original text or the current innerText.
    let original = box.getAttribute("data-original-text") || box.innerText;

    // Regex for #variable# format - match only if there are no spaces inside the #...#
    const hashRegex = /#([^#\s]+)#/g;
    for (const match of original.matchAll(hashRegex)) {
      if (match[1].trim()) {
        detected.add(normalizeVariable('#' + match[1] + '#'));
      }
    }
    
    // For backward compatibility, also check for the old {variable} format
    const singleRegex = /(?:^|[\s,.;:()])\{([^}]+)\}/g;
    for (const match of original.matchAll(singleRegex)) {
      if (match[1].trim()) {
        detected.add(normalizeVariable(match[1]));
      }
    }
  });
  
  // Check the answer field.
  const ansElem = document.getElementById("correct-answer");
  if (ansElem) {
    const ansRule = ansElem.value;
    if (ansRule) {
      // Check for #variable# format
      const hashRegex = /#([^#\s]+)#/g;
      for (const match of ansRule.matchAll(hashRegex)) {
        if (match[1].trim()) {
          detected.add(normalizeVariable('#' + match[1] + '#'));
        }
      }
      
      // For backward compatibility, also check for {variable} format
      const singleRegex = /(?:^|[\s,.;:()])\{([^}]+)\}/g;
      for (const match of ansRule.matchAll(singleRegex)) {
        if (match[1].trim()) {
          detected.add(normalizeVariable(match[1]));
        }
      }
    }
  }
  
  // Add new variables to the variable list.
  const varListDiv = document.getElementById("variable-list");
  detected.forEach(v => {
    if (!document.getElementById("var-item-" + v)) {
      const div = document.createElement("div");
      div.className = "variable-item";
      div.id = "var-item-" + v;
      div.innerHTML = `<strong>${v}</strong> 
        <button onclick="deleteVariable('${v}')">Delete</button><br>
        <label>Type:</label>
        <select onchange="updateVariableType(this, '${v}')">
          <option value="">Select type</option>
          <option value="rand-int">Random Integer</option>
          <option value="simp-frac">Simplified Fraction</option>
          <option value="unsimp-frac">Unsimplified Fraction</option>
          <option value="rounded">Rounded Number</option>
          <option value="formula">Formula</option>
        </select>
        <div class="var-options" id="options-${v}"></div>`;
      varListDiv.appendChild(div);
    }
  });
  
  // Recompute variables.
  let computedVars = computeAllVariables();
  
  // Update text boxes (skip updating if the box is focused
  // or if it already contains an inline equation element).
  boxes.forEach(box => {
    if (document.activeElement === box) return;
    // Check for either inline equation button or inline equation span.
    if (box.querySelector('.equation-button') || box.querySelector('.inline-equation')) return;
    let original = box.getAttribute("data-original-text") || box.innerHTML;
    box.innerHTML = original;
  });
  
  // Update the answer image.
  updateAnswerImage(computedVars);
  
  // Update any dynamic image elements.
  document.querySelectorAll("[data-image-code]").forEach(function(container) {
    updateImageCodeElement(container, computedVars);
  });
}



function updateAnswerOptions() {
  const type = document.getElementById("answer-type").value;
  document.getElementById("box-options").style.display = (type === "box") ? "block" : "none";
  document.getElementById("multiple-options").style.display = (type === "multiple" || type === "multi-select") ? "block" : "none";
  document.getElementById("grid-options").style.display = (type === "grid") ? "block" : "none";
}

function updateAnswerImage(computedVars) {
  const varValues = computedVars || computeAllVariables();
  const answerType = document.getElementById("answer-type").value;
  let content = "";
  
  if (answerType === "box") {
    let correctAns = substituteValue(document.getElementById("correct-answer").value, varValues);
    let labelText = substituteValue(document.getElementById("label-text").value, varValues);
    let labelPosition = document.getElementById("label-position").value;
    if (labelPosition === "before") {
      content = labelText + " " + correctAns;
    } else if (labelPosition === "after") {
      content = correctAns + " " + labelText;
    } else {
      content = correctAns;
    }
  } else if (answerType === "multiple" || answerType === "multi-select") {
    let correctOptionDiv = document.querySelector("#mc-correct .mc-answer-option");
    if (correctOptionDiv) {
      let htmlContent = correctOptionDiv.innerHTML;
      if (correctOptionDiv.firstElementChild && correctOptionDiv.firstElementChild.classList.contains("mc-option-toolbar")) {
        htmlContent = htmlContent.replace(correctOptionDiv.firstElementChild.outerHTML, "");
      }
      content = substituteValue(htmlContent, varValues);
    }
  } else if (document.getElementById("answer-type").value === "grid") {
    let gridQuiz = generateGridQuiz(computedVars);
    const previewArea = document.getElementById("preview-area");
    previewArea.appendChild(gridQuiz);
  }
  document.getElementById("answer-image-content").innerHTML = content;
}

function updateVariableType(selectElem, varName) {
  const type = selectElem.value;
  const optionsDiv = document.getElementById("options-" + varName);
  let html = "";
  if (type === "rand-int") {
    html = `Min: <input type="number" id="${varName}-min" style="width:60px;"> 
            Max: <input type="number" id="${varName}-max" style="width:60px;">`;
  } else if (type === "simp-frac" || type === "unsimp-frac") {
    html = `Numerator: <input type="text" id="${varName}-num" style="width:50px;"> 
            Denom: <input type="text" id="${varName}-den" style="width:50px;">`;
  } else if (type === "rounded") {
    html = `Value: <input type="number" id="${varName}-value" style="width:60px;"> 
            Round to: <input type="number" id="${varName}-round" style="width:40px;">`;
  } else if (type === "formula") {
    html = `Formula: <input type="text" id="${varName}-formula" style="width:150px;" placeholder="e.g., a+b" onfocus="setCurrentFormulaInput(this)">`;
  }
  optionsDiv.innerHTML = html;
}

function addVariable() {
  let varName = prompt("Enter the new variable name (without curly braces):");
  if (!varName) return;
  varName = varName.trim();
  if (!varName) return;
  if (document.getElementById("var-item-" + varName)) {
    alert("Variable already exists.");
    return;
  }
  const varListDiv = document.getElementById("variable-list");
  const div = document.createElement("div");
  div.className = "variable-item";
  div.id = "var-item-" + varName;
  div.innerHTML = `<strong>${varName}</strong><br>
        <label>Type:</label>
        <select onchange="updateVariableType(this, '${varName}')">
          <option value="">Select type</option>
          <option value="rand-int">Random Integer</option>
          <option value="simp-frac">Simplified Fraction</option>
          <option value="unsimp-frac">Unsimplified Fraction</option>
          <option value="rounded">Rounded Number</option>
          <option value="formula">Formula</option>
        </select>
        <div class="var-options" id="options-${varName}"></div>
        <input type="text" placeholder="Enter expression for ${varName}">`;
  varListDiv.appendChild(div);

  let newVarInput = div.querySelector("input");
  if (newVarInput) {
    newVarInput.addEventListener("change", function() {
      varDefinitions[varName] = newVarInput.value.trim();
      buildDependencyGraph();
      let newVal = evaluateExpression(varDefinitions[varName]);
      updateVariable(varName, newVal);
      updateVariables();
    });
  }
}

/******** Preview Problem ********/
// Helper function to copy computed styles.
function copyComputedStyles(source, target) {
  const computed = window.getComputedStyle(source);
  for (let i = 0; i < computed.length; i++) {
    const prop = computed[i];
    target.style.setProperty(prop, computed.getPropertyValue(prop), computed.getPropertyPriority(prop));
  }
  const sourceChildren = source.children;
  const targetChildren = target.children;
  for (let i = 0; i < sourceChildren.length; i++) {
    if (targetChildren[i]) {
      copyComputedStyles(sourceChildren[i], targetChildren[i]);
    }
  }
}
function updateGridColumnNames() {
  const colCount = parseInt(document.getElementById("grid-columns").value, 10);
  const container = document.getElementById("grid-column-names");
  container.innerHTML = "<h4>Column Names</h4>";
  for (let i = 0; i < colCount; i++) {
    let input = document.createElement("input");
    input.type = "text";
    input.placeholder = "Column " + (i + 1);
    input.id = "grid-column-" + i;
    container.appendChild(input);
    container.appendChild(document.createElement("br"));
  }
  updateGridRowSelectOptions();
}
function addGridRowExpression() {
  const container = document.getElementById("grid-row-expressions");
  let rowDiv = document.createElement("div");
  rowDiv.className = "grid-row-expression";
  
  let exprInput = document.createElement("div");
  exprInput.className = "grid-expression";
  exprInput.contentEditable = true;
  exprInput.style.minHeight = "40px";
  exprInput.style.border = "1px solid #ccc";
  exprInput.style.padding = "4px";
  exprInput.innerHTML = "Enter expression (e.g., {a}+5)";
  rowDiv.appendChild(exprInput);
  
  let eqBtn = document.createElement("button");
  eqBtn.innerHTML = "Insert Eq";
  eqBtn.style.marginLeft = "5px";
  eqBtn.onclick = function(e) {
    e.stopPropagation();
    activeTextBox = exprInput;
    showEquationModal();
  };
  rowDiv.appendChild(eqBtn);
  
  let requiredLabel = document.createElement("label");
  requiredLabel.innerText = " Required";
  let requiredCheckbox = document.createElement("input");
  requiredCheckbox.type = "checkbox";
  requiredCheckbox.className = "grid-required";
  requiredLabel.prepend(requiredCheckbox);
  rowDiv.appendChild(requiredLabel);
  
  let select = document.createElement("select");
  select.className = "grid-correct-column";
  rowDiv.appendChild(select);
  
  let removeBtn = document.createElement("button");
  removeBtn.innerText = "Delete";
  removeBtn.onclick = function() { rowDiv.remove(); updateGridRowSelectOptions(); };
  rowDiv.appendChild(removeBtn);
  
  container.appendChild(rowDiv);
  updateGridRowSelectOptions();
}

function updateGridRowSelectOptions() {
  const colCount = parseInt(document.getElementById("grid-columns").value, 10);
  
  const colNames = [];
  for (let i = 0; i < colCount; i++) {
    let input = document.getElementById("grid-column-" + i);
    let colName = input ? substituteValue(input.value, window.currentComputedVars || {}) : "";
    if (!colName) {
      colName = "Column " + (i + 1);
    }
    colNames.push(colName);
  }
  const rows = document.querySelectorAll(".grid-row-expression");
  rows.forEach(row => {
    let select = row.querySelector(".grid-correct-column");
    select.innerHTML = "";
    colNames.forEach((name, index) => {
      let option = document.createElement("option");
      option.value = index;
      option.innerText = name;
      select.appendChild(option);
    });
  });
}

document.addEventListener("input", function(e) {
  if (e.target && e.target.id && e.target.id.indexOf("grid-column-") === 0) {
    updateGridRowSelectOptions();
  }
});

function generateGridQuiz(computedVars, preselect) {
  let container = document.createElement("div");
  container.className = "grid-quiz";
  
  const colCount = parseInt(document.getElementById("grid-columns").value, 10);
  
  const colNames = [];
  for (let i = 0; i < colCount; i++) {
    let input = document.getElementById("grid-column-" + i);
    let colName = input ? substituteValue(input.value, computedVars) : "";
    if (!colName) {
      colName = "Column " + (i + 1);
    }
    colNames.push(colName);
  }
  
  let rowExprDivs = Array.from(document.querySelectorAll(".grid-row-expression"));
  
  let shuffleEnabled = document.getElementById("grid-shuffle") && document.getElementById("grid-shuffle").checked;
  if (shuffleEnabled) {
    if (!window.shuffledGridRows) {
      window.shuffledGridRows = shuffleArray(rowExprDivs.slice());
      rowExprDivs = window.shuffledGridRows;
    } else {
      rowExprDivs = window.shuffledGridRows;
    }
  } else {
    window.shuffledGridRows = null;
  }
  
  let table = document.createElement("table");
  table.style.borderCollapse = "collapse";
  table.style.width = "100%";
  
  let thead = document.createElement("thead");
  let headerRow = document.createElement("tr");
  headerRow.appendChild(document.createElement("th"));
  colNames.forEach(name => {
    let th = document.createElement("th");
    th.innerText = name;
    th.style.border = "1px solid #ccc";
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  let tbody = document.createElement("tbody");
  rowExprDivs.forEach((exprDiv, index) => {
    let tr = document.createElement("tr");
    let exprInput = exprDiv.querySelector(".grid-expression");
    let exprText = exprInput ? substituteValue(exprInput.innerHTML, computedVars) : "";
    let tdExpr = document.createElement("td");
    tdExpr.innerHTML = exprText;
    tdExpr.style.border = "1px solid #ccc";
    tr.appendChild(tdExpr);
    
    let correctSelect = exprDiv.querySelector(".grid-correct-column");
    let correctIndex = correctSelect ? parseInt(correctSelect.value, 10) : 0;
    
    for (let i = 0; i < colCount; i++) {
      let td = document.createElement("td");
      td.style.border = "1px solid #ccc";
      let radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "grid_row_" + index;
      radio.value = i;
      radio.checked = preselect && (i === correctIndex);
      td.appendChild(radio);
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  container.appendChild(table);
  return container;
}
// First, create a helper function that captures snapshots of all LaTeX-mode text boxes.
// Set previewMode to either 'raw' or 'snapshot'
var previewMode = 'snapshot';  // try "raw" first; if not satisfactory, set to "snapshot"

/* 
   For "snapshot" mode, we capture each LaTeX text box into an image.
   In "raw" mode we simply remove extra preview elements.
*/
function captureLatexSnapshots() {
  const latexElements = document.querySelectorAll('#problem-canvas .text-box[data-mode="latex"]');
  const promises = [];
  latexElements.forEach(el => {
    const p = html2canvas(el).then(canvas => {
      el.dataset.latexImage = canvas.toDataURL();
    });
    promises.push(p);
  });
  return Promise.all(promises);
}


function substituteLatexVariables(latex, computedVars) {
  if (!latex || typeof latex !== 'string') return latex;
  
  // For LaTeX, handle both old {{variable}} pattern and new #variable# pattern
  // Process #variable# pattern first
  let result = latex.replace(/#([^#\s]+)#/g, (match, variableName) => {
    if (computedVars[variableName] !== undefined) {
      return computedVars[variableName];
    }
    return match;
  });
  
  // Then process the old {{variable}} pattern
  result = result.replace(/\{\{([^{}]+)\}\}/g, (match, variableName) => {
    const normalizedName = normalizeVariable(variableName.trim());
    if (computedVars[normalizedName] !== undefined) {
      return '{' + computedVars[normalizedName] + '}';
    }
    return match;
  });
  
  return result;
}

function updateMathLiveField(mathField, newValue) {
  // Try different methods to update the MathLive field
  try {
    // Method 1: Set value directly
    mathField.value = newValue;
    
    // Method 2: Use setValue if available
    if (typeof mathField.setValue === 'function') {
      mathField.setValue(newValue);
    }
    
    // Method 3: Insert or replace content if available
    if (typeof mathField.insert === 'function') {
      mathField.select();
      mathField.insert(newValue, {mode: 'math'});
    }
    
    console.log("Updated MathLive field with:", newValue);
  } catch (e) {
    console.error("Error updating MathLive field:", e);
  }
}

// Process tables in the cloned canvas for previewing
function processTable(cloneCanvas, computedVars) {
  const tableElements = cloneCanvas.querySelectorAll('.table-container');
  console.log(`Processing ${tableElements.length} tables`);
  
  tableElements.forEach(element => {
    // Get the table element and inner container
    const tableWrapper = element.querySelector('.table-container-inner');
    if (!tableWrapper) return;
    
    const tableElem = tableWrapper.querySelector('table');
    const titleElem = tableWrapper.querySelector('.table-title');
    const footerElem = tableWrapper.querySelector('.table-footer');
    
    if (!tableElem) return;
    
    // Process title and footer if they have variables
    if (titleElem && titleElem.textContent && titleElem.textContent.includes('#')) {
      titleElem.textContent = processText(titleElem.textContent, computedVars);
    }
    
    if (footerElem && footerElem.textContent && footerElem.textContent.includes('#')) {
      footerElem.textContent = processText(footerElem.textContent, computedVars);
    }
    
    // Process all cells in the table
    const cells = tableElem.querySelectorAll('th, td');
    cells.forEach(cell => {
      if (cell.textContent && (cell.textContent.includes('#') || cell.textContent.includes('{'))) {
        cell.textContent = processText(cell.textContent, computedVars);
      }
    });
  });
  
  // Function to process text with variables and arithmetic expressions
  function processText(text, variables) {
    if (!text) return text;
    
    // Process #variable# substitution
    let processed = text.replace(/#([a-zA-Z0-9_]+)#/g, (match, variableName) => {
      if (variables.hasOwnProperty(variableName)) {
        return variables[variableName];
      }
      return match; // Keep original if variable not found
    });
    
    // Process {arithmetic expressions}
    processed = processed.replace(/{([^}]*)}/g, (match, expression) => {
      try {
        return evaluateArithmeticExpression(expression, variables);
      } catch (error) {
        console.error(`Error evaluating expression "${expression}": ${error.message}`);
        return match; // Keep original expression on error
      }
    });
    
    return processed;
  }
  
  // Safely evaluate arithmetic expressions with variable substitution
  function evaluateArithmeticExpression(expr, variables) {
  // 1) substitute any #var# → value
  let s = expr.replace(/#([a-zA-Z0-9_]+)#/g, (_, name) =>
    variables[name] != null ? variables[name] : 0
  );
  s = s.replace(/\s+/g, '');             // strip whitespace

  let i = 0;
  function peek() { return s[i]; }
  function get()  { return s[i++]; }

  function parseNumber() {
    let num = '';
    while (/[0-9.]/.test(peek())) num += get();
    if (!num) throw new Error('Expected number at pos '+i);
    return parseFloat(num);
  }

  function parsePrimary() {
    if (peek() === '(') {
      get();                     // consume '('
      const val = parseAddSub();
      if (get() !== ')') throw new Error('Missing )');
      return val;
    }
    // support unary +/-
    if (peek() === '+' || peek() === '-') {
      const sign = get();
      return sign === '-' ? -parsePrimary() : parsePrimary();
    }
    return parseNumber();
  }

  function parsePower() {
    // exponentiation is right-associative
    let base = parsePrimary();
    while (peek() === '^') {
      get();                     // consume '^'
      const exponent = parsePower();
      base = Math.pow(base, exponent);
    }
    return base;
  }

  function parseMulDiv() {
    let val = parsePower();
    while (peek() === '*' || peek() === '/') {
      const op = get();
      const rhs = parsePower();
      val = op === '*' ? val * rhs : val / rhs;
    }
    return val;
  }

  function parseAddSub() {
    let val = parseMulDiv();
    while (peek() === '+' || peek() === '-') {
      const op = get();
      const rhs = parseMulDiv();
      val = op === '+' ? val + rhs : val - rhs;
    }
    return val;
  }

  const result = parseAddSub();
  if (i < s.length) throw new Error('Unexpected "'+peek()+'" at pos '+i);
  return result;
}

}


function processMathLiveEquationsInClone(cloneCanvas, computedVars) {
  console.log("========== PROCESSING MATHLIVE EQUATIONS ==========");
  
  // First, try to find any standalone MathLive elements
  const mathFields = cloneCanvas.querySelectorAll('math-field');
  console.log(`Found ${mathFields.length} math-field elements`);
  
  mathFields.forEach((mathField, index) => {
    // ... existing mathField processing code ...
  });
  
  // Also check for elements with data-latex attribute (inline equations)
  const latexElements = cloneCanvas.querySelectorAll('[data-latex]');
  console.log(`\nFound ${latexElements.length} elements with data-latex attribute`);
  
  latexElements.forEach((element, index) => {
    console.log(`--- Processing data-latex element #${index + 1} ---`);
    
    const latex = element.getAttribute('data-latex');
    console.log("LaTeX value:", latex);
    
    // First, update the data-latex attribute to show variables unescaped
    // This is important for correct variable identification
    let processedLatex = latex;
    
    // Check for #variable# patterns - make sure we handle both escaped and unescaped
    processedLatex = processedLatex.replace(/\\?#([a-zA-Z0-9_]+)\\?#/g, (match, variableName) => {
      console.log(`Found variable pattern containing: ${variableName}`);
      
      // Check if this variable has a value
      if (computedVars[variableName] !== undefined) {
        console.log(`Found value: ${computedVars[variableName]}`);
        return computedVars[variableName];
      }
      
      return match; // Keep original if not found
    });
    

    
    if (processedLatex !== latex) {
      console.log("Updating data-latex with:", processedLatex);
      element.setAttribute('data-latex', processedLatex);
      
      try {
        // For direct DOM update, set the innerHTML
        element.innerHTML = '\\(' + processedLatex + '\\)';
        
        // Then use appropriate renderer
        if (typeof MathJax !== 'undefined') {
          MathJax.typesetPromise([element]).catch(err => console.error('MathJax error:', err));
        } else if (typeof MathLive !== 'undefined' && typeof MathLive.renderMathInElement === 'function') {
          MathLive.renderMathInElement(element);
        }
      } catch (e) {
        console.error("Error re-rendering:", e);
      }
    }
  });
  
  console.log("========== FINISHED PROCESSING MATHLIVE EQUATIONS ==========");
}

function processInlineEquation(eqElement, computedVars) {
  // substitute #x# → 5 etc.
  const raw = eqElement.getAttribute('data-latex') || '';
  const substituted = substituteValue(raw, computedVars);
  eqElement.setAttribute('data-latex', substituted);

  /*—— wipe previous rendering to avoid duplicates ——*/
  eqElement.textContent = '\\(' + substituted + '\\)';

  /*—— typeset once, with MathJax only ——*/
  if (window.MathJax) {
    MathJax.typesetPromise([eqElement]);
  }
}


function processTextBoxWithEquations(textbox, computedVars) {
  // We need to walk through all nodes and process them differently based on type
  const childNodes = Array.from(textbox.childNodes);
  
  childNodes.forEach(node => {
    if (node.nodeType === Node.TEXT_NODE) {
      // Text node: replace variables directly
      const newText = substituteValue(node.textContent, computedVars);
      if (newText !== node.textContent) {
        node.textContent = newText;
      }
    } 
    else if (node.nodeType === Node.ELEMENT_NODE) {
      if (node.classList && node.classList.contains('inline-equation')) {
        // This is an equation element - process it differently
        processInlineEquation(node, computedVars);
      } 
      else {
        // Regular element (like <p>, <div>, etc) - process its children recursively
        if (node.childNodes && node.childNodes.length > 0) {
          Array.from(node.childNodes).forEach(childNode => {
            if (childNode.nodeType === Node.TEXT_NODE) {
              // Replace variables in text
              const newText = substituteValue(childNode.textContent, computedVars);
              if (newText !== childNode.textContent) {
                childNode.textContent = newText;
              }
            } 
            else if (childNode.classList && childNode.classList.contains('inline-equation')) {
              processInlineEquation(childNode, computedVars);
            }
          });
        }
      }
    }
  });
}
// Process stem-and-leaf plots in the cloned canvas
function processStemLeafPlotsInClone(cloneCanvas, computedVars) {
  const stemLeafElements = cloneCanvas.querySelectorAll('.stem-leaf-container');
  console.log(`Processing ${stemLeafElements.length} stem-and-leaf plots`);
  
  stemLeafElements.forEach(element => {
    // Get the canvas element and the stored data
    const plotCanvas = element.querySelector("canvas");
    if (!plotCanvas) return;
    
    const data = element.stemLeafData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process variables in the title and keyNote
    processedData.title = substituteValue(data.title, computedVars);
    if (data.keyNote) {
      processedData.keyNote = substituteValue(data.keyNote, computedVars);
    }
    
    // Process variables in the stems and leaves
    processedData.stems.forEach((stem, index) => {
      // Process stem
      stem.stem = substituteValue(data.stems[index].stem, computedVars);
      
      // Process leaves
      if (typeof data.stems[index].leaves === 'string') {
        const leaves = data.stems[index].leaves.split(',');
        const processedLeaves = leaves.map(leaf => substituteValue(leaf.trim(), computedVars));
        
        // Sort the processed leaves in ascending order
        // Convert to numbers for numerical sorting if possible
        const sortedLeaves = processedLeaves.map(leaf => {
          const num = Number(leaf);
          return isNaN(num) ? leaf : num;
        }).sort((a, b) => {
          if (typeof a === 'number' && typeof b === 'number') {
            return a - b; // Numerical sort
          }
          return String(a).localeCompare(String(b)); // String sort
        });
        
        // Convert back to string representation
        stem.leaves = sortedLeaves.join(',');
      } else if (Array.isArray(data.stems[index].leaves)) {
        const processedLeaves = data.stems[index].leaves.map(leaf => substituteValue(leaf, computedVars));
        
        // Sort the processed leaves in ascending order
        const sortedLeaves = processedLeaves.map(leaf => {
          const num = Number(leaf);
          return isNaN(num) ? leaf : num;
        }).sort((a, b) => {
          if (typeof a === 'number' && typeof b === 'number') {
            return a - b; // Numerical sort
          }
          return String(a).localeCompare(String(b)); // String sort
        });
        
        stem.leaves = sortedLeaves;
      }
    });
    
    // Draw the updated stem-and-leaf plot
    const ctx = plotCanvas.getContext('2d');
    ctx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

    const fontSize = data.titleFontSize;
    const fontFamily = data.fontFamily || 'monospace';
    
    // Title (if present)
    if (processedData.title) {
      ctx.font = `bold ${fontSize}px ${fontFamily}`;
      ctx.textAlign = 'center';
      ctx.fillText(processedData.title, 220, fontSize + 5);
    }

    // Calculate dimensions
    const padding = 40;
    const startY = processedData.title ? fontSize + 30 : 20;
    const lineHeight = fontSize + 10;
    
    // T-shape stem-and-leaf structure with table headers
    const tableStartY = startY + lineHeight;
    
    // HARDCODED VALUES FOR T-STRUCTURE
    // Matched with the values from drawStemLeaf
    const verticalLineX = 200;             // X position of vertical line
    const horizontalLineStart = 120;       // Left endpoint of horizontal line
    const horizontalLineEnd = 400;         // Right endpoint of horizontal line
    const stemHeaderX = verticalLineX - 40; // Position of "stem" header
    const leafHeaderX = verticalLineX + 40; // Position of "leaf" header
    
    // Draw the horizontal line for the top of the T (with custom endpoints)
    ctx.beginPath();
    ctx.moveTo(horizontalLineStart, tableStartY);
    ctx.lineTo(horizontalLineEnd, tableStartY);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Draw "stem" on the left side above the horizontal line
    ctx.font = `${fontSize}px ${fontFamily}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText("stem", stemHeaderX, tableStartY - 5);
    
    // Draw "leaf" on the right side above the horizontal line
    ctx.textAlign = 'center';
    ctx.fillText("leaf", leafHeaderX, tableStartY - 5);
    
    // Reset text baseline
    ctx.textBaseline = 'alphabetic';
    
    // Draw vertical line at the specified X position
    ctx.beginPath();
    ctx.moveTo(verticalLineX, tableStartY - lineHeight);
    ctx.lineTo(verticalLineX, tableStartY + processedData.stems.length * lineHeight + 5);
    ctx.stroke();
    
    // Draw stems and leaves
    const dataStartY = tableStartY + lineHeight;
    
    processedData.stems.forEach((item, index) => {
      const y = dataStartY + index * lineHeight;
      
      // Draw stem
      ctx.textAlign = 'right';
      ctx.fillText(item.stem, verticalLineX - 10, y);
      
      // Draw leaves
      ctx.textAlign = 'left';
      const leaves = Array.isArray(item.leaves) ? item.leaves.join(' ') : 
                     typeof item.leaves === 'string' ? item.leaves.split(',').join(' ') : '';
      ctx.fillText(leaves, verticalLineX + 10, y);
    });
    
    // Draw key note below the table if present
    if (processedData.keyNote) {
      const keyNoteY = dataStartY + (processedData.stems.length * lineHeight) + lineHeight;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.textAlign = 'left';
      ctx.fillText("Key: " + processedData.keyNote, 140, keyNoteY);
    }
  });
}





 function previewProblemInteractive() {
  console.log("Starting preview with answer type:", document.getElementById("answer-type").value);
  
  // Reset grid rows if answer type is grid
  if (document.getElementById("answer-type").value === "grid") {
    window.shuffledGridRows = null;
  }
  
  // Force a fresh recomputation of all variables (and thus re‐run random functions)
  let computedVars = computeAllVariables();
  window.currentComputedVars = computedVars;

  // Update any draggable elements that use image code in the original canvas
 // updateDraggableImagesInOriginal(computedVars);
  
  // Create a clone canvas for preview generation
  const cloneCanvas = createCloneCanvas();

  // Copy box-and-whisker data into the clone so the preview routine can draw it:
// Copy box-and-whisker data into the clone so the preview routine can draw it:
cloneCanvas.querySelectorAll('.box-whisker-container').forEach(cloneBW => {
  // read the data-attribute (not a JS property) from the clone
  const id   = cloneBW.getAttribute('data-box-whisker-id');
  // match up with the original via that same attribute
  const orig = document.querySelector(
   `.box-whisker-container[data-box-whisker-id="${id}"]`
  );
  if (orig && orig.boxWhiskerData) {
    // deep-clone so we don’t mutate the original
    cloneBW.boxWhiskerData = JSON.parse(
      JSON.stringify(orig.boxWhiskerData)
    );
  }
});


// Copy circle data from original to clone
cloneCanvas.querySelectorAll('.circle-container').forEach(cloneCircle => {
  const id = cloneCircle.getAttribute('data-circle-id');
  const orig = document.querySelector(
    `.circle-container[data-circle-id="${id}"]`
  );
  if (orig && orig.circleData) {
    // deep-clone so we don't mutate the original
    cloneCircle.circleData = JSON.parse(JSON.stringify(orig.circleData));
    // copy over the drawing function
    if (typeof orig.drawCircle === 'function') {
      cloneCircle.drawCircle = orig.drawCircle;
    }
  }
});

// Add code to copy angle data from original to clone
cloneCanvas.querySelectorAll('.angle-container').forEach(cloneAngle => {
  const id = cloneAngle.getAttribute('data-angle-id');
  const orig = document.querySelector(
    `.angle-container[data-angle-id="${id}"]`
  );
  if (orig && orig.angleData) {
    // deep-clone so we don't mutate the original
    cloneAngle.angleData = JSON.parse(JSON.stringify(orig.angleData));
    // copy over the drawing function
    if (typeof orig.drawAngle === 'function') {
      cloneAngle.drawAngle = orig.drawAngle;
    }
  }
});

    // copy chartData from original pies into the clones
  // === inside previewProblemInteractive(), after createCloneCanvas() ===
cloneCanvas.querySelectorAll('.pie-container').forEach(clonePie => {
  const id   = clonePie.dataset.pieId;
  const orig = document.querySelector(`.pie-container[data-pie-id="${id}"]`);
  if (orig && orig.chartData) {
    // deep-clone so we don’t mutate the original
    clonePie.chartData = JSON.parse(JSON.stringify(orig.chartData));
    // now tell the preview whether to show the legend
    clonePie.chartData.showLegend = orig.chartData.previewShowLegend === true;
  }
});


cloneCanvas.querySelectorAll('.stem-leaf-container').forEach(cloneSL => {
  const id = cloneSL.getAttribute('data-stem-leaf-id');
  const orig = document.querySelector(`.stem-leaf-container[data-stem-leaf-id="${id}"]`);
  if (orig && orig.stemLeafData) {
    cloneSL.stemLeafData = JSON.parse(JSON.stringify(orig.stemLeafData));
    // Copy the draw function if it exists
    if (typeof orig.drawStemLeaf === 'function') {
      cloneSL.drawStemLeaf = orig.drawStemLeaf;
    }
  }
});

cloneCanvas.querySelectorAll('.bar-graph-container').forEach(cloneBG => {
    const id = cloneBG.getAttribute('data-bar-graph-id');
    const orig = document.querySelector(`.bar-graph-container[data-bar-graph-id="${id}"]`);
    if (orig && orig.barGraphData) {
      cloneBG.barGraphData = JSON.parse(JSON.stringify(orig.barGraphData));
      // Copy the draw function if it exists
      if (typeof orig.drawBarGraph === 'function') {
        cloneBG.drawBarGraph = orig.drawBarGraph;
      }
    }
  });

  cloneCanvas.querySelectorAll('.line-graph-container').forEach(cloneLG => {
  const id = cloneLG.getAttribute('data-line-graph-id');
  const orig = document.querySelector(`.line-graph-container[data-line-graph-id="${id}"]`);
  if (orig && orig.lineGraphData) {
    cloneLG.lineGraphData = JSON.parse(JSON.stringify(orig.lineGraphData));
    // Copy the draw function if it exists
    if (typeof orig.drawLineGraph === 'function') {
      cloneLG.drawLineGraph = orig.drawLineGraph;
    }
  }
});

cloneCanvas.querySelectorAll('.four-quadrant-graph-container').forEach(cloneFQ => {
    const id   = cloneFQ.getAttribute('data-four-quadrant-graph-id');
    const orig = document.querySelector(
      `.four-quadrant-graph-container[data-four-quadrant-graph-id="${id}"]`
    );
    if (orig && orig.graphData) {
      // deep-clone so we don’t mutate the original
      cloneFQ.graphData = JSON.parse(JSON.stringify(orig.graphData));
      // copy over the drawing function
      if (typeof orig.drawGraph === 'function') {
        cloneFQ.drawGraph = orig.drawGraph;
      }
    }
  });

  // Add this inside previewProblemInteractive after the four-quadrant-graph-container handling
cloneCanvas.querySelectorAll('.quad-one-graph-container').forEach(cloneQO => {
  const id = cloneQO.getAttribute('data-quad-one-graph-id');
  const orig = document.querySelector(
    `.quad-one-graph-container[data-quad-one-graph-id="${id}"]`
  );
  if (orig && orig.graphData) {
    // deep-clone so we don't mutate the original
    cloneQO.graphData = JSON.parse(JSON.stringify(orig.graphData));
    // copy over the drawing function
    if (typeof orig.drawGraph === 'function') {
      cloneQO.drawGraph = orig.drawGraph;
    }
  }
});


  // Add the new code to copy number line data
  cloneCanvas.querySelectorAll('.number-line-container').forEach(cloneNL => {
    const id = cloneNL.getAttribute('data-number-line-id');
    const orig = document.querySelector(
      `.number-line-container[data-number-line-id="${id}"]`
    );
    if (orig && orig.numberLineData) {
      // deep-clone so we don't mutate the original
      cloneNL.numberLineData = JSON.parse(JSON.stringify(orig.numberLineData));
      // copy over the drawing function
      if (typeof orig.drawNumberLine === 'function') {
        cloneNL.drawNumberLine = orig.drawNumberLine;
      }
    }
  });

  // Process all elements in the clone for preview
  processElementsInClone(cloneCanvas, computedVars);
  
  // Generate the final preview image
  generatePreviewImage(cloneCanvas, computedVars);
}

/**
 * Updates draggable elements with image code in the original canvas
 * @param {Object} computedVars - Computed variable values
 */
function updateDraggableImagesInOriginal(computedVars) {
  document.querySelectorAll('.draggable-element').forEach(container => {
    if (container.dataset.originalImageCode) {
      updateImageCodeElement(container, computedVars);
    }
  });
}

/**
 * Creates a clone of the problem canvas for preview generation
 * @returns {HTMLElement} The cloned canvas element
 */
function createCloneCanvas() {
  const originalCanvas = document.getElementById("problem-canvas");
  const cloneCanvas = originalCanvas.cloneNode(true);
  cloneCanvas.style.position = 'absolute';
  cloneCanvas.style.left = '-9999px';
  document.body.appendChild(cloneCanvas);

  // Insert a style tag into the clone to hide editing controls
  const styleTag = document.createElement("style");
  styleTag.innerHTML = `
  .element-controls, .resize-handle { display:none !important; }
  /* keep every draggable wrapper and its contents see-through in the clone */
  .draggable-element,
  .draggable-element .element-content,
  .text-box { background:transparent !important; }
`;
  cloneCanvas.appendChild(styleTag);
  
  // Copy computed styles from the original canvas to the clone
  copyComputedStyles(originalCanvas, cloneCanvas);

  /* —— wipe default backgrounds that got copied across —— */
const selectors = [
  '.draggable-element',
  '.textbox-container',
  '.textbox-content-container',
  '.text-box',          // legacy single-div text boxes
  '.draggable-text-box' // MC-option text boxes, etc.
];

selectors.forEach(sel => {
  cloneCanvas.querySelectorAll(sel).forEach(el => {
    el.style.background      = 'none';                // kill colour & images
    el.style.backgroundColor = 'transparent';
    el.style.boxShadow       = 'none';                // drop any shadows
    el.style.border          = el.style.border || ''; // keep your dashed border if you want
  });
});

  
  return cloneCanvas;
}

/**
 * Processes all elements in the clone canvas for preview
 * @param {HTMLElement} cloneCanvas - The cloned canvas element
 * @param {Object} computedVars - Computed variable values
 */
 function processElementsInClone(cloneCanvas, computedVars) {
  // Process text boxes with enhanced handling
  processTextBoxesEnhanced(cloneCanvas, computedVars);
  
  // Process MathLive equations
  processMathLiveEquationsInClone(cloneCanvas, computedVars);
  
  // Keep your existing code for other elements
  processDraggableElements(cloneCanvas, computedVars);
  processGriddedRectangularPrisms(cloneCanvas, computedVars);
  processBoxAndWhiskerPlotsInClone(cloneCanvas, computedVars);
  processStemLeafPlotsInClone(cloneCanvas, computedVars);
  processBarGraphsInClone(cloneCanvas, computedVars);
  processLineGraphsInClone(cloneCanvas, computedVars);
  processFourQuadrantGraphsInClone(cloneCanvas, computedVars);
  processQuadOneGraphInClone(cloneCanvas, computedVars);
  processNumberLine(cloneCanvas, computedVars);
  processRectangleInClone(cloneCanvas, computedVars);
   processTable(cloneCanvas, computedVars);
   processAngle(cloneCanvas, computedVars);
   processCircleChordsAndSectors(cloneCanvas, computedVars);
}

/**
 * Processes text boxes in the clone canvas
 * @param {HTMLElement} cloneCanvas - The cloned canvas element
 * @param {Object} computedVars - Computed variable values
 */
 function processTextBoxesEnhanced(cloneCanvas, computedVars) {
  // Process regular text boxes first (your existing code)
  cloneCanvas.querySelectorAll('.text-box').forEach(box => {
    let mode = box.getAttribute("data-mode") || "manual";
    let original = box.getAttribute("data-original-text") || box.innerHTML;
    if (mode === "latex") {
      // Wrap in delimiters if not already present
      let latexContent = original;
      if (!latexContent.trim().startsWith("\\(") && !latexContent.trim().startsWith("$$")) {
        latexContent = "\\(" + latexContent + "\\)";
      }
      // Now substitute only the double-brace variables
      latexContent = substituteLatexVariables(latexContent, computedVars);
      box.innerHTML = latexContent;
    } else {
      box.innerHTML = substituteValue(original, computedVars);
    }
  });
  
  // Then process textbox-content-container elements (newer elements)
  cloneCanvas.querySelectorAll('.textbox-content-container').forEach(textbox => {
    // Check if there's any math equations inside
    const hasEquations = textbox.querySelector('.inline-equation');
    
    if (hasEquations) {
      // Handle content with equations by processing each node separately
      processTextBoxWithEquations(textbox, computedVars);
    } else {
      // Simple case: just replace variables in the content
      const content = textbox.innerHTML;
      textbox.innerHTML = substituteValue(content, computedVars);
    }
  });
}

/**
 * Processes draggable elements in the clone canvas
 * @param {HTMLElement} cloneCanvas - The cloned canvas element
 * @param {Object} computedVars - Computed variable values
 */
function processDraggableElements(cloneCanvas, computedVars) {
  cloneCanvas.querySelectorAll('.draggable-element').forEach(container => {
    if (container.dataset.imageCode) {
      updateImageCodeElement(container, computedVars);
    } else if (container.dataset.originalEquation && container.dataset.originalEquation.trim() !== "") {
      processGraphElement(container, computedVars);
    } else if (container.classList.contains('circle-container')) {
      processPieChartElement(container, computedVars);
    }
    else if (container.classList.contains('pie-container')) {
      processPieContainerElement(container, computedVars);
    }
  });
}

function processPieContainerElement(container, computedVars) {
  // Skip if no chart data
  if (!container.chartData) {
    console.warn("Pie chart without chart data found");
    return;
  }
  
  // Process title for variables
  if (container.chartData.title) {
    container.chartData.title = substituteValue(container.chartData.title, computedVars);
  }
  
  // Process categories
  if (container.chartData.categories && Array.isArray(container.chartData.categories)) {
    container.chartData.categories.forEach(category => {
      // Process category name
      if (category.name) {
        category.name = substituteValue(category.name, computedVars);
      }
      
      // Process category value (can be string with variables or number)
      if (category.value !== undefined) {
        if (typeof category.value === 'string') {
          try {
            // First substitute any variables
            const substitutedValue = substituteValue(category.value, computedVars);
            
            // Then evaluate the expression if it's a number now
            if (!isNaN(parseFloat(substitutedValue))) {
              category.value = parseFloat(substitutedValue);
            } else {
              console.warn("Could not convert to number:", substitutedValue);
              category.value = 0; // Fallback
            }
          } catch (e) {
            console.error("Error evaluating pie chart category value:", e);
            category.value = 0; // Fallback
          }
        }
      }
    });
    
    // After processing all categories, recalculate percentages if needed
    if (container.chartData.inputType === "total") {
      const total = container.chartData.categories.reduce((sum, cat) => sum + parseFloat(cat.value), 0);
      if (total > 0) {
        container.chartData.categories.forEach(cat => {
          cat.value = (cat.value / total) * 100;
        });
      }
    }
    
    // Apply rounding
    container.chartData.categories.forEach(cat => {
      if (typeof cat.value === 'number') {
        cat.value = container.chartData.roundingType === "whole"
          ? Math.round(cat.value)
          : Math.round(cat.value * 10) / 10;
      }
    });
  }
  
  // Redraw the pie chart in the cloned canvas
  const pieChartCanvas = container.querySelector('canvas');
  if (pieChartCanvas) {
    const ctx = pieChartCanvas.getContext('2d');
    const chartLegend = container.querySelector('.legend');
    
    drawPieChartForPreview(
  ctx,
  container.chartData.categories,
  container.chartData.title,
  container.chartData.displayFormat,
  container.chartData.showLegend,
  container.chartData.fontSettings,
  container.chartData.colorMode,
  container.chartData.lineColor,       // ← NEW
  container.chartData.lineWidth,   
  container.chartData.roundingType,      // ← add this line
  pieChartCanvas.width,
  pieChartCanvas.height,
  chartLegend
);


  }
}

function drawPieChartForPreview(ctx, categories, title, displayFormat, showLegend, fontSettings, colorMode, lineColor, lineWidth, roundingType, width, height, legendElement) {
  const matplotlibColors = [
    '#ff0000', '#1f77b4', '#2ca02c', '#ff7f0e', '#9467bd',
    '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
  ];
  const grayscaleShades = [
    '#000000', '#333333', '#666666', '#999999', '#cccccc',
    '#1a1a1a', '#4d4d4d', '#808080', '#b3b3b3', '#e6e6e6'
  ];

  // Clear canvas
  ctx.clearRect(0, 0, width, height);

  // Compute center and radius
  const cx = width / 2;
  const cy = height / 2;
  const r = Math.min(cx, cy) * 0.7;

  // Total of raw values
  const total = categories.reduce((sum, cat) => sum + parseFloat(cat.value), 0);
  if (total <= 0) return;

  // Raw and percent values
  const rawValues    = categories.map(cat => parseFloat(cat.value));
  let percentValues  = rawValues.map(v => (v / total) * 100);

  // Apply roundingType
  if (roundingType === 'whole') {
    percentValues = percentValues.map(p => Math.round(p));
  } else {
    percentValues = percentValues.map(p => Math.round(p * 10) / 10);
  }

  // Draw title
  ctx.font         = `bold ${fontSettings.titleFontSize}px ${fontSettings.titleFont}`;
  ctx.fillStyle    = fontSettings.titleFontColor;
  ctx.textAlign    = 'center';
  ctx.fillText(title, cx, 30);

  // Setup legend container
  if (legendElement) {
    legendElement.innerHTML = '';
    legendElement.style.display = showLegend ? 'flex' : 'none';
    if (showLegend) {
      legendElement.style.flexWrap    = 'wrap';
      legendElement.style.justifyContent = 'center';
      legendElement.style.gap         = '10px';
    }
  }

  // Draw slices
  let angle = -Math.PI / 2;
  categories.forEach((cat, i) => {
    const raw      = rawValues[i];
    const arcAngle = raw / total * 2 * Math.PI;
    const fillColor = (colorMode === 'grayscale')
      ? grayscaleShades[i % grayscaleShades.length]
      : (cat.color || matplotlibColors[i % matplotlibColors.length]);

    // Slice
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, angle, angle + arcAngle);
    ctx.closePath();
    ctx.fillStyle   = fillColor;
    ctx.fill();
    ctx.lineWidth   = 2
    ctx.strokeStyle = lineColor;
    
    ctx.stroke();

    // Label positioning
    const midAngle   = angle + arcAngle / 2;
    const tx         = cx + Math.cos(midAngle) * r * 0.6;
    const ty         = cy + Math.sin(midAngle) * r * 0.6;
    ctx.font         = `bold ${fontSettings.labelFontSize}px ${fontSettings.labelFont}`;
    ctx.fillStyle    = fontSettings.labelFontColor;
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'middle';

    // Decide decimal places
    const decimals = (roundingType === 'whole' ? 0 : 1);
    const pct      = percentValues[i].toFixed(decimals) + '%';

    // Draw text
    const lineSpacing = parseInt(fontSettings.labelFontSize) * 1.2;
    if (displayFormat === 'percentInPie') {
      ctx.fillText(pct, tx, ty);
    } else if (displayFormat === 'nameInPie') {
      ctx.fillText(cat.name, tx, ty);
    } else {
      ctx.fillText(cat.name, tx, ty - lineSpacing / 2);
      ctx.fillText(pct,       tx, ty + lineSpacing / 2);
    }

    // Legend entry
    if (showLegend && legendElement) {
      const legendItem = document.createElement('div');
      legendItem.className        = 'legend-item';
      legendItem.style.display    = 'flex';
      legendItem.style.alignItems = 'center';
      legendItem.style.margin     = '0 5px';

      const colorBox = document.createElement('div');
      colorBox.className            = 'legend-color';
      colorBox.style.width          = '15px';
      colorBox.style.height         = '15px';
      colorBox.style.marginRight    = '5px';
      colorBox.style.border         = '1px solid #ccc';
      colorBox.style.backgroundColor = fillColor;

      const text = document.createElement('span');
      text.textContent            = `${cat.name} (${percentValues[i].toFixed(decimals)}%)`;
      text.style.fontSize         = '12px';

      legendItem.appendChild(colorBox);
      legendItem.appendChild(text);
      legendElement.appendChild(legendItem);
    }

    angle += arcAngle;
  });
}

/**
 * Processes a graph element
 * @param {HTMLElement} container - The graph container element
 * @param {Object} computedVars - Computed variable values
 */
function processGraphElement(container, computedVars) {
  let originalEq = container.dataset.originalEquation;
  let substitutedEq = originalEq.replace(/\{([^}]+)\}/g, (match, p1) => {
    let key = p1.trim();
    return computedVars[key] !== undefined ? computedVars[key] : match;
  });
  const xInterval = container.dataset.xInterval || 1;
  const yInterval = container.dataset.yInterval || 1;
  const xLabel = container.dataset.xLabel || "X";
  const yLabel = container.dataset.yLabel || "Y";
  const fontSize = container.dataset.fontSize || 12;
  const newSVG = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, fontSize, substitutedEq);
  container.querySelector('.element-content').innerHTML = newSVG;
}

/**
 * Processes a pie chart element
 * @param {HTMLElement} container - The pie chart container element
 * @param {Object} computedVars - Computed variable values
 */
function processPieChartElement(container, computedVars) {
  const totalPiecesExpr = container.getAttribute("data-total-pieces");
  const shadedPiecesExpr = container.getAttribute("data-shaded-pieces");
  console.log("Circle expressions:", { totalPiecesExpr, shadedPiecesExpr });
  
  if (totalPiecesExpr && shadedPiecesExpr) {
    try {
      const totalPieces = math.evaluate(substituteValue(totalPiecesExpr, computedVars));
      const shadedPieces = math.evaluate(substituteValue(shadedPiecesExpr, computedVars));
      console.log("Evaluated:", { totalPieces, shadedPieces });
      
      if (typeof totalPieces === "number" && typeof shadedPieces === "number" && 
          totalPieces > 0 && shadedPieces >= 0 && shadedPieces <= totalPieces) {
        const shadedColor = container.getAttribute("data-shaded-color") || "#ff0000";
        const unshadedColor = container.getAttribute("data-unshaded-color") || "#ffffff";
        const width = container.offsetWidth || 150;
        const height = (container.offsetHeight || 170) - 20; // Account for toolbar
        const svgHTML = generatePieChartSVG(totalPieces, shadedPieces, shadedColor, unshadedColor, width, height, []);
        
        const circleContent = container.querySelector('.circle-content');
        if (circleContent) {
          svgToCanvas(svgHTML, width, height).then(canvas => {
            circleContent.innerHTML = "";
            canvas.style.width = "100%";
            canvas.style.height = "100%";
            canvas.style.display = "block"; // Ensure visibility
            circleContent.appendChild(canvas);
            console.log("High-res canvas inserted for pie chart");
          }).catch(err => {
            console.error("Failed to convert SVG to canvas:", err);
            circleContent.innerHTML = svgHTML; // Fallback
            console.log("Fallback SVG applied:", circleContent.innerHTML.substring(0, 200));
          });
        } else {
          console.error("No circle-content found");
        }
      } else {
        console.warn("Invalid parameters:", { totalPieces, shadedPieces });
      }
    } catch (e) {
      console.error("Evaluation error:", e);
    }
  }
}

function processGriddedRectangularPrisms(cloneCanvas, computedVars) {
  cloneCanvas.querySelectorAll('.gridded-rectangular-prism').forEach(container => {
    console.log('Processing gridded prism');
    
    // Get expressions from data attributes 
    const lengthExpr = container.getAttribute("data-length-expr");
    const widthExpr = container.getAttribute("data-width-expr");  
    const heightExpr = container.getAttribute("data-height-expr");
    
    // Get current values
    let length = container.length || 3;
    let width = container.width || 4;
    let height = container.height || 2;
    
    // Process length
    if (lengthExpr) {
      if (lengthExpr.includes('#')) {
        // Variable pattern - substitute
        const substituted = substituteValue(lengthExpr, computedVars);
        const numValue = parseInt(substituted);
        if (!isNaN(numValue) && numValue > 0) {
          length = numValue;
        }
      } else {
        // Direct value
        const numValue = parseInt(lengthExpr);
        if (!isNaN(numValue) && numValue > 0) {
          length = numValue;
        }
      }
    }
    
    // Process width  
    if (widthExpr) {
      if (widthExpr.includes('#')) {
        const substituted = substituteValue(widthExpr, computedVars);
        const numValue = parseInt(substituted);
        if (!isNaN(numValue) && numValue > 0) {
          width = numValue;
        }
      } else {
        const numValue = parseInt(widthExpr);
        if (!isNaN(numValue) && numValue > 0) {
          width = numValue;
        }
      }
    }
    
    // Process height
    if (heightExpr) {
      if (heightExpr.includes('#')) {
        const substituted = substituteValue(heightExpr, computedVars);
        const numValue = parseInt(substituted);
        if (!isNaN(numValue) && numValue > 0) {
          height = numValue;
        }
      } else {
        const numValue = parseInt(heightExpr);
        if (!isNaN(numValue) && numValue > 0) {
          height = numValue;
        }
      }
    }
    
    // Draw the gridded rectangular prism with processed values
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = container.querySelector('svg');
    if (!svg) return;
    
    // Get container drawing dimensions
    const contentDiv = container.querySelector('.prism-content');
    const containerWidth = contentDiv?.clientWidth || 220;
    const containerHeight = contentDiv?.clientHeight || 200;
    
    // Cabinet projection parameters (45° angle for consistent projection)
    const depthRatio = 0.5;
    const angle = Math.PI / 4; // 45 degrees
    
    // Compute unitSize so that the entire prism fits
    const possibleUnitSizeX = containerWidth / (length + depthRatio * Math.cos(angle) * height);
    const possibleUnitSizeY = containerHeight / (width + depthRatio * Math.sin(angle) * height);
    const scaleMargin = 0.9; // to add some padding
    const unitSize = Math.min(possibleUnitSizeX, possibleUnitSizeY) * scaleMargin;
    
    // Compute depth offsets
    const depthOffsetX = unitSize * depthRatio * Math.cos(angle);
    const depthOffsetY = -unitSize * depthRatio * Math.sin(angle);
    
    // Compute overall drawn dimensions
    const totalWidth = length * unitSize + depthOffsetX * height;
    const totalHeight = width * unitSize - depthOffsetY * height;  // subtract because depthOffsetY is negative
    
    // Center the drawing inside the container
    const startX = (containerWidth - totalWidth) / 2;
    // For Y, adjust so that the top face (which extends upward) is visible
    const startY = (containerHeight - totalHeight) / 2 - depthOffsetY * height;
    
    // Get style properties
    const strokeCol     = container.getAttribute("data-stroke-color")    || '#000000';
const fillCol       = container.getAttribute("data-fill-color")      || '#ffffff';
const lineThickness = parseInt(container.getAttribute("data-line-thickness")) || 1;
    
    // Clear existing content
    svg.innerHTML = '';
    
    // Create groups for the three faces
    const frontFaceGroup = document.createElementNS(svgNS, "g");
    frontFaceGroup.setAttribute("class", "front-face");
    svg.appendChild(frontFaceGroup);
    
    const topFaceGroup = document.createElementNS(svgNS, "g");
    topFaceGroup.setAttribute("class", "top-face");
    svg.appendChild(topFaceGroup);
    
    const rightFaceGroup = document.createElementNS(svgNS, "g");
    rightFaceGroup.setAttribute("class", "right-face");
    svg.appendChild(rightFaceGroup);
    
    // --- FRONT FACE (x, y) ---
    const frontFace = document.createElementNS(svgNS, "polygon");
    const frontFacePoints = [
      `${startX},${startY + width * unitSize}`,                        // bottom-left
      `${startX},${startY}`,                                           // top-left
      `${startX + length * unitSize},${startY}`,                       // top-right
      `${startX + length * unitSize},${startY + width * unitSize}`     // bottom-right
    ].join(" ");
    frontFace.setAttribute("points", frontFacePoints);
    frontFace.setAttribute("fill", fillCol === "transparent" ? "none" : fillCol);
    frontFace.setAttribute("stroke", strokeCol);
    frontFace.setAttribute("stroke-width", lineThickness);
    frontFaceGroup.appendChild(frontFace);
    
    // Vertical grid lines for front face
    for (let x = 0; x <= length; x++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + x * unitSize);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", startX + x * unitSize);
      line.setAttribute("y2", startY + width * unitSize);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      frontFaceGroup.appendChild(line);
    }
    
    // Horizontal grid lines for front face
    for (let y = 0; y <= width; y++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX);
      line.setAttribute("y1", startY + y * unitSize);
      line.setAttribute("x2", startX + length * unitSize);
      line.setAttribute("y2", startY + y * unitSize);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      frontFaceGroup.appendChild(line);
    }
    
    // --- TOP FACE (x, z) ---
    const topFace = document.createElementNS(svgNS, "polygon");
    const topFacePoints = [
      `${startX},${startY}`,                                                   // bottom-left
      `${startX + depthOffsetX * height},${startY + depthOffsetY * height}`,   // top-left
      `${startX + depthOffsetX * height + length * unitSize},${startY + depthOffsetY * height}`,  // top-right
      `${startX + length * unitSize},${startY}`                                // bottom-right
    ].join(" ");
    topFace.setAttribute("points", topFacePoints);
    topFace.setAttribute("fill", fillCol === "transparent" ? "none" : fillCol);
    topFace.setAttribute("stroke", strokeCol);
    topFace.setAttribute("stroke-width", lineThickness);
    topFaceGroup.appendChild(topFace);
    
    // Horizontal grid lines for top face
    for (let x = 0; x <= length; x++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + x * unitSize);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", startX + depthOffsetX * height + x * unitSize);
      line.setAttribute("y2", startY + depthOffsetY * height);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      topFaceGroup.appendChild(line);
    }
    
    // Vertical grid lines for top face
    for (let z = 0; z <= height; z++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + depthOffsetX * z);
      line.setAttribute("y1", startY + depthOffsetY * z);
      line.setAttribute("x2", startX + depthOffsetX * z + length * unitSize);
      line.setAttribute("y2", startY + depthOffsetY * z);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      topFaceGroup.appendChild(line);
    }
    
    // --- RIGHT FACE (z, y) ---
    const rightFace = document.createElementNS(svgNS, "polygon");
    const rightFacePoints = [
      `${startX + length * unitSize},${startY}`,                                        // top-left
      `${startX + length * unitSize + depthOffsetX * height},${startY + depthOffsetY * height}`,    // top-right
      `${startX + length * unitSize + depthOffsetX * height},${startY + width * unitSize + depthOffsetY * height}`, // bottom-right
      `${startX + length * unitSize},${startY + width * unitSize}`                      // bottom-left
    ].join(" ");
    rightFace.setAttribute("points", rightFacePoints);
    rightFace.setAttribute("fill", fillCol === "transparent" ? "none" : fillCol);
    rightFace.setAttribute("stroke", strokeCol);
    rightFace.setAttribute("stroke-width", lineThickness);
    rightFaceGroup.appendChild(rightFace);
    
    // Horizontal grid lines for right face
    for (let y = 0; y <= width; y++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + length * unitSize);
      line.setAttribute("y1", startY + y * unitSize);
      line.setAttribute("x2", startX + length * unitSize + depthOffsetX * height);
      line.setAttribute("y2", startY + y * unitSize + depthOffsetY * height);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      rightFaceGroup.appendChild(line);
    }
    
    // Vertical grid lines for right face
    for (let z = 0; z <= height; z++) {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", startX + length * unitSize + depthOffsetX * z);
      line.setAttribute("y1", startY + depthOffsetY * z);
      line.setAttribute("x2", startX + length * unitSize + depthOffsetX * z);
      line.setAttribute("y2", startY + depthOffsetY * z + width * unitSize);
      line.setAttribute("stroke", strokeCol);
      line.setAttribute("stroke-width", lineThickness);
      rightFaceGroup.appendChild(line);
    }
  });
}

/**
 * Renders a rectangular prism with grid lines
 * @param {HTMLElement} container - The prism container element
 * @param {Object} computedVars - Computed variable values
 */
function renderRectangularPrism(container, computedVars) {
  // Create a fresh SVG element
  const svg = container.querySelector('svg');
  if (!svg) return;
  
  const frontFaceGroup = svg.querySelector('.front-face');
  const topFaceGroup = svg.querySelector('.top-face');
  const rightFaceGroup = svg.querySelector('.right-face');
  
  if (!frontFaceGroup || !topFaceGroup || !rightFaceGroup) return;
  
  // Clear existing content
  frontFaceGroup.innerHTML = '';
  topFaceGroup.innerHTML = '';
  rightFaceGroup.innerHTML = '';
  
  // Get dimensions from expressions or from container properties as fallback
  let length = container.length || 3;
  let width = container.width || 4;
  let height = container.height || 2;
  
  // Process expressions if they exist
  length = processDimensionExpression(container, "length", lengthExpr, computedVars, length);
  width = processDimensionExpression(container, "width", widthExpr, computedVars, width);
  height = processDimensionExpression(container, "height", heightExpr, computedVars, height);
  
  // Store the computed values for reference
  container.setAttribute("data-computed-length", length);
  container.setAttribute("data-computed-width", width);
  container.setAttribute("data-computed-height", height);
  
  // Calculate drawing parameters
  const drawingParams = calculatePrismDrawingParameters(container, svg, length, width, height);
  
  // Draw the prism faces
  drawPrismFaces(svg, frontFaceGroup, topFaceGroup, rightFaceGroup, drawingParams, length, width, height);
}

/**
 * Processes a dimension expression for a rectangular prism
 * @param {HTMLElement} container - The prism container element
 * @param {string} dimension - The dimension name (length, width, or height)
 * @param {string} expression - The expression to evaluate
 * @param {Object} computedVars - Computed variable values
 * @param {number} defaultValue - The default value to use if evaluation fails
 * @returns {number} The evaluated dimension value
 */
function processDimensionExpression(container, dimension, expression, computedVars, defaultValue) {
  if (expression) {
    try {
      const substituted = substituteValue(expression, computedVars);
      const parsedValue = parseInt(substituted);
      if (!isNaN(parsedValue) && parsedValue > 0) {
        container[dimension] = parsedValue;
        return parsedValue;
      }
    } catch(e) {
      console.error(`Error substituting ${dimension} expression:`, e);
    }
  }
  return defaultValue;
}

/**
 * Calculates drawing parameters for a rectangular prism
 * @param {HTMLElement} container - The prism container element
 * @param {SVGElement} svg - The SVG element
 * @param {number} length - The length dimension
 * @param {number} width - The width dimension
 * @param {number} height - The height dimension
 * @returns {Object} The drawing parameters
 */
function calculatePrismDrawingParameters(container, svg, length, width, height) {
  // Get container dimensions
  const svgWidth = parseInt(svg.getAttribute('width')) || 200;
  const svgHeight = parseInt(svg.getAttribute('height')) || 180;
  
  // Calculate projection parameters
  const depthRatio = 0.5;
  const angle = Math.PI / 4; // 45 degrees
  
  // Calculate unit size to fit
  const possibleUnitSizeX = svgWidth / (length + depthRatio * Math.cos(angle) * height);
  const possibleUnitSizeY = svgHeight / (width + depthRatio * Math.sin(angle) * height);
  const unitSize = Math.min(possibleUnitSizeX, possibleUnitSizeY) * 0.9;
  
  // Calculate offsets
  const depthOffsetX = unitSize * depthRatio * Math.cos(angle);
  const depthOffsetY = -unitSize * depthRatio * Math.sin(angle);
  
  // Calculate dimensions
  const totalWidth = length * unitSize + depthOffsetX * height;
  const totalHeight = width * unitSize - depthOffsetY * height;
  
  // Center the drawing
  const startX = (svgWidth - totalWidth) / 2;
  const startY = (svgHeight - totalHeight) / 2 - depthOffsetY * height;
  
  // Get stroke and fill colors from container properties
  const strokeColor = container.strokeColor || "#000000";
  const fillColor = container.fillColor || "#ffffff";
  const lineThickness = container.lineThickness || 1;
  
  return {
    unitSize,
    depthOffsetX,
    depthOffsetY,
    startX,
    startY,
    strokeColor,
    fillColor,
    lineThickness
  };
}

/**
 * Draws the faces of a rectangular prism
 * @param {SVGElement} svg - The SVG element
 * @param {SVGElement} frontFaceGroup - The front face group element
 * @param {SVGElement} topFaceGroup - The top face group element
 * @param {SVGElement} rightFaceGroup - The right face group element
 * @param {Object} params - The drawing parameters
 * @param {number} length - The length dimension
 * @param {number} width - The width dimension
 * @param {number} height - The height dimension
 */
function drawPrismFaces(svg, frontFaceGroup, topFaceGroup, rightFaceGroup, params, length, width, height) {
  const svgNS = "http://www.w3.org/2000/svg";
  
  // Draw front face
  drawFrontFace(svgNS, frontFaceGroup, params, length, width);
  
  // Draw top face
  drawTopFace(svgNS, topFaceGroup, params, length, height);
  
  // Draw right face
  drawRightFace(svgNS, rightFaceGroup, params, width, height);
}

/**
 * Draws the front face of a rectangular prism
 * @param {string} svgNS - The SVG namespace
 * @param {SVGElement} frontFaceGroup - The front face group element
 * @param {Object} params - The drawing parameters
 * @param {number} length - The length dimension
 * @param {number} width - The width dimension
 */
function drawFrontFace(svgNS, frontFaceGroup, params, length, width) {
  const { startX, startY, unitSize, strokeColor, fillColor, lineThickness } = params;
  
  // Draw the face polygon
  const frontFace = document.createElementNS(svgNS, "polygon");
  frontFace.setAttribute("points", `
    ${startX},${startY + width * unitSize} 
    ${startX},${startY} 
    ${startX + length * unitSize},${startY} 
    ${startX + length * unitSize},${startY + width * unitSize}
  `);
  frontFace.setAttribute("fill", fillColor === "transparent" ? "none" : fillColor);
  frontFace.setAttribute("stroke", strokeColor);
  frontFace.setAttribute("stroke-width", lineThickness);
  frontFaceGroup.appendChild(frontFace);
  
  // Add vertical grid lines
  for (let x = 0; x <= length; x++) {
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", startX + x * unitSize);
    line.setAttribute("y1", startY);
    line.setAttribute("x2", startX + x * unitSize);
    line.setAttribute("y2", startY + width * unitSize);
    line.setAttribute("stroke", strokeColor);
    line.setAttribute("stroke-width", lineThickness);
    frontFaceGroup.appendChild(line);
  }
  
  // Add horizontal grid lines
  for (let y = 0; y <= width; y++) {
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", startX);
    line.setAttribute("y1", startY + y * unitSize);
    line.setAttribute("x2", startX + length * unitSize);
    line.setAttribute("y2", startY + y * unitSize);
    line.setAttribute("stroke", strokeColor);
    line.setAttribute("stroke-width", lineThickness);
    frontFaceGroup.appendChild(line);
  }
}

/**
 * Draws the top face of a rectangular prism
 * @param {string} svgNS - The SVG namespace
 * @param {SVGElement} topFaceGroup - The top face group element
 * @param {Object} params - The drawing parameters
 * @param {number} length - The length dimension
 * @param {number} height - The height dimension
 */
function drawTopFace(svgNS, topFaceGroup, params, length, height) {
  const { startX, startY, unitSize, depthOffsetX, depthOffsetY, strokeColor, fillColor, lineThickness } = params;
  
  // Draw the face polygon
  const topFace = document.createElementNS(svgNS, "polygon");
  topFace.setAttribute("points", `
    ${startX},${startY}
    ${startX + depthOffsetX * height},${startY + depthOffsetY * height}
    ${startX + depthOffsetX * height + length * unitSize},${startY + depthOffsetY * height}
    ${startX + length * unitSize},${startY}
  `);
  topFace.setAttribute("fill", fillColor === "transparent" ? "none" : fillColor);
  topFace.setAttribute("stroke", strokeColor);
  topFace.setAttribute("stroke-width", lineThickness);
  topFaceGroup.appendChild(topFace);
  
  // Add length grid lines
  for (let x = 0; x <= length; x++) {
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", startX + x * unitSize);
    line.setAttribute("y1", startY);
    line.setAttribute("x2", startX + depthOffsetX * height + x * unitSize);
    line.setAttribute("y2", startY + depthOffsetY * height);
    line.setAttribute("stroke", strokeColor);
    line.setAttribute("stroke-width", lineThickness);
    topFaceGroup.appendChild(line);
  }
  
  // Add height grid lines
  for (let z = 0; z <= height; z++) {
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", startX + depthOffsetX * z);
    line.setAttribute("y1", startY + depthOffsetY * z);
    line.setAttribute("x2", startX + depthOffsetX * z + length * unitSize);
    line.setAttribute("y2", startY + depthOffsetY * z);
    line.setAttribute("stroke", strokeColor);
    line.setAttribute("stroke-width", lineThickness);
    topFaceGroup.appendChild(line);
  }
}

/**
 * Draws the right face of a rectangular prism
 * @param {string} svgNS - The SVG namespace
 * @param {SVGElement} rightFaceGroup - The right face group element
 * @param {Object} params - The drawing parameters
 * @param {number} width - The width dimension
 * @param {number} height - The height dimension
 */
function drawRightFace(svgNS, rightFaceGroup, params, width, height) {
  const { startX, startY, unitSize, depthOffsetX, depthOffsetY, strokeColor, fillColor, lineThickness, length } = params;
  
  // Draw the face polygon
  const rightFace = document.createElementNS(svgNS, "polygon");
  rightFace.setAttribute("points", `
    ${startX + length * unitSize},${startY}
    ${startX + length * unitSize + depthOffsetX * height},${startY + depthOffsetY * height}
    ${startX + length * unitSize + depthOffsetX * height},${startY + width * unitSize + depthOffsetY * height}
    ${startX + length * unitSize},${startY + width * unitSize}
  `);
  rightFace.setAttribute("fill", fillColor === "transparent" ? "none" : fillColor);
  rightFace.setAttribute("stroke", strokeColor);
  rightFace.setAttribute("stroke-width", lineThickness);
  rightFaceGroup.appendChild(rightFace);
  
  // Add width grid lines
  for (let y = 0; y <= width; y++) {
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", startX + length * unitSize);
    line.setAttribute("y1", startY + y * unitSize);
    line.setAttribute("x2", startX + length * unitSize + depthOffsetX * height);
    line.setAttribute("y2", startY + y * unitSize + depthOffsetY * height);
    line.setAttribute("stroke", strokeColor);
    line.setAttribute("stroke-width", lineThickness);
    rightFaceGroup.appendChild(line);
  }
  
  // Add height grid lines
  for (let z = 0; z <= height; z++) {
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", startX + length * unitSize + depthOffsetX * z);
    line.setAttribute("y1", startY + depthOffsetY * z);
    line.setAttribute("x2", startX + length * unitSize + depthOffsetX * z);
    line.setAttribute("y2", startY + depthOffsetY * z + width * unitSize);
    line.setAttribute("stroke", strokeColor);
    line.setAttribute("stroke-width", lineThickness);
    rightFaceGroup.appendChild(line);
  }
}

/**
 * Generates the final preview image
 * @param {HTMLElement} cloneCanvas - The cloned canvas element
 * @param {Object} computedVars - Computed variable values
 */
function generatePreviewImage(cloneCanvas, computedVars) {
  console.log("Clone canvas structure before MathJax:", 
    cloneCanvas.querySelectorAll('.circle-container').length, 
    "pie charts found");

  // Wait for MathJax to typeset the LaTeX in the cloned text boxes
  MathJax.typesetPromise(cloneCanvas.querySelectorAll('.text-box'))
  .then(function() {
    console.log("MathJax typesetting complete");
    
    // Process all pie charts after MathJax is done
    processPieChartsAfterMathJax(cloneCanvas, computedVars)
      .then(() => renderFinalImage(cloneCanvas))
      .catch(err => {
        console.error("Error processing pie charts:", err);
        renderFinalImage(cloneCanvas);
      });
  })
  .catch(function(err) {
    console.error("MathJax typesetting error:", err);
    setTimeout(() => renderFinalImage(cloneCanvas), 500);
  });
}

/**
 * Processes pie charts after MathJax typesetting is complete
 * @param {HTMLElement} cloneCanvas - The cloned canvas element
 * @param {Object} computedVars - Computed variable values
 * @returns {Promise} A promise that resolves when all pie charts are processed
 */


 // Process box-and-whisker plots in the cloned canvas
function processBoxAndWhiskerPlotsInClone(cloneCanvas, computedVars) {
  const boxWhiskerElements = cloneCanvas.querySelectorAll('.box-whisker-container');
  console.log(`Processing ${boxWhiskerElements.length} box-and-whisker plots`);
  
  boxWhiskerElements.forEach(element => {
    // Get the canvas element and the stored data
    const plotCanvas = element.querySelector("canvas");
    if (!plotCanvas) return;
    
    const data = element.boxWhiskerData;
    if (!data) return;
    
    // Clone the data to avoid modifying the original
    const processedData = JSON.parse(JSON.stringify(data));
    
    // Process variables in the number line settings
    processedData.numberLine.min = processVariableValue(data.numberLine.min, computedVars);
    processedData.numberLine.max = processVariableValue(data.numberLine.max, computedVars);
    processedData.numberLine.tickInterval = processVariableValue(data.numberLine.tickInterval, computedVars);
    processedData.numberLine.labelInterval = processVariableValue(data.numberLine.labelInterval, computedVars);
    
    // Process variables in the boxes
    processedData.boxes.forEach((box, index) => {
      box.min = processVariableValue(data.boxes[index].min, computedVars);
      box.q1 = processVariableValue(data.boxes[index].q1, computedVars);
      box.med = processVariableValue(data.boxes[index].med, computedVars);
      box.q3 = processVariableValue(data.boxes[index].q3, computedVars);
      box.max = processVariableValue(data.boxes[index].max, computedVars);
    });
    
    // Draw the updated box-and-whisker plot
    const ctx = plotCanvas.getContext('2d');
    ctx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

    const fontSize = data.titleFontSize;

// Title
ctx.font = `bold ${fontSize}px sans-serif`;
ctx.textAlign = 'center';
ctx.fillText(data.title, plotCanvas.width/2, fontSize + 5);

ctx.textAlign = 'start';

    const nlMin = parseFloat(processedData.numberLine.min);
    const nlMax = parseFloat(processedData.numberLine.max);
    const nlInt = parseFloat(processedData.numberLine.tickInterval);
    const labelInt = parseFloat(processedData.numberLine.labelInterval);
    const boxThk = parseFloat(processedData.boxThickness);
    const axisLabel = processedData.numberLine.axisLabel;

    const padding = 60;
    const axisY = plotCanvas.height - 60;
    const plotWidth = plotCanvas.width - 2*padding;
    const scale = plotWidth / (nlMax - nlMin);
    const xOf = v => padding + (v - nlMin)*scale;

    // Axis line
    ctx.beginPath();
    ctx.strokeStyle = '#000'; 
    ctx.lineWidth = 2;
    ctx.moveTo(xOf(nlMin), axisY);
    ctx.lineTo(xOf(nlMax), axisY);
    ctx.stroke();

    // Ticks & labels
    ctx.font = `bold ${fontSize}px sans-serif`;
ctx.fillStyle = '#000';
ctx.lineWidth = 1;
for (let v = nlMin; v <= nlMax; v += nlInt) {
  const x = xOf(v);
  ctx.beginPath();
    ctx.moveTo(x, axisY - 5);
    ctx.lineTo(x, axisY + 5);
  ctx.stroke();
  if (labelInt > 0 && ((v - nlMin) % labelInt) === 0) {
    ctx.fillText(
      v,
      x - ctx.measureText(v).width/2,
      axisY + fontSize + 5
    );
  }
}

    // Axis label
    ctx.font = `bold ${fontSize}px sans-serif`;
ctx.fillStyle = '#000';
ctx.textAlign = 'center';
ctx.textBaseline = 'top';
ctx.fillText(
  axisLabel,
  plotCanvas.width/2,
  axisY + fontSize + 10
);

    // Plot boxes
    const whiskerYBase = axisY - 30;
    const boxYBase = axisY - 50;
    const boxHeight = 30;

    processedData.boxes.forEach((box, i) => {
      const mn = parseFloat(box.min), q1 = parseFloat(box.q1);
      const md = parseFloat(box.med), q3 = parseFloat(box.q3);
      const mx = parseFloat(box.max);

      ctx.strokeStyle = '#000'; 
      ctx.lineWidth = boxThk;
      
      // Whiskers
      ctx.beginPath();
      ctx.moveTo(xOf(mn), whiskerYBase - i*(boxHeight+10));
      ctx.lineTo(xOf(q1), whiskerYBase - i*(boxHeight+10));
      ctx.moveTo(xOf(q3), whiskerYBase - i*(boxHeight+10));
      ctx.lineTo(xOf(mx), whiskerYBase - i*(boxHeight+10));
      ctx.stroke();
      
      // Caps
      [mn, mx].forEach(val => {
        const x = xOf(val);
        ctx.beginPath();
        ctx.moveTo(x, whiskerYBase - 10 - i*(boxHeight+10));
        ctx.lineTo(x, whiskerYBase + 10 - i*(boxHeight+10));
        ctx.stroke();
      });

      // Box
      const top = boxYBase - i*(boxHeight+10);
      ctx.strokeRect(xOf(q1), top, xOf(q3) - xOf(q1), boxHeight);
      
      // Median
      ctx.beginPath();
      const xm = xOf(md);
      ctx.moveTo(xm, top);
      ctx.lineTo(xm, top+boxHeight);
      ctx.stroke();

      // Box label
      ctx.font = 'bold ${fontSize}px sans-serif'; 
      ctx.textBaseline = 'alphabetic';
      ctx.fillText(box.name, 40, top - 5);
    });
  });
}

// Helper function to process variable values
function processVariableValue(value, computedVars) {
  if (typeof value !== 'string') return value;
  
  // Check if the value contains variables
  let processedValue = value;
  
  // Replace variables like #a# with computed values
  const variableRegex = /#([a-z0-9]+)#/gi;
  let match;
  
  while ((match = variableRegex.exec(value)) !== null) {
    const variableName = match[1];
    if (computedVars && computedVars[variableName] !== undefined) {
      processedValue = processedValue.replace(match[0], computedVars[variableName]);
    }
  }
  
  // After replacing variables, try to convert to number
  const numValue = parseFloat(processedValue);
  return isNaN(numValue) ? processedValue : numValue;
}


function processPieChartsAfterMathJax(cloneCanvas, computedVars) {
  // Collect all circle containers and convert their SVGs to canvases
  const circlePromises = Array.from(cloneCanvas.querySelectorAll('.circle-container')).map(container => {
    const totalPiecesExpr = container.getAttribute("data-total-pieces");
    const shadedPiecesExpr = container.getAttribute("data-shaded-pieces");
    if (totalPiecesExpr && shadedPiecesExpr) {
      const totalPieces = math.evaluate(substituteValue(totalPiecesExpr, computedVars));
      const shadedPieces = math.evaluate(substituteValue(shadedPiecesExpr, computedVars));
      const shadedColor = container.getAttribute("data-shaded-color") || "#ff0000";
      const unshadedColor = container.getAttribute("data-unshaded-color") || "#ffffff";
      const width = container.offsetWidth || 150;
      const height = (container.offsetHeight || 170) - 20;
      const svgHTML = generatePieChartSVG(totalPieces, shadedPieces, shadedColor, unshadedColor, width, height, []);
      const circleContent = container.querySelector('.circle-content');
      if (circleContent) {
        return svgToCanvas(svgHTML, width, height).then(canvas => {
          circleContent.innerHTML = "";
          canvas.style.width = "100%";
          canvas.style.height = "100%";
          canvas.style.display = "block";
          circleContent.appendChild(canvas);
          console.log("Canvas inserted for pie chart in clone");
        });
      }
    }
    return Promise.resolve(); // No conversion needed
  });

  return Promise.all(circlePromises).then(() => {
    console.log("All pie charts converted to canvas");
  });
}


/**********************************************************************
 * renderFinalImage(cloneCanvas) – builds the PNG for the Preview pane
 *********************************************************************/
 function renderFinalImage(cloneCanvas) {
  console.log("🔥 renderFinalImage() — pre-rendering SVGs…");

  setTimeout(() => {

    /* ---- 1. rasterise any inline SVG content you already handle ---- */
    const svgSelectors = [
      '.cone-content svg',
      '.cylinder-content svg',
      '.bar-graph-content svg',
      '.circle-content svg',
      '.semicircle-content svg',
      '.triangle-content svg',
      '.regular-polygon-content svg',
      '.line-content svg',
      '.graph-content svg',
      '.rectangular-prism-content svg',
      '.triangular-prism-content svg'
    ].join(',');

    const svgEls = Array.from(cloneCanvas.querySelectorAll(svgSelectors));
    const svgPromises = svgEls.map(svg => {
      const xml = new XMLSerializer().serializeToString(svg);
      const w   = parseFloat(svg.getAttribute('width'))  || svg.clientWidth;
      const h   = parseFloat(svg.getAttribute('height')) || svg.clientHeight;

      return svgToCanvas(xml, w, h).then(canv => {
        canv.style.width  = w + 'px';
        canv.style.height = h + 'px';
        svg.parentNode.replaceChild(canv, svg);
      });
    });

    /* ---- 2. once those are rasterised, convert tables to SVG ---- */
    Promise.all(svgPromises).then(() => {

      /* 🟢 NEW – turn every <table> into a single-stroke SVG */
      replaceTablesWithSVG(cloneCanvas);

      /* ---- 3. snapshot the whole thing with html2canvas ---- */
      const dpr = window.devicePixelRatio || 1;
      html2canvas(cloneCanvas, {
        logging:         true,
        scale:           dpr,
        letterRendering: true
        
      })
      .then(finalCanvas => {
        const w = cloneCanvas.offsetWidth,
              h = cloneCanvas.offsetHeight;

        if (cloneCanvas.parentNode)
          cloneCanvas.parentNode.removeChild(cloneCanvas);

        const preview = document.getElementById("preview-area");
        preview.innerHTML = '';

        finalCanvas.style.width          = w + 'px';
        finalCanvas.style.height         = h + 'px';
        finalCanvas.style.imageRendering = dpr > 1 ? 'auto' : 'crisp-edges';

        preview.appendChild(finalCanvas);
        console.log("🎉 Preview complete!");
      })
      .catch(err => console.error("❌ html2canvas snapshot failed:", err));
    });
  }, 50);
}






/******** Update Problem and Answer Sizes ********/
function updateProblemSize() {
let w = document.getElementById("problem-width").value;
let h = document.getElementById("problem-height").value;
savedProblemWidth = w;
savedProblemHeight = h;
document.getElementById("problem-canvas").style.width = w + "px";
document.getElementById("problem-canvas").style.height = h + "px";
}
function updateSavedAnswerSize() {
savedAnswerWidth = document.getElementById("answer-width").value;
savedAnswerHeight = document.getElementById("answer-height").value;
const answerContent = document.getElementById("answer-image-content");
answerContent.style.width = savedAnswerWidth + "px";
answerContent.style.height = savedAnswerHeight + "px";
}

/******** NEW CODE: Table Cell Selection and Highlighting ********/
let selectedCell = null;
function cellClicked(event) {
if (selectedCell) {
  selectedCell.classList.remove("selected-cell");
}
selectedCell = event.currentTarget;
selectedCell.classList.add("selected-cell");
event.stopPropagation();
}
function attachCellClickHandlers(table) {
let cells = table.querySelectorAll("td, th");
cells.forEach(cell => {
  cell.addEventListener("click", cellClicked);
});
}
function highlightRow(table, cell, color) {
if (!cell) return;
let row = cell.closest("tr");
if (row) {
  for (let c of row.cells) {
    c.style.backgroundColor = color;
  }
}
}
function highlightColumn(table, cell, color) {
if (!cell) return;
let colIndex = cell.cellIndex;
for (let row of table.rows) {
  if (row.cells[colIndex]) {
    row.cells[colIndex].style.backgroundColor = color;
  }
}
}
function applyHighlight(mode) {
let color = document.getElementById("highlight-color").value;
let table = document.querySelector("#problem-canvas table");
if (!table) {
  alert("No table found in the problem image.");
  return;
}
if (!selectedCell) {
  alert("Please click on a table cell first to select its row/column.");
  return;
}
if (mode === "row") {
  highlightRow(table, selectedCell, color);
} else if (mode === "column") {
  highlightColumn(table, selectedCell, color);
}
}

/******** NEW CODE: Variable Options Toolbar Functions ********/
function getDefaultFormula(type) {
switch(type) {
  case 'random-int':
    return "randomInt(min, max)";
  case 'random-number':
    return "randomNumber(min, max, decimals)";
  case 'round':
    return "round(value, decimals)";
  case 'unreduced-fraction':
    return "unreducedfraction(num, denom)";
  case 'improper-fraction':
    return "reduceFraction(num, denom)";
  case 'mixed-number':
    return "mixedFraction(num, denom)";
  case 'choose-from-list':
    return "chooseFromWordList('word1', 'word2', 'word3')";
  case 'choose-from-list-number':
    return "chooseFromNumberList(1, 2, 3)";
  case 'arrange-asc':
    return "arrangeAscending('1,4,2')";
  case 'arrange-desc':
    return "arrangeDescending('1,4,2')";
  default:
    return "";
}
}
function setVariableFormula(type) {
if (currentFormulaInput) {
  let template = getDefaultFormula(type);
  let input = currentFormulaInput;
  let startPos = input.selectionStart;
  let endPos = input.selectionEnd;
  let currentValue = input.value;
  input.value = currentValue.substring(0, startPos) + template + currentValue.substring(endPos);
  let newPos = startPos + template.length;
  input.selectionStart = input.selectionEnd = newPos;
  input.focus();
} else {
  alert("Please click on a formula input field to focus it before inserting a template.");
}
}

// Helper function to shuffle an array (Fisher–Yates shuffle)
function shuffleArray(array) {
for (let i = array.length - 1; i > 0; i--) {
  let j = Math.floor(Math.random() * (i + 1));
  [array[i], array[j]] = [array[j], array[i]];
}
return array;
}

function getFinalAnswerOptions(computedVars) {
let options = [];
const correctContainer = document.getElementById("mc-correct");
const incorrectContainer = document.getElementById("mc-incorrect");

function processOption(optionNode, isCorrect) {
  let cloneOption = optionNode.cloneNode(true);
  let editors = cloneOption.querySelectorAll("button.edit-graph, button.delete-graph, button.edit-table, button.delete-table, .mc-option-toolbar");
  editors.forEach(el => el.remove());
  let graphElem = cloneOption.querySelector(".answer-graph");
  if (graphElem) {
    updateGraphInAnswerOption(graphElem, computedVars);
    let graphBtns = graphElem.querySelectorAll("button.edit-graph, button.delete-graph");
    graphBtns.forEach(btn => btn.remove());
  }
  let contentHTML = substituteValue(cloneOption.innerHTML, computedVars);
  options.push({ html: contentHTML, correct: isCorrect });
}

correctContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, true));
incorrectContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, false));

options = shuffleArray(options);
return options;
}

function getCorrectAnswerLettersFromOptions(options) {
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
let correctLetters = "";
options.forEach((option, index) => {
  if (option.correct) {
    correctLetters += letters[index];
  }
});
return correctLetters;
}

function initGraph(svgElement, aValue) {
aValue = Number(aValue);
let circle = svgElement.querySelector("#point");
if (circle) {
  circle.setAttribute("cy", aValue);
}
let label = svgElement.querySelector("#pointLabel");
if (label) {
  label.setAttribute("y", aValue);
  label.textContent = "(0, " + aValue + ")";
}
}
window.initGraph = initGraph;

function addMCOption(type) {
  let containerId = (type === "correct") ? "mc-correct" : "mc-incorrect";
  let container = document.getElementById(containerId);
  
  // Create the overall answer option container (non‑editable)
  let optionDiv = document.createElement("div");
  optionDiv.className = "mc-answer-option";
  optionDiv.setAttribute("data-correct", type === "correct" ? "true" : "false");
  optionDiv.setAttribute("data-required", "false");
  optionDiv.contentEditable = false; // Protect the container
  
  // Required checkbox container (non‑editable)
  let requiredContainer = document.createElement("span");
  requiredContainer.className = "option-required-edit";
  let requiredLabel = document.createElement("label");
  requiredLabel.style.marginRight = "5px";
  let requiredCheckbox = document.createElement("input");
  requiredCheckbox.type = "checkbox";
  requiredCheckbox.addEventListener("change", function(e) {
    optionDiv.setAttribute("data-required", requiredCheckbox.checked ? "true" : "false");
  });
  requiredLabel.appendChild(requiredCheckbox);
  requiredLabel.appendChild(document.createTextNode("Required"));
  requiredContainer.appendChild(requiredLabel);
  optionDiv.appendChild(requiredContainer);
  
  // Create the toolbar container (non‑editable)
  let toolbar = document.createElement("div");
  toolbar.className = "mc-option-toolbar";
  
  let graphBtn = document.createElement("button");
  graphBtn.textContent = "Add Graph";
  graphBtn.onclick = function(e) {
    e.stopPropagation();
    addGraphToAnswerOption(optionDiv);
  };
  toolbar.appendChild(graphBtn);
  
  let tableBtn = document.createElement("button");
  tableBtn.textContent = "Add Table";
  tableBtn.onclick = function(e) {
    e.stopPropagation();
    addTableToAnswerOption(optionDiv);
  };
  toolbar.appendChild(tableBtn);
  
  let imageBtn = document.createElement("button");
  imageBtn.textContent = "Add Image with Code";
  imageBtn.onclick = function(e) {
    e.stopPropagation();
    addImageWithCodeToAnswerOption(optionDiv);
  };
  toolbar.appendChild(imageBtn);
  
  let eqBtn = document.createElement("button");
  eqBtn.textContent = "Eq";
  eqBtn.title = "Insert Equation Element";
  eqBtn.style.marginRight = "4px";
  // When clicked, we set the main text container as the active text box.
  eqBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    activeTextBox = textContainer;
    showEquationModal();
  });
  toolbar.appendChild(eqBtn);
  
  // New: Add Text Box button.
  let textBoxBtn = document.createElement("button");
  textBoxBtn.textContent = "Add Text Box";
  textBoxBtn.onclick = function(e) {
    e.stopPropagation();
    addTextBoxToAnswerOption(optionDiv);
  };
  toolbar.appendChild(textBoxBtn);
  
  let delBtnToolbar = document.createElement("button");
  delBtnToolbar.textContent = "Delete";
  delBtnToolbar.className = "delete-btn";
  delBtnToolbar.style.marginLeft = "5px";
  delBtnToolbar.addEventListener("click", function(e) {
    e.stopPropagation();
    optionDiv.remove();
  });
  toolbar.appendChild(delBtnToolbar);
  
  // Append the toolbar (non‑editable) to the overall container.
  optionDiv.appendChild(toolbar);
  
  // Create a separate editable text container for the answer option text.
  let textContainer = document.createElement("div");
  textContainer.className = "option-text";
  textContainer.contentEditable = true;
  textContainer.innerHTML = "Enter answer option (you may use {variable})";
  textContainer.style.outline = "none"; // Optional: remove default focus outline
  textContainer.addEventListener('click', function(e) {
    activeTextBox = textContainer;
    e.stopPropagation();
  });
  
  // Append the text container.
  optionDiv.appendChild(textContainer);
  
  container.appendChild(optionDiv);
}


function addTextBoxToAnswerOption(parent) {
  // Ensure the parent (MC option container) is relatively positioned
  parent.style.position = "relative";
  
  // Compute safe zone using your change: toolbar.offsetHeight - 45
  let safeTop = 0;
  let toolbar = parent.querySelector(".mc-option-toolbar");
  if (toolbar) {
    safeTop = toolbar.offsetHeight - 45;
  }
  
  // Create the container for the extra text box using relative positioning.
  let container = document.createElement("div");
  container.className = "draggable-text-box";
  container.style.position = "relative"; // in normal flow
  container.style.margin = "10px 0";
  container.style.width = "200px";
  container.style.minHeight = "50px";
  container.style.border = "1px dashed #ccc";
  container.style.background = "#fff";
  
  // Create the inner toolbar.
  let controls = document.createElement("div");
  controls.className = "answer-text-toolbar";
  controls.style.display = "flex";
  controls.style.alignItems = "center";
  controls.style.marginBottom = "3px";
  controls.addEventListener("click", function(e) {
    e.stopPropagation();
  });
  
  // Create the drag handle.
  let dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.innerHTML = "&#9776;";
  dragHandle.style.cursor = "move";
  dragHandle.style.background = "#ccc";
  dragHandle.style.padding = "2px 4px";
  controls.appendChild(dragHandle);
  
  // Equation button.
  let eqBtn = document.createElement("button");
  eqBtn.innerHTML = "Eq";
  eqBtn.title = "Insert Equation Element";
  eqBtn.style.marginRight = "4px";
  eqBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    activeTextBox = textArea;
    showEquationModal();
  });
  controls.appendChild(eqBtn);
  
  // Text Code button.
  let textCodeBtn = document.createElement("button");
  textCodeBtn.innerHTML = "Text Code";
  textCodeBtn.title = "Insert Text With Code (LaTeX)";
  textCodeBtn.style.marginRight = "4px";
  textCodeBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    activeTextBox = textArea;
    showTextCodeModal();
  });
  controls.appendChild(textCodeBtn);
  
  // Delete button – removes the entire text box container.
  let delBtn = document.createElement("button");
  delBtn.innerHTML = "Delete";
  delBtn.title = "Delete this text box";
  delBtn.style.marginLeft = "auto";
  delBtn.style.fontSize = "10px";
  delBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    container.remove();
  });
  controls.appendChild(delBtn);
  
  container.appendChild(controls);
  
  // Create the editable text area.
  let textArea = document.createElement("div");
  textArea.className = "text-box";
  textArea.contentEditable = true;
  textArea.innerHTML = "Type here... (use {variable} notation)";
  textArea.setAttribute("data-original-text", textArea.innerHTML);
  textArea.setAttribute("data-mode", "manual");
  textArea.style.marginLeft = "25px"; // so text doesn't cover the drag handle
  textArea.style.outline = "none";
  textArea.style.overflow = "hidden";
  textArea.style.height = "auto";
  textArea.addEventListener("click", function(e) {
    activeElement = container;
    activeTextBox = textArea;
    e.stopPropagation();
  });
  textArea.addEventListener("input", function() {
    textArea.style.height = "auto";
    textArea.style.height = textArea.scrollHeight + "px";
    updateVariables();
  });
  container.appendChild(textArea);
  
  // Create a resize handle (positioned absolutely within the container).
  let resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  container.appendChild(resizeHandle);
  
  // DRAG: update container margins for dragging within parent's boundaries.
  let isDragging = false;
  let dragStartX, dragStartY, origMarginLeft, origMarginTop;
  
  dragHandle.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    origMarginLeft = parseInt(window.getComputedStyle(container).marginLeft) || 0;
    origMarginTop = parseInt(window.getComputedStyle(container).marginTop) || 0;
    
    // Get parent's current width and height via its bounding rectangle.
    var parentRect = parent.getBoundingClientRect();
    var elemWidth = container.offsetWidth;
    var elemHeight = container.offsetHeight;
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    
    function onMouseMove(e) {
      if (!isDragging) return;
      let dx = e.clientX - dragStartX;
      let dy = e.clientY - dragStartY;
      
      // Compute new margins.
      let newLeft = origMarginLeft + dx;
      let newTop = origMarginTop + dy;
      
      // Clamp newLeft to be between 0 and parent's width - element's width.
      newLeft = Math.max(0, Math.min(newLeft, parentRect.width - elemWidth));
      // Clamp newTop so it does not go above safeTop and stays within parent's height.
      newTop = Math.max(safeTop, Math.min(newTop, parentRect.height - elemHeight));
      
      container.style.marginLeft = newLeft + "px";
      container.style.marginTop = newTop + "px";
    }
    
    function onMouseUp() {
      isDragging = false;
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      
      // After dragging, update parent's size so it exactly encloses all its draggable children.
      let maxRight = 0, maxBottom = 0;
      parent.querySelectorAll(".draggable-text-box, .draggable-answer-image").forEach(function(child) {
        let childRect = child.getBoundingClientRect();
        let parentRectNow = parent.getBoundingClientRect();
        let rightEdge = childRect.right - parentRectNow.left;
        let bottomEdge = childRect.bottom - parentRectNow.top;
        if (rightEdge > maxRight) { maxRight = rightEdge; }
        if (bottomEdge > maxBottom) { maxBottom = bottomEdge; }
      });
      parent.style.width = maxRight + "px";
      parent.style.height = maxBottom + "px";
    }
  });
  
  // RESIZE: update container’s width and height on drag of the resize handle.
  resizeHandle.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    let startX = e.clientX, startY = e.clientY;
    let startWidth = container.offsetWidth;
    let startHeight = container.offsetHeight;
    function onMouseMove(e) {
      let newWidth = startWidth + (e.clientX - startX);
      let newHeight = startHeight + (e.clientY - startY);
      if (newWidth > 50) container.style.width = newWidth + "px";
      if (newHeight > 20) container.style.height = newHeight + "px";
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  parent.appendChild(container);
}



function addGraphToAnswerOption(parent) {
let xInterval = prompt("Enter x-axis interval for answer graph:", "1");
let yInterval = prompt("Enter y-axis interval for answer graph:", "1");
let xLabel = prompt("Enter x-axis label for answer graph:", "X");
let yLabel = prompt("Enter y-axis label for answer graph:", "Y");
let fontSizeInput = prompt("Enter graph font size in px for answer graph (default 12):", "12");
let graphFontSize = parseInt(fontSizeInput);
if (isNaN(graphFontSize)) graphFontSize = 12;
xInterval = parseFloat(xInterval);
yInterval = parseFloat(yInterval);
if (isNaN(xInterval) || isNaN(yInterval)) {
  alert("Invalid interval value for answer graph.");
  return;
}
let eq = prompt("Enter equation to graph for answer option (e.g., y = {a}*{x} + 10), or leave blank:");
let wrapper = document.createElement("div");
wrapper.className = "answer-graph";
wrapper.contentEditable = false;
wrapper.setAttribute("data-xInterval", xInterval);
wrapper.setAttribute("data-yInterval", yInterval);
wrapper.setAttribute("data-xLabel", xLabel);
wrapper.setAttribute("data-yLabel", yLabel);
wrapper.setAttribute("data-fontSize", graphFontSize);
wrapper.setAttribute("data-equation", eq);
wrapper.setAttribute("data-width", "300");
wrapper.setAttribute("data-height", "300");
let svgContent = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, graphFontSize, eq);
wrapper.innerHTML = svgContent;
let editBtn = document.createElement("button");
editBtn.textContent = "Edit Graph";
editBtn.className = "edit-graph";
editBtn.style.fontSize = "10px";
editBtn.style.pointerEvents = "auto";
editBtn.onclick = function(e) {
  e.stopPropagation();
  editGraphInAnswerOption(wrapper);
};
wrapper.appendChild(editBtn);
let deleteBtn = document.createElement("button");
deleteBtn.textContent = "Delete Graph";
deleteBtn.className = "delete-graph";
deleteBtn.style.fontSize = "10px";
deleteBtn.style.pointerEvents = "auto";
deleteBtn.onclick = function(e) {
  e.stopPropagation();
  wrapper.remove();
};
wrapper.appendChild(deleteBtn);
parent.appendChild(wrapper);
}

function updateGraphInAnswerOption(wrapper, computedVars) {
let xInterval = wrapper.getAttribute("data-xInterval");
let yInterval = wrapper.getAttribute("data-yInterval");
let xLabel = wrapper.getAttribute("data-xLabel");
let yLabel = wrapper.getAttribute("data-yLabel");
let fontSize = wrapper.getAttribute("data-fontSize");
let rawEquation = wrapper.getAttribute("data-equation");
let width = wrapper.getAttribute("data-width");
let height = wrapper.getAttribute("data-height");

let substitutedEquation = substituteValue(rawEquation, computedVars);
substitutedEquation = substitutedEquation.replace(/\{x\}/g, "x");

let newSVG = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, fontSize, substitutedEquation);
newSVG = newSVG.replace(/<svg /, `<svg width="${width}" height="${height}" `);

let editBtn = wrapper.querySelector("button.edit-graph");
let deleteBtn = wrapper.querySelector("button.delete-graph");

wrapper.innerHTML = newSVG;
if (editBtn) wrapper.appendChild(editBtn);
if (deleteBtn) wrapper.appendChild(deleteBtn);
}

function editGraphInAnswerOption(wrapper) {
let currentXInterval = wrapper.getAttribute("data-xInterval") || "1";
let currentYInterval = wrapper.getAttribute("data-yInterval") || "1";
let currentXLabel = wrapper.getAttribute("data-xLabel") || "X";
let currentYLabel = wrapper.getAttribute("data-yLabel") || "Y";
let currentFontSize = wrapper.getAttribute("data-fontSize") || "12";
let currentEquation = wrapper.getAttribute("data-equation") || "";
let currentWidth = wrapper.getAttribute("data-width") || "300";
let currentHeight = wrapper.getAttribute("data-height") || "300";

let newXInterval = prompt("Enter x-axis interval:", currentXInterval);
let newYInterval = prompt("Enter y-axis interval:", currentYInterval);
let newXLabel = prompt("Enter x-axis label:", currentXLabel);
let newYLabel = prompt("Enter y-axis label:", currentYLabel);
let newFontSize = prompt("Enter graph font size in px:", currentFontSize);
let newEquation = prompt("Enter equation to graph (e.g., y = {a}*{x} + 10), or leave blank:", currentEquation);
let newWidth = prompt("Enter graph width in px:", currentWidth);
let newHeight = prompt("Enter graph height in px:", currentHeight);

wrapper.setAttribute("data-xInterval", newXInterval);
wrapper.setAttribute("data-yInterval", newYInterval);
wrapper.setAttribute("data-xLabel", newXLabel);
wrapper.setAttribute("data-yLabel", newYLabel);
wrapper.setAttribute("data-fontSize", newFontSize);
wrapper.setAttribute("data-equation", newEquation);
wrapper.setAttribute("data-width", newWidth);
wrapper.setAttribute("data-height", newHeight);

if (newEquation && newEquation.trim() !== "") {
  newEquation = newEquation.replace(/\{x\}/g, "x");
}
let newSVG = generateGraphSVG(newXInterval, newYInterval, newXLabel, newYLabel, newFontSize, newEquation);
newSVG = newSVG.replace(/<svg /, `<svg width="${newWidth}" height="${newHeight}" `);

let editBtn = wrapper.querySelector("button");
wrapper.innerHTML = newSVG;
if (editBtn) {
  wrapper.appendChild(editBtn);
}
}

function addTableToAnswerOption(parent) {
  let rows = prompt("Enter number of rows for answer table:", "3");
  let cols = prompt("Enter number of columns for answer table:", "3");
  rows = parseInt(rows);
  cols = parseInt(cols);
  if (isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) {
    alert("Invalid input for rows or columns in answer table.");
    return;
  }
  // Create table without forcing width:100%; let the resizer determine the proper sizing.
  let tableHTML = "<table style='border-collapse: collapse;'>";
  for (let i = 0; i < rows; i++) {
    tableHTML += "<tr>";
    for (let j = 0; j < cols; j++) {
      tableHTML += "<td contenteditable='true' style='border: 1px solid black; padding: 5px;'> </td>";
    }
    tableHTML += "</tr>";
  }
  tableHTML += "</table>";
  
  // Wrap the table in a container.
  let wrapper = document.createElement("div");
  wrapper.className = "answer-table";
  wrapper.contentEditable = false;
  
  wrapper.innerHTML = tableHTML;
  
  // Add a delete button for the table.
  let deleteBtn = document.createElement("button");
  deleteBtn.textContent = "Delete Table";
  deleteBtn.className = "delete-table";
  deleteBtn.style.fontSize = "10px";
  deleteBtn.style.pointerEvents = "auto";
  deleteBtn.onclick = function(e) {
    e.stopPropagation();
    wrapper.remove();
  };
  wrapper.appendChild(deleteBtn);
  
  // Append the wrapper to the answer option container.
  parent.appendChild(wrapper);
  
  // Make the table resizable and attach cell click handlers,
  // just as in the problem image.
  let tableElement = wrapper.querySelector("table");
  if (tableElement) {
    makeTableResizable(tableElement);
    attachCellClickHandlers(tableElement);
  }
}



function generateAnswerImages(computedVars) {
  const answerType = document.getElementById("answer-type").value;
  let container = document.createElement("div");
  container.className = "answer-images";
  container.style.marginTop = "10px";
  
  if (answerType === "box") {
    let correctAns = substituteValue(document.getElementById("correct-answer").value, computedVars);
    let labelText = substituteValue(document.getElementById("label-text").value, computedVars);
    let labelPosition = document.getElementById("label-position").value;
    
    let fullAnswer = "";
    if (labelText) {
      if (labelPosition === "before") {
        fullAnswer = labelText + " " + correctAns;
      } else if (labelPosition === "after") {
        fullAnswer = correctAns + " " + labelText;
      } else {
        fullAnswer = correctAns;
      }
    } else {
      fullAnswer = correctAns;
    }
    let minimalAnswer = correctAns;
    
    let fullDiv = document.createElement("div");
    fullDiv.id = "answer-full";
    fullDiv.innerHTML = fullAnswer;
    fullDiv.style.border = "1px solid black";
    fullDiv.style.display = "inline-block";
    fullDiv.style.padding = "5px";
    fullDiv.style.marginRight = "10px";
    
    let minimalDiv = document.createElement("div");
    minimalDiv.id = "answer-minimal";
    minimalDiv.innerHTML = minimalAnswer;
    minimalDiv.style.border = "1px solid black";
    minimalDiv.style.display = "inline-block";
    minimalDiv.style.padding = "5px";
    
    container.appendChild(fullDiv);
    container.appendChild(minimalDiv);
  
  } else if (answerType === "multiple" || answerType === "multi-select") {
    // Use the same computed ordering as in generateAnswerQuiz
    let options = window.currentAnswerOptions || computeAnswerOptions(computedVars);
    let correctLetters = getCorrectAnswerLettersFromOptions(options);
    let answerDiv = document.createElement("div");
    answerDiv.id = "answer-correct";
    answerDiv.innerHTML = `<div style="font-size:48px; font-weight:bold; text-align:center;">${correctLetters}</div>`;
    container.appendChild(answerDiv);
  
  } else if (answerType === "grid") {
    // For grid, generate the grid with correct answers pre‑selected.
    let gridQuiz = generateGridQuiz(computedVars, true);
    container.appendChild(gridQuiz);
  }
  
  return container;
}

/******** Save Images ********/
function saveProblemImages() {
  // Save the preview area (problem image and interactive quiz)
  html2canvas(document.getElementById("preview-area")).then(function(canvas) {
    let link1 = document.createElement('a');
    link1.download = "problem_with_answer.png";
    link1.href = canvas.toDataURL();
    link1.click();
  });
  
  // Save the full answer image separately.
  let fullElem = document.getElementById("answer-full");
  if (fullElem) {
    html2canvas(fullElem).then(function(canvas) {
      let link2 = document.createElement('a');
      link2.download = "answer_full.png";
      link2.href = canvas.toDataURL();
      link2.click();
    });
  }
  
  // Save the minimal answer image separately.
  let minimalElem = document.getElementById("answer-minimal");
  if (minimalElem) {
    html2canvas(minimalElem).then(function(canvas) {
      let link3 = document.createElement('a');
      link3.download = "answer_minimal.png";
      link3.href = canvas.toDataURL();
      link3.click();
    });
  }
}

function makeAroundTheRoomActivity() {
  let numProblems = parseInt(prompt("How many problems do you want to use?"));
  if (isNaN(numProblems) || numProblems < 1) {
    alert("Please enter a valid number.");
    return;
  }

  // Arrays to store canvases for problem and answer images.
  let problemImages = [];
  let answerImages = [];

  // Function to capture the current preview and answer images.
  function captureImages() {
    return new Promise((resolve) => {
      // Update the preview area
      previewProblemInteractive();
      // Short delay to allow preview update
      setTimeout(() => {
        html2canvas(document.getElementById("preview-area")).then(problemCanvas => {
          html2canvas(document.getElementById("answer-image-content")).then(answerCanvas => {
            problemImages.push(problemCanvas);
            answerImages.push(answerCanvas);
            resolve();
          });
        });
      }, 500);
    });
  }

  // Capture images for all problems sequentially.
  async function captureAll() {
    for (let i = 0; i < numProblems; i++) {
      updateVariables();
      await captureImages();
    }
  }

  captureAll().then(() => {
    // Build the Around the Room Activity layout.
    let activityContainer = document.createElement("div");
    activityContainer.id = "activityContainer";
    activityContainer.style.width = "650px";
    activityContainer.style.margin = "auto";

    // For each problem, create a page with two halves:
    // Top half: answer image from the previous problem (for the first page, use the last problem’s answer)
    // Bottom half: problem image from the current problem.
    for (let i = 0; i < numProblems; i++) {
      let page = document.createElement("div");
      page.className = "activity-page";

      let topHalf = document.createElement("div");
      topHalf.style.height = "50%";
      topHalf.style.borderBottom = "1px dashed gray";
      topHalf.style.display = "flex";
      topHalf.style.justifyContent = "center";
      topHalf.style.alignItems = "center";

      let bottomHalf = document.createElement("div");
      bottomHalf.style.height = "50%";
      bottomHalf.style.display = "flex";
      bottomHalf.style.justifyContent = "center";
      bottomHalf.style.alignItems = "center";

      bottomHalf.appendChild(problemImages[i]);

      let answerIndex = (i === 0) ? numProblems - 1 : i - 1;
      topHalf.appendChild(answerImages[answerIndex]);

      page.appendChild(topHalf);
      page.appendChild(bottomHalf);
      activityContainer.appendChild(page);
    }

    // Open a new window and display the activity.
    let activityWindow = window.open("", "ActivityWindow");
    activityWindow.document.body.innerHTML = "";
    activityWindow.document.body.appendChild(activityContainer);
  });
}

/******** Global Click Handler to Clear Selection ********/
document.addEventListener("click", function(e) {
  if (e.target.tagName !== "TD" && e.target.tagName !== "TH") {
    if (selectedCell) {
      selectedCell.classList.remove("selected-cell");
      selectedCell = null;
    }
  }
});
const canvas = document.getElementById("problem-canvas");

// Add this just before cyclingIndex is incremented in your click handler

/******** Initial Setup ********/
// Global variables for cycling tracking
// Global variables for click tracking and cycling:
// Global variables for cycling and click tracking:
let isDragging = false;
let cyclingIndex = 0;
let lastClickTime = 0;
let lastClickX = 0;
let lastClickY = 0;
const doubleClickThreshold = 300; // milliseconds
const clickTolerance = 5;            // pixels

document.getElementById("problem-canvas").addEventListener(
  "click",
  function(e) {
    // Skip if we should ignore this click (it was the result of a drag operation)
    if (ignoreNextClick) {
      ignoreNextClick = false;
      return;
    }
    
    // Skip if the click is on controls that should handle their own events
    if (
      e.target.closest('.fill-display') ||
      e.target.closest('.stroke-display') ||
      (e.target.closest('.circle-container') && e.target.tagName.toLowerCase() === 'path')
    ) {
      return;
    }
    
    // If a drag occurred, skip cycling
    if (isDragging) return;
    
    const currentTime = Date.now();
    const clickX = e.clientX;
    const clickY = e.clientY;
    
    // Reset cycling index if the click is not near the previous one
    if (
      Math.abs(clickX - lastClickX) > clickTolerance ||
      Math.abs(clickY - lastClickY) > clickTolerance ||
      (currentTime - lastClickTime) > doubleClickThreshold
    ) {
      cyclingIndex = 0;
    }
    
    lastClickX = clickX;
    lastClickY = clickY;
    lastClickTime = currentTime;
    
    // Get all elements under the click point
    const allElements = document.elementsFromPoint(clickX, clickY);
    // Filter only the draggable elements
    const draggableElements = allElements.filter(el =>
      el.classList.contains("draggable-element")
    );
    
    if (draggableElements.length > 0) {
      // If we have a previously active element, restore its z-index
      if (activeElement && activeElement !== draggableElements[cyclingIndex]) {
        restoreElementZIndex(activeElement);
      }
      
      // Hide controls and endpoints on all elements
      document.querySelectorAll(".draggable-element").forEach(el => {
        const ctrl = el.querySelector(".element-controls");
        if (ctrl) { ctrl.style.display = "none"; }
        const svg = el.querySelector("svg");
        if (svg && svg.currentLine) {
          if (svg.endpoint1) svg.endpoint1.style.display = "none";
          if (svg.endpoint2) svg.endpoint2.style.display = "none";
        }
      });
      
      // Cycle to the next element
      cyclingIndex = (cyclingIndex + 1) % draggableElements.length;
      activeElement = draggableElements[cyclingIndex];
      
      // Raise the active element above all others
      raiseElementTemporarily(activeElement);
      
      // Immediately highlight and show controls for the active element
      highlightActiveElement();
      const controls = activeElement.querySelector(".element-controls");
      if (controls) { 
        controls.style.display = "flex"; 
      }
      
      // If there's a text box inside, set it as active
      const textBox = activeElement.querySelector(".text-box");
      if (textBox) { activeTextBox = textBox; }
      
      // For line elements, show their endpoints
      const svg = activeElement.querySelector("svg");
      if (svg && svg.currentLine) {
        if (svg.endpoint1) svg.endpoint1.style.display = "block";
        if (svg.endpoint2) svg.endpoint2.style.display = "block";
      }
      
      e.stopPropagation();
    } else {
      cyclingIndex = 0;
      updateVariables();
    }
  },
  true // Use capture phase
);


document.addEventListener("click", function(e) {
  // If the clicked target is not inside any draggable element and we have an active element...
  if (!e.target.closest(".draggable-element") && activeElement) {
    // Restore the original z-index
    restoreElementZIndex(activeElement);
    
    // Remove highlighting and blur the element to remove the browser's default focus outline
    activeElement.style.outline = "";
    activeElement.blur();
    activeElement = null;
  }
});


document.getElementById("problem-canvas").addEventListener("click", function(e) {
  // If the click is directly on the canvas background (not on a draggable element)
  if (e.target === this) {
    if (activeElement) {
      restoreElementZIndex(activeElement);
      activeElement.style.outline = "";
      activeElement.blur();
      activeElement = null;
    }
  }
});



updateVariables();
updateAnswerOptions();

// Create the marker definitions when the page loads
// Create the marker definitions when the page loads
document.addEventListener("DOMContentLoaded", function() {
  // Add a click handler to all element controls
  function setupControlsClickHandlers() {
    document.querySelectorAll('.element-controls').forEach(toolbar => {
      toolbar.addEventListener('click', function(e) {
        // Stop event propagation to prevent the canvas handler from running
        e.stopPropagation();
        
        // Find the parent element (the draggable container)
        const container = this.closest('.draggable-element');
        if (container) {
          // Make this the active element
          activeElement = container;
          // Raise it temporarily
          raiseElementTemporarily(container);
        }
      });
    });
  }
  
  // Call the setup function
  setupControlsClickHandlers();
  
  // The rest of your existing DOMContentLoaded code
  createSVGMarkerDefs();
 
  updateLayerButtons();
  
  // Observer to handle dynamically added controls
  const observer = new MutationObserver(function(mutations) {
    setupControlsClickHandlers();
  });
  
  observer.observe(document.getElementById('problem-canvas'), { 
    childList: true,
    subtree: true 
  });
});


</script>
  
</body>
</html>
