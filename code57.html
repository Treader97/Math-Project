<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Bulk Math Problem Creator – Combined Version</title>
  <!-- Include html2canvas for saving images and preview rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.6.4/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fraction.js@4.0.12/fraction.min.js"></script>

  <script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    /* Basic resets */
    * { box-sizing: border-box; }
    body, html {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
    /* Grid layout */
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto auto auto;
      grid-template-areas:
        "problem-image variables"
        "answer preview"
        "answer-image answer-image";
      gap: 5px;
      padding: 5px;
    }
    .section {
      border: 1px solid #ccc;
      padding: 5px;
      overflow: auto;
    }
    /* Grid areas */
    #problem-image { grid-area: problem-image; }
    #variables    { grid-area: variables; }
    #answer       { grid-area: answer; }
    #preview      { grid-area: preview; }
    #answer-image { grid-area: answer-image; }
    /* Toolbar and size controls */
    .toolbar button, .toolbar select, .toolbar input {
      margin: 2px 5px 2px 0;
    }
    .size-controls { margin: 5px 0; font-size: 13px; }
    /* Problem canvas styling */
    #problem-canvas {
      position: relative;
      width: 600px;
      height: 300px;
      border: 1px solid #ddd;
      /* NEW: Make background white */
      background-color: white;
    }
    /* Draggable element container */
    .draggable-element {
  position: relative; /* So the toolbar can position absolutely within this container */
}
.element-controls {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;       /* So the toolbar spans the top of the container */
  z-index: 9999;     /* Big number so it stays above shapes or text */
  display: none;     /* stays hidden by default until clicked */
  background: #f0f0f0;
  padding: 2px;
  font-size: 12px;
  align-items: center;
}
    .drag-handle {
      cursor: move;
      background: #ccc;
      padding: 2px 4px;
      margin-right: 4px;
    }
    .layer-button, .adjust-button, .delete-button {
      margin-right: 4px;
      cursor: pointer;
    }
    /* Text box styling */
    .text-box {
  direction: ltr;
  unicode-bidi: normal;
  text-align: left;
  min-width: 80px;
  min-height: 30px;
  padding: 2px;
  border: none;
  outline: none;
}

.triangle-container {
    min-width: 150px;
    min-height: 170px; /* Height + toolbar space */
}

.triangle-point {
    z-index: 10;
}

    /* Resize handle styling */
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: blue;
      right: 0;
      bottom: 0;
      cursor: se-resize;
      z-index: 10;
    }
    /* Preview area styling */
    .preview-area {
      border: 1px solid #ddd;
      padding: 10px;
      background-color: #fff;
      display: inline-block;
      pointer-events: none;
    }
    /* Answer image section styling */
    #answer-image {
      border: 1px solid #ddd;
      padding: 10px;
      background-color: #fff;
      width: 600px;
    }
    #answer-image-content {
      font-size: 24px;
      text-align: center;
      padding: 20px;
      width: 600px;
      height: 100px;
    }
    /* Variables panel styling */
    .variable-item {
      margin-bottom: 10px;
      border-bottom: 1px dashed #ccc;
      padding-bottom: 5px;
    }
    .fraction {
      display: inline-block;
      text-align: center;
      vertical-align: middle;
      margin: 0 2px;
    }
    .fraction .num {
      display: block;
      border-bottom: 1px solid;
      padding: 0 2px;
    }
    .fraction .den {
      display: block;
      padding: 0 2px;
    }
    /* NEW: Style for a selected table cell */
    .selected-cell {
      outline: 2px dashed red;
    }
    /* NEW: Variable Options Toolbar */
    #variable-options {
      margin-bottom: 5px;
    }
    #variable-options button {
      margin-right: 5px;
      font-size: 12px;
    }

    /* === New Styles for Multiple Choice Answer Options === */
    .mc-answer-option {
      border: 1px solid #ccc;
      padding: 5px;
      margin-bottom: 5px;
      min-height: 40px;
      position: relative;
    }
    .mc-option-toolbar {
      background: #f9f9f9;
      border-bottom: 1px solid #ddd;
      padding: 2px;
      margin-bottom: 3px;
    }
    .mc-option-toolbar button {
      margin-right: 5px;
      font-size: 12px;
    }
    /* New Styles for Equation Modal */
    #equationModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background: white;
      border: 1px solid #ccc;
      padding: 10px;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
    }
    #equationModal h3 {
      margin-top: 0;
    }
    #equationModal button {
      margin: 2px;
      font-size: 12px;
    }

    .division {
      display: inline-block;
      vertical-align: middle;
    }

    .fraction, .sqrt, .nth-root, .division {
      /* Ensure these elements align well with text */
      vertical-align: middle;
    }
    .grid-expression {
      min-height: 40px;
      border: 1px solid #ccc;
      padding: 4px;
      margin-bottom: 4px;
      outline: none;
    }
    .mjx-tex {
  display: none !important;
}

.triangle-toolbar {
  display: flex; /* Remove !important */
  align-items: center;
  background: #f0f0f0;
  padding: 2px;
  font-size: 12px;
  height: 20px;
  box-sizing: border-box;
}
.triangle-content {
  position: absolute;
  top: 20px; /* leave space for the toolbar */
  left: 0;
  width: 100%;
  bottom: 0;
  overflow: hidden;
}

/* Circle container styling */
.circle-container {
  min-width: 150px;
  min-height: 170px; /* Height + toolbar space */
}

/* Circle content (SVG container) */
.circle-content {
  position: absolute;
  top: 20px; /* Leave space for the toolbar */
  left: 0;
  width: 100%;
  bottom: 0;
  overflow: hidden;
}

/* Center marker styling */
.circle-center {
  z-index: 10; /* Ensure it’s above the SVG */
}

/* Toolbar styling (reuse existing triangle-toolbar styles where possible) */
.circle-toolbar {
  display: flex;
  align-items: center;
  background: #f0f0f0;
  padding: 2px;
  font-size: 12px;
  height: 20px;
  box-sizing: border-box;
}

/* Ensure dropdowns and input fit nicely in the toolbar */
.circle-toolbar select,
.circle-toolbar input[type="number"] {
  height: 18px; /* Fit within 20px toolbar height */
  padding: 0 2px;
  border: 1px solid #ccc;
  background: #fff;
}

/* Optional: Adjust toolbar elements for better spacing */
.circle-toolbar .stroke-display,
.circle-toolbar .fill-display {
  width: 20px;
  height: 20px;
  border: 1px solid #ccc;
  cursor: pointer;
}

/* Ensure the SVG scales correctly */
.circle-content svg {
  width: 100%;
  height: 100%;
}


.element-controls {
  z-index: 1000;
  position: relative;
}

.line-container {
  overflow: visible !important;  /* ensure endpoints/toolbar remain clickable */
}
.line-content {
  overflow: visible !important;
}

.draggable-element:focus {
  outline: none !important;
}


  </style>
</head>
<body>
        <!-- Modal overlay for image code input (hidden by default) -->
<div id="modalOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:900;"></div>

<!-- Pie Chart Settings Modal -->
<div id="pieChartModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
      z-index:1000; background:white; border:1px solid #ccc; padding:10px; box-shadow: 2px 2px 8px rgba(0,0,0,0.3);">
  <h3>Pie Chart Settings</h3>
  <label>Total Pieces: <input type="text" id="pie-total-pieces" placeholder="e.g., 8 or {a}"></label><br>
  <label>Shaded Pieces: <input type="text" id="pie-shaded-pieces" placeholder="e.g., 3 or {b}"></label><br>
  <label>Shaded Color: <input type="color" id="pie-shaded-color" value="#ff0000"></label><br>
  <label>Unshaded Color: <input type="color" id="pie-unshaded-color" value="#ffffff"></label><br>
  <button id="pieChartOK">OK</button>
  <button id="pieChartCancel">Cancel</button>
</div>

<!-- Modal for entering/editing image code (hidden by default) -->
<div id="imageCodeModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
      z-index:1000; background:white; border:1px solid #ccc; padding:10px; box-shadow: 2px 2px 8px rgba(0,0,0,0.3);">
  <h3>Enter Image Code</h3>
  <textarea id="imageCodeTextarea" style="width:400px; height:200px;"></textarea><br>
  <button id="imageCodeOK">OK</button>
  <button id="imageCodeCancel">Cancel</button>
</div>
<!-- NEW: Modal for Equation Insertion -->
<!-- NEW: Modal for Equation Insertion -->
<div id="equationModal">
    <h3>Insert Equation Element</h3>
    <div id="equationButtons">
      <button onclick="insertEquationElement('fraction')">Fraction</button>
      <button onclick="insertEquationElement('division')">Division</button>
      <button onclick="insertEquationElement('sqrt')">Square Root</button>
      <button onclick="insertEquationElement('nthroot')">Nth Root</button>
      <button onclick="insertEquationElement('pi')">π</button>
      <button onclick="insertEquationElement('superscript')">Superscript</button>
      <button onclick="insertEquationElement('subscript')">Subscript</button>
    </div>
    <br>
    <button onclick="closeEquationModal()">Close</button>
  </div>
  <!-- NEW: Modal for Text With Code -->
<div id="textCodeModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
     z-index:1000; background:white; border:1px solid #ccc; padding:10px; box-shadow:2px 2px 8px rgba(0,0,0,0.3);">
  <h3>Insert Text With Code</h3>
  <textarea id="textCodeTextarea" style="width:400px; height:150px;" placeholder="Enter LaTeX code here"></textarea><br>
  <button id="textCodeOK">OK</button>
  <button id="textCodeCancel">Cancel</button>
</div>
  <div class="container">
    <!-- Problem Image Section -->
    <div id="problem-image" class="section">
      <h2>Problem Image</h2>
      <div class="toolbar">
        <button onclick="execCmd('bold')"><b>B</b></button>
        <button onclick="execCmd('italic')"><i>I</i></button>
        <button onclick="execCmd('underline')"><u>U</u></button>
        <button onclick="execCmd('superscript')">Sup</button>
        <button onclick="execCmd('subscript')">Sub</button>
        <button onclick="execCmd('justifyLeft')">Left</button>
        <button onclick="execCmd('justifyCenter')">Center</button>
        <button onclick="execCmd('justifyRight')">Right</button>
        <button onclick="addTextBox()">Add Text Box</button>
        <button onclick="addCircle()">Add Circle</button>
        <button onclick="addSemicircle()">Add Semicircle</button>
        <button onclick="addRectangle()">Add Rectangle</button>
        <button onclick="addParallelogram()">Add Parallelogram</button>
        <button onclick="addRectangularPrism()">Add Rectangular Prism</button>
        <button onclick="addTriangle()">Add Triangle</button>
        <button onclick="addPolygon()">Add Polygon</button>
        <button onclick="addLine()">Add Line</button>
        <button onclick="addImageViaModal()">Add Image</button>

	<button onclick="addImageWithCode()">Add Image with Code</button>
        <button onclick="addTable()">Add Table</button>
        <button onclick="addGraph()">Add Graph</button>
        <button onclick="deleteActiveElement()">Delete Selected</button>
        <label for="highlight-color">Highlight Color:</label>
        <input type="color" id="highlight-color" value="#ffff99">
        <button onclick="applyHighlight('row')">Highlight Row</button>
        <button onclick="applyHighlight('column')">Highlight Column</button>
      </div>
      <div class="size-controls">
        Saved Problem Image Size: Width:
        <input type="number" id="problem-width" value="600" style="width:60px;"> px,
        Height: <input type="number" id="problem-height" value="300" style="width:60px;"> px
        <button onclick="updateProblemSize()">Update Size</button>
      </div>
      <div id="problem-canvas"></div>
    </div>
    
    <!-- Variables Section -->
<div id="variables" class="section">
  <h2>Variables</h2>

  <!-- Mode selection toggle -->
  <div id="variable-mode-selection">
    <label>
      <input type="radio" name="variable-mode" value="ui" checked> User Friendly Mode
    </label>
    &nbsp;&nbsp;
    <label>
      <input type="radio" name="variable-mode" value="code"> Code Mode
    </label>
  </div>

  <!-- UI Mode: Your original variable UI -->
  <div id="variable-ui-container">
    <div id="variable-options">
      <button onclick="setVariableFormula('random-int')">Random Integer</button>
      <button onclick="setVariableFormula('random-number')">Random Number</button>
      <button onclick="setVariableFormula('round')">Round</button>
      <button onclick="setVariableFormula('unreduced-fraction')">Unreduced Fraction</button>
      <button onclick="setVariableFormula('improper-fraction')">Reduced Improper Fraction</button>
      <button onclick="setVariableFormula('mixed-number')">Reduced Mixed Number</button>
      <button onclick="setVariableFormula('choose-from-list')">Choose from Word List</button>
      <button onclick="setVariableFormula('choose-from-list-number')">Choose from Number List</button>
      <button onclick="setVariableFormula('arrange-asc')">Arrange Ascending</button>
      <button onclick="setVariableFormula('arrange-desc')">Arrange Descending</button>
    </div>
    <p>
      All text using the <code>{variable}</code> notation is automatically detected.
      You may define its “rule” below.
    </p>
    <button onclick="addVariable()">Add Variable</button>
    <div id="variable-list"></div>
  </div>

  <!-- Code Mode: A single textarea for all variable rules (initially hidden) -->
  <div id="variable-code-container" style="display:none;">
    <div id="variable-code-toolbar">
      <button onclick="setVariableFormula('random-int')">Random Integer</button>
      <button onclick="setVariableFormula('random-number')">Random Number</button>
      <button onclick="setVariableFormula('round')">Round</button>
      <button onclick="setVariableFormula('unreduced-fraction')">Unreduced Fraction</button>
      <button onclick="setVariableFormula('improper-fraction')">Reduced Improper Fraction</button>
      <button onclick="setVariableFormula('mixed-number')">Reduced Mixed Number</button>
      <button onclick="setVariableFormula('choose-from-list')">Choose from Word List</button>
      <button onclick="setVariableFormula('choose-from-list-number')">Choose from Number List</button>
      <button onclick="setVariableFormula('arrange-asc')">Arrange Ascending</button>
      <button onclick="setVariableFormula('arrange-desc')">Arrange Descending</button>
    </div>
    <textarea id="variable-code" placeholder="For example:
a = randomInt(1,10)
b = randomNumber(1,10,2)
c = a + b"></textarea>
  </div>

  <br>
  <button onclick="updateVariables()">Update Variables</button>
</div>
    
    <!-- Answer Configuration Section -->
    <!-- Answer Configuration Section -->
    <div id="answer" class="section">
        <h2>Answer Configuration</h2>
        <label for="answer-type">Select Answer Type:</label>
        <select id="answer-type" onchange="updateAnswerOptions()">
          <option value="box">Answer Box</option>
          <option value="multiple">Multiple Choice</option>
          <option value="multi-select">Multi-Select</option>
          <option value="grid">Single Select Grid</option>
        </select>
        
        <!-- Answer Box Options -->
        <div id="box-options" class="answer-config">
          <h3>Answer Box Options</h3>
          <label for="label-position">Label Position:</label>
          <select id="label-position">
            <option value="none">No Label</option>
            <option value="before">Label Before</option>
            <option value="after">Label After</option>
          </select>
          <input type="text" id="label-text" placeholder="Enter label text (e.g., cm, in)">
          <br><br>
          <label for="answer-rule">Answer Rule:</label>
          <select id="answer-rule">
            <option value="exact">Exact Match</option>
            <option value="equiv">Equivalent Answer</option>
          </select>
          <input type="text" id="correct-answer" placeholder="Enter correct answer (you may use {variable})">
        </div>
        
        <!-- Multiple Choice / Multi-Select Options -->
        <div id="multiple-options" class="answer-config" style="display:none;">
          <h3>Multiple Choice / Multi-Select Options</h3>
          <div id="mc-global-settings">
            <label>
              Total Options: 
              <input type="number" id="mc-total-options" value="5" min="1">
            </label>
            <label style="margin-left:10px;">
              Correct Options Range: 
              <input type="number" id="mc-correct-min" value="2" min="0"> 
              - 
              <input type="number" id="mc-correct-max" value="4" min="0">
            </label>
          </div>
          <div id="mc-options">
            <h4>Correct Answers</h4>
            <div id="mc-correct"></div>
            <button onclick="addMCOption('correct')">Add Correct Answer</button>
            <h4>Incorrect Answers</h4>
            <div id="mc-incorrect"></div>
            <button onclick="addMCOption('incorrect')">Add Incorrect Answer</button>
          </div>
        </div>
        
        <!-- Begin Grid Options Panel -->
        <div id="grid-options" class="answer-config" style="display:none;">
          <h3>Single Select Grid Options</h3>
          
          <!-- Input for number of rows -->
          <label for="grid-rows">Number of Rows:</label>
          <input type="number" id="grid-rows" value="3" min="1">
          <br>
          
          <!-- Input for number of columns -->
          <label for="grid-columns">Number of Columns:</label>
          <input type="number" id="grid-columns" value="3" min="1">
          <br>
          
          <!-- Div for Column Name Inputs -->
          <div id="grid-column-names">
            <h4>Column Names</h4>
            <!-- Column name inputs will be generated here -->
          </div>  <!-- End of grid-column-names -->
          
          <button onclick="updateGridColumnNames()">Update Column Names</button>
          <br>
          
          <!-- Div for Row Expressions -->
          <div id="grid-row-expressions">
            <h4>Row Expressions</h4>
            <!-- Row expression entries will appear here -->
          </div>  <!-- End of grid-row-expressions -->
          
          <button onclick="addGridRowExpression()">Add Expression</button>
          <br>
  <!-- New shuffle checkbox -->
  <label>
    <input type="checkbox" id="grid-shuffle">
    Shuffle Expressions
  </label>
        </div>  <!-- End of grid-options panel -->
        <!-- End Grid Options Panel -->
        
      </div>
      

    
    <!-- Preview Section -->
   <div id="preview" class="section">
  <h2>Preview</h2>
  <button onclick="previewProblemInteractive()">Preview Problem</button>
  <div id="preview-area" class="preview-area"></div>
</div>

    
    <!-- Answer Image Section -->
    <!-- Answer Image Section -->
<div id="answer-image" class="section">
  <h2>Answer Image</h2>
  <div class="size-controls">
    Saved Answer Image Size: Width:
    <input type="number" id="answer-width" value="600" style="width:60px;"> px,
    Height: <input type="number" id="answer-height" value="100" style="width:60px;"> px
    <button onclick="updateSavedAnswerSize()">Update Saved Size</button>
  </div>
  <div id="answer-image-content"></div>
  <br>
  <button onclick="saveProblemImages()">Save Problem Images</button>
<br>
<button onclick="makeAroundTheRoomActivity()">Make Around the Room Activity</button>
</div>
<script>

    // ===== Dependency Graph Globals =====
  var varDefinitions = {};    // Holds each variable’s definition (e.g., { a: "5", b: "a+5" })
  var dependencyGraph = {};   // Maps a variable to a set of variables that depend on it
  var computedValues = {};    // Holds the current computed value for each variable
  
      /******** Global Variables ********/
      let savedProblemWidth = 600, savedProblemHeight = 300;
      let savedAnswerWidth = 600, savedAnswerHeight = 100;
      let nextElementOffset = 10;
      let activeElement = null, activeTextBox = null;
      let globalTopZ = 100;  // or any starting number you like
      let ignoreNextClick = false;
      const problemCanvas = document.getElementById("problem-canvas");
      
       
      // NEW: Global variable to hold the currently focused formula input
      let currentFormulaInput = null;
   
      

  // ===== Dependency Extraction =====
  function extractDependencies(expression) {
    // Find all word tokens (e.g., a, b, myVar, etc.)
    let tokens = expression.match(/\b[a-zA-Z]\w*\b/g) || [];
    // Filter out tokens that are known function names or reserved words.
    const reserved = new Set(["Math", "randomInt", "randomNumber", "reduceFraction", "gcd", "round", "unreducedfraction", "mixedFraction"]);
    return tokens.filter(token => !reserved.has(token));
  }
  
  // ===== Build Dependency Graph =====
  function buildDependencyGraph() {
    dependencyGraph = {};
    // Initialize a dependency set for every variable defined.
    for (let varName in varDefinitions) {
      dependencyGraph[varName] = new Set();
    }
    // For each variable, parse its expression and add dependency edges.
    for (let varName in varDefinitions) {
      let expr = varDefinitions[varName];
      let deps = extractDependencies(expr);
      deps.forEach(dep => {
        if (varDefinitions.hasOwnProperty(dep)) {
          dependencyGraph[dep].add(varName);
        }
      });
    }
  }

  // First, add a function to find all draggable elements at a specific point
  function findElementsAtPoint(x, y) {
  // Get all draggable elements in the problem canvas
  const elements = Array.from(document.querySelectorAll("#problem-canvas .draggable-element"));
  const elementsAtPoint = [];
  
  // Check each element to see if it contains the point (x, y)
  elements.forEach(element => {
    const rect = element.getBoundingClientRect();
    if (
      x >= rect.left && 
      x <= rect.right && 
      y >= rect.top && 
      y <= rect.bottom
    ) {
      elementsAtPoint.push(element);
    }
  });
  
  // Sort elements by z-index (highest to lowest)
  elementsAtPoint.sort((a, b) => {
    const zIndexA = parseInt(getComputedStyle(a).zIndex) || 0;
    const zIndexB = parseInt(getComputedStyle(b).zIndex) || 0;
    return zIndexB - zIndexA;
  });
  
  return elementsAtPoint;
}

// Add a cycling index to track which element in the stack is currently active


// Helper function to highlight the active element



// Function to add a hint to the UI
function addCyclingHintToUI() {
  const problemSection = document.getElementById("problem-image");
  const hintDiv = document.createElement("div");
  hintDiv.innerHTML = "<small>Double-click in the same spot to cycle through stacked elements</small>";
  hintDiv.style.marginTop = "5px";
  hintDiv.style.color = "#666";
  
  // Insert after the toolbar
  const toolbar = problemSection.querySelector(".toolbar");
  if (toolbar) {
    toolbar.after(hintDiv);
  } else {
    problemSection.appendChild(hintDiv);
  }
}
// Function to create draggable endpoints for the line

function createDraggableEndpoints(svgContainer) {
  const line = svgContainer.currentLine;
  if (!line) return;
  
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));
  
  // Create endpoint markers (circles)
  const endpoint1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  endpoint1.setAttribute("cx", x1);
  endpoint1.setAttribute("cy", y1);
  endpoint1.setAttribute("r", "6");
  endpoint1.setAttribute("fill", "rgba(0, 0, 255, 0.5)");
  endpoint1.setAttribute("stroke", "blue");
  endpoint1.setAttribute("stroke-width", "1.5");
  endpoint1.style.cursor = "move";
  endpoint1.style.pointerEvents = "all"; // Ensure it catches events
  
  const endpoint2 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  endpoint2.setAttribute("cx", x2);
  endpoint2.setAttribute("cy", y2);
  endpoint2.setAttribute("r", "6");
  endpoint2.setAttribute("fill", "rgba(0, 0, 255, 0.5)");
  endpoint2.setAttribute("stroke", "blue");
  endpoint2.setAttribute("stroke-width", "1.5");
  endpoint2.style.cursor = "move";
  endpoint2.style.pointerEvents = "all"; // Ensure it catches events
  
  // Add endpoints to SVG
  svgContainer.appendChild(endpoint1);
  svgContainer.appendChild(endpoint2);
  
  // Store references
  svgContainer.endpoint1 = endpoint1;
  svgContainer.endpoint2 = endpoint2;
  
  // Add event listeners for dragging
  endpoint1.addEventListener("mousedown", function(e) {
    e.stopPropagation(); // Prevent parent container's drag from activating
    dragEndpoint(e, endpoint1, line, "start", svgContainer);
  });
  
  endpoint2.addEventListener("mousedown", function(e) {
    e.stopPropagation(); // Prevent parent container's drag from activating
    dragEndpoint(e, endpoint2, line, "end", svgContainer);
  });
}


// Helper function to adjust SVG container size based on line endpoints
function adjustSVGContainer(svgElement) {
  const line = svgElement.currentLine;
  if (!line) return;
  
  // Get current endpoint positions from the line (in the current SVG coordinate system)
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));
  
  // Determine the bounding box of the line
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);
  
  // Set a desired padding (in SVG coordinate units)
  const padding = 20;
  
  // Compute new dimensions: add padding on all sides
  const newWidth = (maxX - minX) + 2 * padding;
  const newHeight = (maxY - minY) + 2 * padding;
  
  // Adjust the SVG element:
  svgElement.setAttribute("width", newWidth);
  svgElement.setAttribute("height", newHeight);
  // Now make the viewBox start at 0,0 with the new width/height
  svgElement.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);
  
  // Offset the line so that its previous coordinates are preserved:
  line.setAttribute("x1", x1 - minX + padding);
  line.setAttribute("y1", y1 - minY + padding);
  line.setAttribute("x2", x2 - minX + padding);
  line.setAttribute("y2", y2 - minY + padding);
  
  // Update the endpoints similarly if they exist
  if (svgElement.endpoint1) {
    svgElement.endpoint1.setAttribute("cx", x1 - minX + padding);
    svgElement.endpoint1.setAttribute("cy", y1 - minY + padding);
  }
  if (svgElement.endpoint2) {
    svgElement.endpoint2.setAttribute("cx", x2 - minX + padding);
    svgElement.endpoint2.setAttribute("cy", y2 - minY + padding);
  }
  
  // Now adjust the outer container (the draggable element that wraps the SVG)
  // In addLine(), you create a container that holds the toolbar and a content div,
  // which in turn holds this SVG.
  // We assume the toolbar height is fixed (e.g., 20px).
  const toolbarHeight = 20;
  // The SVG is placed inside a content div that starts at top=toolbarHeight.
  // Find the outer container:
  const contentDiv = svgElement.parentElement;
  const outerContainer = contentDiv.parentElement;
  
  // Get the container’s current position:
  let currentLeft = parseFloat(outerContainer.style.left) || 0;
  let currentTop = parseFloat(outerContainer.style.top) || 0;
  
  // We want to reposition the container so that the new SVG is not cut off.
  // Shift the container’s position by (minX - padding, minY - padding)
  outerContainer.style.left = (currentLeft + minX - padding) + "px";
  outerContainer.style.top  = (currentTop + minY - padding) + "px";
  
  // Also update the outer container’s dimensions:
  outerContainer.style.width  = newWidth + "px";
  outerContainer.style.height = (toolbarHeight + newHeight) + "px";
}






  function substituteLatexVariables(latexString, computed) {
  // This regex matches any instance of {{...}} (without escaping)
  return latexString.replace(/\{\{([^}]+)\}\}/g, (match, varName) => {
    varName = varName.trim();
    if (computed.hasOwnProperty(varName) && computed[varName] != null) {
      return computed[varName].toString();
    }
    return match; // if no computed value exists, keep the placeholder
  });
}

  // ===== Evaluation and Update Propagation =====
  function evaluateExpression(expression) {
    if (!expression || expression.trim() === "") {
      return "";
    }
    try {
      // Build a context that includes the current computedValues and helper functions.
      let context = Object.assign({}, computedValues, {
        randomInt: randomInt,
        randomNumber: randomNumber,
        round: round,
        reduceFraction: reduceFraction,
        gcd: gcd,
        unreducedfraction: unreducedfraction,
        mixedFraction: mixedFraction,
        chooseFromWordList: chooseFromWordList,
        chooseFromNumberList: chooseFromNumberList,
        arrangeAscending: arrangeAscending,
        arrangeDescending: arrangeDescending,
        Math: Math
      });
      return new Function("with(this){ return (" + expression + "); }").call(context);
    } catch (e) {
      console.error("Error evaluating expression:", expression, e);
      return null;
    }
  }
  
  function propagateUpdate(varName) {
    // Get the set of variables that depend on varName.
    let dependents = dependencyGraph[varName];
    if (dependents) {
      dependents.forEach(dependentVar => {
        // Recalculate the dependent variable using its expression.
        let expr = varDefinitions[dependentVar];
        computedValues[dependentVar] = evaluateExpression(expr);
        // Recursively propagate changes further down the dependency chain.
        propagateUpdate(dependentVar);
      });
    }
  }
  
      // NEW: Function to set the current formula input when it receives focus.
      function setCurrentFormulaInput(input) {
        currentFormulaInput = input;
      }
      
      /******** Helper Functions (for formulas) ********/
   function randomInt(min, max) {
    min = Number(min);
    max = Number(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  
  
  function randomNumber(min, max, decimals) {
    return Number((Math.random() * (max - min) + min).toFixed(decimals));
  }
  
  function round(num, decimals) {
    return Number(Math.round(num + 'e' + decimals) + 'e-' + decimals);
  }
  
  function createDraggableElement(innerContentHTML, isText) {
  const container = document.createElement('div');
  container.setAttribute('tabindex', '0');
  container.id = "draggable_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
  container.className = 'draggable-element';
  container.style.position = 'absolute';
  container.style.left = nextElementOffset + 'px';
  container.style.top = nextElementOffset + 'px';
  nextElementOffset += 20;
  if (nextElementOffset > 100) nextElementOffset = 10;
  
  // NEW: Set default z-index if not already set and record it.
  if (!container.style.zIndex || container.style.zIndex === "") {
    container.style.zIndex = "1";
    container.dataset.originalZ = "1";
  }
  
  const controls = document.createElement('div');
  controls.className = 'element-controls';
  
  const handle = document.createElement('span');
  handle.className = 'drag-handle';
  handle.innerHTML = '&#9776;';
  controls.appendChild(handle);
  
  const forwardBtn = document.createElement('button');
forwardBtn.className = 'layer-button';
forwardBtn.innerHTML = '↑';
forwardBtn.addEventListener('click', function(e) {
  let z = parseInt(container.style.zIndex) || 1;
  z += 1;
  container.style.zIndex = z;
  // Update the original z-index
  container.dataset.originalZ = z.toString();
  e.stopPropagation();
});
controls.appendChild(forwardBtn);

const backBtn = document.createElement('button');
backBtn.className = 'layer-button';
backBtn.innerHTML = '↓';
backBtn.addEventListener('click', function(e) {
  let z = parseInt(container.style.zIndex) || 1;
  z = Math.max(1, z - 1); // Don't go below 1
  container.style.zIndex = z;
  // Update the original z-index
  container.dataset.originalZ = z.toString();
  e.stopPropagation();
});
controls.appendChild(backBtn);
  
  const adjustBtn = document.createElement('button');
  adjustBtn.className = 'adjust-button';
  // If the element has image code, show "Change Code"; otherwise, "Adjust"
  adjustBtn.innerHTML = container.dataset.imageCode ? 'Change Code' : 'Adjust';
  adjustBtn.addEventListener('click', function(e) {
    const contentDiv = container.querySelector('.element-content');
    if (container.dataset.imageCode) {
      editImageCode(container);
    } else if (contentDiv.querySelector('svg')) {
      editGraph(container);
    } else {
      const textBox = contentDiv.querySelector('.text-box');
      if (textBox) {
        let newSize = prompt("Enter new font size (e.g., 16px):", textBox.style.fontSize || "16px");
        if (newSize) textBox.style.fontSize = newSize;
      }
    }
    e.stopPropagation();
  });
  controls.appendChild(adjustBtn);

  const delBtn = document.createElement('button');
  delBtn.className = 'delete-button';
  delBtn.innerHTML = 'X';
  delBtn.addEventListener('click', function(e) {
    deleteElement(delBtn);
    e.stopPropagation();
  });
  controls.appendChild(delBtn);
  
  container.appendChild(controls);
  
  const contentDiv = document.createElement('div');
  contentDiv.className = 'element-content';
  if (isText) {
    const textBox = document.createElement('div');
    textBox.className = 'text-box';
    textBox.contentEditable = true;
    textBox.innerHTML = innerContentHTML;
    // Save the original text (with {variable} placeholders) for later substitution.
    textBox.setAttribute("data-original-text", innerContentHTML);
    textBox.setAttribute("data-mode", "manual"); // default to manual
    textBox.addEventListener('click', function(e) {
      activeElement = container;
      activeTextBox = textBox;
    });
    textBox.addEventListener('input', function() {
      textBox.setAttribute("data-original-text", textBox.innerHTML);
      updateVariables();
    });
    contentDiv.appendChild(textBox);

    // --- Add radio buttons for mode selection in the toolbar ---
    const modeContainer = document.createElement('span');
    modeContainer.className = "mode-container";
    modeContainer.style.marginRight = "4px";

    // Create the Manual radio button.
    const manualLabel = document.createElement('label');
    manualLabel.style.marginRight = "4px";
    const manualRadio = document.createElement('input');
    manualRadio.type = "radio";
    manualRadio.name = "mode_" + container.id;
    manualRadio.value = "manual";
    manualRadio.checked = true; // default
    manualRadio.addEventListener('change', function(e) {
      if (manualRadio.checked && activeTextBox) {
        activeTextBox.setAttribute("data-mode", "manual");
        updateVariables();
      }
    });
    manualLabel.appendChild(manualRadio);
    manualLabel.appendChild(document.createTextNode("Manual"));

    // Create the LaTeX radio button.
    const latexLabel = document.createElement('label');
    latexLabel.style.marginRight = "4px";
    const latexRadio = document.createElement('input');
    latexRadio.type = "radio";
    latexRadio.name = "mode_" + container.id;
    latexRadio.value = "latex";
    latexRadio.checked = false;
    latexRadio.addEventListener('change', function(e) {
      if (latexRadio.checked && activeTextBox) {
        activeTextBox.setAttribute("data-mode", "latex");
        updateVariables();
      }
    });
    latexLabel.appendChild(latexRadio);
    latexLabel.appendChild(document.createTextNode("LaTeX"));

    modeContainer.appendChild(manualLabel);
    modeContainer.appendChild(latexLabel);
    controls.appendChild(modeContainer);
    // --- End of mode radio button group ---
    
  } else {
    contentDiv.innerHTML = innerContentHTML;
    contentDiv.addEventListener('click', function(e) {
      activeElement = container;
      e.stopPropagation();
    });
  }
  container.appendChild(contentDiv);

  container.addEventListener('click', function(e) {
    e.stopPropagation();
    hideAllControls();
    controls.style.display = 'flex';
  });
  makeDraggable(handle, container);
  
  // Resize handle for non-text elements.
  if (!isText && (contentDiv.querySelector('.shape') || contentDiv.querySelector('table') || contentDiv.querySelector('svg') || container.dataset.imageCode)) {
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle';
    container.appendChild(resizeHandle);
    resizeHandle.addEventListener('mousedown', function(e) {
      e.stopPropagation();
      let startX = e.clientX, startY = e.clientY;
      let startWidth, startHeight;
      let resizableElem;
      if (container.dataset.imageCode) {
        resizableElem = container;
        startWidth = container.offsetWidth;
        startHeight = container.offsetHeight;
      } else {
        resizableElem = contentDiv.querySelector('.shape') ||
                        contentDiv.querySelector('table') ||
                        contentDiv.querySelector('svg');
        startWidth = parseFloat(getComputedStyle(resizableElem).width);
        startHeight = parseFloat(getComputedStyle(resizableElem).height);
      }
      function onMouseMove(e) {
        let newWidth = startWidth + (e.clientX - startX);
        let newHeight = startHeight + (e.clientY - startY);
        if (newWidth > 10) resizableElem.style.width = newWidth + 'px';
        if (newHeight > 10) resizableElem.style.height = newHeight + 'px';
      }
      function onMouseUp(e) {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      }
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }
  // Make inner SVG responsive if added via image code.
  if (container.dataset.imageCode) {
    let svgElem = contentDiv.querySelector('svg');
    if (svgElem) {
      svgElem.removeAttribute('width');
      svgElem.removeAttribute('height');
      svgElem.style.width = "100%";
      svgElem.style.height = "100%";
    }
  }
  // Additional toolbar buttons for text elements.
  if (isText) {
    let eqBtn = document.createElement('button');
    eqBtn.innerHTML = "Eq";
    eqBtn.title = "Insert Equation Element";
    eqBtn.style.marginRight = "4px";
    eqBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      showEquationModal();
    });
    controls.appendChild(eqBtn);
    
    let textCodeBtn = document.createElement('button');
    textCodeBtn.innerHTML = "Text Code";
    textCodeBtn.title = "Insert Text With Code (LaTeX)";
    textCodeBtn.style.marginRight = "4px";
    textCodeBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      let textBox = container.querySelector('.text-box');
      if (textBox) {
        activeTextBox = textBox;
      }
      showTextCodeModal();
    });
    controls.appendChild(textCodeBtn);
  }

  if (container.dataset.imageCode) {
    let svgElem = contentDiv.querySelector('svg');
    if (svgElem) {
      svgElem.removeAttribute('width');
      svgElem.removeAttribute('height');
      svgElem.style.width = "100%";
      svgElem.style.height = "100%";
    }
  }
  return container;
}

function updateLayerButtons() {
  document.querySelectorAll('.layer-button').forEach(button => {
    // Remove existing event listeners (if possible)
    const newButton = button.cloneNode(true);
    button.parentNode.replaceChild(newButton, button);
    
    if (newButton.innerHTML === '↑') {
      newButton.addEventListener('click', function(e) {
        const container = this.closest('.draggable-element');
        if (container) {
          let z = parseInt(container.style.zIndex) || 1;
          z += 1;
          container.style.zIndex = z;
          // Update the original z-index
          container.dataset.originalZ = z.toString();
        }
        e.stopPropagation();
      });
    } else if (newButton.innerHTML === '↓') {
      newButton.addEventListener('click', function(e) {
        const container = this.closest('.draggable-element');
        if (container) {
          let z = parseInt(container.style.zIndex) || 1;
          z = Math.max(1, z - 1);
          container.style.zIndex = z;
          // Update the original z-index
          container.dataset.originalZ = z.toString();
        }
        e.stopPropagation();
      });
    }
  });
}

  function updateSVGElement(container, computedVars) {
    // Get the original SVG code (with placeholders)
    let rawCode = container.dataset.imageCode;
    // Replace all placeholders with their computed values
    let substitutedCode = substituteValue(rawCode, computedVars);
    console.log("Substituted SVG code:", substitutedCode);
    
    // Use DOMParser to convert the substituted string into an SVG element
    let parser = new DOMParser();
    let doc = parser.parseFromString(substitutedCode, "image/svg+xml");
    let newSVG = doc.documentElement;
    
    // Replace the old SVG with the new one
    let contentDiv = container.querySelector('.element-content');
    contentDiv.innerHTML = "";
    contentDiv.appendChild(newSVG);
  }
  
  // Functions to show/close the equation modal and insert equation elements
  function showEquationModal() {
    document.getElementById("equationModal").style.display = "block";
  }
  function closeEquationModal() {
    document.getElementById("equationModal").style.display = "none";
  }
  
  // Show the Text With Code modal
  function showTextCodeModal() {
    let modal = document.getElementById("textCodeModal");
    modal.style.display = "block";
  }
  
  // Close the Text With Code modal
  function closeTextCodeModal() {
    let modal = document.getElementById("textCodeModal");
    modal.style.display = "none";
  }
  
  // Set up OK/Cancel events for the text code modal
  document.getElementById("textCodeOK").addEventListener("click", function() {
    let code = document.getElementById("textCodeTextarea").value;
    if (code) {
      // Perform variable substitution on the pasted code.
      let computedVars = computeAllVariables();
      let substitutedCode = substituteValue(code, computedVars);
      // Use MathJax to convert LaTeX to HTML.
      // MathJax.tex2chtmlPromise returns a promise that resolves to an HTML node.
      MathJax.tex2chtmlPromise(substitutedCode, {display: false}).then(function(node) {
        // Convert the node to HTML string
        let htmlSnippet = node.outerHTML;
        // Insert the resulting HTML into the active text box at the current caret position.
        activeTextBox.innerHTML += htmlSnippet;
        activeTextBox.focus();
        // Clear the textarea for next use.
        document.getElementById("textCodeTextarea").value = "";
      }).catch(function(err) {
        console.error("MathJax conversion error:", err);
      });
    }
    closeTextCodeModal();
  });
  
  document.getElementById("textCodeCancel").addEventListener("click", function() {
    closeTextCodeModal();
  });

// Function to create and append the necessary SVG marker definitions
// Modified createSVGMarkerDefs to create colored markers


// Function to update marker colors


  function insertEquationElement(type) {
  let snippet = "";
  switch(type) {
    case 'fraction':
      snippet = '<span class="fraction">' +
                  '<table style="display:inline-table; border-collapse:collapse;">' +
                    '<tr><td contenteditable="true" style="text-align:center; border-bottom:1px solid; padding:0 2px;">numerator</td></tr>' +
                    '<tr><td contenteditable="true" style="text-align:center; padding:0 2px;">denominator</td></tr>' +
                  '</table>' +
                '</span>';
      break;
    case 'division':
      // Division is represented the same as a fraction.
      snippet = '<span class="division">' +
              '<table style="display:inline-table; border-collapse:collapse;">' +
                '<tr>' +
                  '<td contenteditable="true" style="text-align:center; border-right:1px solid; padding:0 2px;">divisor</td>' +
                  '<td contenteditable="true" style="text-align:center; border-top:1px solid; padding:0 2px;">dividend</td>' +
                '</tr>' +
              '</table>' +
            '</span>';
  break;
    case 'sqrt':
      snippet = '<span class="sqrt">√' +
                  '<span class="radicand" contenteditable="true" ' +
                        'style="display:inline-block; border-top:1px solid; padding:0 2px;">radicand</span>' +
                '</span>';
      break;
    case 'nthroot':
      snippet = '<span class="nth-root">' +
                  '<sup contenteditable="true" style="display:inline-block; padding:0 2px;">n</sup>' +
                  '√' +
                  '<span class="radicand" contenteditable="true" ' +
                        'style="display:inline-block; border-top:1px solid; padding:0 2px;">radicand</span>' +
                '</span>';
      break;
    case 'pi':
      snippet = 'π';
      break;
    case 'superscript':
        snippet = '<sup contenteditable="true" style="display:inline-block;" onkeydown="exitOnArrowRight(event)">sup</sup>';
  break;
    case 'subscript':
        snippet = '<sub contenteditable="true" style="display:inline-block;" onkeydown="exitOnArrowRight(event)">sub</sub>';
  break;

    default:
      snippet = "";
  }
  if (activeTextBox) {
    document.execCommand('insertHTML', false, snippet);
    activeTextBox.focus();
  } else {
    alert("Please click inside a text box before inserting an equation element.");
  }
  closeEquationModal();
}



// Modal for image code input
function showImageCodeModal(defaultCode, callback) {
  const modal = document.getElementById("imageCodeModal");
  const overlay = document.getElementById("modalOverlay");
  const textarea = document.getElementById("imageCodeTextarea");
  const okButton = document.getElementById("imageCodeOK");
  const cancelButton = document.getElementById("imageCodeCancel");

  // Set default code into the textarea.
  textarea.value = defaultCode || "";
  // Show modal and overlay.
  modal.style.display = "block";
  overlay.style.display = "block";

  // Define cleanup and event handlers.
  function cleanup() {
    modal.style.display = "none";
    overlay.style.display = "none";
    okButton.removeEventListener("click", onOK);
    cancelButton.removeEventListener("click", onCancel);
  }
  function onOK() {
    const code = textarea.value;
    cleanup();
    callback(code);
  }
  function onCancel() {
    cleanup();
    callback(null);
  }
  okButton.addEventListener("click", onOK);
  cancelButton.addEventListener("click", onCancel);
}

function showColorPicker(title, initialColor, allowNone, callback) {
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  // Ensure the modal is always on top.
  overlay.style.zIndex = "10000";

  const modal = document.createElement("div");
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.border = "1px solid #ccc";
  modal.style.fontSize = "14px";
  modal.innerHTML = `<div style="margin-bottom:10px;">${title}</div>`;

  const colorInput = document.createElement("input");
  colorInput.type = "color";
  colorInput.value = initialColor;
  modal.appendChild(colorInput);

  if (allowNone) {
    const noneBtn = document.createElement("button");
    noneBtn.textContent = "None";
    noneBtn.style.marginLeft = "10px";
    modal.appendChild(noneBtn);
    noneBtn.addEventListener("click", () => {
      cleanup();
      callback("none");
    });
  }

  const okBtn = document.createElement("button");
  okBtn.textContent = "OK";
  okBtn.style.marginLeft = "10px";
  modal.appendChild(okBtn);
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.marginLeft = "10px";
  modal.appendChild(cancelBtn);

  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  okBtn.addEventListener("click", () => {
    cleanup();
    callback(colorInput.value);
  });
  cancelBtn.addEventListener("click", () => {
    cleanup();
    callback(null);
  });
  function cleanup() {
    document.body.removeChild(overlay);
  }
}



// The first issue in your code is that there's a misplaced closing brace
// And the showAdvancedLineToolbar function isn't being found
// Here's the correct implementation for these functions:
function createSVGMarkerDefs() {
  // Check if markers already exist to avoid duplicates
  if (document.getElementById('arrowMarkerEnd')) return;
  
  // Create a defs element if it doesn't exist
  let svgDefs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  svgDefs.id = "markerDefs";
  
  // Arrow marker for end points (points right)
  let arrowMarkerEnd = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  arrowMarkerEnd.setAttribute("id", "arrowMarkerEnd");
  arrowMarkerEnd.setAttribute("markerWidth", "10");
  arrowMarkerEnd.setAttribute("markerHeight", "7");
  arrowMarkerEnd.setAttribute("refX", "9");
  arrowMarkerEnd.setAttribute("refY", "3.5");
  arrowMarkerEnd.setAttribute("orient", "auto");
  arrowMarkerEnd.setAttribute("markerUnits", "strokeWidth");
  
  let arrowPathEnd = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  arrowPathEnd.setAttribute("points", "0 0, 10 3.5, 0 7");
  arrowPathEnd.setAttribute("fill", "#000000");
  arrowMarkerEnd.appendChild(arrowPathEnd);
  svgDefs.appendChild(arrowMarkerEnd);
  
  // Arrow marker for start points (points left)
  let arrowMarkerStart = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  arrowMarkerStart.setAttribute("id", "arrowMarkerStart");
  arrowMarkerStart.setAttribute("markerWidth", "10");
  arrowMarkerStart.setAttribute("markerHeight", "7");
  arrowMarkerStart.setAttribute("refX", "1");
  arrowMarkerStart.setAttribute("refY", "3.5");
  arrowMarkerStart.setAttribute("orient", "auto");
  arrowMarkerStart.setAttribute("markerUnits", "strokeWidth");
  
  let arrowPathStart = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  arrowPathStart.setAttribute("points", "10 0, 0 3.5, 10 7");
  arrowPathStart.setAttribute("fill", "#000000");
  arrowMarkerStart.appendChild(arrowPathStart);
  svgDefs.appendChild(arrowMarkerStart);
  
  // Closed circle marker (for points/endpoints)
  let circleMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  circleMarker.setAttribute("id", "closedCircleMarker");
  circleMarker.setAttribute("markerWidth", "8");
  circleMarker.setAttribute("markerHeight", "8");
  circleMarker.setAttribute("refX", "4");
  circleMarker.setAttribute("refY", "4");
  circleMarker.setAttribute("orient", "auto");
  circleMarker.setAttribute("markerUnits", "strokeWidth");
  
  let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", "4");
  circle.setAttribute("cy", "4");
  circle.setAttribute("r", "3");
  circle.setAttribute("fill", "#000000");
  circleMarker.appendChild(circle);
  svgDefs.appendChild(circleMarker);
  
  // Open circle marker (hollow circle for rays)
  let openCircleMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  openCircleMarker.setAttribute("id", "openCircleMarker");
  openCircleMarker.setAttribute("markerWidth", "8");
  openCircleMarker.setAttribute("markerHeight", "8");
  openCircleMarker.setAttribute("refX", "4");
  openCircleMarker.setAttribute("refY", "4");
  openCircleMarker.setAttribute("orient", "auto");
  openCircleMarker.setAttribute("markerUnits", "strokeWidth");
  
  let openCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  openCircle.setAttribute("cx", "4");
  openCircle.setAttribute("cy", "4");
  openCircle.setAttribute("r", "3");
  openCircle.setAttribute("fill", "white");
  openCircle.setAttribute("stroke", "#000000");
  openCircle.setAttribute("stroke-width", "1");
  openCircleMarker.appendChild(openCircle);
  svgDefs.appendChild(openCircleMarker);
  
  // Square marker (for special segment endpoints)
  let squareMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  squareMarker.setAttribute("id", "squareMarker");
  squareMarker.setAttribute("markerWidth", "8");
  squareMarker.setAttribute("markerHeight", "8");
  squareMarker.setAttribute("refX", "4");
  squareMarker.setAttribute("refY", "4");
  squareMarker.setAttribute("orient", "auto");
  squareMarker.setAttribute("markerUnits", "strokeWidth");
  
  let square = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  square.setAttribute("x", "1");
  square.setAttribute("y", "1");
  square.setAttribute("width", "6");
  square.setAttribute("height", "6");
  square.setAttribute("fill", "#000000");
  squareMarker.appendChild(square);
  svgDefs.appendChild(squareMarker);
  
  // Span marker (vertical line) for start points
  let spanMarkerStart = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  spanMarkerStart.setAttribute("id", "spanMarkerStart");
  spanMarkerStart.setAttribute("markerWidth", "4");
  spanMarkerStart.setAttribute("markerHeight", "10");
  spanMarkerStart.setAttribute("refX", "2");
  spanMarkerStart.setAttribute("refY", "5");
  spanMarkerStart.setAttribute("orient", "auto");
  spanMarkerStart.setAttribute("markerUnits", "strokeWidth");
  
  let spanLineStart = document.createElementNS("http://www.w3.org/2000/svg", "line");
  spanLineStart.setAttribute("x1", "2");
  spanLineStart.setAttribute("y1", "0");
  spanLineStart.setAttribute("x2", "2");
  spanLineStart.setAttribute("y2", "10");
  spanLineStart.setAttribute("stroke", "#000000");
  spanLineStart.setAttribute("stroke-width", "2");
  spanMarkerStart.appendChild(spanLineStart);
  svgDefs.appendChild(spanMarkerStart);
  
  // Span marker (vertical line) for end points
  let spanMarkerEnd = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  spanMarkerEnd.setAttribute("id", "spanMarkerEnd");
  spanMarkerEnd.setAttribute("markerWidth", "4");
  spanMarkerEnd.setAttribute("markerHeight", "10");
  spanMarkerEnd.setAttribute("refX", "2");
  spanMarkerEnd.setAttribute("refY", "5");
  spanMarkerEnd.setAttribute("orient", "auto");
  spanMarkerEnd.setAttribute("markerUnits", "strokeWidth");
  
  let spanLineEnd = document.createElementNS("http://www.w3.org/2000/svg", "line");
  spanLineEnd.setAttribute("x1", "2");
  spanLineEnd.setAttribute("y1", "0");
  spanLineEnd.setAttribute("x2", "2");
  spanLineEnd.setAttribute("y2", "10");
  spanLineEnd.setAttribute("stroke", "#000000");
  spanLineEnd.setAttribute("stroke-width", "2");
  spanMarkerEnd.appendChild(spanLineEnd);
  svgDefs.appendChild(spanMarkerEnd);
  
  // Add the defs to the first SVG in the document
  const firstSvg = document.querySelector('svg');
  if (firstSvg) {
    firstSvg.insertBefore(svgDefs, firstSvg.firstChild);
  } else {
    // Create a hidden SVG element to hold the defs if no SVG exists yet
    const hiddenSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    hiddenSvg.style.position = "absolute";
    hiddenSvg.style.width = "0";
    hiddenSvg.style.height = "0";
    hiddenSvg.style.overflow = "hidden";
    hiddenSvg.appendChild(svgDefs);
    document.body.appendChild(hiddenSvg);
  }
}

function addLine() {
  createSVGMarkerDefs(); // Ensure markers are defined

  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 28; // fixed toolbar height

  // Create the outer container for the line.
  const container = document.createElement("div");
  container.className = "draggable-element line-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = "300px";
  container.style.height = (toolbarHeight + 50) + "px"; // toolbar + content area
  container.style.zIndex = globalTopZ++;
  container.dataset.originalZ = container.style.zIndex;
  nextElementOffset += 10;

  // Create the toolbar.
  const toolbar = document.createElement("div");
  toolbar.className = "line-toolbar element-controls";
  toolbar.style.height = toolbarHeight + "px";
  toolbar.style.width = "420px";
  toolbar.style.boxSizing = "border-box";
  toolbar.style.backgroundColor = "#f0f0f0";
  toolbar.style.display = "none"; // hidden initially
  toolbar.style.alignItems = "center";
  toolbar.style.flexShrink = "0";
  toolbar.style.position = "relative"; // Ensure toolbar has its own stacking context
  toolbar.style.zIndex = "1000"; // High z-index for toolbar

  // ----- DRAG HANDLE -----
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "10px";
  dragHandle.textContent = "☰";
  toolbar.appendChild(dragHandle);

  // ----- COLOR CONTROL -----
  // Wrap the visible color box and hidden input in a container.
  const colorContainer = document.createElement("div");
  colorContainer.style.position = "relative"; // positioning context
  colorContainer.style.display = "inline-block";
  colorContainer.style.marginRight = "8px";

  // Visible color box.
  const colorBox = document.createElement("div");
  colorBox.style.width = "20px";
  colorBox.style.height = "20px";
  colorBox.style.backgroundColor = "#000000";
  colorBox.style.border = "1px solid #ccc";
  colorBox.style.cursor = "pointer";
  colorContainer.appendChild(colorBox);

  // Hidden color input exactly covers the color box.
  const strokeInput = document.createElement("input");
  strokeInput.type = "color";
  strokeInput.value = "#000000";
  strokeInput.style.position = "absolute";
  strokeInput.style.top = "0";
  strokeInput.style.left = "0";
  strokeInput.style.width = "100%";
  strokeInput.style.height = "100%";
  strokeInput.style.opacity = "0";
  strokeInput.style.cursor = "pointer";
  colorContainer.appendChild(strokeInput);

  strokeInput.addEventListener("input", function(e) {
    const newColor = strokeInput.value;
    colorBox.style.backgroundColor = newColor;
    line.setAttribute("stroke", newColor);
    updateMarkerColors(newColor);
    if (svg.endpoint1) {
      svg.endpoint1.setAttribute("stroke", newColor);
      svg.endpoint1.setAttribute("fill", "rgba(" + hexToRgb(newColor).join(",") + ",0.5)");
    }
    if (svg.endpoint2) {
      svg.endpoint2.setAttribute("stroke", newColor);
      svg.endpoint2.setAttribute("fill", "rgba(" + hexToRgb(newColor).join(",") + ",0.5)");
    }
    e.stopPropagation();
  });

  toolbar.appendChild(colorContainer);

  // ----- THICKNESS CONTROL -----
  const thicknessLabel = document.createElement("span");
  thicknessLabel.textContent = "Width:";
  thicknessLabel.style.fontSize = "12px";
  thicknessLabel.style.marginRight = "4px";
  toolbar.appendChild(thicknessLabel);

  const thicknessInput = document.createElement("input");
  thicknessInput.type = "number";
  thicknessInput.min = "1";
  thicknessInput.value = "2";
  thicknessInput.style.width = "35px";
  toolbar.appendChild(thicknessInput);

  // ----- LINE STYLE DROPDOWN -----
  const styleLabel = document.createElement("span");
  styleLabel.textContent = "Style:";
  styleLabel.style.fontSize = "12px";
  styleLabel.style.marginRight = "4px";
  styleLabel.style.marginLeft = "6px";
  toolbar.appendChild(styleLabel);

  const lineStyleSelect = document.createElement("select");
  lineStyleSelect.style.marginRight = "6px";
  lineStyleSelect.style.width = "150px"; // Adjust width for longer text

  // New lineStyles array with updated text values.
  const lineStyles = [
    { value: "line", text: "Line" },
    { value: "line-arrow-both", text: "Line with arrows" },
    { value: "line-dashed", text: "Dashed Line" },
    { value: "ray", text: "Ray with endpoint" },
    { value: "ray-no-endpoint", text: "Ray no endpoint" },
    { value: "ray-circle-open", text: "Ray with open circle" },
    { value: "segment", text: "Segment" },
    { value: "segment-points", text: "Segment with endpoints" },
    { value: "segment-open-circles", text: "Segment with open circle endpoints" },
    { value: "segment-mixed-circles", text: "Segment with mixed circle endpoints" },
    { value: "span-segment", text: "Span segment" },
    { value: "span-segment-dashed", text: "Dashed Span segment" }
  ];

  lineStyles.forEach(style => {
    const option = document.createElement("option");
    option.value = style.value;
    option.textContent = style.text;
    lineStyleSelect.appendChild(option);
  });
  toolbar.appendChild(lineStyleSelect);

  // ----- DELETE BUTTON -----
  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "✕";
  deleteBtn.style.marginLeft = "auto";
  deleteBtn.style.fontSize = "12px";
  deleteBtn.style.padding = "2px 6px";
  toolbar.appendChild(deleteBtn);

  container.appendChild(toolbar);

  // ----- SVG CONTENT AREA -----
  const content = document.createElement("div");
  content.className = "line-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = "calc(100% - " + toolbarHeight + "px)";
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create the SVG element.
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  const svgWidth = parseInt(container.style.width);
  const svgHeight = parseInt(container.style.height) - toolbarHeight;
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Create the line element with default endpoints.
  const line = document.createElementNS(svgNS, "line");
  line.setAttribute("x1", 10);
  line.setAttribute("y1", svgHeight / 2);
  line.setAttribute("x2", svgWidth - 10);
  line.setAttribute("y2", svgHeight / 2);
  line.setAttribute("stroke", strokeInput.value);
  line.setAttribute("stroke-width", thicknessInput.value);
  svg.appendChild(line);

  // Save a reference to the line on the SVG element.
  svg.currentLine = line;

  // Make the endpoints draggable.
  createDraggableEndpoints(svg);

  // Function to update line style based on the selected style.
  function updateLineStyle() {
    const style = lineStyleSelect.value;
    line.removeAttribute("marker-start");
    line.removeAttribute("marker-end");
    line.removeAttribute("stroke-dasharray");

    switch(style) {
      case "line":
        break;
      case "line-dashed":
        line.setAttribute("stroke-dasharray", "5,3");
        break;
      case "line-arrow-both":
        line.setAttribute("marker-start", "url(#arrowMarkerStart)");
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "ray":
        line.setAttribute("marker-start", "url(#closedCircleMarker)");
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "ray-no-endpoint":
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "ray-circle-open":
        line.setAttribute("marker-start", "url(#openCircleMarker)");
        line.setAttribute("marker-end", "url(#arrowMarkerEnd)");
        break;
      case "segment":
        break;
      case "segment-points":
        line.setAttribute("marker-start", "url(#closedCircleMarker)");
        line.setAttribute("marker-end", "url(#closedCircleMarker)");
        break;
      case "segment-open-circles":
        line.setAttribute("marker-start", "url(#openCircleMarker)");
        line.setAttribute("marker-end", "url(#openCircleMarker)");
        break;
      case "segment-mixed-circles":
        line.setAttribute("marker-start", "url(#openCircleMarker)");
        line.setAttribute("marker-end", "url(#closedCircleMarker)");
        break;
        case "span-segment":
        // New change: for span segment, add a marker only at the end (vertical bar)
        line.setAttribute("marker-start", "url(#spanMarkerEnd)");
        line.setAttribute("marker-end", "url(#spanMarkerEnd)");
        break;
      case "span-segment-dashed":
        line.setAttribute("marker-start", "url(#spanMarkerStart)");
        line.setAttribute("marker-end", "url(#spanMarkerEnd)");
        line.setAttribute("stroke-dasharray", "5,3");
        break;
    }
  }

  // Add event stopPropagation to prevent clicking through to elements below
  // for all interactive toolbar elements
  function addStopPropagation(element) {
    element.addEventListener("click", function(e) {
      e.stopPropagation();
    });
    element.addEventListener("mousedown", function(e) {
      e.stopPropagation();
    });
    element.addEventListener("change", function(e) {
      e.stopPropagation();
    });
  }

  // Apply stopPropagation to all interactive elements
  addStopPropagation(toolbar);
  addStopPropagation(thicknessInput);
  addStopPropagation(lineStyleSelect);
  addStopPropagation(colorBox);
  addStopPropagation(strokeInput);
  addStopPropagation(colorContainer);
  
  // Update line appearance when controls change.
  thicknessInput.addEventListener("change", function(e) {
    line.setAttribute("stroke-width", thicknessInput.value);
    e.stopPropagation();
  });
  
  lineStyleSelect.addEventListener("change", function(e) {
    updateLineStyle();
    e.stopPropagation();
  });
  
  deleteBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    container.remove();
  });

  // When the container is clicked, show its toolbar (and hide others).
  container.addEventListener("click", function(e) {
    e.stopPropagation();
    if (activeElement && activeElement !== container && activeElement.dataset.tempRaised) {
      restoreElementZIndex(activeElement);
    }
    document.querySelectorAll('.element-controls').forEach(ctrl => {
      if (ctrl !== toolbar) ctrl.style.display = "none";
    });
    document.querySelectorAll('.line-container svg').forEach(s => {
      if (s !== svg && s.endpoint1) s.endpoint1.style.display = "none";
      if (s !== svg && s.endpoint2) s.endpoint2.style.display = "none";
    });
    toolbar.style.display = "flex";
    activeElement = container;
    raiseElementTemporarily(container);
    if (svg.endpoint1) svg.endpoint1.style.display = "block";
    if (svg.endpoint2) svg.endpoint2.style.display = "block";
  });

  // Add pointer events to ensure toolbar is interactive
  toolbar.addEventListener("pointerdown", function(e) {
    e.stopPropagation();
  });

  // Make the toolbar click event handler take precedence
  toolbar.addEventListener("click", function(e) {
    e.stopPropagation();
    // Keep focus on this line
    if (activeElement !== container) {
      if (activeElement && activeElement.dataset.tempRaised) {
        restoreElementZIndex(activeElement);
      }
      activeElement = container;
      raiseElementTemporarily(container);
    }
  }, true); // Using capture phase to handle event first

  // Make the container draggable using the drag handle.
  makeDraggable(dragHandle, container);
  canvas.appendChild(container);
  updateLineStyle();
}


// Helper function to convert hex color to RGB array
function hexToRgb(hex) {
  // Remove # if present
  hex = hex.replace(/^#/, '');
  
  // Parse the hex values
  let r, g, b;
  if (hex.length === 3) {
    // 3-digit hex
    r = parseInt(hex.charAt(0) + hex.charAt(0), 16);
    g = parseInt(hex.charAt(1) + hex.charAt(1), 16);
    b = parseInt(hex.charAt(2) + hex.charAt(2), 16);
  } else {
    // 6-digit hex
    r = parseInt(hex.substring(0, 2), 16);
    g = parseInt(hex.substring(2, 4), 16);
    b = parseInt(hex.substring(4, 6), 16);
  }
  
  return [r, g, b];
}

function updateMarkerColors(color) {
  const markerIds = ["arrowMarkerEnd", "arrowMarkerStart", "squareMarker", "closedCircleMarker"];
  
  markerIds.forEach(id => {
    const marker = document.getElementById(id);
    if (marker) {
      const elements = marker.querySelectorAll("*");
      elements.forEach(el => {
        if (el.hasAttribute("fill") && el.getAttribute("fill") !== "white") {
          el.setAttribute("fill", color);
        }
      });
    }
  });
  
  // For open circle marker, we only change the stroke
  const openCircleMarker = document.getElementById("openCircleMarker");
  if (openCircleMarker) {
    const circle = openCircleMarker.querySelector("circle");
    if (circle) {
      circle.setAttribute("stroke", color);
    }
  }
  
  // For span markers, update the stroke color
  const spanMarkerIds = ["spanMarkerStart", "spanMarkerEnd"];
  spanMarkerIds.forEach(id => {
    const marker = document.getElementById(id);
    if (marker) {
      const lines = marker.querySelectorAll("line");
      lines.forEach(line => {
        line.setAttribute("stroke", color);
      });
    }
  });
}


// --- Function to add image via file input ---
// Function to show a modal drop-zone / upload area for images.
function showImageUploadModal(callback) {
  // Create the overlay.
  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  overlay.style.zIndex = "10000";

  // Create the modal container.
  const modal = document.createElement("div");
  modal.style.backgroundColor = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "5px";
  modal.style.textAlign = "center";
  modal.style.width = "300px";
  modal.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
  
  // Create the drop zone.
  const dropZone = document.createElement("div");
  dropZone.style.border = "2px dashed #ccc";
  dropZone.style.borderRadius = "5px";
  dropZone.style.padding = "20px";
  dropZone.style.marginBottom = "10px";
  dropZone.style.cursor = "pointer";
  dropZone.innerHTML = "Drag & drop your image here";
  
  // Create the upload button.
  const uploadBtn = document.createElement("button");
  uploadBtn.innerText = "Upload Image";
  uploadBtn.style.marginRight = "10px";
  
  // Create the cancel button.
  const cancelBtn = document.createElement("button");
  cancelBtn.innerText = "Cancel";
  
  // Assemble the modal.
  modal.appendChild(dropZone);
  modal.appendChild(uploadBtn);
  modal.appendChild(cancelBtn);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // Create a hidden file input.
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = "image/*";
  fileInput.style.display = "none";
  document.body.appendChild(fileInput);

  // Helper to process the image file.
  function handleFile(file) {
    if (file && file.type.startsWith("image/")) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const dataURL = e.target.result;
        callback(dataURL);
        cleanup();
      };
      reader.readAsDataURL(file);
    } else {
      alert("Please upload a valid image file.");
    }
  }
  
  // File input change event.
  fileInput.addEventListener("change", function(e) {
    const file = e.target.files[0];
    handleFile(file);
  });
  
  // When the upload button is clicked, trigger the file input.
  uploadBtn.addEventListener("click", function(e) {
    fileInput.click();
  });
  
  // Cancel button removes the modal.
  cancelBtn.addEventListener("click", function(e) {
    cleanup();
  });
  
  // Drag and drop events on the drop zone.
  dropZone.addEventListener("dragover", function(e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "#f0f0f0";
  });
  
  dropZone.addEventListener("dragleave", function(e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "";
  });
  
  dropZone.addEventListener("drop", function(e) {
    e.preventDefault();
    dropZone.style.backgroundColor = "";
    const dt = e.dataTransfer;
    if (dt && dt.files && dt.files.length > 0) {
      const file = dt.files[0];
      handleFile(file);
    }
  });
  
  // Cleanup function to remove the modal and file input.
  function cleanup() {
    if (overlay.parentNode) {
      overlay.parentNode.removeChild(overlay);
    }
    if (fileInput.parentNode) {
      fileInput.parentNode.removeChild(fileInput);
    }
  }
}

// --- Function to integrate the uploaded image into the canvas ---

function insertUploadedImage(dataURL) {
  const imgObj = new Image();
  imgObj.onload = function() {
    // Get the original dimensions.
    let origWidth = imgObj.naturalWidth;
    let origHeight = imgObj.naturalHeight;
    
    // Determine maximum allowed dimensions from your problem image settings.
    const problemWidthInput = document.getElementById("problem-width");
    const problemHeightInput = document.getElementById("problem-height");
    const maxWidth = problemWidthInput ? parseInt(problemWidthInput.value) : 600;
    const maxHeight = problemHeightInput ? parseInt(problemHeightInput.value) : 300;
    
    // If the uploaded image is larger than the problem canvas, scale it down.
    let scale = 1;
    if (origWidth > maxWidth || origHeight > maxHeight) {
      scale = Math.min(maxWidth / origWidth, maxHeight / origHeight);
      origWidth = origWidth * scale;
      origHeight = origHeight * scale;
    }
    
    // Create an <img> tag that fills its container and disables pointer events.
    const imgHTML = `<img src="${dataURL}" style="width:100%; height:100%; object-fit: contain; pointer-events: none;">`;
    
    // Create the container using your helper function.
    const container = createDraggableElement(imgHTML, false);
    container.style.width = origWidth + "px";
    container.style.height = origHeight + "px";
    // Ensure overflow is visible so the resize handle is not clipped.
    container.style.overflow = "visible";
    
    // Remove any default toolbar from the container.
    const defaultToolbar = container.querySelector('.element-controls');
    if (defaultToolbar) {
      defaultToolbar.remove();
    }
    
    // Append the container to the problem canvas.
    const canvas = document.getElementById("problem-canvas");
    canvas.appendChild(container);
    
    // Create a custom toolbar for the image.
    const toolbar = document.createElement("div");
    toolbar.className = "image-toolbar element-controls";
    toolbar.style.position = "absolute";
    toolbar.style.top = "0";
    toolbar.style.left = "0";
    toolbar.style.width = "100%";
    toolbar.style.zIndex = "10001"; // High z-index so it stays above the image.
    toolbar.style.display = "none"; // Hidden by default.
    toolbar.style.flexDirection = "row";
    toolbar.style.alignItems = "center";
    toolbar.style.justifyContent = "flex-start";
    toolbar.style.background = "rgba(240,240,240,0.8)";
    toolbar.style.pointerEvents = "auto";
    
    // Create a move (drag) handle.
    const moveHandle = document.createElement("span");
    moveHandle.className = "drag-handle";
    moveHandle.style.cursor = "move";
    moveHandle.style.padding = "2px 4px";
    moveHandle.style.background = "#ccc";
    moveHandle.textContent = "☰";
    toolbar.appendChild(moveHandle);
    makeDraggable(moveHandle, container);
    
    // Append the custom toolbar to the container.
    container.appendChild(toolbar);
    
    // Create a resize handle (blue box) that will always stay at the bottom-right.
    const resizeHandle = document.createElement("div");
    resizeHandle.className = "resize-handle";
    resizeHandle.style.position = "absolute";
    resizeHandle.style.width = "10px";
    resizeHandle.style.height = "10px";
    resizeHandle.style.backgroundColor = "blue";
    resizeHandle.style.right = "0";
    resizeHandle.style.bottom = "0";
    resizeHandle.style.cursor = "se-resize";
    resizeHandle.style.zIndex = "10002"; // Above the toolbar.
    // Prevent text selection on the resize handle.
    resizeHandle.style.userSelect = "none";
    container.appendChild(resizeHandle);
    
    resizeHandle.addEventListener("mousedown", function(e) {
      e.preventDefault();
      e.stopPropagation();
      const startX = e.clientX, startY = e.clientY;
      const startWidth = container.offsetWidth;
      const startHeight = container.offsetHeight;
      function onMouseMove(e) {
        let newWidth = startWidth + (e.clientX - startX);
        let newHeight = startHeight + (e.clientY - startY);
        if (newWidth > 10) container.style.width = newWidth + "px";
        if (newHeight > 10) container.style.height = newHeight + "px";
        // The resize handle remains pinned at bottom-right due to its CSS.
      }
      function onMouseUp(e) {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
    
    // Make the container focusable.
    container.setAttribute("tabindex", "0");
    
    // Container click event: mimic addTriangle behavior.
    container.addEventListener("click", function(e) {
      e.stopPropagation();
      // Hide toolbars from all other draggable elements.
      document.querySelectorAll('.element-controls').forEach(ctrl => ctrl.style.display = "none");
      // Show this container's toolbar.
      toolbar.style.display = "flex";
      activeElement = container;
      raiseElementTemporarily(container);
      // Apply a blue outline as a highlight.
      container.style.outline = "2px solid #00aaff";
      container.focus();
    });
    
    // Reapply highlight on focus.
    container.addEventListener("focus", function(e) {
      container.style.outline = "2px solid #00aaff";
    });
  };
  imgObj.src = dataURL;
}



// --- New "Add Image" function to be called from the toolbar ---
function addImageViaModal() {
  showImageUploadModal(insertUploadedImage);
}

document.addEventListener("keydown", function(e) {
  if (e.key === "Backspace" && activeElement && activeElement.classList.contains('draggable-element')) {
    // Check if the active element is not a text box in edit mode
    const textBox = activeElement.querySelector('.text-box[contenteditable="true"]:focus');
    if (!textBox) { // Only delete if not editing text
      e.preventDefault(); // Prevent default Backspace behavior (e.g., browser navigation)
      activeElement.remove();
      activeElement = null; // Clear the active element
    }
  }
});

// Function to add an image element from code.
function addImageWithCode() {
  showImageCodeModal(
    // Default template
    "<svg id='dynamicImage' width='300' height='300' viewBox='-50 -50 100 100' xmlns='http://www.w3.org/2000/svg'>\n" +
    "  <line x1='-50' y1='0' x2='50' y2='0' stroke='black' stroke-width='0.5'/>\n" +
    "  <line x1='0' y1='-50' x2='0' y2='50' stroke='black' stroke-width='0.5'/>\n" +
    "  <circle id='point' cx='0' cy='{a:plain}' r='5' fill='red'/>\n" +
    "  <text id='pointLabel' x='0' y='{a:plain}' dy='-10' font-size='10' text-anchor='middle'>(0, {a:plain})</text>\n" +
    "</svg>",
    function(code) {
      if (!code) return; // Do nothing if canceled
      
const canvas = document.getElementById("problem-canvas");
const container = createDraggableElement(code, false);
container.dataset.imageCode = code;
container.dataset.originalImageCode = code;

// Instead of reading the values from inputs, set them explicitly to 200px.
container.style.width = "300px";
container.style.height = "300px";

canvas.appendChild(container);

// Update immediately using the fresh template
updateImageCodeElement(container);


    }
  );
}

// Make sure the function is available globally:
window.addImageWithCode = addImageWithCode;

// Attach addImageWithCode to the global window so it’s available in onclick attributes.
window.addImageWithCode = addImageWithCode;

function addImageWithCodeToAnswerOption(parent) {
  showImageCodeModal(
    "<svg id='dynamicImage' width='300' height='300' viewBox='-50 -50 100 100' xmlns='http://www.w3.org/2000/svg'>\n" +
    "  <line x1='-50' y1='0' x2='50' y2='0' stroke='black' stroke-width='0.5'/>\n" +
    "  <line x1='0' y1='-50' x2='0' y2='50' stroke='black' stroke-width='0.5'/>\n" +
    "  <circle id='point' cx='0' cy='{a:plain}' r='5' fill='red'/>\n" +
    "  <text id='pointLabel' x='0' y='{a:plain}' dy='-10' font-size='10' text-anchor='middle'>(0, {a:plain})</text>\n" +
    "</svg>",
    function(code) {
      if (!code) return;
      
      // Ensure the answer option container is relatively positioned.
      parent.style.position = "relative";
      
      // Create the container for the image.
      let container = document.createElement("div");
      container.className = "draggable-answer-image";
      container.setAttribute("contentEditable", "false");
      container.style.display = "inline-block";
      container.style.position = "relative";
      container.style.width = "300px";
      container.style.height = "300px";
      container.dataset.imageCode = code;
      container.dataset.originalImageCode = code;
      
      // Create inner content to hold the SVG.
      let contentDiv = document.createElement("div");
      contentDiv.className = "element-content";
      contentDiv.innerHTML = code;
      contentDiv.setAttribute("contentEditable", "false");
      container.appendChild(contentDiv);
      
      // Create a drag handle.
      let dragHandle = document.createElement("div");
      dragHandle.className = "drag-handle";
      dragHandle.innerHTML = "&#9776;";
      dragHandle.style.position = "absolute";
      dragHandle.style.top = "0";
      dragHandle.style.left = "0";
      dragHandle.style.cursor = "move";
      container.appendChild(dragHandle);
      
      // Drag event handler (updates margins so it stays in flow).
      dragHandle.addEventListener("mousedown", function(e) {
        e.preventDefault();
        let startX = e.clientX, startY = e.clientY;
        let origMarginLeft = parseInt(window.getComputedStyle(container).marginLeft) || 0;
        let origMarginTop = parseInt(window.getComputedStyle(container).marginTop) || 0;
        function onMouseMove(e) {
          let dx = e.clientX - startX, dy = e.clientY - startY;
          container.style.marginLeft = (origMarginLeft + dx) + "px";
          container.style.marginTop = (origMarginTop + dy) + "px";
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
      
      // Create a resize handle.
      let resizeHandle = document.createElement("div");
      resizeHandle.className = "resize-handle";
      resizeHandle.style.position = "absolute";
      resizeHandle.style.right = "0";
      resizeHandle.style.bottom = "0";
      container.appendChild(resizeHandle);
      
      resizeHandle.addEventListener("mousedown", function(e) {
        e.preventDefault();
        let startX = e.clientX, startY = e.clientY;
        let startWidth = container.offsetWidth, startHeight = container.offsetHeight;
        function onMouseMove(e) {
          let newWidth = startWidth + (e.clientX - startX);
          let newHeight = startHeight + (e.clientY - startY);
          if (newWidth > 10) container.style.width = newWidth + "px";
          if (newHeight > 10) container.style.height = newHeight + "px";
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });

      // Add a delete button.
      let deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete Image";
      deleteBtn.className = "delete-image"; // Unique class for targeting
      deleteBtn.style.fontSize = "10px";
      deleteBtn.style.position = "absolute";
      deleteBtn.style.top = "0";
      deleteBtn.style.right = "0";
      deleteBtn.style.pointerEvents = "auto";
      deleteBtn.onclick = function(e) {
        e.stopPropagation();
        container.remove();
      };
      container.appendChild(deleteBtn);
      
      // Update the SVG content.
      updateImageCodeElement(container);
      
      // Append the container to the answer option.
      parent.appendChild(container);
    }
  );
}



// (Optional) Function to edit image code later.
function editImageCode(container) {
  const currentCode = container.dataset.imageCode || container.querySelector('.element-content').innerHTML;
  showImageCodeModal(currentCode, function(newCode) {
    if (!newCode) return;
    container.dataset.imageCode = newCode;
    container.dataset.originalImageCode = newCode; // Update the original code too
    container.querySelector('.element-content').innerHTML = newCode;
  });
}

// Helper function to shuffle an array (Fisher–Yates shuffle)
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
// Returns the current variable mode ("ui" or "code")
function getVariableMode() {
  let modeRadio = document.querySelector('input[name="variable-mode"]:checked');
  return modeRadio ? modeRadio.value : "ui";
}

// Updates the variable section display based on the selected mode
function updateVariableModeUI() {
  let mode = getVariableMode();
  if (mode === "code") {
    document.getElementById("variable-ui-container").style.display = "none";
    document.getElementById("variable-code-container").style.display = "block";
  } else {
    document.getElementById("variable-ui-container").style.display = "block";
    document.getElementById("variable-code-container").style.display = "none";
  }
  updateVariables();
}

// Attach change listeners to the mode radio buttons
document.querySelectorAll('input[name="variable-mode"]').forEach(radio => {
  radio.addEventListener("change", updateVariableModeUI);
});

function computeAnswerOptions(computedVars) {
  let options = [];
  const correctContainer = document.getElementById("mc-correct");
  const incorrectContainer = document.getElementById("mc-incorrect");

  function processOption(optionNode, isCorrect) {
    // Clone the option so we don’t affect the editor.
    let cloneOption = optionNode.cloneNode(true);

    // Remove editing controls (toolbar, graph/table buttons, etc.).
    let editors = cloneOption.querySelectorAll(".mc-option-toolbar, .edit-graph, .delete-graph, .edit-table, .delete-table");
    editors.forEach(el => el.remove());

    // Remove the required checkbox container.
    let reqContainers = cloneOption.querySelectorAll(".option-required-edit");
    reqContainers.forEach(el => el.remove());

    // Handle text boxes: remove toolbar and outline.
    let textBoxes = cloneOption.querySelectorAll(".draggable-text-box");
    textBoxes.forEach(textBox => {
      let toolbar = textBox.querySelector(".answer-text-toolbar");
      if (toolbar) toolbar.remove();
      let resizeHandle = textBox.querySelector(".resize-handle");
      if (resizeHandle) resizeHandle.remove();
      let textArea = textBox.querySelector(".text-box");
      if (textArea) {
        textArea.style.border = "none";
        textArea.style.outline = "none";
        textArea.contentEditable = false;
      }
      textBox.style.border = "none";
      textBox.style.background = "transparent";
      textBox.style.marginLeft = "0";
    });

    // Handle images with code: remove drag handle, resize handle, and delete button.
    let imageContainers = cloneOption.querySelectorAll(".draggable-answer-image");
    imageContainers.forEach(imageContainer => {
      // Remove drag handle.
      let dragHandle = imageContainer.querySelector(".drag-handle");
      if (dragHandle) dragHandle.remove();

      // Remove resize handle.
      let resizeHandle = imageContainer.querySelector(".resize-handle");
      if (resizeHandle) resizeHandle.remove();

      // Remove delete button.
      let deleteBtn = imageContainer.querySelector(".delete-image");
      if (deleteBtn) deleteBtn.remove();

      // Update the SVG with computed variables and clean up styling.
      updateImageCodeElement(imageContainer, computedVars);
      imageContainer.style.border = "none";
      imageContainer.style.background = "transparent";
      imageContainer.contentEditable = false;
    });

    // Process rich content if present.
    let graphElem = cloneOption.querySelector(".answer-graph");
    if (graphElem) {
      updateGraphInAnswerOption(graphElem, computedVars);
      let graphBtns = graphElem.querySelectorAll("button.edit-graph, button.delete-graph");
      graphBtns.forEach(btn => btn.remove());
      options.push({ 
        html: graphElem.outerHTML, 
        correct: isCorrect, 
        required: optionNode.getAttribute("data-required") === "true" 
      });
    } else {
      let contentHTML = substituteValue(cloneOption.innerHTML, computedVars);
      options.push({ 
        html: contentHTML, 
        correct: isCorrect, 
        required: optionNode.getAttribute("data-required") === "true" 
      });
    }
  }

  // Process all answer options.
  correctContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, true));
  incorrectContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, false));

  // Get global settings.
  let totalOptions = parseInt(document.getElementById("mc-total-options").value) || options.length;
  let correctMin = parseInt(document.getElementById("mc-correct-min").value) || 0;
  let correctMax = parseInt(document.getElementById("mc-correct-max").value) || 0;

  // Separate options into groups.
  let reqCorrect = options.filter(opt => opt.correct && opt.required);
  let optCorrect = options.filter(opt => opt.correct && !opt.required);
  let reqIncorrect = options.filter(opt => !opt.correct && opt.required);
  let optIncorrect = options.filter(opt => !opt.correct && !opt.required);

  // Randomly choose a number of correct options within the given range.
  let numCorrectDesired = correctMin;
  if (correctMax > correctMin) {
    numCorrectDesired = Math.floor(Math.random() * (correctMax - correctMin + 1)) + correctMin;
  }

  // Build final correct options.
  let selectedCorrect = reqCorrect.slice();
  let additionalCorrectNeeded = numCorrectDesired - selectedCorrect.length;
  if (additionalCorrectNeeded > 0) {
    let shuffledOptCorrect = shuffleArray(optCorrect.slice());
    selectedCorrect = selectedCorrect.concat(shuffledOptCorrect.slice(0, additionalCorrectNeeded));
  }

  // Determine number of incorrect options needed.
  let numIncorrectDesired = totalOptions - selectedCorrect.length;
  let selectedIncorrect = reqIncorrect.slice();
  let additionalIncorrectNeeded = numIncorrectDesired - selectedIncorrect.length;
  if (additionalIncorrectNeeded > 0) {
    let shuffledOptIncorrect = shuffleArray(optIncorrect.slice());
    selectedIncorrect = selectedIncorrect.concat(shuffledOptIncorrect.slice(0, additionalIncorrectNeeded));
  }

  // Combine and shuffle final options.
  let finalOptions = selectedCorrect.concat(selectedIncorrect);
  finalOptions = shuffleArray(finalOptions);
  window.currentAnswerOptions = finalOptions;
  return finalOptions;
}

function exitOnArrowRight(e) {
  if (e.key === "ArrowRight") {
    // Get the current selection and range
    const sel = window.getSelection();
    if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    const target = e.target;
    
    // Check if the caret is at the end of the element's text content
    if (range.endOffset >= target.textContent.length) {
      // Insert a space (or empty text node) after the current element
      let space = document.createTextNode(" ");
      target.parentNode.insertBefore(space, target.nextSibling);
      
      // Move the caret after the space
      range.setStartAfter(space);
      range.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range);
      e.preventDefault();
    }
  }
}
// Generates an interactive quiz (as HTML) based on the current answer configuration.
function generateAnswerQuiz(computedVars) {
  const answerType = document.getElementById("answer-type").value;
  let container = document.createElement("div");
  container.className = "answer-quiz";
  container.style.marginTop = "10px";

  if (answerType === "box") {
    // For answer boxes, do not display the correct answer in the preview.
    // (We compute it for possible use elsewhere but do not show it here.)
    let correctAns = substituteValue(document.getElementById("correct-answer").value, computedVars);
    let labelText = substituteValue(document.getElementById("label-text").value, computedVars);
    let labelPosition = document.getElementById("label-position").value;

    let inputBox = document.createElement("input");
    inputBox.type = "text";
    inputBox.style.width = "300px";
    // Instead of setting the placeholder to the correct answer, leave it empty or use a generic prompt.
    inputBox.placeholder = ""; // or you can use "Your Answer" if you prefer

    if (labelText && labelPosition === "before") {
      let label = document.createElement("span");
      label.textContent = labelText + " ";
      container.appendChild(label);
      container.appendChild(inputBox);
    } else if (labelText && labelPosition === "after") {
      container.appendChild(inputBox);
      let label = document.createElement("span");
      label.textContent = " " + labelText;
      container.appendChild(label);
    } else {
      container.appendChild(inputBox);
    }
  } else if (answerType === "multiple" || answerType === "multi-select") {
    // For multiple choice / multi-select, render each option on its own line.
    let options = window.currentAnswerOptions || computeAnswerOptions(computedVars);
    let form = document.createElement("form");
    let inputType = (answerType === "multiple") ? "radio" : "checkbox";
    let letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    options.forEach((option, index) => {
      let wrapper = document.createElement("div");
      // Each option appears on its own line.
      wrapper.style.display = "block";
      wrapper.style.marginBottom = "5px";

      let input = document.createElement("input");
      input.type = inputType;
      input.name = "quizOption";
      input.value = index;

      let optionLabel = document.createElement("label");
      // Build the label with the answer letter and the option content on the same line.
      optionLabel.innerHTML = "<span style='display:inline-block; vertical-align:middle;'>" + letters[index] + ". </span>" +
                              "<span style='display:inline-block; vertical-align:middle;'>" + option.html + "</span>";
      optionLabel.style.marginLeft = "5px";
      optionLabel.style.display = "inline-block";
      optionLabel.style.verticalAlign = "middle";

      wrapper.appendChild(input);
      wrapper.appendChild(optionLabel);
      form.appendChild(wrapper);
    });
    container.appendChild(form);
  }

  return container;
}

// Helper for "choose from list" (words)
function chooseFromWordList() {
  var args = Array.prototype.slice.call(arguments);
  if (args.length === 0) return "";
  return args[Math.floor(Math.random() * args.length)];
}

// Helper for "choose from list" (numbers)
function chooseFromNumberList() {
  var args = Array.prototype.slice.call(arguments);
  if (args.length === 0) return "";
  return args[Math.floor(Math.random() * args.length)];
}
// Helper for computing the greatest common divisor (already in your code)
function gcd(a, b) { return b ? gcd(b, a % b) : a; }

// ------------------ Fraction Helpers ------------------

// Returns an unreduced fraction string.
function unreducedfraction(num, denom) {
  return num + "/" + denom;
}

// Returns a reduced fraction string (improper fraction) by dividing numerator and denominator by their gcd.
function reduceFraction(num, denom) {
  let g = gcd(num, denom);
  return (num / g) + "/" + (denom / g);
}

// Returns a mixed fraction string.
// If the fraction is proper, it returns "whole remainder/denom" (with the fractional part reduced).
function mixedFraction(num, denom) {
  let whole = Math.floor(num / denom);
  let remainder = num % denom;
  if (remainder === 0) {
    return whole.toString();
  }
  let g = gcd(remainder, denom);
  return whole + " " + (remainder / g) + "/" + (denom / g);
}

// ------------------ Arranging Helpers ------------------

// Takes a comma-separated string (e.g., "1, 4, 2") and returns a comma-separated string arranged in ascending order.
function arrangeAscending(list) {
  let arr = list.split(",").map(item => item.trim());
  // If all elements can be converted to numbers, sort numerically.
  if (arr.every(x => !isNaN(x) && x !== "")) {
    arr = arr.map(Number).sort((a, b) => a - b);
  } else {
    arr.sort();
  }
  return arr.join(", ");
}

// Takes a comma-separated string and returns it arranged in descending order.
function arrangeDescending(list) {
  let arr = list.split(",").map(item => item.trim());
  if (arr.every(x => !isNaN(x) && x !== "")) {
    arr = arr.map(Number).sort((a, b) => b - a);
  } else {
    arr.sort().reverse();
  }
  return arr.join(", ");
}
/******** Utility Functions ********/
// Formats fractions if the string is in "num/den" format.
function formatFraction(fracStr) {
  let match = fracStr.match(/^(\d+(?:\.\d+)?)\/(\d+(?:\.\d+)?)$/);
  if (match) {
    // If the denominator is 1, just return the numerator.
    if (parseFloat(match[2]) === 1) {
      return match[1];
    }
    return `<span class="fraction"><span class="num">${match[1]}</span><span class="den">${match[2]}</span></span>`;
  }
  return fracStr;
}
function formatUsingFractionJS(fracStr) {
  try {
    let f = new Fraction(fracStr);
    // If the denominator is 1, return just the numerator.
    if (f.d === 1) {
      return f.n.toString();
    }
    return f.toFraction();
  } catch (e) {
    console.error("Invalid fraction", fracStr);
    return fracStr;
  }
}


// Substitutes {variable} placeholders using values from computed object.
function substituteValue(str, computed) {
  const cache = {};
  return str.replace(/(?<!\\)\{([^}:]+)(:plain)?\}/g, (match, p1, plainFlag) => {
    let expr = p1.trim();
    if (computed.hasOwnProperty(expr) && computed[expr] != null) {
      let val = computed[expr].toString();
      return plainFlag ? val : formatFraction(val);
    }
    if (cache.hasOwnProperty(expr)) {
      let cachedVal = cache[expr];
      return plainFlag ? cachedVal.toString() : formatFraction(cachedVal.toString());
    }
    try {
      let value = new Function("with(this){ return " + expr + "; }").call(computed);
      cache[expr] = value;
      if (value == null) {
        return "";
      }
      let valStr = value.toString();
      return plainFlag ? valStr : formatFraction(valStr);
    } catch (e) {
      return match;
    }
  });
}

function updateImageCodeElement(container, computedVars) {
  // Use the stored original template code (with placeholders)
  var rawCode = container.dataset.originalImageCode;
  if (!rawCode) return;
  
  if (!computedVars) {
    computedVars = computeAllVariables();
  }
  
  var substitutedCode = substituteValue(rawCode, computedVars);
  
  var parser = new DOMParser();
  var doc = parser.parseFromString(substitutedCode, "image/svg+xml");
  var newSVG = doc.documentElement;
  
  var contentDiv = container.querySelector(".element-content");
  if (contentDiv) {
    contentDiv.innerHTML = "";
    contentDiv.appendChild(newSVG);
  }
}

// Parses a graph equation string into a function f(x)
function parseEquation(eqStr) {
  eqStr = eqStr.trim();
  if (eqStr.toLowerCase().startsWith("y=")) { eqStr = eqStr.substring(2); }
  eqStr = eqStr.replace(/(\d)([a-zA-Z\(])/g, '$1*$2');
  eqStr = eqStr.replace(/\)([a-zA-Z])/g, ')*$1');
  eqStr = eqStr.replace(/([a-zA-Z0-9\.\)\]])\^([a-zA-Z0-9\.\(])/g, 'Math.pow($1,$2)');
  eqStr = eqStr.replace(/sqrt\(/gi, 'Math.sqrt(');
  try {
    let f = new Function('x', 'return ' + eqStr + ';');
    f(1);
    return f;
  } catch(e) { return null; }
}
/******** Hide/Show Controls ********/
// Hides all element controls and line endpoints.
// Hide all element controls and SVG endpoints.
function hideAllControls() {
  document.querySelectorAll(".element-controls").forEach(ctrl => {
    ctrl.style.display = "none";
  });
  // Hide endpoints in all SVGs inside line containers.
  document.querySelectorAll(".line-container svg").forEach(svg => {
    if (svg.currentLine) {
      if (svg.endpoint1) svg.endpoint1.style.display = "none";
      if (svg.endpoint2) svg.endpoint2.style.display = "none";
    }
  });
}

// Immediately highlight the active element using an outline.
function highlightActiveElement() {
  // Remove previous outlines.
  document.querySelectorAll("#problem-canvas .draggable-element").forEach(el => {
    el.style.outline = "";
  });
  // Apply a visible outline to the active element.
  if (activeElement) {
    activeElement.style.outline = "2px solid #00aaff";
  }
}


document.addEventListener('click', () => hideAllControls());

function raiseElementTemporarily(element) {
  if (!element) return;
  
  // If not already stored, save the original z-index
  if (!element.dataset.originalZ) {
    element.dataset.originalZ = element.style.zIndex || "1";
  }
  
  // Mark as temporarily raised
  element.dataset.tempRaised = "true";
  
  // Set a very high z-index to ensure it's on top
  const highZIndex = (1000000 + Date.now() % 1000).toString();
  element.style.zIndex = highZIndex;
  
  // IMPORTANT: Make the toolbar's z-index even higher
  const toolbar = element.querySelector('.element-controls');
  if (toolbar) {
    // Store the toolbar's original z-index if not already saved
    if (!toolbar.dataset.originalZ) {
      toolbar.dataset.originalZ = toolbar.style.zIndex || "auto";
    }
    
    // Ensure the toolbar has a higher z-index than the element
    toolbar.style.zIndex = (parseInt(highZIndex) + 1000).toString();
    
    // Also ensure the toolbar is displayed
    toolbar.style.display = "flex";
  }
}

function restoreElementZIndex(element) {
  if (!element || !element.dataset.tempRaised) return;
  
  // Restore original z-index
  if (element.dataset.originalZ) {
    element.style.zIndex = element.dataset.originalZ;
  }
  
  // Also restore the toolbar's z-index
  const toolbar = element.querySelector('.element-controls');
  if (toolbar && toolbar.dataset.originalZ) {
    toolbar.style.zIndex = toolbar.dataset.originalZ;
  }
  
  // Remove temporary raise marker
  delete element.dataset.tempRaised;
}

/******** Element Deletion ********/
function deleteElement(button) {
  let container = button.closest('.draggable-element');
  if (container) container.remove();
}
function deleteActiveElement() {
  if (activeElement) { activeElement.remove(); activeElement = null; activeTextBox = null; }
}

function deleteVariable(varName) {
  // Remove the variable's DOM element.
  const elem = document.getElementById("var-item-" + varName);
  if (elem) {
    elem.remove();
  }
  // Optionally, remove the variable definition from your objects.
  if (varDefinitions.hasOwnProperty(varName)) {
    delete varDefinitions[varName];
  }
  if (computedValues.hasOwnProperty(varName)) {
    delete computedValues[varName];
  }
  // Re-run updateVariables to re-compute any substitutions.
  updateVariables();
}


/******** Draggable Functionality ********/
function makeDraggable(handle, container) {
  handle.addEventListener("mousedown", function(e) {
    // If this container isn't already active, hide controls on others.
    if (activeElement !== container) {
      hideAllControls();
    }
    
    // Set this as the active element
    activeElement = container;
    
    // Raise it to the top
    raiseElementTemporarily(container);
    
    let startX = e.clientX,
        startY = e.clientY;
    let origX = parseInt(container.style.left) || 0,
        origY = parseInt(container.style.top) || 0;
    
    // Reset the dragging flag.
    isDragging = false;
    
    function onMouseMove(e) {
      let dx = e.clientX - startX,
          dy = e.clientY - startY;
      // If movement exceeds threshold, mark as dragging.
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
        isDragging = true;
      }
      container.style.left = (origX + dx) + "px";
      container.style.top = (origY + dy) + "px";
    }
    
    function onMouseUp(e) {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      
      if (isDragging) {
        // If we dragged, prevent the next click from selecting a different element
        ignoreNextClick = true;
        
        // Important: Add this to keep focus on the dragged element
        e.stopPropagation();
        
        // Add a small delay before resetting isDragging
        setTimeout(() => {
          isDragging = false;
        }, 200);
      }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    e.stopPropagation();
  });
}


/******** Create Draggable Element ********/
// Modified dragEndpoint that calls our expand helper on every mouse move.

  
// Modified dragEndpoint that calls our expand helper on every mouse move.
 // Global flag

function dragEndpoint(e, endpoint, line, whichEnd, svgContainer) {
  e.stopPropagation();
  e.preventDefault();
  
  let hasDragged = false;  // Track if the endpoint was actually moved
  
  // Get initial positions and calculate offsets…
  const svgRect = svgContainer.getBoundingClientRect();
  const initialCX = parseFloat(endpoint.getAttribute("cx"));
  const initialCY = parseFloat(endpoint.getAttribute("cy"));
  
  let viewBox = svgContainer.getAttribute("viewBox");
  let [vbX, vbY, vbWidth, vbHeight] = viewBox.split(" ").map(Number);
  const scaleX = vbWidth / svgContainer.clientWidth;
  const scaleY = vbHeight / svgContainer.clientHeight;
  
  const startMouseSVGX = (e.clientX - svgRect.left) * scaleX + vbX;
  const startMouseSVGY = (e.clientY - svgRect.top) * scaleY + vbY;
  const offsetX = initialCX - startMouseSVGX;
  const offsetY = initialCY - startMouseSVGY;
  
  function onMouseMove(e) {
    hasDragged = true;  // Mark that a drag occurred
    const mouseSVGX = (e.clientX - svgRect.left) * scaleX + vbX;
    const mouseSVGY = (e.clientY - svgRect.top) * scaleY + vbY;
    const newCX = mouseSVGX + offsetX;
    const newCY = mouseSVGY + offsetY;
    
    // Update the endpoint and the corresponding end of the line.
    endpoint.setAttribute("cx", newCX);
    endpoint.setAttribute("cy", newCY);
    if (whichEnd === "start") {
      line.setAttribute("x1", newCX);
      line.setAttribute("y1", newCY);
    } else {
      line.setAttribute("x2", newCX);
      line.setAttribute("y2", newCY);
    }
    
    updateLineContainer(svgContainer);
  }
  
  function onMouseUp(e) {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    
    // If a drag occurred, set the flag to ignore the next click.
    if (hasDragged) {
      ignoreNextClick = true;
    }
    
    // Ensure the active element remains focused.
    if (activeElement) {
      activeElement.focus();
    }
    
    e.stopPropagation();
    e.preventDefault();
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
}


function updateLineContainer(svgContainer) {
  const line = svgContainer.currentLine;
  if (!line) return;

  // Get current endpoint coordinates.
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));

  // Calculate bounding box with fixed padding.
  const padding = 20;
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);

  const newWidth = (maxX - minX) + 2 * padding;
  const newHeight = (maxY - minY) + 2 * padding;

  // Update the SVG element.
  svgContainer.setAttribute("width", newWidth);
  svgContainer.setAttribute("height", newHeight);
  svgContainer.setAttribute("viewBox", `${minX - padding} ${minY - padding} ${newWidth} ${newHeight}`);

  // Update the outer container.
  const outerContainer = svgContainer.closest('.line-container');
  if (outerContainer) {
    outerContainer.style.left = (minX - padding) + "px";
    outerContainer.style.top  = (minY - padding) + "px";
    outerContainer.style.width = newWidth + "px";
    const toolbarHeight = 20; // Fixed toolbar height.
    outerContainer.style.height = (toolbarHeight + newHeight) + "px";

    // Force the toolbar inside the container to have a fixed width.
    const toolbar = outerContainer.querySelector('.line-toolbar');
    if (toolbar) {
      toolbar.style.width = "400px"; // Set to your fixed width.
    }
  }
}


// Helper: expand the SVG viewBox (and outer container) if the line’s endpoints are too close
// to or beyond the current boundaries. We use the line’s bounding box.
function expandContainerIfNeeded(svgContainer) {
  const line = svgContainer.currentLine;
  if (!line) return;
  
  // Get the bounding box of the line (in current SVG coordinates)
  const bbox = line.getBBox();
  const padding = 20; // extra space in SVG coordinate units
  
  // Get current viewBox
  let viewBox = svgContainer.getAttribute("viewBox");
  let [vbX, vbY, vbWidth, vbHeight] = viewBox.split(" ").map(Number);
  
  let needUpdate = false;
  let newVbX = vbX, newVbY = vbY, newVbWidth = vbWidth, newVbHeight = vbHeight;
  
  // If the left side of the line (bbox.x) is too close to the left boundary...
  if (bbox.x < vbX + padding) {
    newVbX = bbox.x - padding;
    newVbWidth = (vbX + vbWidth) - newVbX;
    needUpdate = true;
  }
  // If the top side is too close to the top boundary...
  if (bbox.y < vbY + padding) {
    newVbY = bbox.y - padding;
    newVbHeight = (vbY + vbHeight) - newVbY;
    needUpdate = true;
  }
  // If the right side exceeds the current boundary...
  if (bbox.x + bbox.width > vbX + vbWidth - padding) {
    newVbWidth = (bbox.x + bbox.width + padding) - vbX;
    needUpdate = true;
  }
  // If the bottom side exceeds the current boundary...
  if (bbox.y + bbox.height > vbY + vbHeight - padding) {
    newVbHeight = (bbox.y + bbox.height + padding) - vbY;
    needUpdate = true;
  }
  
  if (needUpdate) {
    // Update the SVG's viewBox and its width/height attributes.
    svgContainer.setAttribute("viewBox", `${newVbX} ${newVbY} ${newVbWidth} ${newVbHeight}`);
    svgContainer.setAttribute("width", newVbWidth);
    svgContainer.setAttribute("height", newVbHeight);
    
    // Also update the outer container (the div wrapping the SVG, e.g., .line-container)
    const outerContainer = svgContainer.closest('.line-container');
    if (outerContainer) {
      const toolbarHeight = 20; // fixed toolbar height
      outerContainer.style.left = newVbX + "px";
      outerContainer.style.top  = newVbY + "px";
      outerContainer.style.width  = newVbWidth + "px";
      outerContainer.style.height = (newVbHeight + toolbarHeight) + "px";
    }
  }
}


// New helper function to adjust the container
function adjustSVGContainer(svgElement) {
  const line = svgElement.currentLine;
  if (!line) return;
  
  // Get the current endpoint positions (in SVG coordinates)
  const x1 = parseFloat(line.getAttribute("x1"));
  const y1 = parseFloat(line.getAttribute("y1"));
  const x2 = parseFloat(line.getAttribute("x2"));
  const y2 = parseFloat(line.getAttribute("y2"));
  
  // Determine the bounding box of the line and add padding
  const padding = 20;
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);
  const newWidth = (maxX - minX) + 2 * padding;
  const newHeight = (maxY - minY) + 2 * padding;
  
  // Update the SVG: set the viewBox so that (0,0) is at (minX - padding, minY - padding)
  svgElement.setAttribute("width", newWidth);
  svgElement.setAttribute("height", newHeight);
  svgElement.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);
  
  // Offset the line (and endpoints) so that they remain in the same place relative to the canvas.
  line.setAttribute("x1", x1 - minX + padding);
  line.setAttribute("y1", y1 - minY + padding);
  line.setAttribute("x2", x2 - minX + padding);
  line.setAttribute("y2", y2 - minY + padding);
  if (svgElement.endpoint1) {
    svgElement.endpoint1.setAttribute("cx", x1 - minX + padding);
    svgElement.endpoint1.setAttribute("cy", y1 - minY + padding);
  }
  if (svgElement.endpoint2) {
    svgElement.endpoint2.setAttribute("cx", x2 - minX + padding);
    svgElement.endpoint2.setAttribute("cy", y2 - minY + padding);
  }
  
  // Adjust the outer container’s position and size.
  const toolbarHeight = 20;
  const outerContainer = svgElement.closest('.draggable-element');
  if (outerContainer) {
    // Shift the container’s left and top by (minX - padding, minY - padding)
    let currentLeft = parseFloat(outerContainer.style.left) || 0;
    let currentTop = parseFloat(outerContainer.style.top) || 0;
    outerContainer.style.left = (currentLeft + minX - padding) + "px";
    outerContainer.style.top = (currentTop + minY - padding) + "px";
    outerContainer.style.width = newWidth + "px";
    outerContainer.style.height = (newHeight + toolbarHeight) + "px";
  }
}

/******** Add Elements ********/
function addTextBox() {
  const canvas = document.getElementById('problem-canvas');
  const box = createDraggableElement('Type here... (use {variable} notation)', true);
  canvas.appendChild(box);
  updateVariables();
}

function addCircle() {
  const canvas = document.getElementById("problem-canvas");
  const problemToolbar = document.querySelector("#problem-image .toolbar");
  const problemToolbarHeight = problemToolbar ? problemToolbar.offsetHeight : 0;
  const toolbarHeight = 20; // Fixed toolbar height

  // Create the outer container.
  const container = document.createElement("div");
  container.className = "draggable-element circle-container";
  container.style.position = "absolute";
  container.style.left = `${nextElementOffset}px`;
  container.style.top = `${nextElementOffset}px`;
  container.style.width = "150px";
  container.style.height = "170px"; // Toolbar + content
  nextElementOffset += 10;


  container.addEventListener("click", function(e) {
  e.stopPropagation();
  activeElement = container;
  raiseElementTemporarily(container);
  highlightActiveElement();
});

// After creating and configuring the container...



  // Store initial properties in dataset
  container.dataset.fillColor = "transparent"; // Default circle fill
  container.dataset.strokeColor = "#000000";   // Default stroke
  container.dataset.pieFills = JSON.stringify([]); // Array to store pie wedge fills

  // Create the toolbar.
  const toolbar = document.createElement("div");
  toolbar.className = "circle-toolbar element-controls";
  toolbar.style.height = toolbarHeight + "px";
  toolbar.style.width = "150px";
  toolbar.style.boxSizing = "border-box";
  toolbar.style.backgroundColor = "#f0f0f0";
  toolbar.style.display = "none"; // Initially hidden
  toolbar.style.alignItems = "center";
  toolbar.style.flexShrink = "0";

  // Left controls container.
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  leftControls.style.flex = "1";

  // Drag handle.
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);

  // Stroke control.
  const strokeGroup = document.createElement("div");
  strokeGroup.style.display = "flex";
  strokeGroup.style.alignItems = "center";
  strokeGroup.style.marginRight = "5px";
  const strokeLabel = document.createElement("span");
  strokeLabel.textContent = "Line:";
  strokeLabel.style.fontSize = "12px";
  strokeGroup.appendChild(strokeLabel);
  const strokeDisplay = document.createElement("div");
  strokeDisplay.className = "stroke-display";
  strokeDisplay.style.width = "20px";
  strokeDisplay.style.height = "20px";
  strokeDisplay.style.backgroundColor = container.dataset.strokeColor;
  strokeDisplay.style.cursor = "pointer";
  strokeDisplay.style.border = "1px solid #ccc";
  strokeDisplay.style.marginLeft = "3px";
  strokeGroup.appendChild(strokeDisplay);
  leftControls.appendChild(strokeGroup);

  // Fill control.
  const fillGroup = document.createElement("div");
  fillGroup.style.display = "flex";
  fillGroup.style.alignItems = "center";
  fillGroup.style.marginRight = "5px";
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Shade:";
  fillLabel.style.fontSize = "12px";
  fillGroup.appendChild(fillLabel);
  const fillDisplay = document.createElement("div");
  fillDisplay.className = "fill-display";
  fillDisplay.style.width = "20px";
  fillDisplay.style.height = "20px";
  fillDisplay.style.backgroundColor = "#ffffff"; // Visual default
  fillDisplay.style.cursor = "pointer";
  fillDisplay.style.border = "1px solid #ccc";
  fillDisplay.style.marginLeft = "3px";
  fillGroup.appendChild(fillDisplay);
  leftControls.appendChild(fillGroup);

  // Show Center control.
  const centerGroup = document.createElement("div");
  centerGroup.style.display = "flex";
  centerGroup.style.alignItems = "center";
  centerGroup.style.marginRight = "5px";
  const centerLabel = document.createElement("span");
  centerLabel.textContent = "Show Center:";
  centerLabel.style.fontSize = "12px";
  centerLabel.style.backgroundColor = "#f0f0f0";
  centerLabel.style.padding = "0 2px";
  centerGroup.appendChild(centerLabel);
  const showCenterSelect = document.createElement("select");
  showCenterSelect.className = "show-center";
  showCenterSelect.style.marginLeft = "3px";
  showCenterSelect.style.fontSize = "12px";
  const centerYes = document.createElement("option");
  centerYes.value = "yes";
  centerYes.textContent = "Yes";
  const centerNo = document.createElement("option");
  centerNo.value = "no";
  centerNo.textContent = "No";
  showCenterSelect.appendChild(centerYes);
  showCenterSelect.appendChild(centerNo);
  centerGroup.appendChild(showCenterSelect);
  leftControls.appendChild(centerGroup);

  // Draw Radius control.
  const radiusGroup = document.createElement("div");
  radiusGroup.style.display = "flex";
  radiusGroup.style.alignItems = "center";
  radiusGroup.style.marginRight = "5px";
  const radiusLabel = document.createElement("span");
  radiusLabel.textContent = "Draw Radius:";
  radiusLabel.style.fontSize = "12px";
  radiusLabel.style.backgroundColor = "#f0f0f0";
  radiusLabel.style.padding = "0 2px";
  radiusGroup.appendChild(radiusLabel);
  const drawRadiusSelect = document.createElement("select");
  drawRadiusSelect.className = "draw-radius";
  drawRadiusSelect.style.marginLeft = "3px";
  drawRadiusSelect.style.fontSize = "12px";
  const radiusYes = document.createElement("option");
  radiusYes.value = "yes";
  radiusYes.textContent = "Yes";
  const radiusNo = document.createElement("option");
  radiusNo.value = "no";
  radiusNo.textContent = "No";
  drawRadiusSelect.appendChild(radiusYes);
  drawRadiusSelect.appendChild(radiusNo);
  radiusGroup.appendChild(drawRadiusSelect);
  leftControls.appendChild(radiusGroup);

  // Draw Diameter control.
  const diameterGroup = document.createElement("div");
  diameterGroup.style.display = "flex";
  diameterGroup.style.alignItems = "center";
  diameterGroup.style.marginRight = "5px";
  const diameterLabel = document.createElement("span");
  diameterLabel.textContent = "Draw Diameter:";
  diameterLabel.style.fontSize = "12px";
  diameterLabel.style.backgroundColor = "#f0f0f0";
  diameterLabel.style.padding = "0 2px";
  diameterGroup.appendChild(diameterLabel);
  const drawDiameterSelect = document.createElement("select");
  drawDiameterSelect.className = "draw-diameter";
  drawDiameterSelect.style.marginLeft = "3px";
  drawDiameterSelect.style.fontSize = "12px";
  const diameterYes = document.createElement("option");
  diameterYes.value = "yes";
  diameterYes.textContent = "Yes";
  const diameterNo = document.createElement("option");
  diameterNo.value = "no";
  diameterNo.textContent = "No";
  drawDiameterSelect.appendChild(diameterYes);
  drawDiameterSelect.appendChild(diameterNo);
  diameterGroup.appendChild(drawDiameterSelect);
  leftControls.appendChild(diameterGroup);

  // Pie Pieces control.
  const pieGroup = document.createElement("div");
  pieGroup.style.display = "flex";
  pieGroup.style.alignItems = "center";
  pieGroup.style.marginRight = "5px";
  const pieLabel = document.createElement("span");
  pieLabel.textContent = "Pie Pieces:";
  pieLabel.style.fontSize = "12px";
  pieLabel.style.backgroundColor = "#f0f0f0";
  pieLabel.style.padding = "0 2px";
  pieGroup.appendChild(pieLabel);
  const pieInput = document.createElement("input");
  pieInput.type = "number";
  pieInput.min = "0";
  pieInput.value = "0";
  pieInput.style.width = "40px";
  pieInput.style.marginLeft = "3px";
  pieInput.style.fontSize = "12px";
  pieGroup.appendChild(pieInput);
  leftControls.appendChild(pieGroup);

  // Add "Shade Pieces" button.
  const shadePiecesBtn = document.createElement("button");
  shadePiecesBtn.textContent = "Shade Pieces";
  shadePiecesBtn.style.fontSize = "12px";
  shadePiecesBtn.style.marginRight = "5px";
  leftControls.appendChild(shadePiecesBtn);

  // Automate button.
  const automateBtn = document.createElement("button");
  automateBtn.textContent = "Automate";
  automateBtn.className = "automate-btn";
  automateBtn.style.fontSize = "12px";
  automateBtn.style.marginRight = "5px";
  leftControls.appendChild(automateBtn);

  // Right controls container: delete button.
  const rightControls = document.createElement("div");
  rightControls.style.flexShrink = "0";
  const deleteButton = document.createElement("button");
  deleteButton.className = "delete-button";
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  rightControls.appendChild(deleteButton);

  // Assemble the toolbar.
  toolbar.appendChild(leftControls);
  toolbar.appendChild(rightControls);
  container.appendChild(toolbar);

  // Create a content div for the SVG and center marker.
  const content = document.createElement("div");
  content.className = "circle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create the SVG element.
  const svgWidth = 150;
  const svgHeight = 150;
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Create the circle.
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  const center = { x: 0.5, y: 0.5 };
  let pieWedges = []; // Array to hold pie wedge elements
  let radiusLine = null;
  let diameterLine = null;

  function updateCircle() {
    const w = svg.clientWidth || svgWidth;
    const h = svg.clientHeight || svgHeight;
    const radius = Math.min(w, h) * 0.45;
    circle.setAttribute("cx", center.x * w);
    circle.setAttribute("cy", center.y * h);
    circle.setAttribute("r", radius);
    circle.setAttribute("stroke", container.dataset.strokeColor);
    circle.setAttribute("stroke-width", "2");
    circle.setAttribute("fill", container.dataset.fillColor); // Apply stored fill
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    svg.setAttribute("width", w);
    svg.setAttribute("height", h);

    // Update radius line
    if (radiusLine && drawRadiusSelect.value === "yes" && pieInput.value == "0") {
      radiusLine.setAttribute("x1", center.x * w);
      radiusLine.setAttribute("y1", center.y * h);
      radiusLine.setAttribute("x2", center.x * w + radius);
      radiusLine.setAttribute("y2", center.y * h);
      radiusLine.setAttribute("stroke", container.dataset.strokeColor);
    } else if (radiusLine && (drawRadiusSelect.value === "no" || pieInput.value != "0")) {
      radiusLine.remove();
      radiusLine = null;
    }

    // Update diameter line
    if (diameterLine && drawDiameterSelect.value === "yes" && pieInput.value == "0") {
      diameterLine.setAttribute("x1", center.x * w - radius);
      diameterLine.setAttribute("y1", center.y * h);
      diameterLine.setAttribute("x2", center.x * w + radius);
      diameterLine.setAttribute("y2", center.y * h);
      diameterLine.setAttribute("stroke", container.dataset.strokeColor);
    } else if (diameterLine && (drawDiameterSelect.value === "no" || pieInput.value != "0")) {
      diameterLine.remove();
      diameterLine = null;
    }

    // Update pie wedges
    pieWedges.forEach(wedge => wedge.remove());
    pieWedges.length = 0;
    const pieces = parseInt(pieInput.value) || 0;
    const pieFills = JSON.parse(container.dataset.pieFills || "[]");
    if (pieces > 0) {
      const angleStep = (2 * Math.PI) / pieces;
      for (let i = 0; i < pieces; i++) {
        const startAngle = i * angleStep;
        const endAngle = (i + 1) * angleStep;
        const x1 = center.x * w + radius * Math.cos(startAngle);
        const y1 = center.y * h + radius * Math.sin(startAngle);
        const x2 = center.x * w + radius * Math.cos(endAngle);
        const y2 = center.y * h + radius * Math.sin(endAngle);
        
        const wedge = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const d = `M ${center.x * w} ${center.y * h} ` +
                  `L ${x1} ${y1} ` +
                  `A ${radius} ${radius} 0 0 1 ${x2} ${y2} ` +
                  `Z`;
        wedge.setAttribute("d", d);
        wedge.setAttribute("stroke", container.dataset.strokeColor);
        wedge.setAttribute("stroke-width", "1");
        wedge.setAttribute("fill", pieFills[i] || "transparent"); // Apply stored fill
        wedge.style.pointerEvents = "all";

        wedge.addEventListener("click", (e) => {
          if (isShadingMode) {
            e.stopPropagation();
            showPieColorPicker(wedge, i);
          }
          // When not in shading mode, do nothing special so the event bubbles up.
        });
        

        svg.appendChild(wedge);
        pieWedges.push(wedge);
      }
    }
  }
  circle.setAttribute("stroke", container.dataset.strokeColor);
  circle.setAttribute("stroke-width", "2");
  circle.setAttribute("fill", container.dataset.fillColor);
  svg.appendChild(circle);

  // Create center marker.
  const centerMarker = document.createElement("div");
  centerMarker.className = "circle-center";
  centerMarker.style.position = "absolute";
  centerMarker.style.width = "10px";
  centerMarker.style.height = "10px";
  centerMarker.style.background = container.dataset.strokeColor;
  centerMarker.style.borderRadius = "50%";
  centerMarker.style.cursor = "move";
  function updateCenterMarker() {
    const w = svg.clientWidth || svgWidth;
    const h = svg.clientHeight || svgHeight;
    centerMarker.style.left = `${center.x * w - 5}px`;
    centerMarker.style.top = `${center.y * h - 5}px`;
  }
  updateCenterMarker();
  content.appendChild(centerMarker);

  updateCircle();

  // Toolbar functionality.
  deleteButton.addEventListener("click", () => {
    container.remove();
  });

  strokeDisplay.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation(); // Prevent the global handler from hiding controls
    
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
    overlay.style.zIndex = "10000";
    overlay.style.display = "flex";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";

    const modal = document.createElement("div");
    modal.style.background = "#fff";
    modal.style.padding = "10px";
    modal.style.border = "1px solid #ccc";
    modal.style.fontSize = "14px";
    modal.innerHTML = `<div style="margin-bottom:10px;">Choose Stroke Color</div>`;

    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = container.dataset.strokeColor || "#000000";
    modal.appendChild(colorInput);

    const okBtn = document.createElement("button");
    okBtn.textContent = "OK";
    okBtn.style.marginLeft = "10px";
    modal.appendChild(okBtn);
    
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancel";
    cancelBtn.style.marginLeft = "10px";
    modal.appendChild(cancelBtn);

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    function cleanup() {
      document.body.removeChild(overlay);
    }

    okBtn.addEventListener("click", function() {
      const selectedColor = colorInput.value;
      strokeDisplay.style.backgroundColor = selectedColor;
      container.dataset.strokeColor = selectedColor;
      circle.setAttribute("stroke", selectedColor);
      centerMarker.style.background = selectedColor;
      if (radiusLine) radiusLine.setAttribute("stroke", selectedColor);
      if (diameterLine) diameterLine.setAttribute("stroke", selectedColor);
      pieWedges.forEach(wedge => wedge.setAttribute("stroke", selectedColor));
      cleanup();
    });
    
    cancelBtn.addEventListener("click", cleanup);
    
    overlay.addEventListener("click", function(e) {
      if (e.target === overlay) cleanup();
    });
});


fillDisplay.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation(); // Prevent the click from propagating
    
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0,0,0,0.5)";
    overlay.style.zIndex = "10000";
    overlay.style.display = "flex";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";

    const modal = document.createElement("div");
    modal.style.background = "#fff";
    modal.style.padding = "10px";
    modal.style.border = "1px solid #ccc";
    modal.style.fontSize = "14px";
    modal.innerHTML = `<div style="margin-bottom:10px;">Choose Fill Color</div>`;

    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = container.dataset.fillColor === "transparent" ? "#ffffff" : container.dataset.fillColor || "#ffffff";
    modal.appendChild(colorInput);

    // Add "None" option for fill
    const noneBtn = document.createElement("button");
    noneBtn.textContent = "None";
    noneBtn.style.marginLeft = "10px";
    modal.appendChild(noneBtn);

    const okBtn = document.createElement("button");
    okBtn.textContent = "OK";
    okBtn.style.marginLeft = "10px";
    modal.appendChild(okBtn);
    
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancel";
    cancelBtn.style.marginLeft = "10px";
    modal.appendChild(cancelBtn);

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    function cleanup() {
      document.body.removeChild(overlay);
    }

    okBtn.addEventListener("click", function() {
      const selectedColor = colorInput.value;
      fillDisplay.style.backgroundColor = selectedColor;
      container.dataset.fillColor = selectedColor;
      circle.setAttribute("fill", selectedColor);
      cleanup();
    });
    
    noneBtn.addEventListener("click", function() {
      fillDisplay.style.backgroundColor = "#ffffff";
      container.dataset.fillColor = "transparent";
      circle.setAttribute("fill", "transparent");
      cleanup();
    });
    
    cancelBtn.addEventListener("click", cleanup);
    
    overlay.addEventListener("click", function(e) {
      if (e.target === overlay) cleanup();
    });
});


  showCenterSelect.addEventListener("change", (e) => {
    centerMarker.style.display = e.target.value === "yes" ? "block" : "none";
  });

  drawRadiusSelect.addEventListener("change", (e) => {
    if (e.target.value === "yes") {
      drawDiameterSelect.value = "no";
      if (diameterLine) {
        diameterLine.remove();
        diameterLine = null;
      }
      if (!radiusLine) {
        radiusLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        radiusLine.setAttribute("stroke", container.dataset.strokeColor);
        radiusLine.setAttribute("stroke-width", "1");
        svg.appendChild(radiusLine);
      }
    } else if (radiusLine) {
      radiusLine.remove();
      radiusLine = null;
    }
    updateCircle();
  });

  drawDiameterSelect.addEventListener("change", (e) => {
    if (e.target.value === "yes") {
      drawRadiusSelect.value = "no";
      if (radiusLine) {
        radiusLine.remove();
        radiusLine = null;
      }
      if (!diameterLine) {
        diameterLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        diameterLine.setAttribute("stroke", container.dataset.strokeColor);
        diameterLine.setAttribute("stroke-width", "1");
        svg.appendChild(diameterLine);
      }
    } else if (diameterLine) {
      diameterLine.remove();
      diameterLine = null;
    }
    updateCircle();
  });

  pieInput.addEventListener("input", () => {
    if (parseInt(pieInput.value) > 0) {
      drawRadiusSelect.value = "no";
      drawDiameterSelect.value = "no";
      if (radiusLine) { radiusLine.remove(); radiusLine = null; }
      if (diameterLine) { diameterLine.remove(); diameterLine = null; }
      // Reset pie fills if number of pieces changes
      let currentFills = JSON.parse(container.dataset.pieFills || "[]");
      let newFills = Array(parseInt(pieInput.value)).fill("transparent");
      for (let i = 0; i < Math.min(currentFills.length, newFills.length); i++) {
        newFills[i] = currentFills[i];
      }
      container.dataset.pieFills = JSON.stringify(newFills);
    }
    updateCircle();
  });

  // Shade Pieces functionality.
  let isShadingMode = false;
  shadePiecesBtn.addEventListener("click", () => {
    isShadingMode = !isShadingMode;
    shadePiecesBtn.style.backgroundColor = isShadingMode ? "#ddd" : "";
    content.style.cursor = isShadingMode ? "pointer" : "default";
    if (parseInt(pieInput.value) === 0) {
      alert("Please set Pie Pieces to a number greater than 0 to shade individual pieces.");
      isShadingMode = false;
      shadePiecesBtn.style.backgroundColor = "";
      content.style.cursor = "default";
    }
  });

  document.addEventListener("click", function(e) {
  // Check if shading mode is active AND the click target is NOT within this circle container.
  if (isShadingMode && !container.contains(e.target)) {
    isShadingMode = false;
    shadePiecesBtn.style.backgroundColor = "";
    content.style.cursor = "default";
  }
});


  // Automate button event listener.
  automateBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    showPieChartModal(container);
  });

  // Make container draggable.
 // Make container draggable for the circle
dragHandle.addEventListener("mousedown", (e) => {
  e.preventDefault();
  const canvasRect = canvas.getBoundingClientRect();
  const rect = container.getBoundingClientRect();
  const startX = e.clientX;
  const startY = e.clientY;
  const shiftX = e.clientX - rect.left;
  const shiftY = e.clientY - rect.top;
  let isDraggingLocal = false; // local flag to detect drag

  function onMouseMove(e) {
    let dx = e.clientX - startX;
    let dy = e.clientY - startY;
    // If the movement exceeds a small threshold, mark as dragging.
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
      isDraggingLocal = true;
    }
    let newLeft = e.clientX - shiftX - canvasRect.left;
    let newTop = e.clientY - shiftY - canvasRect.top;
    container.style.left = newLeft + "px";
    container.style.top = newTop + "px";
  }
  
  function onMouseUp(e) {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    // If a drag occurred, set the flag to ignore the next click.
    if (isDraggingLocal) {
      ignoreNextClick = true;
    }
  }
  
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
  e.stopPropagation();
});


  // Resize handle.
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  container.appendChild(resizeHandle);

  resizeHandle.addEventListener("mousedown", (e) => {
    e.preventDefault();
    let startX = e.clientX, startY = e.clientY;
    let startWidth = container.offsetWidth, startHeight = container.offsetHeight;
    function onMouseMove(e) {
      let newWidth = startWidth + (e.clientX - startX);
      let newHeight = startHeight + (e.clientY - startY);
      if (newWidth > 50) {
        container.style.width = newWidth + "px";
        content.style.width = newWidth + "px";
        svg.setAttribute("width", newWidth);
      }
      if (newHeight > toolbarHeight + 50) {
        container.style.height = newHeight + "px";
        content.style.height = (newHeight - toolbarHeight) + "px";
        svg.setAttribute("height", newHeight - toolbarHeight);
      }
      updateCircle(); // Reapply all SVG elements with stored fills
      updateCenterMarker();
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Show toolbar on container click.
  container.addEventListener("click", (e) => {
    e.stopPropagation();
    document.querySelectorAll('.element-controls').forEach(ctrl => ctrl.style.display = "none");
    toolbar.style.display = "flex";
  });

  canvas.appendChild(container);
}

function showPieChartModal(container) {
  const modal = document.getElementById("pieChartModal");
  const overlay = document.getElementById("modalOverlay");

  // Load existing values from container, if any
  const totalPieces = container.getAttribute("data-total-pieces") || "";
  const shadedPieces = container.getAttribute("data-shaded-pieces") || "";
  const shadedColor = container.getAttribute("data-shaded-color") || "#ff0000";
  const unshadedColor = container.getAttribute("data-unshaded-color") || "#ffffff";

  document.getElementById("pie-total-pieces").value = totalPieces;
  document.getElementById("pie-shaded-pieces").value = shadedPieces;
  document.getElementById("pie-shaded-color").value = shadedColor;
  document.getElementById("pie-unshaded-color").value = unshadedColor;

  modal.style.display = "block";
  overlay.style.display = "block";

  function onOK() {
    const total = document.getElementById("pie-total-pieces").value;
    const shaded = document.getElementById("pie-shaded-pieces").value;
    const shadedCol = document.getElementById("pie-shaded-color").value;
    const unshadedCol = document.getElementById("pie-unshaded-color").value;

    container.setAttribute("data-total-pieces", total);
    container.setAttribute("data-shaded-pieces", shaded);
    container.setAttribute("data-shaded-color", shadedCol);
    container.setAttribute("data-unshaded-color", unshadedCol);

    // NEW: Update the pieInput element's value inside the container, if it exists.
    const pieInput = container.querySelector('input[type="number"]');
    if (pieInput) {
      pieInput.value = total;
    }

    cleanup();
  }

  function onCancel() {
    cleanup();
  }

  function cleanup() {
    modal.style.display = "none";
    overlay.style.display = "none";
    document.getElementById("pieChartOK").removeEventListener("click", onOK);
    document.getElementById("pieChartCancel").removeEventListener("click", onCancel);
  }

  document.getElementById("pieChartOK").addEventListener("click", onOK);
  document.getElementById("pieChartCancel").addEventListener("click", onCancel);
}


function generatePieChartSVG(totalPieces, shadedPieces, shadedColor, unshadedColor, width, height) {
  if (totalPieces < 1 || !Number.isFinite(totalPieces) || !Number.isFinite(shadedPieces)) return "";
  
  // Use a simpler approach - create a single circle and overlay wedge-shaped masks
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  
  const safeWidth = Math.max(width, 50);
  const safeHeight = Math.max(height, 50);
  svg.setAttribute("width", safeWidth);
  svg.setAttribute("height", safeHeight);
  svg.setAttribute("viewBox", `0 0 ${safeWidth} ${safeHeight}`);
  
  const cx = safeWidth / 2;
  const cy = safeHeight / 2;
  const radius = Math.min(safeWidth, safeHeight) * 0.45;
  
  // Create a unique ID for the defs section
  const uniqueId = "pie_" + Math.random().toString(36).substr(2, 9);
  
  // Create a full circle background
  const background = document.createElementNS(svgNS, "circle");
  background.setAttribute("cx", cx);
  background.setAttribute("cy", cy);
  background.setAttribute("r", radius);
  background.setAttribute("fill", unshadedColor);
  background.setAttribute("stroke", "#000000");  // True black
  background.setAttribute("stroke-width", "0.5");
  svg.appendChild(background);
  
  // Calculate the number of shaded pieces (rounded to nearest integer)
  const numShaded = Math.min(Math.max(Math.round(shadedPieces), 0), totalPieces);
  
  if (numShaded > 0) {
    // If all pieces are shaded, just use a full circle
    if (numShaded >= totalPieces) {
      background.setAttribute("fill", shadedColor);
    } else {
      // Generate a random starting position for the shaded wedges
      const angleStep = (2 * Math.PI) / totalPieces;
      // Random starting piece (0 to totalPieces-1)
      const startingPiece = Math.floor(Math.random() * totalPieces);
      
      // Draw the shaded sectors as a contiguous group
      for (let i = 0; i < numShaded; i++) {
        // Calculate the actual piece index, wrapping around if needed
        const pieceIndex = (startingPiece + i) % totalPieces;
        const startAngle = pieceIndex * angleStep;
        const endAngle = (pieceIndex + 1) * angleStep;
        
        const startX = cx + radius * Math.cos(startAngle);
        const startY = cy + radius * Math.sin(startAngle);
        const endX = cx + radius * Math.cos(endAngle);
        const endY = cy + radius * Math.sin(endAngle);
        
        // Large arc flag
        const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;
        
        // Create a path for the sector
        const sector = document.createElementNS(svgNS, "path");
        const d = [
          `M ${cx} ${cy}`,
          `L ${startX} ${startY}`,
          `A ${radius} ${radius} 0 ${largeArc} 1 ${endX} ${endY}`,
          `Z`
        ].join(" ");
        
        sector.setAttribute("d", d);
        sector.setAttribute("fill", shadedColor);
        sector.setAttribute("stroke", "none");
        svg.appendChild(sector);
      }
    }
  }
  
  // Add dividing lines
  if (totalPieces > 1) {
    const angleStep = (2 * Math.PI) / totalPieces;
    
    // Draw lines from center to edge for each piece
    for (let i = 0; i < totalPieces; i++) {
      const angle = i * angleStep;
      const endX = cx + radius * Math.cos(angle);
      const endY = cy + radius * Math.sin(angle);
      
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", cx);
      line.setAttribute("y1", cy);
      line.setAttribute("x2", endX);
      line.setAttribute("y2", endY);
      line.setAttribute("stroke", "#000000");  // True black
      line.setAttribute("stroke-width", "0..8");
      svg.appendChild(line);
    }
    
    // Add the circle outline again to ensure it's visible
    const outline = document.createElementNS(svgNS, "circle");
    outline.setAttribute("cx", cx);
    outline.setAttribute("cy", cy);
    outline.setAttribute("r", radius);
    outline.setAttribute("fill", "none");
    outline.setAttribute("stroke", "#000000");  // True black
    outline.setAttribute("stroke-width", "0.5");
    svg.appendChild(outline);
  }
  
  return svg.outerHTML;
}

function showPieColorPicker(piece, wedgeIndex) {
  // Define your available colors.
  const colors = [
    { name: "No fill", value: "transparent" },
    { name: "White", value: "#ffffff" },
    { name: "Black", value: "#000000" },
    { name: "Gray", value: "#808080" },
    { name: "Red", value: "#ff0000" },
    { name: "Orange", value: "#ffa500" },
    { name: "Green", value: "#008000" },
    { name: "Blue", value: "#0000ff" },
    { name: "Purple", value: "#800080" },
    { name: "Pink", value: "#ffc1cc" }
  ];

  // Find the circle container so we can position the modal relative to it.
  const circleContainer = piece.closest(".circle-container");
  if (!circleContainer) return;
  const rect = circleContainer.getBoundingClientRect();

  // Create the modal element.
  const modal = document.createElement("div");
  modal.style.position = "absolute";
  // Position it to the right of the circle with a 10px offset.
  modal.style.top = rect.top + "px";
  modal.style.left = (rect.right + 10) + "px";
  // Ensure the modal appears on top.
  modal.style.zIndex = "2000";
  // Basic styling for visibility.
  modal.style.background = "#fff";
  modal.style.padding = "10px";
  modal.style.border = "1px solid #ccc";
  modal.style.maxHeight = "80vh";
  modal.style.overflowY = "auto";

  // Add a title.
  const title = document.createElement("h3");
  title.textContent = "Select Shade Color";
  modal.appendChild(title);

  // Create a button for each color.
  colors.forEach(color => {
    const btn = document.createElement("button");
    btn.textContent = color.name;
    btn.style.backgroundColor = (color.value === "transparent" ? "#fff" : color.value);
    btn.style.border = "1px solid #ccc";
    btn.style.margin = "2px";
    btn.style.padding = "5px";
    btn.style.width = "100px";
    btn.addEventListener("click", () => {
      // Set the fill on the wedge.
      piece.setAttribute("fill", color.value);
      // Also update the stored pie fills in the circle container.
      const container = piece.closest(".circle-container");
      let pieFills = JSON.parse(container.dataset.pieFills || "[]");
      pieFills[wedgeIndex] = color.value;
      container.dataset.pieFills = JSON.stringify(pieFills);
      closeModal();
    });
    modal.appendChild(btn);
  });

  // Create a Cancel button.
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.marginTop = "10px";
  cancelBtn.addEventListener("click", closeModal);
  modal.appendChild(cancelBtn);

  // Function to remove the modal.
  function closeModal() {
    document.body.removeChild(modal);
    document.removeEventListener("click", clickOutsideListener);
  }

  // Add the modal to the document body.
  document.body.appendChild(modal);

  // Set up a click listener to close the modal if the user clicks outside it.
  function clickOutsideListener(e) {
    // If the click target is not inside the modal, close it.
    if (!modal.contains(e.target)) {
      closeModal();
    }
  }
  // Use capture phase so that even if some elements stop propagation, this still fires.
  document.addEventListener("click", clickOutsideListener, true);
}


function addRectangle() {
  const canvas = document.getElementById('problem-canvas');
  const shapeHTML = '<div class="shape" data-shape="rectangle" style="width:100px; height:50px; border:2px solid black; background-color:#eee;"></div>';
  const rectangle = createDraggableElement(shapeHTML, false);
  canvas.appendChild(rectangle);
}

function addParallelogram() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20; // fixed toolbar height

  // Create the outer container with fixed initial size
  const container = document.createElement("div");
  container.className = "draggable-element parallelogram-container";
  container.style.position = "absolute";
  container.style.left = `${nextElementOffset}px`;
  container.style.top = `${nextElementOffset}px`;
  container.style.width = "250px";  // Larger initial size
  container.style.height = toolbarHeight + 200 + "px";  // Larger initial size
  container.style.zIndex = globalTopZ++;
  nextElementOffset += 10;
  if (nextElementOffset > 100) nextElementOffset = 10;

  // Create the toolbar.
  const toolbar = document.createElement("div");
  toolbar.className = "parallelogram-toolbar element-controls";
  toolbar.style.height = toolbarHeight + "px";
  toolbar.style.width = "100%";
  toolbar.style.boxSizing = "border-box";
  toolbar.style.backgroundColor = "#f0f0f0";
  toolbar.style.display = "none"; // initially hidden
  toolbar.style.alignItems = "center";
  toolbar.style.flexShrink = "0";

  // Left controls: drag handle, stroke, fill, vertex visibility.
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  leftControls.style.flex = "1";

  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);

  // Stroke control.
  const strokeGroup = document.createElement("div");
  strokeGroup.style.display = "flex";
  strokeGroup.style.alignItems = "center";
  strokeGroup.style.marginRight = "5px";
  const strokeLabel = document.createElement("span");
  strokeLabel.textContent = "Line:";
  strokeLabel.style.fontSize = "12px";
  strokeGroup.appendChild(strokeLabel);
  const strokeInput = document.createElement("input");
  strokeInput.type = "color";
  strokeInput.value = "#000000";
  strokeInput.style.marginLeft = "3px";
  strokeGroup.appendChild(strokeInput);
  leftControls.appendChild(strokeGroup);

  // Fill control.
  const fillGroup = document.createElement("div");
  fillGroup.style.display = "flex";
  fillGroup.style.alignItems = "center";
  fillGroup.style.marginRight = "5px";
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Fill:";
  fillLabel.style.fontSize = "12px";
  fillGroup.appendChild(fillLabel);
  const fillInput = document.createElement("input");
  fillInput.type = "color";
  fillInput.value = "#ffffff";
  fillInput.style.marginLeft = "3px";
  fillGroup.appendChild(fillInput);
  leftControls.appendChild(fillGroup);

  // Vertex Color control.
  const vertexColorGroup = document.createElement("div");
  vertexColorGroup.style.display = "flex";
  vertexColorGroup.style.alignItems = "center";
  vertexColorGroup.style.marginRight = "5px";
  const vertexColorLabel = document.createElement("span");
  vertexColorLabel.textContent = "Vertex:";
  vertexColorLabel.style.fontSize = "12px";
  vertexColorGroup.appendChild(vertexColorLabel);
  const vertexColorInput = document.createElement("input");
  vertexColorInput.type = "color";
  vertexColorInput.value = "#0000ff"; // Default blue
  vertexColorInput.style.marginLeft = "3px";
  vertexColorGroup.appendChild(vertexColorInput);
  leftControls.appendChild(vertexColorGroup);

  // Vertex Size control.
  const vertexSizeGroup = document.createElement("div");
  vertexSizeGroup.style.display = "flex";
  vertexSizeGroup.style.alignItems = "center";
  vertexSizeGroup.style.marginRight = "5px";
  const vertexSizeLabel = document.createElement("span");
  vertexSizeLabel.textContent = "Size:";
  vertexSizeLabel.style.fontSize = "12px";
  vertexSizeGroup.appendChild(vertexSizeLabel);
  const vertexSizeInput = document.createElement("input");
  vertexSizeInput.type = "number";
  vertexSizeInput.min = "1";
  vertexSizeInput.max = "20";
  vertexSizeInput.value = "5"; // Default size
  vertexSizeInput.style.width = "40px";
  vertexSizeInput.style.marginLeft = "3px";
  vertexSizeGroup.appendChild(vertexSizeInput);
  leftControls.appendChild(vertexSizeGroup);

  // Vertex visibility control.
  const vertexGroup = document.createElement("div");
  vertexGroup.style.display = "flex";
  vertexGroup.style.alignItems = "center";
  vertexGroup.style.marginRight = "5px";
  const vertexLabel = document.createElement("span");
  vertexLabel.textContent = "Show:";
  vertexLabel.style.fontSize = "12px";
  vertexGroup.appendChild(vertexLabel);
  const vertexSelect = document.createElement("select");
  vertexSelect.style.marginLeft = "3px";
  vertexSelect.style.fontSize = "12px";
  const optYes = document.createElement("option");
  optYes.value = "yes";
  optYes.textContent = "Yes";
  const optNo = document.createElement("option");
  optNo.value = "no";
  optNo.textContent = "No";
  vertexSelect.appendChild(optYes);
  vertexSelect.appendChild(optNo);
  vertexGroup.appendChild(vertexSelect);
  leftControls.appendChild(vertexGroup);

  // Right control: Delete button.
  const rightControls = document.createElement("div");
  rightControls.style.flexShrink = "0";
  const deleteButton = document.createElement("button");
  deleteButton.className = "delete-button";
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  rightControls.appendChild(deleteButton);

  toolbar.appendChild(leftControls);
  toolbar.appendChild(rightControls);
  container.appendChild(toolbar);

  // Create content div for the SVG.
  const content = document.createElement("div");
  content.className = "parallelogram-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden"; // Clip overflow
  container.appendChild(content);

  // Create the SVG element with initial viewBox.
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
  const initialViewBox = { x: 0, y: 0, width: 200, height: 150 };
  svg.setAttribute("viewBox", `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Create the polygon element.
  const polygon = document.createElementNS(svgNS, "polygon");
  polygon.setAttribute("stroke", strokeInput.value);
  polygon.setAttribute("stroke-width", "2");
  polygon.setAttribute("fill", fillInput.value);
  svg.appendChild(polygon);

  // Define points for parallelogram with initial positioning.
  const points = {
    topLeft: { x: 50, y: 30 },
    topRight: { x: 150, y: 30 },
    bottomRight: { x: 120, y: 120 },
    bottomLeft: { x: 20, y: 120 }
  };

  // Store initial horizontal distances – CRITICAL for correct movement.
  const initialTopDX = points.topRight.x - points.topLeft.x;
  const initialBottomDX = points.bottomRight.x - points.bottomLeft.x;

  // Helper function to update the polygon.
  function updatePolygon() {
    polygon.setAttribute("points", 
      `${points.topLeft.x},${points.topLeft.y} ` +
      `${points.topRight.x},${points.topRight.y} ` +
      `${points.bottomRight.x},${points.bottomRight.y} ` +
      `${points.bottomLeft.x},${points.bottomLeft.y}`);
  }
  updatePolygon();

  // Create draggable points.
  function createDraggablePoint(x, y, type) {
    const circle = document.createElementNS(svgNS, "circle");
    circle.setAttribute("cx", x);
    circle.setAttribute("cy", y);
    circle.setAttribute("r", vertexSizeInput.value);
    circle.setAttribute("fill", vertexColorInput.value);
    circle.setAttribute("stroke", "black");
    circle.setAttribute("stroke-width", "1");
    circle.className = `parallelogram-point ${type}`;
    circle.style.cursor = "move";
    circle.style.pointerEvents = "all";
    return circle;
  }

  const topLeftPoint = createDraggablePoint(points.topLeft.x, points.topLeft.y, "top-left");
  const topRightPoint = createDraggablePoint(points.topRight.x, points.topRight.y, "top-right");
  const bottomLeftPoint = createDraggablePoint(points.bottomLeft.x, points.bottomLeft.y, "bottom-left");
  const bottomRightPoint = createDraggablePoint(points.bottomRight.x, points.bottomRight.y, "bottom-right");

  svg.appendChild(topLeftPoint);
  svg.appendChild(topRightPoint);
  svg.appendChild(bottomLeftPoint);
  svg.appendChild(bottomRightPoint);

  // Function to update vertex appearance.
  function updateVertexAppearance() {
    const newColor = vertexColorInput.value;
    const newSize = vertexSizeInput.value;
    [topLeftPoint, topRightPoint, bottomLeftPoint, bottomRightPoint].forEach(pt => {
      pt.setAttribute("fill", newColor);
      pt.setAttribute("r", newSize);
    });
  }

  // Function to get current viewBox dimensions.
  function getCurrentViewBox() {
    const vb = svg.viewBox.baseVal;
    return { x: vb.x, y: vb.y, width: vb.width, height: vb.height };
  }

  // Helper: Check if a coordinate is out-of-bounds.
  function isOutOfBounds(x, y) {
    const padding = 2;
    const vb = getCurrentViewBox();
    return (x < vb.x + padding ||
            x > vb.x + vb.width - padding ||
            y < vb.y + padding ||
            y > vb.y + vb.height - padding);
  }

  // ---------------------------
  // Top-Left Point Handler
  // ---------------------------
  topLeftPoint.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    let hasDragged = false;
    const svgRect = svg.getBoundingClientRect();
    const viewBox = getCurrentViewBox();
    const scaleX = viewBox.width / svgRect.width;
    const scaleY = viewBox.height / svgRect.height;
    const startX = parseFloat(topLeftPoint.getAttribute("cx"));
    const startY = parseFloat(topLeftPoint.getAttribute("cy"));
    const startMouseX = e.clientX;
    const startMouseY = e.clientY;
    
    function onMouseMove(e) {
      hasDragged = true;
      const deltaX = (e.clientX - startMouseX) * scaleX;
      const deltaY = (e.clientY - startMouseY) * scaleY;
      // Compute new positions using your original formulas.
      const newTopLeftX = startX + deltaX;
      const newTopLeftY = startY + deltaY;
      const newTopRightX = newTopLeftX + initialTopDX;
      const newTopRightY = newTopLeftY;
      // Bottom-left x is computed so that:
      // newBottomLeft.x = newTopLeft.x - (newTopRight.x - current bottomRight.x)
      const newBottomLeftX = newTopLeftX - (newTopRightX - points.bottomRight.x);
      const newBottomLeftY = points.bottomLeft.y; // y remains unchanged.
      const newBottomRightX = newBottomLeftX + initialBottomDX;
      const newBottomRightY = points.bottomRight.y;
      
      // Check boundaries for all computed positions.
      if (isOutOfBounds(newTopLeftX, newTopLeftY) ||
          isOutOfBounds(newTopRightX, newTopRightY) ||
          isOutOfBounds(newBottomLeftX, newBottomLeftY) ||
          isOutOfBounds(newBottomRightX, newBottomRightY)) {
        return;
      }
      
      // Update all positions.
      points.topLeft.x = newTopLeftX;
      points.topLeft.y = newTopLeftY;
      topLeftPoint.setAttribute("cx", newTopLeftX);
      topLeftPoint.setAttribute("cy", newTopLeftY);
      
      points.topRight.x = newTopRightX;
      points.topRight.y = newTopRightY;
      topRightPoint.setAttribute("cx", newTopRightX);
      topRightPoint.setAttribute("cy", newTopRightY);
      
      points.bottomLeft.x = newBottomLeftX;
      bottomLeftPoint.setAttribute("cx", newBottomLeftX);
      
      points.bottomRight.x = newBottomRightX;
      bottomRightPoint.setAttribute("cx", newBottomRightX);
      
      updatePolygon();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      if (hasDragged) { ignoreNextClick = true; }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // ---------------------------
  // Top-Right Point Handler
  // ---------------------------
  topRightPoint.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    let hasDragged = false;
    const svgRect = svg.getBoundingClientRect();
    const viewBox = getCurrentViewBox();
    const scaleX = viewBox.width / svgRect.width;
    const scaleY = viewBox.height / svgRect.height;
    const startX = parseFloat(topRightPoint.getAttribute("cx"));
    const startY = parseFloat(topRightPoint.getAttribute("cy"));
    const startMouseX = e.clientX;
    const startMouseY = e.clientY;
    
    function onMouseMove(e) {
      hasDragged = true;
      const deltaX = (e.clientX - startMouseX) * scaleX;
      const deltaY = (e.clientY - startMouseY) * scaleY;
      const newTopRightX = startX + deltaX;
      const newTopRightY = startY + deltaY;
      // Top-left's y should follow.
      const newTopLeftY = newTopRightY;
      // Bottom-right x is computed as:
      // newBottomRight.x = newTopRight.x - (current topLeft.x - current bottomLeft.x)
      const newBottomRightX = newTopRightX - (points.topLeft.x - points.bottomLeft.x);
      
      if (isOutOfBounds(newTopRightX, newTopRightY) ||
          isOutOfBounds(points.topLeft.x, newTopLeftY) ||
          isOutOfBounds(newBottomRightX, points.bottomRight.y)) {
        return;
      }
      
      points.topRight.x = newTopRightX;
      points.topRight.y = newTopRightY;
      topRightPoint.setAttribute("cx", newTopRightX);
      topRightPoint.setAttribute("cy", newTopRightY);
      
      points.topLeft.y = newTopLeftY;
      topLeftPoint.setAttribute("cy", newTopLeftY);
      
      points.bottomRight.x = newBottomRightX;
      bottomRightPoint.setAttribute("cx", newBottomRightX);
      
      updatePolygon();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      if (hasDragged) { ignoreNextClick = true; }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // ---------------------------
  // Bottom-Left Point Handler
  // ---------------------------
  bottomLeftPoint.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    let hasDragged = false;
    const svgRect = svg.getBoundingClientRect();
    const viewBox = getCurrentViewBox();
    const scaleX = viewBox.width / svgRect.width;
    const scaleY = viewBox.height / svgRect.height;
    const startX = parseFloat(bottomLeftPoint.getAttribute("cx"));
    const startY = parseFloat(bottomLeftPoint.getAttribute("cy"));
    const startMouseX = e.clientX;
    const startMouseY = e.clientY;
    
    function onMouseMove(e) {
      hasDragged = true;
      const deltaX = (e.clientX - startMouseX) * scaleX;
      const deltaY = (e.clientY - startMouseY) * scaleY;
      const newBottomLeftX = startX + deltaX;
      const newBottomLeftY = startY + deltaY;
      // Bottom-right: keep same y and add fixed initialBottomDX.
      const newBottomRightX = newBottomLeftX + initialBottomDX;
      const newBottomRightY = newBottomLeftY;
      // Top-left: adjust x so that:
      // newTopLeft.x = newBottomLeft.x - (newBottomRight.x - current topRight.x)
      const newTopLeftX = newBottomLeftX - (newBottomRightX - points.topRight.x);
      
      if (isOutOfBounds(newBottomLeftX, newBottomLeftY) ||
          isOutOfBounds(newBottomRightX, newBottomRightY) ||
          isOutOfBounds(newTopLeftX, points.topLeft.y)) {
        return;
      }
      
      points.bottomLeft.x = newBottomLeftX;
      points.bottomLeft.y = newBottomLeftY;
      bottomLeftPoint.setAttribute("cx", newBottomLeftX);
      bottomLeftPoint.setAttribute("cy", newBottomLeftY);
      
      points.bottomRight.x = newBottomRightX;
      points.bottomRight.y = newBottomRightY;
      bottomRightPoint.setAttribute("cx", newBottomRightX);
      bottomRightPoint.setAttribute("cy", newBottomRightY);
      
      points.topLeft.x = newTopLeftX;
      topLeftPoint.setAttribute("cx", newTopLeftX);
      
      // Recalculate top-right from top-left and fixed initialTopDX.
      points.topRight.x = newTopLeftX + initialTopDX;
      topRightPoint.setAttribute("cx", points.topRight.x);
      
      updatePolygon();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      if (hasDragged) { ignoreNextClick = true; }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // ---------------------------
  // Bottom-Right Point Handler
  // ---------------------------
  bottomRightPoint.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    let hasDragged = false;
    const svgRect = svg.getBoundingClientRect();
    const viewBox = getCurrentViewBox();
    const scaleX = viewBox.width / svgRect.width;
    const scaleY = viewBox.height / svgRect.height;
    const startX = parseFloat(bottomRightPoint.getAttribute("cx"));
    const startY = parseFloat(bottomRightPoint.getAttribute("cy"));
    const startMouseX = e.clientX;
    const startMouseY = e.clientY;
    
    function onMouseMove(e) {
      hasDragged = true;
      const deltaX = (e.clientX - startMouseX) * scaleX;
      const deltaY = (e.clientY - startMouseY) * scaleY;
      const newBottomRightX = startX + deltaX;
      const newBottomRightY = startY + deltaY;
      // Bottom-left: keep its x, update y to match new bottom-right.
      const newBottomLeftY = newBottomRightY;
      // Top-right: adjust x so that:
      // newTopRight.x = newBottomRight.x - (current bottomLeft.x - current topLeft.x)
      const newTopRightX = newBottomRightX - (points.bottomLeft.x - points.topLeft.x);
      
      if (isOutOfBounds(newBottomRightX, newBottomRightY) ||
          isOutOfBounds(points.bottomLeft.x, newBottomLeftY) ||
          isOutOfBounds(newTopRightX, points.topRight.y)) {
        return;
      }
      
      points.bottomRight.x = newBottomRightX;
      points.bottomRight.y = newBottomRightY;
      bottomRightPoint.setAttribute("cx", newBottomRightX);
      bottomRightPoint.setAttribute("cy", newBottomRightY);
      
      points.bottomLeft.y = newBottomLeftY;
      bottomLeftPoint.setAttribute("cy", newBottomLeftY);
      
      points.topRight.x = newTopRightX;
      topRightPoint.setAttribute("cx", newTopRightX);
      
      updatePolygon();
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      if (hasDragged) { ignoreNextClick = true; }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Input listeners.
  strokeInput.addEventListener("input", function() {
    polygon.setAttribute("stroke", strokeInput.value);
    [topLeftPoint, topRightPoint, bottomLeftPoint, bottomRightPoint].forEach(pt => {
      pt.setAttribute("stroke", strokeInput.value);
    });
  });
  
  fillInput.addEventListener("input", function() {
    polygon.setAttribute("fill", fillInput.value);
  });
  
  vertexColorInput.addEventListener("input", updateVertexAppearance);
  vertexSizeInput.addEventListener("input", updateVertexAppearance);
  
  vertexSelect.addEventListener("change", function() {
    const show = vertexSelect.value === "yes";
    [topLeftPoint, topRightPoint, bottomLeftPoint, bottomRightPoint].forEach(pt => {
      pt.style.display = show ? "block" : "none";
    });
  });
  
  deleteButton.addEventListener("click", function() {
    container.remove();
  });

  // Container click: show toolbar and raise z-index.
  container.addEventListener("click", function(e) {
    e.stopPropagation();
    if (activeElement && activeElement !== container && activeElement.dataset.tempRaised) {
      restoreElementZIndex(activeElement);
    }
    hideAllControls();
    toolbar.style.display = "flex";
    activeElement = container;
    raiseElementTemporarily(container);
  });

  makeDraggable(dragHandle, container);
  
  // Create a blue resize handle.
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  resizeHandle.style.zIndex = "1000";
  container.appendChild(resizeHandle);
  
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    const contentHeight = startHeight - toolbarHeight;
    const originalViewBox = getCurrentViewBox();
    
    function onMouseMove(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const newWidth = Math.max(150, startWidth + dx);
      const newHeight = Math.max(100, startHeight + dy);
      const newContentHeight = newHeight - toolbarHeight;
      container.style.width = newWidth + "px";
      container.style.height = newHeight + "px";
      content.style.height = newContentHeight + "px";
      const widthRatio = newWidth / startWidth;
      const heightRatio = newContentHeight / contentHeight;
      const newViewBoxWidth = originalViewBox.width * widthRatio;
      const newViewBoxHeight = originalViewBox.height * heightRatio;
      svg.setAttribute("viewBox", `${originalViewBox.x} ${originalViewBox.y} ${newViewBoxWidth} ${newViewBoxHeight}`);
    }
    
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  canvas.appendChild(container);
  container.dataset.originalZ = container.style.zIndex;
}

function addSemicircle() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  let svgSize = 150;         // initial width of the semicircle container
  let drawSize = svgSize * 0.5; // drawing area height

  // Create the outer container.
  const container = document.createElement("div");
  container.className = "draggable-element semicircle-container";
  container.style.position = "absolute";
  container.style.left = `${nextElementOffset}px`;
  container.style.top = `${nextElementOffset}px`;
  container.style.width = svgSize + "px";
  container.style.height = (toolbarHeight + drawSize) + "px";
  nextElementOffset += 10;

  // Create the toolbar.
  const toolbar = document.createElement("div");
  toolbar.className = "semicircle-toolbar element-controls";
  toolbar.style.width = svgSize + "px";
  toolbar.style.height = toolbarHeight + "px";
  toolbar.style.boxSizing = "border-box";
  toolbar.style.backgroundColor = "#f0f0f0";
  toolbar.style.opacity = "1";
  toolbar.style.zIndex = "10000";
  toolbar.style.display = "none";
  toolbar.style.alignItems = "center";
  toolbar.style.flexShrink = "0";
  toolbar.addEventListener("click", function(e) {
    e.stopPropagation();
  });

  // --- Toolbar Controls ---
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  leftControls.style.flex = "1";

  // DRAG HANDLE.
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);

  // Line Color Control.
  const lineColorGroup = document.createElement("div");
  lineColorGroup.style.display = "flex";
  lineColorGroup.style.alignItems = "center";
  lineColorGroup.style.marginRight = "5px";
  const lineColorLabel = document.createElement("span");
  lineColorLabel.textContent = "Line:";
  lineColorLabel.style.fontSize = "12px";
  lineColorGroup.appendChild(lineColorLabel);
  const lineColorInput = document.createElement("input");
  lineColorInput.type = "color";
  lineColorInput.value = "#000000";
  lineColorInput.style.marginLeft = "3px";
  lineColorGroup.appendChild(lineColorInput);
  leftControls.appendChild(lineColorGroup);

  // Fill Color Control.
  const fillColorGroup = document.createElement("div");
  fillColorGroup.style.display = "flex";
  fillColorGroup.style.alignItems = "center";
  fillColorGroup.style.marginRight = "5px";
  const fillColorLabel = document.createElement("span");
  fillColorLabel.textContent = "Fill:";
  fillColorLabel.style.fontSize = "12px";
  fillColorGroup.appendChild(fillColorLabel);
  const fillColorInput = document.createElement("input");
  fillColorInput.type = "color";
  fillColorInput.value = "#ffffff";
  fillColorInput.style.marginLeft = "3px";
  fillColorGroup.appendChild(fillColorInput);
  leftControls.appendChild(fillColorGroup);

  // Show Center Control.
  const centerGroup = document.createElement("div");
  centerGroup.style.display = "flex";
  centerGroup.style.alignItems = "center";
  centerGroup.style.marginRight = "5px";
  const centerLabel = document.createElement("span");
  centerLabel.textContent = "Show Center:";
  centerLabel.style.fontSize = "12px";
  centerGroup.appendChild(centerLabel);
  const centerSelect = document.createElement("select");
  centerSelect.style.marginLeft = "3px";
  centerSelect.style.fontSize = "12px";
  const centerYes = document.createElement("option");
  centerYes.value = "yes";
  centerYes.textContent = "Yes";
  const centerNo = document.createElement("option");
  centerNo.value = "no";
  centerNo.textContent = "No";
  centerSelect.appendChild(centerYes);
  centerSelect.appendChild(centerNo);
  centerSelect.value = "yes";
  centerGroup.appendChild(centerSelect);
  leftControls.appendChild(centerGroup);

  toolbar.appendChild(leftControls);

  // Right side: Delete button.
  const rightControls = document.createElement("div");
  rightControls.style.flexShrink = "0";
  const deleteButton = document.createElement("button");
  deleteButton.className = "delete-button";
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  rightControls.appendChild(deleteButton);
  toolbar.appendChild(rightControls);

  container.appendChild(toolbar);

  // Create content div for the SVG.
  const content = document.createElement("div");
  content.className = "semicircle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = drawSize + "px";
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create the SVG element.
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", svgSize);
  svg.setAttribute("height", drawSize);
  // Set the viewBox normally; we'll adjust drawing positions internally.
  svg.setAttribute("viewBox", `0 0 ${svgSize} ${drawSize}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // We'll add a small top offset so the stroke isn't clipped.
  const topOffset = 2;

  // Function to draw the semicircle with extra inner margin.
  function drawSemicircle() {
    const currentWidth = parseFloat(svg.getAttribute("width"));
    const currentHeight = parseFloat(svg.getAttribute("height")); // equals drawSize
    const innerMargin = currentHeight * 0.1;
    const xStart = innerMargin;
    const xEnd = currentWidth - innerMargin;
    const arcRadius = (currentWidth - 2 * innerMargin) / 2;
    // Shift the arc downward by topOffset.
    const yFlat = currentHeight - innerMargin + topOffset;
    const d = `M ${xStart},${yFlat} A ${arcRadius},${arcRadius} 0 0,1 ${xEnd},${yFlat} L ${xStart},${yFlat} Z`;
    path.setAttribute("d", d);
    // Place the center marker at the horizontal center and at yFlat.
    centerMarker.setAttribute("cx", (xStart + xEnd) / 2);
    centerMarker.setAttribute("cy", yFlat);
  }

  // Create the semicircular path.
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  // Initial drawing.
  const initialInnerMargin = drawSize * 0.1;
  const initialXStart = initialInnerMargin;
  const initialXEnd = svgSize - initialInnerMargin;
  const initialArcRadius = (svgSize - 2 * initialInnerMargin) / 2;
  const initialYFlat = drawSize - initialInnerMargin + topOffset;
  const initialD = `M ${initialXStart},${initialYFlat} A ${initialArcRadius},${initialArcRadius} 0 0,1 ${initialXEnd},${initialYFlat} L ${initialXStart},${initialYFlat} Z`;
  path.setAttribute("d", initialD);
  path.setAttribute("stroke", lineColorInput.value);
  path.setAttribute("stroke-width", "2");
  path.setAttribute("fill", fillColorInput.value);
  svg.appendChild(path);

  // Create a center marker.
  const centerMarker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  centerMarker.setAttribute("cx", (initialXStart + initialXEnd) / 2);
  centerMarker.setAttribute("cy", initialYFlat);
  centerMarker.setAttribute("r", 5);
  centerMarker.setAttribute("fill", lineColorInput.value);
  svg.appendChild(centerMarker);

  // --- Toolbar Event Listeners ---
  lineColorInput.addEventListener("input", (e) => {
    e.stopPropagation();
    path.setAttribute("stroke", lineColorInput.value);
    centerMarker.setAttribute("fill", lineColorInput.value);
  });
  
  fillColorInput.addEventListener("input", (e) => {
    e.stopPropagation();
    path.setAttribute("fill", fillColorInput.value);
  });
  
  centerSelect.addEventListener("change", (e) => {
    e.stopPropagation();
    centerMarker.style.display = centerSelect.value === "yes" ? "block" : "none";
  });
  
  deleteButton.addEventListener("click", (e) => {
    e.stopPropagation();
    container.remove();
  });
  
  container.addEventListener("click", (e) => {
    e.stopPropagation();
    document.querySelectorAll('.element-controls').forEach(ctrl => ctrl.style.display = "none");
    toolbar.style.display = "flex";
    activeElement = container;
    raiseElementTemporarily(container);
  });
  
  makeDraggable(dragHandle, container);
  
  // Add a blue resize handle.
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  container.appendChild(resizeHandle);
  
  // Resize handler: force the container's drawing area to update.
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    const startX = e.clientX, startY = e.clientY;
    const startWidth = parseFloat(container.style.width);
    function onMouseMove(e) {
      let newWidth = startWidth + (e.clientX - startX);
      if (newWidth < 50) newWidth = 50;
      let newDrawSize = newWidth * 0.5;
      container.style.width = newWidth + "px";
      container.style.height = (toolbarHeight + newDrawSize) + "px";
      content.style.width = newWidth + "px";
      content.style.height = newDrawSize + "px";
      svg.setAttribute("width", newWidth);
      svg.setAttribute("height", newDrawSize);
      svg.setAttribute("viewBox", `0 0 ${newWidth} ${newDrawSize}`);
      drawSemicircle();
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  canvas.appendChild(container);
}

// If the fill color is the snippet's default (#add8e6), use the snippet's three-face colors.
// Otherwise, use a single uniform color for all faces.
function getPrismFillColors(baseFill) {
  if (baseFill.toLowerCase() === "#add8e6") {
    return {
      front: "#add8e6",
      top: "#87cefa",
      side: "#6495ed"
    };
  } else {
    return {
      front: baseFill,
      top: baseFill,
      side: baseFill
    };
  }
}

function addRectangularPrism() {
  // --- Local helper functions for color manipulation ---
  function lightenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r + (255 - r) * percent);
    g = Math.floor(g + (255 - g) * percent);
    b = Math.floor(b + (255 - b) * percent);
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }
  function darkenColor(hex, percent) {
    hex = hex.replace(/^#/, "");
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);
    r = Math.floor(r * (1 - percent));
    g = Math.floor(g * (1 - percent));
    b = Math.floor(b * (1 - percent));
    return "#" + [r, g, b].map(x => ("0" + x.toString(16)).slice(-2)).join("");
  }
  
  // --- Draggable function (constrained to #problem-canvas) ---
  function makeDraggable(handle, container) {
    handle.addEventListener("mousedown", function(e) {
      e.preventDefault();
      const parent = document.getElementById("problem-canvas");
      const parentRect = parent.getBoundingClientRect();
      let startX = e.clientX, startY = e.clientY;
      let origX = parseFloat(container.style.left) || 0;
      let origY = parseFloat(container.style.top) || 0;
      function onMouseMove(e) {
        let dx = e.clientX - startX;
        let dy = e.clientY - startY;
        let newLeft = origX + dx;
        let newTop = origY + dy;
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
        newLeft = Math.max(0, Math.min(newLeft, parentRect.width - containerWidth));
        newTop = Math.max(0, Math.min(newTop, parentRect.height - containerHeight));
        container.style.left = newLeft + "px";
        container.style.top = newTop + "px";
      }
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
  }
  
  // --- End Local Helpers ---
  
  // Get the problem canvas.
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  const logicalWidth = 300, logicalHeight = 200; // Logical coordinate space

  // Create the outer container.
  const container = document.createElement("div");
  container.className = "draggable-element prism-container";
  container.style.position = "absolute";
  container.style.left = nextElementOffset + "px";
  container.style.top = nextElementOffset + "px";
  container.style.width = logicalWidth + "px";
  container.style.height = (toolbarHeight + logicalHeight) + "px";
  container.style.zIndex = globalTopZ++;
  nextElementOffset += 10;
  container.tabIndex = 0; // Make focusable

  // Create toolbar.
  const toolbar = document.createElement("div");
  toolbar.className = "prism-toolbar element-controls";
  toolbar.style.width = "100%";
  toolbar.style.height = toolbarHeight + "px";
  toolbar.style.boxSizing = "border-box";
  toolbar.style.backgroundColor = "#f0f0f0";
  toolbar.style.display = "none"; // Initially hidden
  toolbar.style.alignItems = "center";
  toolbar.style.flexShrink = "0";
  toolbar.style.position = "absolute"; // Make toolbar absolute positioned
  toolbar.style.top = "0"; // Position at the top of the container
  toolbar.style.zIndex = "10"; // Ensure it's above the content

  // Left controls container.
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  leftControls.style.flex = "1";

  // Drag handle.
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);

  // Stroke color control.
  const strokeGroup = document.createElement("div");
  strokeGroup.style.display = "flex";
  strokeGroup.style.alignItems = "center";
  strokeGroup.style.marginRight = "5px";
  const strokeLabel = document.createElement("span");
  strokeLabel.textContent = "Line:";
  strokeLabel.style.fontSize = "12px";
  strokeGroup.appendChild(strokeLabel);
  const strokeInput = document.createElement("input");
  strokeInput.type = "color";
  strokeInput.value = "#000000";
  strokeInput.style.marginLeft = "3px";
  strokeGroup.appendChild(strokeInput);
  leftControls.appendChild(strokeGroup);

  // Fill color control with No Fill option
  const fillGroup = document.createElement("div");
  fillGroup.style.display = "flex";
  fillGroup.style.alignItems = "center";
  fillGroup.style.marginRight = "5px";
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Fill:";
  fillLabel.style.fontSize = "12px";
  fillGroup.appendChild(fillLabel);
  
  // Create fill type dropdown (none or color)
  const fillTypeDropdown = document.createElement("select");
  fillTypeDropdown.style.marginLeft = "3px";
  fillTypeDropdown.style.marginRight = "3px";
  
  const noneOption = document.createElement("option");
  noneOption.value = "none";
  noneOption.textContent = "No Fill";
  fillTypeDropdown.appendChild(noneOption);
  
  const colorOption = document.createElement("option");
  colorOption.value = "color";
  colorOption.textContent = "Color";
  colorOption.selected = true;
  fillTypeDropdown.appendChild(colorOption);
  
  fillGroup.appendChild(fillTypeDropdown);
  
  const fillInput = document.createElement("input");
  fillInput.type = "color";
  fillInput.value = "#add8e6";
  fillInput.style.marginLeft = "3px";
  fillGroup.appendChild(fillInput);
  leftControls.appendChild(fillGroup);

  // Fill Type control.
  const fillTypeGroup = document.createElement("div");
  fillTypeGroup.style.display = "flex";
  fillTypeGroup.style.alignItems = "center";
  fillTypeGroup.style.marginRight = "5px";
  const fillTypeLabel = document.createElement("span");
  fillTypeLabel.textContent = "Fill Type:";
  fillTypeLabel.style.fontSize = "12px";
  fillTypeGroup.appendChild(fillTypeLabel);
  const fillTypeSelect = document.createElement("select");
  fillTypeSelect.style.marginLeft = "3px";
  const optionSolidFill = document.createElement("option");
  optionSolidFill.value = "solid";
  optionSolidFill.textContent = "Solid";
  fillTypeSelect.appendChild(optionSolidFill);
  const optionGradient = document.createElement("option");
  optionGradient.value = "gradient";
  optionGradient.textContent = "Gradient";
  fillTypeSelect.appendChild(optionGradient);
  fillTypeGroup.appendChild(fillTypeSelect);
  leftControls.appendChild(fillTypeGroup);

  // Prism Type control.
  const prismTypeGroup = document.createElement("div");
  prismTypeGroup.style.display = "flex";
  prismTypeGroup.style.alignItems = "center";
  prismTypeGroup.style.marginRight = "5px";
  const prismTypeLabel = document.createElement("span");
  prismTypeLabel.textContent = "Prism Type:";
  prismTypeLabel.style.fontSize = "12px";
  prismTypeGroup.appendChild(prismTypeLabel);
  const prismTypeSelect = document.createElement("select");
  prismTypeSelect.style.marginLeft = "3px";
  const optionSolidPrism = document.createElement("option");
  optionSolidPrism.value = "solid";
  optionSolidPrism.textContent = "Solid";
  prismTypeSelect.appendChild(optionSolidPrism);
  const optionXray = document.createElement("option");
  optionXray.value = "xray";
  optionXray.textContent = "X‑Ray";
  prismTypeSelect.appendChild(optionXray);
  prismTypeGroup.appendChild(prismTypeSelect);
  leftControls.appendChild(prismTypeGroup);

  toolbar.appendChild(leftControls);

  // Right controls: Delete button.
  const rightControls = document.createElement("div");
  rightControls.style.flexShrink = "0";
  const deleteBtn = document.createElement("button");
  deleteBtn.className = "delete-button";
  deleteBtn.textContent = "Delete";
  deleteBtn.style.fontSize = "12px";
  deleteBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    container.remove();
  });
  rightControls.appendChild(deleteBtn);
  toolbar.appendChild(rightControls);

  container.appendChild(toolbar);

  // Content area.
  const content = document.createElement("div");
  content.className = "prism-content";
  content.style.position = "relative";
  content.style.width = "100%";
  content.style.height = logicalHeight + "px";
  content.style.overflow = "visible";
  container.appendChild(content);

  // Create SVG element.
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", content.clientWidth || logicalWidth);
  svg.setAttribute("height", content.clientHeight || logicalHeight);
  svg.setAttribute("viewBox", `0 0 ${logicalWidth} ${logicalHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Define front face rectangle and offset.
  let frontRect = { x1: 50, y1: 70, x2: 150, y2: 150 };
  let offset = { dx: 40, dy: -40 };

  // Create polygons for the three visible faces.
  const frontFace = document.createElementNS(svgNS, "polygon");
  frontFace.setAttribute("stroke-width", "2");
  svg.appendChild(frontFace);
  const topFace = document.createElementNS(svgNS, "polygon");
  topFace.setAttribute("stroke-width", "2");
  svg.appendChild(topFace);
  const sideFace = document.createElementNS(svgNS, "polygon");
  sideFace.setAttribute("stroke-width", "2");
  svg.appendChild(sideFace);

  // Create additional polygons for hidden (x‑ray) faces.
  const backFace = document.createElementNS(svgNS, "polygon");
  backFace.style.display = "none";
  backFace.setAttribute("stroke-width", "2");
  svg.appendChild(backFace);
  const leftFace = document.createElementNS(svgNS, "polygon");
  leftFace.style.display = "none";
  leftFace.setAttribute("stroke-width", "2");
  svg.appendChild(leftFace);
  const bottomFace = document.createElementNS(svgNS, "polygon");
  bottomFace.style.display = "none";
  bottomFace.setAttribute("stroke-width", "2");
  svg.appendChild(bottomFace);

  // --- Helper functions to clamp geometry.
  function clampFrontRect() {
    frontRect.x1 = Math.max(0, Math.min(frontRect.x1, logicalWidth));
    frontRect.x2 = Math.max(0, Math.min(frontRect.x2, logicalWidth));
    frontRect.y1 = Math.max(0, Math.min(frontRect.y1, logicalHeight));
    frontRect.y2 = Math.max(0, Math.min(frontRect.y2, logicalHeight));
    if (frontRect.x1 > frontRect.x2) [frontRect.x1, frontRect.x2] = [frontRect.x2, frontRect.x1];
    if (frontRect.y1 > frontRect.y2) [frontRect.y1, frontRect.y2] = [frontRect.y2, frontRect.y1];
  }
  function clampOffset() {
    const B = { x: frontRect.x2, y: frontRect.y1 };
    let bx = B.x + offset.dx;
    let by = B.y + offset.dy;
    if (bx < B.x) bx = B.x;
    if (bx > logicalWidth) bx = logicalWidth;
    if (by < 0) by = 0;
    if (by > B.y) by = B.y;
    offset.dx = bx - B.x;
    offset.dy = by - B.y;
  }

  // --- Recompute polygons and markers.
  function updatePrismDrawing() {
    clampFrontRect();
    clampOffset();
    
    let fills;
    // Check if "No Fill" is selected
    if (fillTypeDropdown.value === "none") {
      fills = { front: "none", top: "none", side: "none" };
    } else if (fillTypeSelect.value === "gradient") {
      fills = {
        front: fillInput.value,
        top: lightenColor(fillInput.value, 0.2),
        side: darkenColor(fillInput.value, 0.2)
      };
    } else {
      fills = { front: fillInput.value, top: fillInput.value, side: fillInput.value };
    }
    
    const strokeCol = strokeInput.value;
    // Compute front face vertices.
    let A = { x: frontRect.x1, y: frontRect.y1 };
    let B = { x: frontRect.x2, y: frontRect.y1 };
    let C = { x: frontRect.x2, y: frontRect.y2 };
    let D = { x: frontRect.x1, y: frontRect.y2 };
    // Compute back face vertices.
    let A_back = { x: A.x + offset.dx, y: A.y + offset.dy };
    let B_back = { x: B.x + offset.dx, y: B.y + offset.dy };
    let C_back = { x: C.x + offset.dx, y: C.y + offset.dy };
    let D_back = { x: D.x + offset.dx, y: D.y + offset.dy };
    
    // Draw visible faces (front, top, right).
    frontFace.setAttribute("points", `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`);
    frontFace.setAttribute("fill", fills.front);
    frontFace.setAttribute("stroke", strokeCol);
    
    topFace.setAttribute("points", `${A.x},${A.y} ${A_back.x},${A_back.y} ${B_back.x},${B_back.y} ${B.x},${B.y}`);
    // In x-ray mode, the visible faces remain solid.
    if (prismTypeSelect.value === "xray") {
      topFace.setAttribute("fill", fills.top);
      topFace.removeAttribute("stroke-dasharray");
    } else {
      topFace.setAttribute("fill", fills.top);
      topFace.removeAttribute("stroke-dasharray");
    }
    topFace.setAttribute("stroke", strokeCol);
    
    sideFace.setAttribute("points", `${B.x},${B.y} ${B_back.x},${B_back.y} ${C_back.x},${C_back.y} ${C.x},${C.y}`);
    if (prismTypeSelect.value === "xray") {
      sideFace.setAttribute("fill", fills.side);
      sideFace.removeAttribute("stroke-dasharray");
    } else {
      sideFace.setAttribute("fill", fills.side);
      sideFace.removeAttribute("stroke-dasharray");
    }
    sideFace.setAttribute("stroke", strokeCol);
    
    // For X‑Ray mode, add dashed lines for the hidden edges.
    if (prismTypeSelect.value === "xray") {
      // Extra dashed line for back top edge (from A_back to B_back)
      let extraBackTopLine = svg.querySelector('.extra-back-top-line');
      if (!extraBackTopLine) {
        extraBackTopLine = document.createElementNS(svgNS, "line");
        extraBackTopLine.classList.add("extra-back-top-line");
        svg.appendChild(extraBackTopLine);
      }
      extraBackTopLine.setAttribute("x1", A_back.x);
      extraBackTopLine.setAttribute("y1", A_back.y);
      extraBackTopLine.setAttribute("x2", B_back.x);
      extraBackTopLine.setAttribute("y2", B_back.y);
      extraBackTopLine.setAttribute("stroke", strokeCol);
      extraBackTopLine.setAttribute("stroke-width", "2");
      extraBackTopLine.setAttribute("stroke-dasharray", "4,2");
  
      // Extra dashed line for back bottom edge (from D_back to C_back)
      let extraBackBottomLine = svg.querySelector('.extra-back-bottom-line');
      if (!extraBackBottomLine) {
        extraBackBottomLine = document.createElementNS(svgNS, "line");
        extraBackBottomLine.classList.add("extra-back-bottom-line");
        svg.appendChild(extraBackBottomLine);
      }
      extraBackBottomLine.setAttribute("x1", D_back.x);
      extraBackBottomLine.setAttribute("y1", D_back.y);
      extraBackBottomLine.setAttribute("x2", C_back.x);
      extraBackBottomLine.setAttribute("y2", C_back.y);
      extraBackBottomLine.setAttribute("stroke", strokeCol);
      extraBackBottomLine.setAttribute("stroke-width", "2");
      extraBackBottomLine.setAttribute("stroke-dasharray", "4,2");
  
      // Extra dashed line for back left edge (from A_back to D_back)
      let extraBackLeftLine = svg.querySelector('.extra-back-left-line');
      if (!extraBackLeftLine) {
        extraBackLeftLine = document.createElementNS(svgNS, "line");
        extraBackLeftLine.classList.add("extra-back-left-line");
        svg.appendChild(extraBackLeftLine);
      }
      extraBackLeftLine.setAttribute("x1", A_back.x);
      extraBackLeftLine.setAttribute("y1", A_back.y);
      extraBackLeftLine.setAttribute("x2", D_back.x);
      extraBackLeftLine.setAttribute("y2", D_back.y);
      extraBackLeftLine.setAttribute("stroke", strokeCol);
      extraBackLeftLine.setAttribute("stroke-width", "2");
      extraBackLeftLine.setAttribute("stroke-dasharray", "4,2");
  
      // --- NEW: Extra dashed line connecting front D to back D_back ---
      let extraLeftConnectingLine = svg.querySelector('.extra-left-connecting-line');
      if (!extraLeftConnectingLine) {
        extraLeftConnectingLine = document.createElementNS(svgNS, "line");
        extraLeftConnectingLine.classList.add("extra-left-connecting-line");
        svg.appendChild(extraLeftConnectingLine);
      }
      extraLeftConnectingLine.setAttribute("x1", D.x);
      extraLeftConnectingLine.setAttribute("y1", D.y);
      extraLeftConnectingLine.setAttribute("x2", D_back.x);
      extraLeftConnectingLine.setAttribute("y2", D_back.y);
      extraLeftConnectingLine.setAttribute("stroke", strokeCol);
      extraLeftConnectingLine.setAttribute("stroke-width", "2");
      extraLeftConnectingLine.setAttribute("stroke-dasharray", "4,2");
    } else {
      // Remove extra dashed lines if not in x‑ray mode.
      let extraBackTopLine = svg.querySelector('.extra-back-top-line');
      if (extraBackTopLine) extraBackTopLine.remove();
      let extraBackBottomLine = svg.querySelector('.extra-back-bottom-line');
      if (extraBackBottomLine) extraBackBottomLine.remove();
      let extraBackLeftLine = svg.querySelector('.extra-back-left-line');
      if (extraBackLeftLine) extraBackLeftLine.remove();
      let extraLeftConnectingLine = svg.querySelector('.extra-left-connecting-line');
      if (extraLeftConnectingLine) extraLeftConnectingLine.remove();
    }
  
    // Update markers.
    markers.forEach(marker => marker.style.backgroundColor = strokeCol);
    backMarker.style.backgroundColor = strokeCol;
    updateMarkers();
  }

  // --- Update markers using actual SVG dimensions.
  const markers = [];
  function updateMarkers() {
    const actualWidth = svg.clientWidth;
    const actualHeight = svg.clientHeight;
    const frontPoints = [
      { x: frontRect.x1, y: frontRect.y1 },
      { x: frontRect.x2, y: frontRect.y1 },
      { x: frontRect.x2, y: frontRect.y2 },
      { x: frontRect.x1, y: frontRect.y2 }
    ];
    frontPoints.forEach((pt, i) => {
      const pixelX = (pt.x / logicalWidth) * actualWidth;
      const pixelY = (pt.y / logicalHeight) * actualHeight;
      markers[i].style.left = pixelX + "px";
      markers[i].style.top = pixelY + "px";
    });
    let B_back = { x: frontRect.x2 + offset.dx, y: frontRect.y1 + offset.dy };
    const backPixelX = (B_back.x / logicalWidth) * actualWidth;
    const backPixelY = (B_back.y / logicalHeight) * actualHeight;
    backMarker.style.left = backPixelX + "px";
    backMarker.style.top = backPixelY + "px";
  }

  // --- Create 4 markers for the front face vertices.
  for (let i = 0; i < 4; i++) {
    const marker = document.createElement("div");
    marker.className = "prism-marker";
    marker.style.position = "absolute";
    marker.style.width = "10px";
    marker.style.height = "10px";
    marker.style.backgroundColor = strokeInput.value;
    marker.style.borderRadius = "50%";
    marker.style.cursor = "move";
    marker.dataset.index = i.toString();
    content.appendChild(marker);
    markers.push(marker);
    marker.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      const index = parseInt(marker.dataset.index);
      function onMouseMove(e) {
        const svgRect = svg.getBoundingClientRect();
        const scaleX = logicalWidth / svgRect.width;
        const scaleY = logicalHeight / svgRect.height;
        const newX = (e.clientX - svgRect.left) * scaleX;
        const newY = (e.clientY - svgRect.top) * scaleY;
        if (index === 0) { frontRect.x1 = newX; frontRect.y1 = newY; }
        else if (index === 1) { frontRect.x2 = newX; frontRect.y1 = newY; }
        else if (index === 2) { frontRect.x2 = newX; frontRect.y2 = newY; }
        else if (index === 3) { frontRect.x1 = newX; frontRect.y2 = newY; }
        updatePrismDrawing();
      }
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
  }

  // --- Create the back marker for adjusting offset.
  const backMarker = document.createElement("div");
  backMarker.className = "prism-marker back-marker";
  backMarker.style.position = "absolute";
  backMarker.style.width = "10px";
  backMarker.style.height = "10px";
  backMarker.style.backgroundColor = strokeInput.value;
  backMarker.style.borderRadius = "50%";
  backMarker.style.cursor = "move";
  content.appendChild(backMarker);
  backMarker.addEventListener("mousedown", (e) => {
    e.stopPropagation();
    function onMouseMove(e) {
      const svgRect = svg.getBoundingClientRect();
      const scaleX = logicalWidth / svgRect.width;
      const scaleY = logicalHeight / svgRect.height;
      let newX = (e.clientX - svgRect.left) * scaleX;
      let newY = (e.clientY - svgRect.top) * scaleY;
      const B = { x: frontRect.x2, y: frontRect.y1 };
      newX = Math.max(B.x, Math.min(newX, logicalWidth));
      newY = Math.max(0, Math.min(newY, B.y));
      offset.dx = newX - B.x;
      offset.dy = newY - B.y;
      updatePrismDrawing();
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Attach listeners so that when stroke, fill, fill type, or prism type changes, update immediately.
  strokeInput.addEventListener("input", updatePrismDrawing);
  fillInput.addEventListener("input", updatePrismDrawing);
  fillTypeSelect.addEventListener("change", updatePrismDrawing);
  prismTypeSelect.addEventListener("change", updatePrismDrawing);
  fillTypeDropdown.addEventListener("change", function() {
    if (fillTypeDropdown.value === "none") {
      fillInput.disabled = true;
      fillTypeSelect.disabled = true;
    } else {
      fillInput.disabled = false;
      fillTypeSelect.disabled = false;
    }
    updatePrismDrawing();
  });

  // --- Blue resize handle.
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  container.appendChild(resizeHandle);
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = container.offsetWidth;
    const startHeight = container.offsetHeight;
    function onMouseMove(e) {
      const newWidth = startWidth + (e.clientX - startX);
      const newHeight = startHeight + (e.clientY - startY);
      if (newWidth > 50) {
        container.style.width = newWidth + "px";
        content.style.width = newWidth + "px";
        svg.setAttribute("width", newWidth);
      }
      if (newHeight > toolbarHeight + 50) {
        container.style.height = newHeight + "px";
        content.style.height = (newHeight - toolbarHeight) + "px";
        svg.setAttribute("height", newHeight - toolbarHeight);
      }
      updatePrismDrawing();
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Show toolbar and markers when container is clicked.
  container.addEventListener("click", function(e) {
    e.stopPropagation();
    document.querySelectorAll('.element-controls').forEach(ctrl => ctrl.style.display = "none");
    toolbar.style.display = "flex";
    activeElement = container;
    raiseElementTemporarily(container);
    markers.forEach(marker => marker.style.display = "block");
    backMarker.style.display = "block";
    container.focus();
  });
  // When container receives focus, show markers.
  container.addEventListener("focus", function(e) {
    markers.forEach(marker => marker.style.display = "block");
    backMarker.style.display = "block";
  });
  // Hide markers when container loses focus.
  container.addEventListener("blur", function() {
    markers.forEach(marker => marker.style.display = "none");
    backMarker.style.display = "none";
  });

  makeDraggable(dragHandle, container);
  canvas.appendChild(container);
  updatePrismDrawing();
}

// --- addTriangle function ---
function addTriangle() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20; // fixed toolbar height
  const padding = 20;       // extra padding around the triangle

  // Create the outer container.
  const container = document.createElement("div");
  container.className = "draggable-element triangle-container";
  container.style.position = "absolute";
  container.style.left = `${nextElementOffset}px`;
  container.style.top = `${nextElementOffset}px`;
  // Initial dimensions (will be updated by updateContainer)
  container.style.width = "150px";
  container.style.height = (toolbarHeight + 150) + "px";
  nextElementOffset += 10;

  // Create the toolbar.
  const toolbar = document.createElement("div");
  toolbar.className = "triangle-toolbar element-controls";
  toolbar.style.width = "150px"; // fixed toolbar width
  toolbar.style.height = toolbarHeight + "px";
  toolbar.style.boxSizing = "border-box";
  toolbar.style.backgroundColor = "#f0f0f0";
  toolbar.style.display = "none"; // hidden by default
  toolbar.style.alignItems = "center";
  toolbar.style.flexShrink = "0";

  // --- Left side of toolbar ---
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  leftControls.style.flex = "1";
  
  // Drag handle.
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);
  
  // Stroke color control.
  const strokeGroup = document.createElement("div");
  strokeGroup.style.display = "flex";
  strokeGroup.style.alignItems = "center";
  strokeGroup.style.marginRight = "5px";
  const strokeLabel = document.createElement("span");
  strokeLabel.textContent = "Line:";
  strokeLabel.style.fontSize = "12px";
  strokeGroup.appendChild(strokeLabel);
  const strokeInput = document.createElement("input");
  strokeInput.type = "color";
  strokeInput.value = "#000000";
  strokeInput.style.marginLeft = "3px";
  strokeGroup.appendChild(strokeInput);
  leftControls.appendChild(strokeGroup);
  
  // Fill color control.
  const fillGroup = document.createElement("div");
  fillGroup.style.display = "flex";
  fillGroup.style.alignItems = "center";
  fillGroup.style.marginRight = "5px";
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Fill:";
  fillLabel.style.fontSize = "12px";
  fillGroup.appendChild(fillLabel);
  const fillInput = document.createElement("input");
  fillInput.type = "color";
  fillInput.value = "#ffffff";
  fillInput.style.marginLeft = "3px";
  fillGroup.appendChild(fillInput);
  leftControls.appendChild(fillGroup);

  // NEW: Vertex Color control
  const vertexColorGroup = document.createElement("div");
  vertexColorGroup.style.display = "flex";
  vertexColorGroup.style.alignItems = "center";
  vertexColorGroup.style.marginRight = "5px";
  const vertexColorLabel = document.createElement("span");
  vertexColorLabel.textContent = "Vertex:";
  vertexColorLabel.style.fontSize = "12px";
  vertexColorGroup.appendChild(vertexColorLabel);
  const vertexColorInput = document.createElement("input");
  vertexColorInput.type = "color";
  vertexColorInput.value = "#0000ff"; // Default blue
  vertexColorInput.style.marginLeft = "3px";
  vertexColorGroup.appendChild(vertexColorInput);
  leftControls.appendChild(vertexColorGroup);

  // NEW: Vertex Size control
  const vertexSizeGroup = document.createElement("div");
  vertexSizeGroup.style.display = "flex";
  vertexSizeGroup.style.alignItems = "center";
  vertexSizeGroup.style.marginRight = "5px";
  const vertexSizeLabel = document.createElement("span");
  vertexSizeLabel.textContent = "Size:";
  vertexSizeLabel.style.fontSize = "12px";
  vertexSizeGroup.appendChild(vertexSizeLabel);
  const vertexSizeInput = document.createElement("input");
  vertexSizeInput.type = "number";
  vertexSizeInput.min = "1";
  vertexSizeInput.max = "20";
  vertexSizeInput.value = "10"; // Default size
  vertexSizeInput.style.width = "40px";
  vertexSizeInput.style.marginLeft = "3px";
  vertexSizeGroup.appendChild(vertexSizeInput);
  leftControls.appendChild(vertexSizeGroup);
  
  // Vertex visibility control.
  const vertexGroup = document.createElement("div");
  vertexGroup.style.display = "flex";
  vertexGroup.style.alignItems = "center";
  vertexGroup.style.marginRight = "5px";
  const vertexLabel = document.createElement("span");
  vertexLabel.textContent = "Show Vertices:";
  vertexLabel.style.fontSize = "12px";
  vertexGroup.appendChild(vertexLabel);
  const vertexSelect = document.createElement("select");
  vertexSelect.style.marginLeft = "3px";
  vertexSelect.style.fontSize = "12px";
  const optYes = document.createElement("option");
  optYes.value = "yes";
  optYes.textContent = "Yes";
  const optNo = document.createElement("option");
  optNo.value = "no";
  optNo.textContent = "No";
  vertexSelect.appendChild(optYes);
  vertexSelect.appendChild(optNo);
  vertexGroup.appendChild(vertexSelect);
  leftControls.appendChild(vertexGroup);

  toolbar.appendChild(leftControls);

  // --- Right side of toolbar: Delete button ---
  const rightControls = document.createElement("div");
  rightControls.style.flexShrink = "0";
  const deleteButton = document.createElement("button");
  deleteButton.className = "delete-button";
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  rightControls.appendChild(deleteButton);
  toolbar.appendChild(rightControls);
  
  container.appendChild(toolbar);

  // Create the content div to hold the SVG and markers.
  const content = document.createElement("div");
  content.className = "triangle-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "visible"; // Allow markers to show outside.
  container.appendChild(content);

  // Create the SVG element.
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", "150");
  svg.setAttribute("height", "150");
  svg.setAttribute("viewBox", "0 0 150 150");
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Create an SVG group.
  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svg.appendChild(g);

  // --- Use absolute coordinates for vertices ---
  let vertices = [
    { x: 75, y: 15 },
    { x: 30, y: 135 },
    { x: 120, y: 135 }
  ];

  // Create the triangle polygon.
  const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  polygon.setAttribute("stroke", "#000000");
  polygon.setAttribute("stroke-width", "2");
  polygon.setAttribute("fill", "transparent");
  g.appendChild(polygon);

  function updatePolygon() {
    const pointsStr = vertices.map(v => `${v.x},${v.y}`).join(" ");
    polygon.setAttribute("points", pointsStr);
  }
  updatePolygon();

  // --- Create vertex markers ---
  let markers = [];
  function createMarkers() {
    markers.forEach(m => m.remove());
    markers = [];
    vertices.forEach((v, i) => {
      const marker = document.createElement("div");
      marker.className = "triangle-point";
      marker.style.position = "absolute";
      marker.style.width = vertexSizeInput.value + "px";
      marker.style.height = vertexSizeInput.value + "px";
      marker.style.background = vertexColorInput.value;
      marker.style.borderRadius = "50%";
      marker.style.cursor = "move";
      marker.dataset.index = i;
      markers.push(marker);
      content.appendChild(marker);
    });
  }
  createMarkers();

  function updateMarkers() {
    const viewBoxArr = svg.getAttribute("viewBox").split(" ").map(Number);
    const [vx, vy] = viewBoxArr;
    const markerSize = parseInt(vertexSizeInput.value);
    const halfSize = markerSize / 2;
    
    markers.forEach((marker, i) => {
      marker.style.left = (vertices[i].x - vx - halfSize) + "px";
      marker.style.top = (vertices[i].y - vy - halfSize) + "px";
      marker.style.width = markerSize + "px";
      marker.style.height = markerSize + "px";
      marker.style.background = vertexColorInput.value;
    });
  }
  updateMarkers();

  // --- Update container & SVG dimensions based on polygon bounding box ---
  function updateContainer() {
    const bbox = polygon.getBBox();
    const newWidth = bbox.width + 2 * padding;
    const newHeight = bbox.height + 2 * padding;
    const newViewX = bbox.x - padding;
    const newViewY = bbox.y - padding;
    svg.setAttribute("viewBox", `${newViewX} ${newViewY} ${newWidth} ${newHeight}`);
    svg.setAttribute("width", newWidth);
    svg.setAttribute("height", newHeight);
    container.style.left = newViewX + "px";
    container.style.top = newViewY + "px";
    container.style.width = newWidth + "px";
    container.style.height = (toolbarHeight + newHeight) + "px";
    updateMarkers();
  }

  // --- Marker dragging events ---
  markers.forEach((marker, i) => {
    marker.addEventListener("mousedown", function(e) {
      e.preventDefault();
      e.stopPropagation();
      let hasDragged = false;
      function onMouseMove(e) {
        hasDragged = true;
        const svgRect = svg.getBoundingClientRect();
        const viewBoxArr = svg.getAttribute("viewBox").split(" ").map(Number);
        const [vx, vy, vw, vh] = viewBoxArr;
        const scaleX = vw / svgRect.width;
        const scaleY = vh / svgRect.height;
        const newX = (e.clientX - svgRect.left) * scaleX + vx;
        const newY = (e.clientY - svgRect.top) * scaleY + vy;
        vertices[i].x = newX;
        vertices[i].y = newY;
        updatePolygon();
        updateContainer();
      }
      function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        if (hasDragged) {
          ignoreNextClick = true;
        }
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
  });

  // --- Blue resize handle for uniform scaling ---
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  container.appendChild(resizeHandle);

  // Revised blue resize handle: cache viewBox and centroid in screen coordinates.
  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    // Cache current SVG rect and viewBox.
    const svgRect = svg.getBoundingClientRect();
    const viewBoxArr = svg.getAttribute("viewBox").split(" ").map(Number);
    const [vx, vy, vw, vh] = viewBoxArr;
    const convX = svgRect.width / vw;
    const convY = svgRect.height / vh;
    // Save initial mouse position.
    const initMouse = { x: e.clientX, y: e.clientY };
    // Compute centroid from current vertices.
    const centroid = {
      x: (vertices[0].x + vertices[1].x + vertices[2].x) / 3,
      y: (vertices[0].y + vertices[1].y + vertices[2].y) / 3
    };
    // Convert centroid to screen coordinates (using cached values).
    const centroidScreen = {
      x: svgRect.left + (centroid.x - vx) * convX,
      y: svgRect.top + (centroid.y - vy) * convY
    };
    const initDistance = Math.hypot(initMouse.x - centroidScreen.x, initMouse.y - centroidScreen.y);
    // Save original vertices.
    const origVertices = vertices.map(v => ({ x: v.x, y: v.y }));
    function onMouseMove(e) {
      const newMouse = { x: e.clientX, y: e.clientY };
      const newDistance = Math.hypot(newMouse.x - centroidScreen.x, newMouse.y - centroidScreen.y);
      const scaleFactor = newDistance / initDistance;
      vertices = origVertices.map(v => ({
        x: centroid.x + (v.x - centroid.x) * scaleFactor,
        y: centroid.y + (v.y - centroid.y) * scaleFactor
      }));
      updatePolygon();
      updateContainer();
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", function() {
      document.removeEventListener("mousemove", onMouseMove);
    }, { once: true });
  });

  // --- Draggable container via drag handle ---
  dragHandle.addEventListener("mousedown", (e) => {
    e.preventDefault();
    const canvasRect = canvas.getBoundingClientRect();
    const rect = container.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const shiftX = e.clientX - rect.left;
    const shiftY = e.clientY - rect.top;
    let isDraggingLocal = false;
    
    function onMouseMove(e) {
      let dx = e.clientX - startX;
      let dy = e.clientY - startY;
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
        isDraggingLocal = true;
      }
      let newLeft = e.clientX - shiftX - canvasRect.left;
      let newTop = e.clientY - shiftY - canvasRect.top;
      container.style.left = newLeft + "px";
      container.style.top = newTop + "px";
    }
    
    function onMouseUp(e) {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      if (isDraggingLocal) {
        ignoreNextClick = true;
      }
    }
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // --- Delete button functionality ---
  deleteButton.addEventListener("click", () => {
    container.remove();
  });

  // --- Show toolbar on container click ---


  container.addEventListener("click", (e) => {
  e.stopPropagation();
  document.querySelectorAll('.element-controls').forEach(ctrl => ctrl.style.display = "none");
  toolbar.style.display = "flex";
  activeElement = container;
});

// Extra toolbar controls with stopPropagation added
strokeInput.addEventListener("input", (e) => {
  e.stopPropagation();
  polygon.setAttribute("stroke", strokeInput.value);
  markers.forEach(marker => marker.style.background = strokeInput.value);
});

fillInput.addEventListener("input", (e) => {
  e.stopPropagation();
  polygon.setAttribute("fill", fillInput.value);
});

// Event listeners for vertex appearance controls with stopPropagation
vertexColorInput.addEventListener("input", (e) => {
  e.stopPropagation();
  markers.forEach(marker => marker.style.background = vertexColorInput.value);
});

vertexSizeInput.addEventListener("input", (e) => {
  e.stopPropagation();
  updateMarkers();
});

vertexSelect.addEventListener("change", (e) => {
  e.stopPropagation();
  const show = vertexSelect.value === "yes";
  markers.forEach(marker => marker.style.display = show ? "block" : "none");
});

canvas.appendChild(container);
// Initial update.
updateContainer();

}


// NEW: Add Polygon – similar to addTriangle but with a “Number of sides” control.
function addPolygon() {
  const canvas = document.getElementById("problem-canvas");
  const toolbarHeight = 20;
  const padding = 20;

  // Create the outer container.
  const container = document.createElement("div");
  container.className = "draggable-element polygon-container";
  container.style.position = "absolute";
  container.style.left = `${nextElementOffset}px`;
  container.style.top = `${nextElementOffset}px`;
  container.style.width = "200px";
  container.style.height = (toolbarHeight + 200) + "px";
  nextElementOffset += 10;

  // Create the toolbar.
  const toolbar = document.createElement("div");
  toolbar.className = "polygon-toolbar element-controls";
  toolbar.style.width = "200px";
  toolbar.style.height = toolbarHeight + "px";
  toolbar.style.boxSizing = "border-box";
  // Set a solid background color and ensure full opacity:
  toolbar.style.backgroundColor = "#f0f0f0";
  toolbar.style.opacity = "1";
  toolbar.style.display = "none"; // hidden by default
  toolbar.style.alignItems = "center";
  toolbar.style.flexShrink = "0";

  // Left controls container.
  const leftControls = document.createElement("div");
  leftControls.style.display = "flex";
  leftControls.style.alignItems = "center";
  leftControls.style.flex = "1";

  // Drag handle.
  const dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.style.cursor = "move";
  dragHandle.style.marginRight = "5px";
  dragHandle.textContent = "☰";
  leftControls.appendChild(dragHandle);

  // Stroke color control.
  const strokeGroup = document.createElement("div");
  strokeGroup.style.display = "flex";
  strokeGroup.style.alignItems = "center";
  strokeGroup.style.marginRight = "5px";
  const strokeLabel = document.createElement("span");
  strokeLabel.textContent = "Line:";
  strokeLabel.style.fontSize = "12px";
  strokeGroup.appendChild(strokeLabel);
  const strokeInput = document.createElement("input");
  strokeInput.type = "color";
  strokeInput.value = "#000000";
  strokeInput.style.marginLeft = "3px";
  strokeGroup.appendChild(strokeInput);
  leftControls.appendChild(strokeGroup);

  // Fill color control.
  const fillGroup = document.createElement("div");
  fillGroup.style.display = "flex";
  fillGroup.style.alignItems = "center";
  fillGroup.style.marginRight = "5px";
  const fillLabel = document.createElement("span");
  fillLabel.textContent = "Fill:";
  fillLabel.style.fontSize = "12px";
  fillGroup.appendChild(fillLabel);
  const fillInput = document.createElement("input");
  fillInput.type = "color";
  fillInput.value = "#ffffff";
  fillInput.style.marginLeft = "3px";
  fillGroup.appendChild(fillInput);
  leftControls.appendChild(fillGroup);

  // Vertex color control.
  const vertexColorGroup = document.createElement("div");
  vertexColorGroup.style.display = "flex";
  vertexColorGroup.style.alignItems = "center";
  vertexColorGroup.style.marginRight = "5px";
  const vertexColorLabel = document.createElement("span");
  vertexColorLabel.textContent = "Vertex:";
  vertexColorLabel.style.fontSize = "12px";
  vertexColorGroup.appendChild(vertexColorLabel);
  const vertexColorInput = document.createElement("input");
  vertexColorInput.type = "color";
  vertexColorInput.value = "#0000ff";
  vertexColorInput.style.marginLeft = "3px";
  vertexColorGroup.appendChild(vertexColorInput);
  leftControls.appendChild(vertexColorGroup);

  // Vertex size control.
  const vertexSizeGroup = document.createElement("div");
  vertexSizeGroup.style.display = "flex";
  vertexSizeGroup.style.alignItems = "center";
  vertexSizeGroup.style.marginRight = "5px";
  const vertexSizeLabel = document.createElement("span");
  vertexSizeLabel.textContent = "Size:";
  vertexSizeLabel.style.fontSize = "12px";
  vertexSizeGroup.appendChild(vertexSizeLabel);
  const vertexSizeInput = document.createElement("input");
  vertexSizeInput.type = "number";
  vertexSizeInput.min = "1";
  vertexSizeInput.max = "20";
  vertexSizeInput.value = "5";
  vertexSizeInput.style.width = "40px";
  vertexSizeInput.style.marginLeft = "3px";
  vertexSizeGroup.appendChild(vertexSizeInput);
  leftControls.appendChild(vertexSizeGroup);

  // Vertex visibility control.
  const vertexGroup = document.createElement("div");
  vertexGroup.style.display = "flex";
  vertexGroup.style.alignItems = "center";
  vertexGroup.style.marginRight = "5px";
  const vertexLabel = document.createElement("span");
  vertexLabel.textContent = "Show:";
  vertexLabel.style.fontSize = "12px";
  vertexGroup.appendChild(vertexLabel);
  const vertexSelect = document.createElement("select");
  vertexSelect.style.marginLeft = "3px";
  vertexSelect.style.fontSize = "12px";
  const optYes = document.createElement("option");
  optYes.value = "yes";
  optYes.textContent = "Yes";
  const optNo = document.createElement("option");
  optNo.value = "no";
  optNo.textContent = "No";
  vertexSelect.appendChild(optYes);
  vertexSelect.appendChild(optNo);
  // Set default to "yes"
  vertexSelect.value = "yes";
  vertexGroup.appendChild(vertexSelect);
  leftControls.appendChild(vertexGroup);

  // Number of sides control.
  const sidesGroup = document.createElement("div");
  sidesGroup.style.display = "flex";
  sidesGroup.style.alignItems = "center";
  sidesGroup.style.marginRight = "5px";
  const sidesLabel = document.createElement("span");
  sidesLabel.textContent = "Sides:";
  sidesLabel.style.fontSize = "12px";
  sidesGroup.appendChild(sidesLabel);
  const sidesInput = document.createElement("input");
  sidesInput.type = "number";
  sidesInput.min = "3";
  sidesInput.value = "5";
  sidesInput.style.width = "40px";
  sidesInput.style.marginLeft = "3px";
  sidesGroup.appendChild(sidesInput);
  leftControls.appendChild(sidesGroup);

  toolbar.appendChild(leftControls);

  // Right side of toolbar: Delete button.
  const rightControls = document.createElement("div");
  rightControls.style.flexShrink = "0";
  const deleteButton = document.createElement("button");
  deleteButton.className = "delete-button";
  deleteButton.textContent = "Delete";
  deleteButton.style.fontSize = "12px";
  rightControls.appendChild(deleteButton);
  toolbar.appendChild(rightControls);
  container.appendChild(toolbar);

  // Create content div for the SVG.
  const content = document.createElement("div");
  content.className = "polygon-content";
  content.style.position = "absolute";
  content.style.top = toolbarHeight + "px";
  content.style.left = "0";
  content.style.width = "100%";
  content.style.height = `calc(100% - ${toolbarHeight}px)`;
  content.style.overflow = "hidden";
  container.appendChild(content);

  // Create the SVG element.
  const svgWidth = 200, svgHeight = 200;
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  content.appendChild(svg);

  // Create an SVG group and the polygon element.
  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svg.appendChild(g);
  const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  polygon.setAttribute("stroke", strokeInput.value);
  polygon.setAttribute("stroke-width", "2");
  polygon.setAttribute("fill", fillInput.value);
  g.appendChild(polygon);

  // Compute initial vertices for a regular polygon.
  let numSides = parseInt(sidesInput.value);
  let center = { x: svgWidth / 2, y: svgHeight / 2 };
  let radius = Math.min(svgWidth, svgHeight) * 0.4;
  let vertices = [];

  function updateVertices() {
    numSides = parseInt(sidesInput.value);
    vertices = [];
    const angleOffset = -Math.PI / 2; // so the polygon points upward.
    for (let i = 0; i < numSides; i++) {
      const angle = angleOffset + (2 * Math.PI * i) / numSides;
      const x = center.x + radius * Math.cos(angle);
      const y = center.y + radius * Math.sin(angle);
      vertices.push({ x: x, y: y });
    }
  }
  updateVertices();

  function updatePolygon() {
    const pointsStr = vertices.map(v => `${v.x},${v.y}`).join(" ");
    polygon.setAttribute("points", pointsStr);
  }
  updatePolygon();

  // Create draggable markers for each vertex.
  let markers = [];
  function createMarkers() {
    markers.forEach(m => m.remove());
    markers = [];
    for (let i = 0; i < vertices.length; i++) {
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      marker.setAttribute("cx", vertices[i].x);
      marker.setAttribute("cy", vertices[i].y);
      marker.setAttribute("r", vertexSizeInput.value);
      marker.setAttribute("fill", vertexColorInput.value);
      marker.setAttribute("stroke", "black");
      marker.setAttribute("stroke-width", "1");
      marker.style.cursor = "move";
      marker.dataset.index = i;
      markers.push(marker);
      svg.appendChild(marker);

      // Add dragging for marker.
      marker.addEventListener("mousedown", function(e) {
        e.stopPropagation();
        const index = parseInt(marker.dataset.index);
        const startX = e.clientX, startY = e.clientY;
        const origX = vertices[index].x, origY = vertices[index].y;
        function onMouseMove(e) {
          const dx = e.clientX - startX, dy = e.clientY - startY;
          vertices[index].x = origX + dx;
          vertices[index].y = origY + dy;
          updatePolygon();
          marker.setAttribute("cx", vertices[index].x);
          marker.setAttribute("cy", vertices[index].y);
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
  }
  createMarkers();

  // Toggle vertex markers visibility.
  vertexSelect.addEventListener("change", function() {
    const show = vertexSelect.value === "yes";
    markers.forEach(marker => {
      marker.style.display = show ? "block" : "none";
    });
  });

  // Update markers when vertex size or color changes.
  vertexSizeInput.addEventListener("input", function() {
    markers.forEach(marker => marker.setAttribute("r", vertexSizeInput.value));
  });
  vertexColorInput.addEventListener("input", function() {
    markers.forEach(marker => marker.setAttribute("fill", vertexColorInput.value));
  });

  // When number of sides changes, reinitialize vertices and markers.
  sidesInput.addEventListener("input", function() {
    updateVertices();
    updatePolygon();
    createMarkers();
    const show = vertexSelect.value === "yes";
    markers.forEach(marker => marker.style.display = show ? "block" : "none");
  });

  // Update polygon stroke and fill when controls change.
  strokeInput.addEventListener("input", function() {
    polygon.setAttribute("stroke", strokeInput.value);
  });
  fillInput.addEventListener("input", function() {
    polygon.setAttribute("fill", fillInput.value);
  });

  // Delete button.
  deleteButton.addEventListener("click", function(e) {
    e.stopPropagation();
    container.remove();
  });

  // Make container draggable.
  makeDraggable(dragHandle, container);

  // Add a blue resize handle.
  const resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.cursor = "se-resize";
  container.appendChild(resizeHandle);

  resizeHandle.addEventListener("mousedown", function(e) {
    e.preventDefault();
    const startX = e.clientX, startY = e.clientY;
    const startWidth = container.offsetWidth, startHeight = container.offsetHeight;
    function onMouseMove(e) {
      const newWidth = startWidth + (e.clientX - startX);
      const newHeight = startHeight + (e.clientY - startY);
      if (newWidth > 50) {
        container.style.width = newWidth + "px";
        content.style.width = newWidth + "px";
        svg.setAttribute("width", newWidth);
      }
      if (newHeight > toolbarHeight + 50) {
        container.style.height = newHeight + "px";
        content.style.height = (newHeight - toolbarHeight) + "px";
        svg.setAttribute("height", newHeight - toolbarHeight);
      }
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });

  // Show toolbar on container click.
  container.addEventListener("click", function(e) {
    e.stopPropagation();
    document.querySelectorAll('.element-controls').forEach(ctrl => ctrl.style.display = "none");
    toolbar.style.display = "flex";
    activeElement = container;
    raiseElementTemporarily(container);
  });

  canvas.appendChild(container);
}



function addTable() {
  let rows = prompt("Enter number of rows:", "3");
  let cols = prompt("Enter number of columns:", "3");
  rows = parseInt(rows);
  cols = parseInt(cols);
  if (isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) {
    alert("Invalid input for rows or columns.");
    return;
  }
  let tableHTML = "<table style='border-collapse: collapse;'>";
  for (let i = 0; i < rows; i++) {
    tableHTML += "<tr>";
    for (let j = 0; j < cols; j++) {
      tableHTML += "<td contenteditable='true' class='text-box' style='border: .5px solid black; padding: 5px; min-width: 30px; height:30px;'> </td>";
    }
    tableHTML += "</tr>";
  }
  tableHTML += "</table>";
  const canvas = document.getElementById('problem-canvas');
  const tableElement = createDraggableElement(tableHTML, false);
  canvas.appendChild(tableElement);
  
  // NEW: Attach click handlers to every cell in the new table.
  attachCellClickHandlers(tableElement.querySelector("table"));
  
  updateVariables();
  makeTableResizable(tableElement.querySelector('table'));
}
function makeTableResizable(table) {
  if (!table) return;

  // ========= VERTICAL (COLUMN) RESIZING =========

  // Create or update a <colgroup> so that each column’s width is set independently.
  let colgroup = table.querySelector("colgroup");
  const firstRow = table.rows[0];
  if (!colgroup) {
    colgroup = document.createElement("colgroup");
    for (let i = 0; i < firstRow.cells.length; i++) {
      let col = document.createElement("col");
      // Use the cell’s current width (or a default if zero)
      let cellWidth = firstRow.cells[i].offsetWidth || 100;
      col.style.width = cellWidth + "px";
      colgroup.appendChild(col);
    }
    table.insertBefore(colgroup, table.firstChild);
  }
  let nCols = colgroup.children.length;

  // Create an array to hold each column’s width.
  let widths = [];
  for (let i = 0; i < nCols; i++) {
    widths[i] = colgroup.children[i].offsetWidth;
  }
  const minColWidth = 30; // Minimum allowed width (in pixels)

  // Helper: compute the cumulative positions of column boundaries.
  // positions[0] = 0, positions[1] = widths[0], positions[2] = widths[0]+widths[1], …, positions[nCols] = total table width.
  function computePositions() {
    let positions = [0];
    let sum = 0;
    for (let i = 0; i < nCols; i++) {
      sum += widths[i];
      positions.push(sum);
    }
    return positions;
  }
  let positions = computePositions();

  // Set the table’s overall width (it will grow or shrink as columns are resized)
  table.style.width = positions[nCols] + "px";
  table.style.position = "relative"; // so overlay elements are positioned relative to the table

  // Remove any existing vertical resizer overlay.
  let oldVResizer = table.querySelector(".vertical-resizer-container");
  if (oldVResizer) oldVResizer.remove();

  // Create an overlay container for vertical (column) resizers.
  let vResizerContainer = document.createElement("div");
  vResizerContainer.className = "vertical-resizer-container";
  vResizerContainer.style.position = "absolute";
  vResizerContainer.style.top = "0";
  vResizerContainer.style.left = "0";
  vResizerContainer.style.width = "100%";
  vResizerContainer.style.height = "100%";
  // Allow mouse events on the resizers even though the container itself ignores them.
  vResizerContainer.style.pointerEvents = "none";
  table.appendChild(vResizerContainer);

  // Helper: update the <colgroup> and reposition all vertical resizers.
  function updateTable() {
    // Update each col’s width in the colgroup.
    for (let i = 0; i < nCols; i++) {
      colgroup.children[i].style.width = widths[i] + "px";
    }
    // Recompute boundary positions.
    positions = computePositions();
    // Update overall table width.
    table.style.width = positions[nCols] + "px";
    // Update all vertical resizers’ positions.
    let resizers = vResizerContainer.children;
    for (let j = 0; j < resizers.length; j++) {
      resizers[j].style.left = (positions[j] - 2) + "px"; // “-2” centers a 4px wide resizer
    }
  }

  // Create one vertical resizer for each boundary from 0 to nCols.
  for (let i = 0; i <= nCols; i++) {
    let resizer = document.createElement("div");
    resizer.className = "vertical-resizer";
    resizer.style.position = "absolute";
    resizer.style.top = "0";
    resizer.style.width = "4px";
    resizer.style.height = "100%";
    resizer.style.cursor = "col-resize";
    // Enable pointer events on the resizer even though the container ignores them.
    resizer.style.pointerEvents = "auto";

    // Optional: provide a light hover background for feedback.
    resizer.addEventListener("mouseenter", () => {
      resizer.style.backgroundColor = "rgba(0,0,0,0.2)";
    });
    resizer.addEventListener("mouseleave", () => {
      resizer.style.backgroundColor = "transparent";
    });

    // Determine the initial x-position for this boundary.
    let initialX = (i === 0) ? 0 : (i === nCols ? positions[nCols] : positions[i]);
    resizer.style.left = (initialX - 2) + "px";

    // Add a mousedown listener.
    resizer.addEventListener("mousedown", function (e) {
      e.preventDefault();
      let startX = e.clientX;
      // Determine which column to adjust:
      let colIndex = (i === 0) ? 0 : (i === nCols ? nCols - 1 : i - 1);
      let startWidth = widths[colIndex];
      function onMouseMove(e) {
        let dx = e.clientX - startX;
        let newWidth = startWidth + dx;
        if (newWidth < minColWidth) newWidth = minColWidth;
        widths[colIndex] = newWidth;
        updateTable();
      }
      function onMouseUp(e) {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
    vResizerContainer.appendChild(resizer);
  }

  // ===== HORIZONTAL (ROW) RESIZING =====

  // We assume the table has a <tbody>; if not, use the table element.
  let tbody = table.tBodies[0] || table;
  const nRows = tbody.rows.length;
  const minRowHeight = 20; // Minimum row height

  // Compute the initial absolute y-positions for each row boundary.
  let rowPositions = [];
  let rpos = 0;
  rowPositions.push(rpos);
  for (let i = 0; i < nRows; i++) {
    rpos += tbody.rows[i].offsetHeight;
    rowPositions.push(rpos);
  }
  table.style.height = rpos + "px";

  // Remove any existing horizontal resizer container.
  let oldHResizer = table.querySelector(".horizontal-resizer-container");
  if (oldHResizer) oldHResizer.remove();

  // Create an overlay container for horizontal (row) resizers.
  let hResizerContainer = document.createElement("div");
  hResizerContainer.className = "horizontal-resizer-container";
  hResizerContainer.style.position = "absolute";
  hResizerContainer.style.left = "0";
  hResizerContainer.style.top = "0";
  hResizerContainer.style.width = "100%";
  hResizerContainer.style.height = "100%";
  hResizerContainer.style.pointerEvents = "none";
  table.appendChild(hResizerContainer);

  // Helper to position a horizontal resizer element at a given y.
  function positionHResizer(resizer, y) {
    resizer.style.top = (y - 2) + "px";
  }

  // Create a horizontal resizer for each row boundary.
  for (let i = 0; i <= nRows; i++) {
    let resizer = document.createElement("div");
    resizer.className = "horizontal-resizer";
    resizer.style.position = "absolute";
    resizer.style.left = "0";
    resizer.style.height = "4px";
    resizer.style.width = "100%";
    resizer.style.cursor = "row-resize";
    resizer.style.pointerEvents = "auto";
    resizer.addEventListener("mouseenter", () => {
      resizer.style.backgroundColor = "rgba(0,0,0,0.2)";
    });
    resizer.addEventListener("mouseleave", () => {
      resizer.style.backgroundColor = "transparent";
    });
    let initialY = (i === 0) ? 0 : (i === nRows ? rowPositions[nRows] : rowPositions[i]);
    positionHResizer(resizer, initialY);

    resizer.addEventListener("mousedown", function (e) {
      e.preventDefault();
      let startY = e.clientY;
      // Determine which row to adjust:
      let rowIndex = (i === 0) ? 0 : (i === nRows ? nRows - 1 : i - 1);
      let startHeight = tbody.rows[rowIndex].offsetHeight;

      function onMouseMove(e) {
        let dy = e.clientY - startY;
        let newHeight = startHeight + dy;
        if (newHeight < minRowHeight) newHeight = minRowHeight;
        tbody.rows[rowIndex].style.height = newHeight + "px";

        // Recompute row positions.
        let totalHeight = 0;
        rowPositions = [];
        rowPositions.push(0);
        for (let j = 0; j < nRows; j++) {
          totalHeight += tbody.rows[j].offsetHeight;
          rowPositions.push(totalHeight);
        }
        table.style.height = totalHeight + "px";
        // Update all horizontal resizers.
        let hResizers = hResizerContainer.children;
        for (let k = 0; k <= nRows; k++) {
          positionHResizer(hResizers[k], rowPositions[k]);
        }
      }
      function onMouseUp(e) {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    });
    hResizerContainer.appendChild(resizer);
  }
}
/******** Edit Graph ********/
function editGraph(container) {
  let currentXInterval = container.dataset.xInterval || "1";
  let currentYInterval = container.dataset.yInterval || "1";
  let currentXLabel = container.dataset.xLabel || "X";
  let currentYLabel = container.dataset.yLabel || "Y";
  let currentFontSize = container.dataset.fontSize || "12";
  let currentEquation = container.dataset.equation || "";
   
  let newXInterval = prompt("Enter x-axis interval:", currentXInterval);
  let newYInterval = prompt("Enter y-axis interval:", currentYInterval);
  let newXLabel = prompt("Enter x-axis label:", currentXLabel);
  let newYLabel = prompt("Enter y-axis label:", currentYLabel);
  let newFontSize = prompt("Enter graph font size in px:", currentFontSize);
  let newEquation = prompt("Enter equation to graph (e.g., y = {a}*x + 10), or leave blank:", currentEquation);
   
  container.dataset.xInterval = newXInterval;
  container.dataset.yInterval = newYInterval;
  container.dataset.xLabel = newXLabel;
  container.dataset.yLabel = newYLabel;
  container.dataset.fontSize = newFontSize;
  // IMPORTANT: Save the new unswapped equation.
  container.dataset.equation = newEquation;
  container.dataset.originalEquation = newEquation;
   
  let computedVars = computeAllVariables();
  if (newEquation && newEquation.trim() !== "") {
    newEquation = newEquation.replace(/\{([^}]+)\}/g, (match, p1) => {
      let key = p1.trim();
      return computedVars[key] !== undefined ? computedVars[key] : match;
    });
  }
   
  let newSVG = generateGraphSVG(newXInterval, newYInterval, newXLabel, newYLabel, newFontSize, newEquation);
  container.querySelector('.element-content').innerHTML = newSVG;
}

/******** Add Graph ********/
function addGraph() {
  let xInterval = prompt("Enter x-axis interval:", "1");
  let yInterval = prompt("Enter y-axis interval:", "1");
  let xLabel = prompt("Enter x-axis label:", "X");
  let yLabel = prompt("Enter y-axis label:", "Y");
  let fontSizeInput = prompt("Enter graph font size in px (default 12):", "12");
  let graphFontSize = parseInt(fontSizeInput);
  if (isNaN(graphFontSize)) graphFontSize = 12;
  xInterval = parseFloat(xInterval);
  yInterval = parseFloat(yInterval);
  if (isNaN(xInterval) || isNaN(yInterval)) {
    alert("Invalid interval value.");
    return;
  }
  
  let eq = prompt("Enter equation to graph (e.g., y = {a}*x + 10), or leave blank:");
  // (Do not substitute variables here – keep the raw equation.)
  
  let svgContent = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, graphFontSize, eq);
  const canvas = document.getElementById('problem-canvas');
  const graphElement = createDraggableElement(svgContent, false);
  graphElement.dataset.xInterval = xInterval;
  graphElement.dataset.yInterval = yInterval;
  graphElement.dataset.xLabel = xLabel;
  graphElement.dataset.yLabel = yLabel;
  graphElement.dataset.fontSize = graphFontSize;
  // IMPORTANT: Store both the current equation and the original equation
  graphElement.dataset.equation = eq;
  graphElement.dataset.originalEquation = eq;
  
  canvas.appendChild(graphElement);
}

/******** Generate Graph SVG ********/
function generateGraphSVG(xInterval, yInterval, xLabel, yLabel, graphFontSize, eq) {
  xInterval = parseFloat(xInterval);
  yInterval = parseFloat(yInterval);
  graphFontSize = parseInt(graphFontSize);
  if (isNaN(graphFontSize)) graphFontSize = 12;
  let f = null;
  if (eq && eq.trim() !== "") { f = parseEquation(eq); }
  
  let svgWidth = 400, svgHeight = 400;
  let marginLeft = 50, marginRight = 20, marginTop = 20, marginBottom = 50;
  let graphWidth = svgWidth - marginLeft - marginRight;
  let graphHeight = svgHeight - marginTop - marginBottom;
  
  let xAxisY = svgHeight - marginBottom;
  let yAxisX = marginLeft;
  
  let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;
  svgContent += `<rect x="0" y="0" width="${svgWidth}" height="${svgHeight}" fill="white" stroke="black" />`;
  
  svgContent += `<clipPath id="graphClip"><rect x="${marginLeft}" y="${marginTop}" width="${graphWidth}" height="${graphHeight}" /></clipPath>`;
  
  for (let i = 1; i < 10; i++) {
    let xPos = marginLeft + (i / 10) * graphWidth;
    svgContent += `<line x1="${xPos}" y1="${marginTop}" x2="${xPos}" y2="${xAxisY}" stroke="#ddd" />`;
  }
  for (let j = 1; j < 10; j++) {
    let yPos = marginTop + (j / 10) * graphHeight;
    svgContent += `<line x1="${marginLeft}" y1="${yPos}" x2="${svgWidth - marginRight}" y2="${yPos}" stroke="#ddd" />`;
  }
  
  svgContent += `<line x1="${marginLeft}" y1="${xAxisY}" x2="${svgWidth - marginRight}" y2="${xAxisY}" stroke="black" />`;
  svgContent += `<line x1="${yAxisX}" y1="${marginTop}" x2="${yAxisX}" y2="${xAxisY}" stroke="black" />`;
  
  for (let i = 0; i <= 10; i++) {
    let xPos = marginLeft + (i / 10) * graphWidth;
    svgContent += `<line x1="${xPos}" y1="${xAxisY}" x2="${xPos}" y2="${xAxisY + 5}" stroke="black" />`;
    let value = i * xInterval;
    let tickVal = (value % 1 === 0) ? value.toString() : value.toFixed(2);
    svgContent += `<text x="${xPos}" y="${xAxisY + 20}" font-size="${graphFontSize}" text-anchor="middle">${tickVal}</text>`;
  }
  
  for (let j = 0; j <= 10; j++) {
    let yPos = marginTop + graphHeight - (j / 10) * graphHeight;
    svgContent += `<line x1="${yAxisX - 5}" y1="${yPos}" x2="${yAxisX}" y2="${yPos}" stroke="black" />`;
    let value = j * yInterval;
    let tickVal = (value % 1 === 0) ? value.toString() : value.toFixed(2);
    svgContent += `<text x="${yAxisX - 10}" y="${yPos + 3}" font-size="${graphFontSize}" text-anchor="end">${tickVal}</text>`;
  }
  
  let xLabelX = marginLeft + graphWidth / 2;
  let xLabelY = svgHeight - 10;
  svgContent += `<text x="${xLabelX}" y="${xLabelY}" font-size="${graphFontSize+2}" text-anchor="middle">${xLabel}</text>`;
  
  let yLabelX = 30;
  let yLabelY = marginTop + graphHeight / 2;
  svgContent += `<text x="${yLabelX}" y="${yLabelY}" font-size="${graphFontSize+2}" text-anchor="middle" transform="rotate(-90, ${yLabelX}, ${yLabelY})">${yLabel}</text>`;
  
  if (f !== null) {
    let points = "";
    let numSamples = 100;
    for (let i = 0; i <= numSamples; i++) {
      let xVal = (10 * xInterval) * (i / numSamples);
      let yVal = f(xVal);
      let xSVG = marginLeft + (xVal / (10 * xInterval)) * graphWidth;
      let ySVG = marginTop + graphHeight - (yVal / (10 * yInterval)) * graphHeight;
      points += xSVG + "," + ySVG + " ";
    }
    svgContent += `<polyline points="${points.trim()}" fill="none" stroke="red" stroke-width="2" clip-path="url(#graphClip)" />`;
  }
  
  svgContent += `</svg>`;
  return svgContent;
}




/******** Text Formatting Commands ********/
function execCmd(command) {
  if (activeTextBox) {
    activeTextBox.focus();
    document.execCommand(command, false, null);
  } else {
    alert("Please click inside a text box to format its text.");
  }
}

/******** Variable Computation ********/
// Computes variables from the defined variable list.
function computeAllVariables() {
  if (getVariableMode() === "code") {
    // Code mode: read the entire code block from the textarea.
    let computed = {};
    let code = document.getElementById("variable-code").value;
    if (code.trim() !== "") {
      try {
        new Function("computed", "with(computed){ " + code + " }")(computed);
      } catch (e) {
        console.error("Error evaluating variable code:", e);
      }
    }
    console.log("Computed values in code mode:", computed);
    return computed;
  } else {
    // UI mode: clear previous definitions and computed values.
    varDefinitions = {};
    computedValues = {};

    // Build variable definitions from the DOM.
    document.querySelectorAll("#variable-list .variable-item").forEach(item => {
      const varName = item.querySelector("strong").innerText.trim();
      const typeSelect = item.querySelector("select");
      let expr = "";

      if (typeSelect) {
        const selectedType = typeSelect.value;
        if (selectedType === "rand-int") {
          // Expect inputs with IDs like "x-min" and "x-max"
          const minInput = item.querySelector(`#${varName}-min`);
          const maxInput = item.querySelector(`#${varName}-max`);
          const minVal = minInput ? minInput.value.trim() : "";
          const maxVal = maxInput ? maxInput.value.trim() : "";
          if (minVal !== "" && maxVal !== "") {
            expr = `randomInt(${minVal}, ${maxVal})`;
          }
        } else if (selectedType === "simp-frac") {
          const numInput = item.querySelector(`#${varName}-num`);
          const denInput = item.querySelector(`#${varName}-den`);
          const numVal = numInput ? numInput.value.trim() : "";
          const denVal = denInput ? denInput.value.trim() : "";
          if (numVal !== "" && denVal !== "") {
            expr = `reduceFraction(${numVal}, ${denVal})`;
          }
        } else if (selectedType === "unsimp-frac") {
          const numInput = item.querySelector(`#${varName}-num`);
          const denInput = item.querySelector(`#${varName}-den`);
          const numVal = numInput ? numInput.value.trim() : "";
          const denVal = denInput ? denInput.value.trim() : "";
          if (numVal !== "" && denVal !== "") {
            expr = `unreducedfraction(${numVal}, ${denVal})`;
          }
        } else if (selectedType === "rounded") {
          const valueInput = item.querySelector(`#${varName}-value`);
          const roundInput = item.querySelector(`#${varName}-round`);
          const valueVal = valueInput ? valueInput.value.trim() : "";
          const roundVal = roundInput ? roundInput.value.trim() : "";
          if (valueVal !== "" && roundVal !== "") {
            expr = `round(${valueVal}, ${roundVal})`;
          }
        } else if (selectedType === "formula") {
          const formulaInput = item.querySelector(`#${varName}-formula`);
          if (formulaInput) {
            expr = formulaInput.value.trim();
          }
        }
      }
      // Fallback: if no expression was built from type-specific inputs,
      // then use any plain text input within the variable item.
      if (!expr) {
        const fallbackInput = item.querySelector("input[type='text']");
        if (fallbackInput) {
          expr = fallbackInput.value.trim();
        }
      }
      console.log("Variable", varName, "expression:", expr);
      varDefinitions[varName] = expr;
    });

    // Build the dependency graph using your existing buildDependencyGraph() function.
    buildDependencyGraph();

    // Perform a topological sort of the variable names.
    let order = [];
    let tempMark = {};
    let permMark = {};

    function visit(n) {
      if (permMark[n]) return;
      if (tempMark[n]) {
        console.error("Cyclic dependency detected for variable", n);
        return;
      }
      tempMark[n] = true;
      // Extract dependencies from the expression.
      let deps = extractDependencies(varDefinitions[n]);
      deps.forEach(dep => {
        if (varDefinitions.hasOwnProperty(dep)) {
          visit(dep);
        }
      });
      permMark[n] = true;
      order.push(n);
    }

    Object.keys(varDefinitions).forEach(n => {
      visit(n);
    });

    console.log("Evaluation order:", order);

    // Evaluate variables in sorted order.
    order.forEach(varName => {
      let expr = varDefinitions[varName];
      let val = evaluateExpression(expr);
      computedValues[varName] = val;
    });

    console.log("Computed values in UI mode:", computedValues);
    return Object.assign({}, computedValues);
  }
}

/******** Update Variables and Answer Image ********/
function updateVariables() {
  // 1. Auto-detect variables in text boxes.
 // -----------------------------
// 1. Auto-detect any {variable} in text boxes and answer fields.
// -----------------------------
// -----------------------------
// 1. Auto-detect any {variable} in text boxes and answer fields.
// -----------------------------
// -----------------------------
// 1. Auto-detect any {variable} in text boxes and answer fields.
// -----------------------------
const detected = new Set();

// Check all text boxes on the problem canvas.
document.querySelectorAll("#problem-canvas .text-box").forEach(box => {
  // If this text box is in LaTeX mode, skip variable detection.
  if (box.getAttribute("data-mode") === "latex") return;
  
  // Use the stored original text.
  let original = box.getAttribute("data-original-text") || box.innerText;
  const matches = original.matchAll(/\{([^}]+)\}/g);
  for (const match of matches) {
    if (match[1].trim()) {
      detected.add(match[1].trim());
    }
  }
});




  
  // Check answer box.
  const ansRule = document.getElementById("correct-answer").value;
  if (ansRule) {
    const matches = ansRule.matchAll(/\{([^}]+)\}/g);
    for (const match of matches) {
      if (match[1].trim()) {
        detected.add(match[1].trim());
      }
    }
  }
  
  // Add new variables to the list.
  const varListDiv = document.getElementById("variable-list");
  detected.forEach(v => {
  if (!document.getElementById("var-item-" + v)) {
    const div = document.createElement("div");
    div.className = "variable-item";
    div.id = "var-item-" + v;
    div.innerHTML = `<strong>${v}</strong> 
      <button onclick="deleteVariable('${v}')">Delete</button><br>
      <label>Type:</label>
      <select onchange="updateVariableType(this, '${v}')">
        <option value="">Select type</option>
        <option value="rand-int">Random Integer</option>
        <option value="simp-frac">Simplified Fraction</option>
        <option value="unsimp-frac">Unsimplified Fraction</option>
        <option value="rounded">Rounded Number</option>
        <option value="formula">Formula</option>
      </select>
      <div class="var-options" id="options-${v}"></div>`;
    varListDiv.appendChild(div);
  }
});

  // Recompute variables.
  let computedVars = computeAllVariables();
  
  // Update text boxes with substitutions.
 document.querySelectorAll("#problem-canvas .text-box").forEach(box => {
  // If this text box is currently focused (the user is typing), skip updating it.
  if (document.activeElement === box) {
    return;
  }
  let original = box.getAttribute("data-original-text") || box.innerHTML;
  box.innerHTML = original;
});




  // Update answer image.
  updateAnswerImage(computedVars);
  
  // Update dynamic image elements.
  document.querySelectorAll("[data-image-code]").forEach(function(container) {
    updateImageCodeElement(container, computedVars);
  });
}

function updateAnswerOptions() {
  const type = document.getElementById("answer-type").value;
  document.getElementById("box-options").style.display = (type === "box") ? "block" : "none";
  document.getElementById("multiple-options").style.display = (type === "multiple" || type === "multi-select") ? "block" : "none";
  document.getElementById("grid-options").style.display = (type === "grid") ? "block" : "none";
}

function updateAnswerImage(computedVars) {
  const varValues = computedVars || computeAllVariables();
  const answerType = document.getElementById("answer-type").value;
  let content = "";
  
  if (answerType === "box") {
    let correctAns = substituteValue(document.getElementById("correct-answer").value, varValues);
    let labelText = substituteValue(document.getElementById("label-text").value, varValues);
    let labelPosition = document.getElementById("label-position").value;
    if (labelPosition === "before") {
      content = labelText + " " + correctAns;
    } else if (labelPosition === "after") {
      content = correctAns + " " + labelText;
    } else {
      content = correctAns;
    }
  } else if (answerType === "multiple" || answerType === "multi-select") {
    let correctOptionDiv = document.querySelector("#mc-correct .mc-answer-option");
    if (correctOptionDiv) {
      let htmlContent = correctOptionDiv.innerHTML;
      if (correctOptionDiv.firstElementChild && correctOptionDiv.firstElementChild.classList.contains("mc-option-toolbar")) {
        htmlContent = htmlContent.replace(correctOptionDiv.firstElementChild.outerHTML, "");
      }
      content = substituteValue(htmlContent, varValues);
    }
  } else if (document.getElementById("answer-type").value === "grid") {
    let gridQuiz = generateGridQuiz(computedVars);
    const previewArea = document.getElementById("preview-area");
    previewArea.appendChild(gridQuiz);
  }
  document.getElementById("answer-image-content").innerHTML = content;
}

function updateVariableType(selectElem, varName) {
  const type = selectElem.value;
  const optionsDiv = document.getElementById("options-" + varName);
  let html = "";
  if (type === "rand-int") {
    html = `Min: <input type="number" id="${varName}-min" style="width:60px;"> 
            Max: <input type="number" id="${varName}-max" style="width:60px;">`;
  } else if (type === "simp-frac" || type === "unsimp-frac") {
    html = `Numerator: <input type="text" id="${varName}-num" style="width:50px;"> 
            Denom: <input type="text" id="${varName}-den" style="width:50px;">`;
  } else if (type === "rounded") {
    html = `Value: <input type="number" id="${varName}-value" style="width:60px;"> 
            Round to: <input type="number" id="${varName}-round" style="width:40px;">`;
  } else if (type === "formula") {
    html = `Formula: <input type="text" id="${varName}-formula" style="width:150px;" placeholder="e.g., a+b" onfocus="setCurrentFormulaInput(this)">`;
  }
  optionsDiv.innerHTML = html;
}

function addVariable() {
  let varName = prompt("Enter the new variable name (without curly braces):");
  if (!varName) return;
  varName = varName.trim();
  if (!varName) return;
  if (document.getElementById("var-item-" + varName)) {
    alert("Variable already exists.");
    return;
  }
  const varListDiv = document.getElementById("variable-list");
  const div = document.createElement("div");
  div.className = "variable-item";
  div.id = "var-item-" + varName;
  div.innerHTML = `<strong>${varName}</strong><br>
        <label>Type:</label>
        <select onchange="updateVariableType(this, '${varName}')">
          <option value="">Select type</option>
          <option value="rand-int">Random Integer</option>
          <option value="simp-frac">Simplified Fraction</option>
          <option value="unsimp-frac">Unsimplified Fraction</option>
          <option value="rounded">Rounded Number</option>
          <option value="formula">Formula</option>
        </select>
        <div class="var-options" id="options-${varName}"></div>
        <input type="text" placeholder="Enter expression for ${varName}">`;
  varListDiv.appendChild(div);

  let newVarInput = div.querySelector("input");
  if (newVarInput) {
    newVarInput.addEventListener("change", function() {
      varDefinitions[varName] = newVarInput.value.trim();
      buildDependencyGraph();
      let newVal = evaluateExpression(varDefinitions[varName]);
      updateVariable(varName, newVal);
      updateVariables();
    });
  }
}

/******** Preview Problem ********/
// Helper function to copy computed styles.
function copyComputedStyles(source, target) {
  const computed = window.getComputedStyle(source);
  for (let i = 0; i < computed.length; i++) {
    const prop = computed[i];
    target.style.setProperty(prop, computed.getPropertyValue(prop), computed.getPropertyPriority(prop));
  }
  const sourceChildren = source.children;
  const targetChildren = target.children;
  for (let i = 0; i < sourceChildren.length; i++) {
    if (targetChildren[i]) {
      copyComputedStyles(sourceChildren[i], targetChildren[i]);
    }
  }
}
function updateGridColumnNames() {
  const colCount = parseInt(document.getElementById("grid-columns").value, 10);
  const container = document.getElementById("grid-column-names");
  container.innerHTML = "<h4>Column Names</h4>";
  for (let i = 0; i < colCount; i++) {
    let input = document.createElement("input");
    input.type = "text";
    input.placeholder = "Column " + (i + 1);
    input.id = "grid-column-" + i;
    container.appendChild(input);
    container.appendChild(document.createElement("br"));
  }
  updateGridRowSelectOptions();
}
function addGridRowExpression() {
  const container = document.getElementById("grid-row-expressions");
  let rowDiv = document.createElement("div");
  rowDiv.className = "grid-row-expression";
  
  let exprInput = document.createElement("div");
  exprInput.className = "grid-expression";
  exprInput.contentEditable = true;
  exprInput.style.minHeight = "40px";
  exprInput.style.border = "1px solid #ccc";
  exprInput.style.padding = "4px";
  exprInput.innerHTML = "Enter expression (e.g., {a}+5)";
  rowDiv.appendChild(exprInput);
  
  let eqBtn = document.createElement("button");
  eqBtn.innerHTML = "Insert Eq";
  eqBtn.style.marginLeft = "5px";
  eqBtn.onclick = function(e) {
    e.stopPropagation();
    activeTextBox = exprInput;
    showEquationModal();
  };
  rowDiv.appendChild(eqBtn);
  
  let requiredLabel = document.createElement("label");
  requiredLabel.innerText = " Required";
  let requiredCheckbox = document.createElement("input");
  requiredCheckbox.type = "checkbox";
  requiredCheckbox.className = "grid-required";
  requiredLabel.prepend(requiredCheckbox);
  rowDiv.appendChild(requiredLabel);
  
  let select = document.createElement("select");
  select.className = "grid-correct-column";
  rowDiv.appendChild(select);
  
  let removeBtn = document.createElement("button");
  removeBtn.innerText = "Delete";
  removeBtn.onclick = function() { rowDiv.remove(); updateGridRowSelectOptions(); };
  rowDiv.appendChild(removeBtn);
  
  container.appendChild(rowDiv);
  updateGridRowSelectOptions();
}

function updateGridRowSelectOptions() {
  const colCount = parseInt(document.getElementById("grid-columns").value, 10);
  
  const colNames = [];
  for (let i = 0; i < colCount; i++) {
    let input = document.getElementById("grid-column-" + i);
    let colName = input ? substituteValue(input.value, window.currentComputedVars || {}) : "";
    if (!colName) {
      colName = "Column " + (i + 1);
    }
    colNames.push(colName);
  }
  const rows = document.querySelectorAll(".grid-row-expression");
  rows.forEach(row => {
    let select = row.querySelector(".grid-correct-column");
    select.innerHTML = "";
    colNames.forEach((name, index) => {
      let option = document.createElement("option");
      option.value = index;
      option.innerText = name;
      select.appendChild(option);
    });
  });
}

document.addEventListener("input", function(e) {
  if (e.target && e.target.id && e.target.id.indexOf("grid-column-") === 0) {
    updateGridRowSelectOptions();
  }
});

function generateGridQuiz(computedVars, preselect) {
  let container = document.createElement("div");
  container.className = "grid-quiz";
  
  const colCount = parseInt(document.getElementById("grid-columns").value, 10);
  
  const colNames = [];
  for (let i = 0; i < colCount; i++) {
    let input = document.getElementById("grid-column-" + i);
    let colName = input ? substituteValue(input.value, computedVars) : "";
    if (!colName) {
      colName = "Column " + (i + 1);
    }
    colNames.push(colName);
  }
  
  let rowExprDivs = Array.from(document.querySelectorAll(".grid-row-expression"));
  
  let shuffleEnabled = document.getElementById("grid-shuffle") && document.getElementById("grid-shuffle").checked;
  if (shuffleEnabled) {
    if (!window.shuffledGridRows) {
      window.shuffledGridRows = shuffleArray(rowExprDivs.slice());
      rowExprDivs = window.shuffledGridRows;
    } else {
      rowExprDivs = window.shuffledGridRows;
    }
  } else {
    window.shuffledGridRows = null;
  }
  
  let table = document.createElement("table");
  table.style.borderCollapse = "collapse";
  table.style.width = "100%";
  
  let thead = document.createElement("thead");
  let headerRow = document.createElement("tr");
  headerRow.appendChild(document.createElement("th"));
  colNames.forEach(name => {
    let th = document.createElement("th");
    th.innerText = name;
    th.style.border = "1px solid #ccc";
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  let tbody = document.createElement("tbody");
  rowExprDivs.forEach((exprDiv, index) => {
    let tr = document.createElement("tr");
    let exprInput = exprDiv.querySelector(".grid-expression");
    let exprText = exprInput ? substituteValue(exprInput.innerHTML, computedVars) : "";
    let tdExpr = document.createElement("td");
    tdExpr.innerHTML = exprText;
    tdExpr.style.border = "1px solid #ccc";
    tr.appendChild(tdExpr);
    
    let correctSelect = exprDiv.querySelector(".grid-correct-column");
    let correctIndex = correctSelect ? parseInt(correctSelect.value, 10) : 0;
    
    for (let i = 0; i < colCount; i++) {
      let td = document.createElement("td");
      td.style.border = "1px solid #ccc";
      let radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "grid_row_" + index;
      radio.value = i;
      radio.checked = preselect && (i === correctIndex);
      td.appendChild(radio);
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  container.appendChild(table);
  return container;
}
// First, create a helper function that captures snapshots of all LaTeX-mode text boxes.
// Set previewMode to either 'raw' or 'snapshot'
var previewMode = 'snapshot';  // try "raw" first; if not satisfactory, set to "snapshot"

/* 
   For "snapshot" mode, we capture each LaTeX text box into an image.
   In "raw" mode we simply remove extra preview elements.
*/
function captureLatexSnapshots() {
  const latexElements = document.querySelectorAll('#problem-canvas .text-box[data-mode="latex"]');
  const promises = [];
  latexElements.forEach(el => {
    const p = html2canvas(el).then(canvas => {
      el.dataset.latexImage = canvas.toDataURL();
    });
    promises.push(p);
  });
  return Promise.all(promises);
}

function previewProblemInteractive() {
  console.log("Starting preview with answer type:", document.getElementById("answer-type").value);
  
  if (document.getElementById("answer-type").value === "grid") {
    window.shuffledGridRows = null;
  }
  // Force a fresh recomputation of all variables (and thus re‐run random functions)
  let computedVars = computeAllVariables();
  window.currentComputedVars = computedVars;

  // Update any draggable elements that use image code in the original canvas.
  document.querySelectorAll('.draggable-element').forEach(container => {
    if (container.dataset.originalImageCode) {
      updateImageCodeElement(container, computedVars);
    }
  });

  // Clone the problem canvas.
  const originalCanvas = document.getElementById("problem-canvas");
  const cloneCanvas = originalCanvas.cloneNode(true);
  cloneCanvas.style.position = 'absolute';
  cloneCanvas.style.left = '-9999px';
  document.body.appendChild(cloneCanvas);

  // Insert a style tag into the clone to hide editing controls.
  const styleTag = document.createElement("style");
  styleTag.innerHTML = ".element-controls, .resize-handle { display: none !important; }";
  cloneCanvas.appendChild(styleTag);

  // Update all text boxes in the clone—substitute {variable} placeholders with computed values.
  cloneCanvas.querySelectorAll('.text-box').forEach(box => {
    let mode = box.getAttribute("data-mode") || "manual";
    let original = box.getAttribute("data-original-text") || box.innerHTML;
    if (mode === "latex") {
      // Wrap in delimiters if not already present.
      let latexContent = original;
      if (!latexContent.trim().startsWith("\\(") && !latexContent.trim().startsWith("$$")) {
        latexContent = "\\(" + latexContent + "\\)";
      }
      // Now substitute only the double-brace variables.
      latexContent = substituteLatexVariables(latexContent, computedVars);
      box.innerHTML = latexContent;
    } else {
      box.innerHTML = substituteValue(original, computedVars);
    }
  });

  // Update each draggable element in the clone:
  // For image-code elements, update them using computedVars.
  // For graph elements, substitute variable values in the equation.
  // For circle elements with pie chart settings, transform into pie charts.
  cloneCanvas.querySelectorAll('.draggable-element').forEach(container => {
    if (container.dataset.imageCode) {
      updateImageCodeElement(container, computedVars);
    } else if (container.dataset.originalEquation && container.dataset.originalEquation.trim() !== "") {
      let originalEq = container.dataset.originalEquation;
      let substitutedEq = originalEq.replace(/\{([^}]+)\}/g, (match, p1) => {
        let key = p1.trim();
        return computedVars[key] !== undefined ? computedVars[key] : match;
      });
      const xInterval = container.dataset.xInterval || 1;
      const yInterval = container.dataset.yInterval || 1;
      const xLabel = container.dataset.xLabel || "X";
      const yLabel = container.dataset.yLabel || "Y";
      const fontSize = container.dataset.fontSize || 12;
      const newSVG = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, fontSize, substitutedEq);
      container.querySelector('.element-content').innerHTML = newSVG;
    } else if (container.classList.contains('circle-container')) {
      const totalPiecesExpr = container.getAttribute("data-total-pieces");
      const shadedPiecesExpr = container.getAttribute("data-shaded-pieces");
      console.log("Pie chart data:", totalPiecesExpr, shadedPiecesExpr);
      
      if (totalPiecesExpr && shadedPiecesExpr) {
        try {
          const totalPieces = math.evaluate(substituteValue(totalPiecesExpr, computedVars));
          const shadedPieces = math.evaluate(substituteValue(shadedPiecesExpr, computedVars));
          console.log("Calculated pieces:", totalPieces, shadedPieces);
          
          if (typeof totalPieces === "number" && typeof shadedPieces === "number" && 
              totalPieces > 0 && shadedPieces >= 0 && shadedPieces <= totalPieces) {
            const shadedColor = container.getAttribute("data-shaded-color") || "#ff0000";
            const unshadedColor = container.getAttribute("data-unshaded-color") || "#ffffff";
            const width = container.offsetWidth;
            const height = container.offsetHeight - 20; // Subtract toolbar height
            const svgHTML = generatePieChartSVG(totalPieces, shadedPieces, shadedColor, unshadedColor, width, height);
            console.log("Generated SVG:", svgHTML.substring(0, 100) + "...");
            
            container.querySelector('.circle-content').innerHTML = svgHTML;
            // Verify the SVG is in the DOM
            console.log("SVG in DOM:", !!container.querySelector('.circle-content svg'));
          } else {
            console.warn("Invalid pie chart parameters:", totalPieces, shadedPieces);
          }
        } catch (e) {
          console.error("Error evaluating pie chart expressions:", e);
        }
      }
    }
  });

  // Copy computed styles from the original canvas to the clone.
  copyComputedStyles(originalCanvas, cloneCanvas);

  console.log("Clone canvas structure before MathJax:", 
    cloneCanvas.querySelectorAll('.circle-container').length, 
    "pie charts found");

  // Wait for MathJax to typeset the LaTeX in the cloned text boxes
  MathJax.typesetPromise(cloneCanvas.querySelectorAll('.text-box'))
    .then(function() {
      console.log("MathJax typesetting complete");
      console.log("Clone canvas structure after MathJax:", 
        cloneCanvas.querySelectorAll('.circle-container').length, 
        "pie charts found");
      
      // Add a delay before html2canvas to ensure all rendering is complete
      setTimeout(() => {
        // Now that LaTeX is rendered, take a snapshot with html2canvas.
        html2canvas(cloneCanvas, {
          logging: true,
          onclone: function(clonedDoc) {
            console.log("html2canvas clone created");
            console.log("Cloned document pie charts:", 
              clonedDoc.querySelectorAll('.circle-container').length);
          }
        }).then(function(canvasImage) {
          console.log("Canvas image generated successfully");
          document.body.removeChild(cloneCanvas);
          const previewArea = document.getElementById("preview-area");
          previewArea.innerHTML = "";
          // Append the problem image first.
          previewArea.appendChild(canvasImage);

          // If the answer type is "grid", generate an unfilled grid for preview.
          if (document.getElementById("answer-type").value === "grid") {
            let gridQuiz = generateGridQuiz(computedVars, false);
            previewArea.appendChild(gridQuiz);
          } else {
            window.currentAnswerOptions = computeAnswerOptions(computedVars);
            let answerQuiz = generateAnswerQuiz(computedVars);
            previewArea.appendChild(answerQuiz);
          }

          // Update the answer image area.
          let answerImages = generateAnswerImages(computedVars);
          const answerImageContent = document.getElementById("answer-image-content");
          answerImageContent.innerHTML = "";
          answerImageContent.appendChild(answerImages);
        }).catch(function(err) {
          console.error("html2canvas error:", err);
        });
      }, 300); // 300ms delay to ensure all SVG elements are fully rendered
    })
    .catch(function(err) {
      console.error("MathJax typesetting error:", err);
      // Even if MathJax fails, try to render the canvas.
      setTimeout(() => {
        html2canvas(cloneCanvas).then(function(canvasImage) {
          document.body.removeChild(cloneCanvas);
          const previewArea = document.getElementById("preview-area");
          previewArea.innerHTML = "";
          previewArea.appendChild(canvasImage);
        }).catch(function(err) {
          console.error("html2canvas error after MathJax failure:", err);
        });
      }, 300);
    });
}

/******** Update Problem and Answer Sizes ********/
function updateProblemSize() {
let w = document.getElementById("problem-width").value;
let h = document.getElementById("problem-height").value;
savedProblemWidth = w;
savedProblemHeight = h;
document.getElementById("problem-canvas").style.width = w + "px";
document.getElementById("problem-canvas").style.height = h + "px";
}
function updateSavedAnswerSize() {
savedAnswerWidth = document.getElementById("answer-width").value;
savedAnswerHeight = document.getElementById("answer-height").value;
const answerContent = document.getElementById("answer-image-content");
answerContent.style.width = savedAnswerWidth + "px";
answerContent.style.height = savedAnswerHeight + "px";
}

/******** NEW CODE: Table Cell Selection and Highlighting ********/
let selectedCell = null;
function cellClicked(event) {
if (selectedCell) {
  selectedCell.classList.remove("selected-cell");
}
selectedCell = event.currentTarget;
selectedCell.classList.add("selected-cell");
event.stopPropagation();
}
function attachCellClickHandlers(table) {
let cells = table.querySelectorAll("td, th");
cells.forEach(cell => {
  cell.addEventListener("click", cellClicked);
});
}
function highlightRow(table, cell, color) {
if (!cell) return;
let row = cell.closest("tr");
if (row) {
  for (let c of row.cells) {
    c.style.backgroundColor = color;
  }
}
}
function highlightColumn(table, cell, color) {
if (!cell) return;
let colIndex = cell.cellIndex;
for (let row of table.rows) {
  if (row.cells[colIndex]) {
    row.cells[colIndex].style.backgroundColor = color;
  }
}
}
function applyHighlight(mode) {
let color = document.getElementById("highlight-color").value;
let table = document.querySelector("#problem-canvas table");
if (!table) {
  alert("No table found in the problem image.");
  return;
}
if (!selectedCell) {
  alert("Please click on a table cell first to select its row/column.");
  return;
}
if (mode === "row") {
  highlightRow(table, selectedCell, color);
} else if (mode === "column") {
  highlightColumn(table, selectedCell, color);
}
}

/******** NEW CODE: Variable Options Toolbar Functions ********/
function getDefaultFormula(type) {
switch(type) {
  case 'random-int':
    return "randomInt(min, max)";
  case 'random-number':
    return "randomNumber(min, max, decimals)";
  case 'round':
    return "round(value, decimals)";
  case 'unreduced-fraction':
    return "unreducedfraction(num, denom)";
  case 'improper-fraction':
    return "reduceFraction(num, denom)";
  case 'mixed-number':
    return "mixedFraction(num, denom)";
  case 'choose-from-list':
    return "chooseFromWordList('word1', 'word2', 'word3')";
  case 'choose-from-list-number':
    return "chooseFromNumberList(1, 2, 3)";
  case 'arrange-asc':
    return "arrangeAscending('1,4,2')";
  case 'arrange-desc':
    return "arrangeDescending('1,4,2')";
  default:
    return "";
}
}
function setVariableFormula(type) {
if (currentFormulaInput) {
  let template = getDefaultFormula(type);
  let input = currentFormulaInput;
  let startPos = input.selectionStart;
  let endPos = input.selectionEnd;
  let currentValue = input.value;
  input.value = currentValue.substring(0, startPos) + template + currentValue.substring(endPos);
  let newPos = startPos + template.length;
  input.selectionStart = input.selectionEnd = newPos;
  input.focus();
} else {
  alert("Please click on a formula input field to focus it before inserting a template.");
}
}

// Helper function to shuffle an array (Fisher–Yates shuffle)
function shuffleArray(array) {
for (let i = array.length - 1; i > 0; i--) {
  let j = Math.floor(Math.random() * (i + 1));
  [array[i], array[j]] = [array[j], array[i]];
}
return array;
}

function getFinalAnswerOptions(computedVars) {
let options = [];
const correctContainer = document.getElementById("mc-correct");
const incorrectContainer = document.getElementById("mc-incorrect");

function processOption(optionNode, isCorrect) {
  let cloneOption = optionNode.cloneNode(true);
  let editors = cloneOption.querySelectorAll("button.edit-graph, button.delete-graph, button.edit-table, button.delete-table, .mc-option-toolbar");
  editors.forEach(el => el.remove());
  let graphElem = cloneOption.querySelector(".answer-graph");
  if (graphElem) {
    updateGraphInAnswerOption(graphElem, computedVars);
    let graphBtns = graphElem.querySelectorAll("button.edit-graph, button.delete-graph");
    graphBtns.forEach(btn => btn.remove());
  }
  let contentHTML = substituteValue(cloneOption.innerHTML, computedVars);
  options.push({ html: contentHTML, correct: isCorrect });
}

correctContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, true));
incorrectContainer.querySelectorAll(".mc-answer-option").forEach(option => processOption(option, false));

options = shuffleArray(options);
return options;
}

function getCorrectAnswerLettersFromOptions(options) {
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
let correctLetters = "";
options.forEach((option, index) => {
  if (option.correct) {
    correctLetters += letters[index];
  }
});
return correctLetters;
}

function initGraph(svgElement, aValue) {
aValue = Number(aValue);
let circle = svgElement.querySelector("#point");
if (circle) {
  circle.setAttribute("cy", aValue);
}
let label = svgElement.querySelector("#pointLabel");
if (label) {
  label.setAttribute("y", aValue);
  label.textContent = "(0, " + aValue + ")";
}
}
window.initGraph = initGraph;

function addMCOption(type) {
  let containerId = (type === "correct") ? "mc-correct" : "mc-incorrect";
  let container = document.getElementById(containerId);
  
  // Create the overall answer option container (non‑editable)
  let optionDiv = document.createElement("div");
  optionDiv.className = "mc-answer-option";
  optionDiv.setAttribute("data-correct", type === "correct" ? "true" : "false");
  optionDiv.setAttribute("data-required", "false");
  optionDiv.contentEditable = false; // Protect the container
  
  // Required checkbox container (non‑editable)
  let requiredContainer = document.createElement("span");
  requiredContainer.className = "option-required-edit";
  let requiredLabel = document.createElement("label");
  requiredLabel.style.marginRight = "5px";
  let requiredCheckbox = document.createElement("input");
  requiredCheckbox.type = "checkbox";
  requiredCheckbox.addEventListener("change", function(e) {
    optionDiv.setAttribute("data-required", requiredCheckbox.checked ? "true" : "false");
  });
  requiredLabel.appendChild(requiredCheckbox);
  requiredLabel.appendChild(document.createTextNode("Required"));
  requiredContainer.appendChild(requiredLabel);
  optionDiv.appendChild(requiredContainer);
  
  // Create the toolbar container (non‑editable)
  let toolbar = document.createElement("div");
  toolbar.className = "mc-option-toolbar";
  
  let graphBtn = document.createElement("button");
  graphBtn.textContent = "Add Graph";
  graphBtn.onclick = function(e) {
    e.stopPropagation();
    addGraphToAnswerOption(optionDiv);
  };
  toolbar.appendChild(graphBtn);
  
  let tableBtn = document.createElement("button");
  tableBtn.textContent = "Add Table";
  tableBtn.onclick = function(e) {
    e.stopPropagation();
    addTableToAnswerOption(optionDiv);
  };
  toolbar.appendChild(tableBtn);
  
  let imageBtn = document.createElement("button");
  imageBtn.textContent = "Add Image with Code";
  imageBtn.onclick = function(e) {
    e.stopPropagation();
    addImageWithCodeToAnswerOption(optionDiv);
  };
  toolbar.appendChild(imageBtn);
  
  let eqBtn = document.createElement("button");
  eqBtn.textContent = "Eq";
  eqBtn.title = "Insert Equation Element";
  eqBtn.style.marginRight = "4px";
  // When clicked, we set the main text container as the active text box.
  eqBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    activeTextBox = textContainer;
    showEquationModal();
  });
  toolbar.appendChild(eqBtn);
  
  // New: Add Text Box button.
  let textBoxBtn = document.createElement("button");
  textBoxBtn.textContent = "Add Text Box";
  textBoxBtn.onclick = function(e) {
    e.stopPropagation();
    addTextBoxToAnswerOption(optionDiv);
  };
  toolbar.appendChild(textBoxBtn);
  
  let delBtnToolbar = document.createElement("button");
  delBtnToolbar.textContent = "Delete";
  delBtnToolbar.className = "delete-btn";
  delBtnToolbar.style.marginLeft = "5px";
  delBtnToolbar.addEventListener("click", function(e) {
    e.stopPropagation();
    optionDiv.remove();
  });
  toolbar.appendChild(delBtnToolbar);
  
  // Append the toolbar (non‑editable) to the overall container.
  optionDiv.appendChild(toolbar);
  
  // Create a separate editable text container for the answer option text.
  let textContainer = document.createElement("div");
  textContainer.className = "option-text";
  textContainer.contentEditable = true;
  textContainer.innerHTML = "Enter answer option (you may use {variable})";
  textContainer.style.outline = "none"; // Optional: remove default focus outline
  textContainer.addEventListener('click', function(e) {
    activeTextBox = textContainer;
    e.stopPropagation();
  });
  
  // Append the text container.
  optionDiv.appendChild(textContainer);
  
  container.appendChild(optionDiv);
}


function addTextBoxToAnswerOption(parent) {
  // Ensure the parent (MC option container) is relatively positioned
  parent.style.position = "relative";
  
  // Compute safe zone using your change: toolbar.offsetHeight - 45
  let safeTop = 0;
  let toolbar = parent.querySelector(".mc-option-toolbar");
  if (toolbar) {
    safeTop = toolbar.offsetHeight - 45;
  }
  
  // Create the container for the extra text box using relative positioning.
  let container = document.createElement("div");
  container.className = "draggable-text-box";
  container.style.position = "relative"; // in normal flow
  container.style.margin = "10px 0";
  container.style.width = "200px";
  container.style.minHeight = "50px";
  container.style.border = "1px dashed #ccc";
  container.style.background = "#fff";
  
  // Create the inner toolbar.
  let controls = document.createElement("div");
  controls.className = "answer-text-toolbar";
  controls.style.display = "flex";
  controls.style.alignItems = "center";
  controls.style.marginBottom = "3px";
  controls.addEventListener("click", function(e) {
    e.stopPropagation();
  });
  
  // Create the drag handle.
  let dragHandle = document.createElement("span");
  dragHandle.className = "drag-handle";
  dragHandle.innerHTML = "&#9776;";
  dragHandle.style.cursor = "move";
  dragHandle.style.background = "#ccc";
  dragHandle.style.padding = "2px 4px";
  controls.appendChild(dragHandle);
  
  // Equation button.
  let eqBtn = document.createElement("button");
  eqBtn.innerHTML = "Eq";
  eqBtn.title = "Insert Equation Element";
  eqBtn.style.marginRight = "4px";
  eqBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    activeTextBox = textArea;
    showEquationModal();
  });
  controls.appendChild(eqBtn);
  
  // Text Code button.
  let textCodeBtn = document.createElement("button");
  textCodeBtn.innerHTML = "Text Code";
  textCodeBtn.title = "Insert Text With Code (LaTeX)";
  textCodeBtn.style.marginRight = "4px";
  textCodeBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    activeTextBox = textArea;
    showTextCodeModal();
  });
  controls.appendChild(textCodeBtn);
  
  // Delete button – removes the entire text box container.
  let delBtn = document.createElement("button");
  delBtn.innerHTML = "Delete";
  delBtn.title = "Delete this text box";
  delBtn.style.marginLeft = "auto";
  delBtn.style.fontSize = "10px";
  delBtn.addEventListener("click", function(e) {
    e.stopPropagation();
    container.remove();
  });
  controls.appendChild(delBtn);
  
  container.appendChild(controls);
  
  // Create the editable text area.
  let textArea = document.createElement("div");
  textArea.className = "text-box";
  textArea.contentEditable = true;
  textArea.innerHTML = "Type here... (use {variable} notation)";
  textArea.setAttribute("data-original-text", textArea.innerHTML);
  textArea.setAttribute("data-mode", "manual");
  textArea.style.marginLeft = "25px"; // so text doesn't cover the drag handle
  textArea.style.outline = "none";
  textArea.style.overflow = "hidden";
  textArea.style.height = "auto";
  textArea.addEventListener("click", function(e) {
    activeElement = container;
    activeTextBox = textArea;
    e.stopPropagation();
  });
  textArea.addEventListener("input", function() {
    textArea.style.height = "auto";
    textArea.style.height = textArea.scrollHeight + "px";
    updateVariables();
  });
  container.appendChild(textArea);
  
  // Create a resize handle (positioned absolutely within the container).
  let resizeHandle = document.createElement("div");
  resizeHandle.className = "resize-handle";
  resizeHandle.style.position = "absolute";
  resizeHandle.style.right = "0";
  resizeHandle.style.bottom = "0";
  resizeHandle.style.width = "10px";
  resizeHandle.style.height = "10px";
  resizeHandle.style.backgroundColor = "blue";
  container.appendChild(resizeHandle);
  
  // DRAG: update container margins for dragging within parent's boundaries.
  let isDragging = false;
  let dragStartX, dragStartY, origMarginLeft, origMarginTop;
  
  dragHandle.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    origMarginLeft = parseInt(window.getComputedStyle(container).marginLeft) || 0;
    origMarginTop = parseInt(window.getComputedStyle(container).marginTop) || 0;
    
    // Get parent's current width and height via its bounding rectangle.
    var parentRect = parent.getBoundingClientRect();
    var elemWidth = container.offsetWidth;
    var elemHeight = container.offsetHeight;
    
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    
    function onMouseMove(e) {
      if (!isDragging) return;
      let dx = e.clientX - dragStartX;
      let dy = e.clientY - dragStartY;
      
      // Compute new margins.
      let newLeft = origMarginLeft + dx;
      let newTop = origMarginTop + dy;
      
      // Clamp newLeft to be between 0 and parent's width - element's width.
      newLeft = Math.max(0, Math.min(newLeft, parentRect.width - elemWidth));
      // Clamp newTop so it does not go above safeTop and stays within parent's height.
      newTop = Math.max(safeTop, Math.min(newTop, parentRect.height - elemHeight));
      
      container.style.marginLeft = newLeft + "px";
      container.style.marginTop = newTop + "px";
    }
    
    function onMouseUp() {
      isDragging = false;
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      
      // After dragging, update parent's size so it exactly encloses all its draggable children.
      let maxRight = 0, maxBottom = 0;
      parent.querySelectorAll(".draggable-text-box, .draggable-answer-image").forEach(function(child) {
        let childRect = child.getBoundingClientRect();
        let parentRectNow = parent.getBoundingClientRect();
        let rightEdge = childRect.right - parentRectNow.left;
        let bottomEdge = childRect.bottom - parentRectNow.top;
        if (rightEdge > maxRight) { maxRight = rightEdge; }
        if (bottomEdge > maxBottom) { maxBottom = bottomEdge; }
      });
      parent.style.width = maxRight + "px";
      parent.style.height = maxBottom + "px";
    }
  });
  
  // RESIZE: update container’s width and height on drag of the resize handle.
  resizeHandle.addEventListener("mousedown", function(e) {
    e.stopPropagation();
    e.preventDefault();
    let startX = e.clientX, startY = e.clientY;
    let startWidth = container.offsetWidth;
    let startHeight = container.offsetHeight;
    function onMouseMove(e) {
      let newWidth = startWidth + (e.clientX - startX);
      let newHeight = startHeight + (e.clientY - startY);
      if (newWidth > 50) container.style.width = newWidth + "px";
      if (newHeight > 20) container.style.height = newHeight + "px";
    }
    function onMouseUp() {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    }
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  
  parent.appendChild(container);
}



function addGraphToAnswerOption(parent) {
let xInterval = prompt("Enter x-axis interval for answer graph:", "1");
let yInterval = prompt("Enter y-axis interval for answer graph:", "1");
let xLabel = prompt("Enter x-axis label for answer graph:", "X");
let yLabel = prompt("Enter y-axis label for answer graph:", "Y");
let fontSizeInput = prompt("Enter graph font size in px for answer graph (default 12):", "12");
let graphFontSize = parseInt(fontSizeInput);
if (isNaN(graphFontSize)) graphFontSize = 12;
xInterval = parseFloat(xInterval);
yInterval = parseFloat(yInterval);
if (isNaN(xInterval) || isNaN(yInterval)) {
  alert("Invalid interval value for answer graph.");
  return;
}
let eq = prompt("Enter equation to graph for answer option (e.g., y = {a}*{x} + 10), or leave blank:");
let wrapper = document.createElement("div");
wrapper.className = "answer-graph";
wrapper.contentEditable = false;
wrapper.setAttribute("data-xInterval", xInterval);
wrapper.setAttribute("data-yInterval", yInterval);
wrapper.setAttribute("data-xLabel", xLabel);
wrapper.setAttribute("data-yLabel", yLabel);
wrapper.setAttribute("data-fontSize", graphFontSize);
wrapper.setAttribute("data-equation", eq);
wrapper.setAttribute("data-width", "300");
wrapper.setAttribute("data-height", "300");
let svgContent = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, graphFontSize, eq);
wrapper.innerHTML = svgContent;
let editBtn = document.createElement("button");
editBtn.textContent = "Edit Graph";
editBtn.className = "edit-graph";
editBtn.style.fontSize = "10px";
editBtn.style.pointerEvents = "auto";
editBtn.onclick = function(e) {
  e.stopPropagation();
  editGraphInAnswerOption(wrapper);
};
wrapper.appendChild(editBtn);
let deleteBtn = document.createElement("button");
deleteBtn.textContent = "Delete Graph";
deleteBtn.className = "delete-graph";
deleteBtn.style.fontSize = "10px";
deleteBtn.style.pointerEvents = "auto";
deleteBtn.onclick = function(e) {
  e.stopPropagation();
  wrapper.remove();
};
wrapper.appendChild(deleteBtn);
parent.appendChild(wrapper);
}

function updateGraphInAnswerOption(wrapper, computedVars) {
let xInterval = wrapper.getAttribute("data-xInterval");
let yInterval = wrapper.getAttribute("data-yInterval");
let xLabel = wrapper.getAttribute("data-xLabel");
let yLabel = wrapper.getAttribute("data-yLabel");
let fontSize = wrapper.getAttribute("data-fontSize");
let rawEquation = wrapper.getAttribute("data-equation");
let width = wrapper.getAttribute("data-width");
let height = wrapper.getAttribute("data-height");

let substitutedEquation = substituteValue(rawEquation, computedVars);
substitutedEquation = substitutedEquation.replace(/\{x\}/g, "x");

let newSVG = generateGraphSVG(xInterval, yInterval, xLabel, yLabel, fontSize, substitutedEquation);
newSVG = newSVG.replace(/<svg /, `<svg width="${width}" height="${height}" `);

let editBtn = wrapper.querySelector("button.edit-graph");
let deleteBtn = wrapper.querySelector("button.delete-graph");

wrapper.innerHTML = newSVG;
if (editBtn) wrapper.appendChild(editBtn);
if (deleteBtn) wrapper.appendChild(deleteBtn);
}

function editGraphInAnswerOption(wrapper) {
let currentXInterval = wrapper.getAttribute("data-xInterval") || "1";
let currentYInterval = wrapper.getAttribute("data-yInterval") || "1";
let currentXLabel = wrapper.getAttribute("data-xLabel") || "X";
let currentYLabel = wrapper.getAttribute("data-yLabel") || "Y";
let currentFontSize = wrapper.getAttribute("data-fontSize") || "12";
let currentEquation = wrapper.getAttribute("data-equation") || "";
let currentWidth = wrapper.getAttribute("data-width") || "300";
let currentHeight = wrapper.getAttribute("data-height") || "300";

let newXInterval = prompt("Enter x-axis interval:", currentXInterval);
let newYInterval = prompt("Enter y-axis interval:", currentYInterval);
let newXLabel = prompt("Enter x-axis label:", currentXLabel);
let newYLabel = prompt("Enter y-axis label:", currentYLabel);
let newFontSize = prompt("Enter graph font size in px:", currentFontSize);
let newEquation = prompt("Enter equation to graph (e.g., y = {a}*{x} + 10), or leave blank:", currentEquation);
let newWidth = prompt("Enter graph width in px:", currentWidth);
let newHeight = prompt("Enter graph height in px:", currentHeight);

wrapper.setAttribute("data-xInterval", newXInterval);
wrapper.setAttribute("data-yInterval", newYInterval);
wrapper.setAttribute("data-xLabel", newXLabel);
wrapper.setAttribute("data-yLabel", newYLabel);
wrapper.setAttribute("data-fontSize", newFontSize);
wrapper.setAttribute("data-equation", newEquation);
wrapper.setAttribute("data-width", newWidth);
wrapper.setAttribute("data-height", newHeight);

if (newEquation && newEquation.trim() !== "") {
  newEquation = newEquation.replace(/\{x\}/g, "x");
}
let newSVG = generateGraphSVG(newXInterval, newYInterval, newXLabel, newYLabel, newFontSize, newEquation);
newSVG = newSVG.replace(/<svg /, `<svg width="${newWidth}" height="${newHeight}" `);

let editBtn = wrapper.querySelector("button");
wrapper.innerHTML = newSVG;
if (editBtn) {
  wrapper.appendChild(editBtn);
}
}

function addTableToAnswerOption(parent) {
  let rows = prompt("Enter number of rows for answer table:", "3");
  let cols = prompt("Enter number of columns for answer table:", "3");
  rows = parseInt(rows);
  cols = parseInt(cols);
  if (isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) {
    alert("Invalid input for rows or columns in answer table.");
    return;
  }
  // Create table without forcing width:100%; let the resizer determine the proper sizing.
  let tableHTML = "<table style='border-collapse: collapse;'>";
  for (let i = 0; i < rows; i++) {
    tableHTML += "<tr>";
    for (let j = 0; j < cols; j++) {
      tableHTML += "<td contenteditable='true' style='border: 1px solid black; padding: 5px;'> </td>";
    }
    tableHTML += "</tr>";
  }
  tableHTML += "</table>";
  
  // Wrap the table in a container.
  let wrapper = document.createElement("div");
  wrapper.className = "answer-table";
  wrapper.contentEditable = false;
  
  wrapper.innerHTML = tableHTML;
  
  // Add a delete button for the table.
  let deleteBtn = document.createElement("button");
  deleteBtn.textContent = "Delete Table";
  deleteBtn.className = "delete-table";
  deleteBtn.style.fontSize = "10px";
  deleteBtn.style.pointerEvents = "auto";
  deleteBtn.onclick = function(e) {
    e.stopPropagation();
    wrapper.remove();
  };
  wrapper.appendChild(deleteBtn);
  
  // Append the wrapper to the answer option container.
  parent.appendChild(wrapper);
  
  // Make the table resizable and attach cell click handlers,
  // just as in the problem image.
  let tableElement = wrapper.querySelector("table");
  if (tableElement) {
    makeTableResizable(tableElement);
    attachCellClickHandlers(tableElement);
  }
}



function generateAnswerImages(computedVars) {
  const answerType = document.getElementById("answer-type").value;
  let container = document.createElement("div");
  container.className = "answer-images";
  container.style.marginTop = "10px";
  
  if (answerType === "box") {
    let correctAns = substituteValue(document.getElementById("correct-answer").value, computedVars);
    let labelText = substituteValue(document.getElementById("label-text").value, computedVars);
    let labelPosition = document.getElementById("label-position").value;
    
    let fullAnswer = "";
    if (labelText) {
      if (labelPosition === "before") {
        fullAnswer = labelText + " " + correctAns;
      } else if (labelPosition === "after") {
        fullAnswer = correctAns + " " + labelText;
      } else {
        fullAnswer = correctAns;
      }
    } else {
      fullAnswer = correctAns;
    }
    let minimalAnswer = correctAns;
    
    let fullDiv = document.createElement("div");
    fullDiv.id = "answer-full";
    fullDiv.innerHTML = fullAnswer;
    fullDiv.style.border = "1px solid black";
    fullDiv.style.display = "inline-block";
    fullDiv.style.padding = "5px";
    fullDiv.style.marginRight = "10px";
    
    let minimalDiv = document.createElement("div");
    minimalDiv.id = "answer-minimal";
    minimalDiv.innerHTML = minimalAnswer;
    minimalDiv.style.border = "1px solid black";
    minimalDiv.style.display = "inline-block";
    minimalDiv.style.padding = "5px";
    
    container.appendChild(fullDiv);
    container.appendChild(minimalDiv);
  
  } else if (answerType === "multiple" || answerType === "multi-select") {
    // Use the same computed ordering as in generateAnswerQuiz
    let options = window.currentAnswerOptions || computeAnswerOptions(computedVars);
    let correctLetters = getCorrectAnswerLettersFromOptions(options);
    let answerDiv = document.createElement("div");
    answerDiv.id = "answer-correct";
    answerDiv.innerHTML = `<div style="font-size:48px; font-weight:bold; text-align:center;">${correctLetters}</div>`;
    container.appendChild(answerDiv);
  
  } else if (answerType === "grid") {
    // For grid, generate the grid with correct answers pre‑selected.
    let gridQuiz = generateGridQuiz(computedVars, true);
    container.appendChild(gridQuiz);
  }
  
  return container;
}

/******** Save Images ********/
function saveProblemImages() {
  // Save the preview area (problem image and interactive quiz)
  html2canvas(document.getElementById("preview-area")).then(function(canvas) {
    let link1 = document.createElement('a');
    link1.download = "problem_with_answer.png";
    link1.href = canvas.toDataURL();
    link1.click();
  });
  
  // Save the full answer image separately.
  let fullElem = document.getElementById("answer-full");
  if (fullElem) {
    html2canvas(fullElem).then(function(canvas) {
      let link2 = document.createElement('a');
      link2.download = "answer_full.png";
      link2.href = canvas.toDataURL();
      link2.click();
    });
  }
  
  // Save the minimal answer image separately.
  let minimalElem = document.getElementById("answer-minimal");
  if (minimalElem) {
    html2canvas(minimalElem).then(function(canvas) {
      let link3 = document.createElement('a');
      link3.download = "answer_minimal.png";
      link3.href = canvas.toDataURL();
      link3.click();
    });
  }
}

function makeAroundTheRoomActivity() {
  let numProblems = parseInt(prompt("How many problems do you want to use?"));
  if (isNaN(numProblems) || numProblems < 1) {
    alert("Please enter a valid number.");
    return;
  }

  // Arrays to store canvases for problem and answer images.
  let problemImages = [];
  let answerImages = [];

  // Function to capture the current preview and answer images.
  function captureImages() {
    return new Promise((resolve) => {
      // Update the preview area
      previewProblemInteractive();
      // Short delay to allow preview update
      setTimeout(() => {
        html2canvas(document.getElementById("preview-area")).then(problemCanvas => {
          html2canvas(document.getElementById("answer-image-content")).then(answerCanvas => {
            problemImages.push(problemCanvas);
            answerImages.push(answerCanvas);
            resolve();
          });
        });
      }, 500);
    });
  }

  // Capture images for all problems sequentially.
  async function captureAll() {
    for (let i = 0; i < numProblems; i++) {
      updateVariables();
      await captureImages();
    }
  }

  captureAll().then(() => {
    // Build the Around the Room Activity layout.
    let activityContainer = document.createElement("div");
    activityContainer.id = "activityContainer";
    activityContainer.style.width = "650px";
    activityContainer.style.margin = "auto";

    // For each problem, create a page with two halves:
    // Top half: answer image from the previous problem (for the first page, use the last problem’s answer)
    // Bottom half: problem image from the current problem.
    for (let i = 0; i < numProblems; i++) {
      let page = document.createElement("div");
      page.className = "activity-page";

      let topHalf = document.createElement("div");
      topHalf.style.height = "50%";
      topHalf.style.borderBottom = "1px dashed gray";
      topHalf.style.display = "flex";
      topHalf.style.justifyContent = "center";
      topHalf.style.alignItems = "center";

      let bottomHalf = document.createElement("div");
      bottomHalf.style.height = "50%";
      bottomHalf.style.display = "flex";
      bottomHalf.style.justifyContent = "center";
      bottomHalf.style.alignItems = "center";

      bottomHalf.appendChild(problemImages[i]);

      let answerIndex = (i === 0) ? numProblems - 1 : i - 1;
      topHalf.appendChild(answerImages[answerIndex]);

      page.appendChild(topHalf);
      page.appendChild(bottomHalf);
      activityContainer.appendChild(page);
    }

    // Open a new window and display the activity.
    let activityWindow = window.open("", "ActivityWindow");
    activityWindow.document.body.innerHTML = "";
    activityWindow.document.body.appendChild(activityContainer);
  });
}

/******** Global Click Handler to Clear Selection ********/
document.addEventListener("click", function(e) {
  if (e.target.tagName !== "TD" && e.target.tagName !== "TH") {
    if (selectedCell) {
      selectedCell.classList.remove("selected-cell");
      selectedCell = null;
    }
  }
});
const canvas = document.getElementById("problem-canvas");

// Add this just before cyclingIndex is incremented in your click handler

/******** Initial Setup ********/
// Global variables for cycling tracking
// Global variables for click tracking and cycling:
// Global variables for cycling and click tracking:
let isDragging = false;
let cyclingIndex = 0;
let lastClickTime = 0;
let lastClickX = 0;
let lastClickY = 0;
const doubleClickThreshold = 300; // milliseconds
const clickTolerance = 5;            // pixels

document.getElementById("problem-canvas").addEventListener(
  "click",
  function(e) {
    // Skip if we should ignore this click (it was the result of a drag operation)
    if (ignoreNextClick) {
      ignoreNextClick = false;
      return;
    }
    
    // Skip if the click is on controls that should handle their own events
    if (
      e.target.closest('.fill-display') ||
      e.target.closest('.stroke-display') ||
      (e.target.closest('.circle-container') && e.target.tagName.toLowerCase() === 'path')
    ) {
      return;
    }
    
    // If a drag occurred, skip cycling
    if (isDragging) return;
    
    const currentTime = Date.now();
    const clickX = e.clientX;
    const clickY = e.clientY;
    
    // Reset cycling index if the click is not near the previous one
    if (
      Math.abs(clickX - lastClickX) > clickTolerance ||
      Math.abs(clickY - lastClickY) > clickTolerance ||
      (currentTime - lastClickTime) > doubleClickThreshold
    ) {
      cyclingIndex = 0;
    }
    
    lastClickX = clickX;
    lastClickY = clickY;
    lastClickTime = currentTime;
    
    // Get all elements under the click point
    const allElements = document.elementsFromPoint(clickX, clickY);
    // Filter only the draggable elements
    const draggableElements = allElements.filter(el =>
      el.classList.contains("draggable-element")
    );
    
    if (draggableElements.length > 0) {
      // If we have a previously active element, restore its z-index
      if (activeElement && activeElement !== draggableElements[cyclingIndex]) {
        restoreElementZIndex(activeElement);
      }
      
      // Hide controls and endpoints on all elements
      document.querySelectorAll(".draggable-element").forEach(el => {
        const ctrl = el.querySelector(".element-controls");
        if (ctrl) { ctrl.style.display = "none"; }
        const svg = el.querySelector("svg");
        if (svg && svg.currentLine) {
          if (svg.endpoint1) svg.endpoint1.style.display = "none";
          if (svg.endpoint2) svg.endpoint2.style.display = "none";
        }
      });
      
      // Cycle to the next element
      cyclingIndex = (cyclingIndex + 1) % draggableElements.length;
      activeElement = draggableElements[cyclingIndex];
      
      // Raise the active element above all others
      raiseElementTemporarily(activeElement);
      
      // Immediately highlight and show controls for the active element
      highlightActiveElement();
      const controls = activeElement.querySelector(".element-controls");
      if (controls) { 
        controls.style.display = "flex"; 
      }
      
      // If there's a text box inside, set it as active
      const textBox = activeElement.querySelector(".text-box");
      if (textBox) { activeTextBox = textBox; }
      
      // For line elements, show their endpoints
      const svg = activeElement.querySelector("svg");
      if (svg && svg.currentLine) {
        if (svg.endpoint1) svg.endpoint1.style.display = "block";
        if (svg.endpoint2) svg.endpoint2.style.display = "block";
      }
      
      e.stopPropagation();
    } else {
      cyclingIndex = 0;
      updateVariables();
    }
  },
  true // Use capture phase
);


document.addEventListener("click", function(e) {
  // If the clicked target is not inside any draggable element and we have an active element...
  if (!e.target.closest(".draggable-element") && activeElement) {
    // Restore the original z-index
    restoreElementZIndex(activeElement);
    
    // Remove highlighting and blur the element to remove the browser's default focus outline
    activeElement.style.outline = "";
    activeElement.blur();
    activeElement = null;
  }
});


document.getElementById("problem-canvas").addEventListener("click", function(e) {
  // If the click is directly on the canvas background (not on a draggable element)
  if (e.target === this) {
    if (activeElement) {
      restoreElementZIndex(activeElement);
      activeElement.style.outline = "";
      activeElement.blur();
      activeElement = null;
    }
  }
});



updateVariables();
updateAnswerOptions();

// Create the marker definitions when the page loads
// Create the marker definitions when the page loads
document.addEventListener("DOMContentLoaded", function() {
  // Add a click handler to all element controls
  function setupControlsClickHandlers() {
    document.querySelectorAll('.element-controls').forEach(toolbar => {
      toolbar.addEventListener('click', function(e) {
        // Stop event propagation to prevent the canvas handler from running
        e.stopPropagation();
        
        // Find the parent element (the draggable container)
        const container = this.closest('.draggable-element');
        if (container) {
          // Make this the active element
          activeElement = container;
          // Raise it temporarily
          raiseElementTemporarily(container);
        }
      });
    });
  }
  
  // Call the setup function
  setupControlsClickHandlers();
  
  // The rest of your existing DOMContentLoaded code
  createSVGMarkerDefs();
  addCyclingHintToUI();
  updateLayerButtons();
  
  // Observer to handle dynamically added controls
  const observer = new MutationObserver(function(mutations) {
    setupControlsClickHandlers();
  });
  
  observer.observe(document.getElementById('problem-canvas'), { 
    childList: true,
    subtree: true 
  });
});


</script>
  
</body>
</html>
