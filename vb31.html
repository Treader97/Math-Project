<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Variable Builder</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.2/math.js"></script>
  <script src="https://unpkg.com/polynomial-roots@1.2.0/dist/polynomial-roots.umd.min.js"></script>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"
  integrity="sha384-Tsl3d5pUAO7a13enIvSsL3O0/95nsthPJiPto5NtLuY8w3+LbZOpr3Fl2MNmrh1E"
  crossorigin="anonymous">
</script>

<script>
    // --- put this below your DOMPurify <script> tag ---
    function setSafeInnerHTML(el, html) {
      el.innerHTML = DOMPurify.sanitize(html, {
        ALLOWED_TAGS: [
          'div','span','p','label','input','button',
          'select','option','textarea','ul','ol','li','br'
        ],
        ALLOWED_ATTR: [
          'type','id','class','for','placeholder','rows',
          'cols','data-config-key','data-*'
        ]
      });
    }
  </script>
  
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Prevent HTML in pasted content
document.querySelectorAll('.equation-text[contenteditable="true"]')
  .forEach(el => {
    el.addEventListener('paste', e => {
      e.preventDefault();
      // Grab only plain text
      const text = e.clipboardData.getData('text/plain');
      // Insert sanitized text (no tags)
      document.execCommand('insertText', false, text);
    });
  });

      document.getElementById('variable-definitions')
        .addEventListener('focusout', function(e) {
          const el = e.target;
          if (el.nodeType === 1 && el.classList.contains('equation-text')) {
            el.innerHTML = DOMPurify.sanitize(el.innerHTML, {
              ALLOWED_TAGS: ['sup','sub','span'],
              ALLOWED_ATTR: ['class','data-var']
            });
          }
        });
    });
  </script>
  
    
  
  <style>
    /* --- CSS --- */
    body { font-family: Arial, sans-serif; padding: 10px; background-color: #f5f5f5; }
    .variable-manager { background: white; padding: 12px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .blocks-bank { margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 5px; }
    .blocks-bank h5 { margin-top: 0; margin-bottom: 8px; color: #495057; }
    .blocks-bank-items { display: flex; flex-wrap: wrap; gap: 8px; }
    .bank-block { display: inline-flex; align-items: center; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 13px; transition: transform 0.2s; user-select: none; }
    .bank-block:hover { transform: scale(1.05); }
    .bank-block.random-int, .bank-block.random-float { background-color: #e8f4fd; border: 1px solid #a8d1f2; } /* Grouped similar */
    .bank-block.fraction { background-color: #e6f9e6; border: 1px solid #a3d9a3; }
    .bank-block.choose { background-color: #fff0e6; border: 1px solid #ffd1b3; }
    .bank-block.random-name { background-color: #e6f7ff; border: 1px solid #b3e0ff; }
    .variable-definition { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #eee; position: relative; }
    .drag-handle { cursor: move; padding: 4px; color: #666; display: inline-block; margin-right: 5px; user-select: none; }
    .drag-handle:hover { color: #333; }
    .variable-name {
      font-weight: bold; display: inline-block; margin-right: 5px; padding: 2px 4px;
      outline: none; border: 1px solid transparent; border-radius: 3px; min-width: 40px; cursor: text;
    }
        /* Add this rule to style blocks inside the equation */
        .editable-equation .building-block {
      border: 1px solid #333; /* A dark grey/black border */
      /* You might want to adjust padding slightly if the border makes it feel cramped */
      /* padding: 3px 5px; */ /* Example adjustment - uncomment if needed */
    }
    .variable-name:hover { border-color: #ddd; background-color: #f9f9f9; }
    .variable-name:focus { border-color: #007bff; background-color: #f0f9ff; box-shadow: 0 0 0 2px rgba(0,123,255,0.25); }
    .variable-name-equals { margin-left: 0px; margin-right: 5px; font-weight: bold; display: inline-block; }
    .variable-expression { display: flex; flex-direction: column; margin-top: 5px; }
    .editable-equation { display: flex; align-items: center; flex-wrap: wrap; min-height: 30px; margin-bottom: 5px; padding: 6px; background-color: #fff; border: 1px solid #ccc; border-radius: 4px; }
    .equation-text { min-width: 1px; padding: 2px 4px; outline: none; display: inline-block; border-radius: 3px; position: relative; white-space: pre-wrap; word-break: break-word; vertical-align: baseline; }
    .equation-text:empty:before { content: "\200B"; }
    .equation-text:hover { background-color: #f0f9ff; }
    .equation-text:focus { background-color: #f0f9ff; box-shadow: 0 0 0 2px rgba(0,123,255,0.25); }
    .building-block { display: inline-flex; align-items: center; border-radius: 4px; padding: 4px 6px; margin: 0 3px; position: relative; cursor: pointer; font-size: 13px; flex-shrink: 0; vertical-align: baseline; user-select: none; transition: opacity 0.15s ease-in-out; outline: none; }
    .building-block:focus-visible { box-shadow: 0 0 0 2px rgba(0,123,255,0.4); }
    .building-block:not(.active):hover { opacity: 0.8; }
    .block-remove { margin-left: 4px; color: #dc3545; font-weight: bold; font-size: 14px; cursor: pointer; padding: 0 3px; }
    .block-remove:hover { background-color: #f8d7da; border-radius: 3px; }
    .block-config { position: absolute; top: calc(100% + 2px); left: 0; background: white; border: 1px solid #b4b4b4; border-radius: 4px; padding: 10px; width: 220px; box-shadow: 0 4px 10px rgba(0,0,0,0.15); z-index: 100; font-size: 12px; display: none; }
    .building-block.active .block-config { display: block; }
    .block-config select, .block-config input, .block-config textarea { width: 100%; margin-bottom: 8px; border: 1px solid #ccc; padding: 4px; font-size: 12px; box-sizing: border-box; } /* Added textarea */
    .block-config .range { display: flex; justify-content: space-between; align-items: center; }
    .block-config .range input { width: 45%; } .block-config .range span { width: 10%; text-align: center; }
    .block-config label { display: block; margin-bottom: 3px; font-weight: 500; color: #333; }
    .block-config input[type="checkbox"] + label { display: inline-block; margin-left: 5px; margin-bottom: 8px; font-weight: normal; vertical-align: middle; color: #333; }
    .block-config input[type="checkbox"] { width: auto; margin-bottom: 8px; vertical-align: middle; }
    .block-config-actions { margin-top: 10px; display: flex; justify-content: flex-end; gap: 8px; }
    .block-config-actions button { padding: 4px 10px; border-radius: 3px; border: 1px solid #ccc; cursor: pointer; font-size: 12px; }
    .block-config-actions .ok-btn { background-color: #28a745; color: white; border-color: #28a745; }
    .block-config-actions .ok-btn:hover { background-color: #218838; }
    .block-config-actions .cancel-btn { background-color: #f8f9fa; color: #333; border-color: #ccc; }
    .block-config-actions .cancel-btn:hover { background-color: #e2e6ea; }
    .add-variable-form { display: flex; align-items: center; margin-bottom: 10px; gap: 5px; }
    .add-variable-form input { padding: 5px; border: 1px solid #ddd; border-radius: 3px; width: 100px; }
    .add-variable-form button { background-color: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }
    .add-variable-form button:hover { background-color: #3e8e41; }
    .delete-btn { background-color: #f8d7da; border-color: #f5c6cb; color: #721c24; margin-left: auto; padding: 3px 6px; border-radius: 3px; font-size: 12px; cursor: pointer; border: 1px solid; }
    .dragging { opacity: 0.4 !important; background-color: #f8f8f8; z-index: 1000; pointer-events: none; }
    .drag-placeholder { border: 2px dashed #aaa; min-height: 40px; margin-bottom: 10px; border-radius: 5px; background-color: #f9f9f9; box-sizing: border-box; }
    .var-header { display: flex; align-items: center; }
    .variable-result { font-style: italic; color: #555; margin-top: 4px; padding-left: 6px; min-height: 1.2em; }
    #calculate-btn { background-color: #007bff; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-bottom: 10px; }
    #calculate-btn:hover { background-color: #0056b3; }

    /* Conditional logic styling */
.condition-block {
  background-color: #e3f2fd;
  border: 1px solid #42a5f5;
  border-radius: 4px;
  padding: 5px;
  margin: 3px 0;
  position: relative;
}

.condition-section {
  border: 1px solid #42a5f5;
  border-radius: 4px;
  margin-bottom: 5px;
  background-color: #e3f2fd;
}

.condition-container {
  margin-left: 20px; /* Indent nested content */
  border-left: 2px solid #42a5f5;
  padding-left: 10px;
  padding-bottom: 5px;
}

.condition-row {
  display: flex;
  align-items: center;
  margin-bottom: 5px;
  flex-wrap: wrap;
}

.condition-type {
  font-weight: bold;
  margin-right: 5px;
  padding: 2px 5px;
  border-radius: 3px;
  background-color: #42a5f5;
  color: white;
}

.condition-input {
  border: 1px solid #ccc;
  border-radius: 3px;
  padding: 2px 5px;
  margin: 0 5px;
  min-width: 60px;
  outline: none;
}

.condition-input:focus {
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

.condition-operator {
  padding: 2px 5px;
  border: 1px solid #ccc;
  border-radius: 3px;
  background-color: white;
  margin: 0 5px;
}

.condition-logical {
  padding: 2px 5px;
  border: 1px solid #ccc;
  border-radius: 3px;
  background-color: #f8f9fa;
  margin: 0 5px;
}

.condition-actions {
  display: flex;
  gap: 5px;
  margin-left: auto;
}

.add-else-btn, .add-elseif-btn, .add-and-btn, .add-or-btn {
  font-size: 11px;
  padding: 2px 5px;
  border-radius: 3px;
  border: 1px solid #ccc;
  background-color: #f8f9fa;
  cursor: pointer;
}

.add-else-btn:hover, .add-elseif-btn:hover, .add-and-btn:hover, .add-or-btn:hover {
  background-color: #e9ecef;
}

/* Different colors for different condition types */
.if-header .condition-type { background-color: #42a5f5; }
.elseif-header .condition-type { background-color: #5c6bc0; }
.else-header .condition-type { background-color: #7986cb; }

.condition-remove {
  color: #dc3545;
  font-weight: bold;
  font-size: 14px;
  cursor: pointer;
  padding: 0 3px;
  margin-left: 5px;
}

.condition-remove:hover {
  background-color: #f8d7da;
  border-radius: 3px;
}

.condition-wrapper {
  background-color: #f0f8ff;
  border-radius: 4px;
  padding: 5px;
  margin: 3px 0;
}

.if-section {
  border-color: #42a5f5;
}

.else-section {
  border-color: #7986cb;
  background-color: #e8eaf6;
}


  </style>
</head>
<body>
    <div style="background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
        <strong>⚠️ Security Notice:</strong> This tool performs calculations client-side only. For production use with sensitive data, implement server-side validation.
      </div>
      <div class="variable-manager">
        <h4 style="margin-top: 0; margin-bottom: 8px;">Variable Builder</h4>

    <!-- Building Blocks Bank -->
    <div class="blocks-bank">
      <h5>Building Blocks Bank</h5>
      <div class="blocks-bank-items">
        <div class="bank-block random-int" data-block-type="random-int">Random Int</div>
        <div class="bank-block fraction" data-block-type="fraction">Random Fraction</div>
        <div class="bank-block random-float" data-block-type="random-float">Random Float</div>
        <!-- Choose Text -->
<div class="bank-block choose-text" data-block-type="choose-text"
style="background-color:#fff0e6;border:1px solid #ffc099;">
Choose Text
</div>

<!-- Choose Alg Expr -->
<div class="bank-block choose-expr" data-block-type="choose-expr"
style="background-color:#e6f7ff;border:1px solid #b3e0ff;">
Choose Alg Expression
</div>

<!-- Choose Number -->
<div class="bank-block choose-num" data-block-type="choose-num"
style="background-color:#e6ffea;border:1px solid #b3ffc6;">
Choose Number
</div>

        <div class="bank-block random-name" data-block-type="random-name">Random Name</div>
        <div class="bank-block gcd" data-block-type="gcd" style="background-color: #f0f0f0; border: 1px solid #cccccc;">GCF/GCD</div>
        <div class="bank-block lcm" data-block-type="lcm" style="background-color: #f5f5f5; border: 1px solid #d9d9d9;">LCM</div>
        <div class="bank-block choose-prime" data-block-type="choose-prime" style="background-color: #fffbe6; border: 1px solid #ffe58f;">Choose Prime</div>
        <div class="bank-block abs" data-block-type="abs" style="background-color: #e6fffb; border: 1px solid #b3f0e5;">Abs Val</div>
        <div class="bank-block quotient" data-block-type="quotient" style="background-color: #f9f0ff; border: 1px solid #e8c0ff;">Quotient</div>
        <div class="bank-block remainder" data-block-type="remainder" style="background-color: #fff2f0; border: 1px solid #ffccc7;">Remainder</div>
        <div class="bank-block create-fraction fraction" data-block-type="create-fraction">Fraction</div>
        <div class="bank-block unsimp-mixed-num fraction" data-block-type="unsimplified-mixed-number">Unsimp Mixed</div>
        <div class="bank-block simp-mixed-num fraction" data-block-type="simplified-mixed-number">Simp Mixed</div>
        <div class="bank-block red-improper-frac fraction" data-block-type="reduced-improper-fraction">Reduced Improper</div>
        <div class="bank-block frac-num" data-block-type="fraction-numerator" style="background-color: #e6f9ff; border: 1px solid #b3e0ff;">Frac Numerator</div>
        <div class="bank-block frac-den" data-block-type="fraction-denominator" style="background-color: #e6f9ff; border: 1px solid #b3e0ff;">Frac Denominator</div>
        <div class="bank-block mixed-num-numerator" data-block-type="mixed-number-numerator" 
        style="background-color: #e6f9ff; border: 1px solid #b3e0ff;">Mixed Num Numerator</div>
        <div class="bank-block add-polynomials" data-block-type="add-polynomials" style="background-color:#e3f2fd;border:1px solid #42a5f5;">Add Polynomials</div>
        <div class="bank-block format-mixed-num" data-block-type="format-mixed-number" style="background-color: #f0e6ff; border: 1px solid #d8c2ff;">Format Mixed Number</div>
     <div class="bank-block mixed-num-whole" data-block-type="mixed-number-whole" style="background-color: #e6f9ff; border: 1px solid #b3e0ff;">Mixed Num Whole</div>
     <div class="bank-block convert-improper" data-block-type="convert-improper" style="background-color: #ffece6; border: 1px solid #ffcbb3;">Convert to Improper</div>
     <div class="bank-block round" data-block-type="round" style="background-color: #e6ffea; border: 1px solid #b3ffc6;">Round</div>
     <div class="bank-block convert-decimal" data-block-type="convert-decimal" style="background-color: #e6f7ff; border: 1px solid #b3e0ff;">Convert to Decimal</div>
     <div class="bank-block round-up" data-block-type="round-up" style="background-color: #ffe6eb; border: 1px solid #ffb3c0;">Round Up</div>
     <div class="bank-block round-down" data-block-type="round-down" style="background-color: #e6f2ff; border: 1px solid #b3d9ff;">Round Down</div>
     <div class="bank-block square-root" data-block-type="square-root" style="background-color: #f0e6ff; border: 1px solid #d9b3ff;">Square Root</div>
     <div class="bank-block nth-root" data-block-type="nth-root" style="background-color: #d1c4e9; border: 1px solid #b39ddb;">Nth Root</div>
     <div class="bank-block algebraic-expr" data-block-type="algebraic-expr" style="background-color: #c8e6c9; border: 1px solid #a5d6a7;">Algebraic Expression</div>
     <div class="bank-block simplify-radical" data-block-type="simplify-radical" style="background-color: #f3e5f5; border: 1px solid #ce93d8;">Simplify Radical</div>
     <div class="bank-block simplify-cube-root" data-block-type="simplify-cube-root" style="background-color: #e1f5fe; border: 1px solid #81d4fa;">Simplify Cube Root</div>
     <div class="bank-block simplify-nth-root" data-block-type="simplify-nth-root" style="background-color: #e8f5e9; border: 1px solid #a5d6a7;">Simplify Nth Root</div>
     <div class="bank-block simp-rad-coefficient" data-block-type="simp-rad-coefficient" style="background-color: #f8eeff; border: 1px solid #d4b6ff;">Simp Rad Coefficient</div>
     <div class="bank-block simp-rad-radicand" data-block-type="simp-rad-radicand" style="background-color: #f0e6ff; border: 1px solid #d0b8ff;">Simp Rad Radicand</div>
     <div class="bank-block simp-cbrt-coefficient" data-block-type="simp-cbrt-coefficient" style="background-color: #e3f2fd; border: 1px solid #90caf9;">Simp Cube Root Coefficient</div>
     <div class="bank-block simp-cbrt-radicand" data-block-type="simp-cbrt-radicand" style="background-color: #e1f5fe; border: 1px solid #81d4fa;">Simp Cube Root Radicand</div>
     <div class="bank-block quadratic-formula-decimal" data-block-type="quadratic-formula-decimal" style="background-color: #ffecb3; border: 1px solid #ffd54f;">Quadratic Formula Decimal</div>
     <div class="bank-block quadratic-formula-radical" data-block-type="quadratic-formula-radical" style="background-color: #fff9c4; border: 1px solid #fff176;">Quadratic Formula Radical</div>
     <div class="bank-block quad-form-dec-ans1" data-block-type="quad-form-dec-ans1" style="background-color: #ffe0b2; border: 1px solid #ffb74d;">Quad Form Dec Ans1</div>
     <div class="bank-block quad-form-dec-ans2" data-block-type="quad-form-dec-ans2" style="background-color: #e6ee9c; border: 1px solid #d4e157;">Quad Form Dec Ans2</div>
     <div class="bank-block sin-decimal" data-block-type="sin-decimal" style="background-color: #bbdefb; border: 1px solid #64b5f6;">Sin Decimal</div>
     <div class="bank-block cos-decimal" data-block-type="cos-decimal" style="background-color: #c8e6c9; border: 1px solid #81c784;">Cos Decimal</div>
     <div class="bank-block tan-decimal" data-block-type="tan-decimal" style="background-color: #fff9c4; border: 1px solid #fff176;">Tan Decimal</div>
     <div class="bank-block pyth-triple-multiples" data-block-type="pyth-triple-multiples"   style="background-color: #e6f7ff; border: 1px solid #91d5ff;"> Pyth Triple Multiples</div>
     <div class="bank-block sin-exact" data-block-type="sin-exact" style="background-color: #e3f2fd; border: 1px solid #90caf9;">Sin Exact</div>
<div class="bank-block cos-exact" data-block-type="cos-exact" style="background-color: #e8f5e9; border: 1px solid #a5d6a7;">Cos Exact</div>
<div class="bank-block tan-exact" data-block-type="tan-exact" style="background-color: #fff8e1; border: 1px solid #ffecb3;">Tan Exact</div>
<div class="bank-block csc-exact" data-block-type="csc-exact" style="background-color: #f3e5f5; border: 1px solid #ce93d8;">Csc Exact</div>
<div class="bank-block sec-exact" data-block-type="sec-exact" style="background-color: #e8eaf6; border: 1px solid #c5cae9;">Sec Exact</div>
<div class="bank-block cot-exact" data-block-type="cot-exact" style="background-color: #fce4ec; border: 1px solid #f8bbd0;">Cot Exact</div>
<div class="bank-block pythagorean-triple" data-block-type="pythagorean-triple"  style="background-color: #e6f7ff; border: 1px solid #91d5ff;">Pythagorean Triple</div>
<div class="bank-block sin-inverse" data-block-type="sin-inverse" style="background-color: #e1bee7; border: 1px solid #ba68c8;">Arcsin</div>
<div class="bank-block cos-inverse" data-block-type="cos-inverse" style="background-color: #b3e5fc; border: 1px solid #4fc3f7;">Arccos</div>
<div class="bank-block tan-inverse" data-block-type="tan-inverse" style="background-color: #c8e6c9; border: 1px solid #81c784;">Arctan</div>
<div class="bank-block prime-factorization" data-block-type="prime-factorization" style="background-color: #ffedd5; border: 1px solid #f97316;">Prime Factorization</div>
<div class="bank-block log-block" data-block-type="log-block" style="background-color: #d1fae5; border: 1px solid #10b981;">Log</div>
<div class="bank-block ln-block" data-block-type="ln-block"   style="background-color: #e0f2fe; border: 1px solid #0ea5e9;">Ln</div>
<div class="bank-block least-to-greatest" data-block-type="least-to-greatest" style="background-color: #e0f7fa; border: 1px solid #80deea;">Least to Greatest</div>
<div class="bank-block greatest-to-least" data-block-type="greatest-to-least" style="background-color: #e0f7fa; border: 1px solid #80deea;">Greatest to Least</div>
<div class="bank-block alphabetical" data-block-type="alphabetical" style="background-color: #e0f7fa; border: 1px solid #80deea;">Alphabetical</div>
<div class="bank-block list-max" data-block-type="list-max"  style="background-color: #e0f7fa; border: 1px solid #80deea;">List Max</div>
<div class="bank-block list-min" data-block-type="list-min" style="background-color: #e0f7fa; border: 1px solid #80deea;">List Min</div>
<div class="bank-block random-order" data-block-type="random-order"  style="background-color: #e0f7fa; border: 1px solid #80deea;">Random Order</div>
<div class="bank-block poly-relative-max" data-block-type="poly-relative-max"  style="background-color: #d1fae5; border: 1px solid #10b981;">Poly Relative Max (y values)</div>
    <div class="bank-block poly-relative-max-coords" data-block-type="poly-relative-max-coords" style="background-color: #dbeafe; border: 1px solid #3b82f6;">Poly Relative Max Coordinates</div>
    <div class="bank-block poly-relative-min" data-block-type="poly-relative-min" style="background-color: #ffe4e6; border: 1px solid #f43f5e;">Poly Relative Min (y values)</div>
<div class="bank-block poly-relative-min-coords" data-block-type="poly-relative-min-coords" style="background-color: #fbcfe8; border: 1px solid #ec4899;">Poly Relative Min Coordinates</div>
<div class="bank-block poly-factored-max" data-block-type="poly-factored-max" style="background-color: #fef3c7; border: 1px solid #d97706;">Poly Factored Form Max</div>
<div class="bank-block poly-factored-max-coords" data-block-type="poly-factored-max-coords"  style="background-color: #fef9c3; border: 1px solid #eab308;">Poly Factored Form Max Coordinates</div>
<div class="bank-block poly-factored-min" data-block-type="poly-factored-min"  style="background-color: #e0f2fe; border: 1px solid #0ea5e9;">Poly Factored Form Min</div>
<div class="bank-block poly-factored-min-coords" data-block-type="poly-factored-min-coords"   style="background-color: #dbeafe; border: 1px solid #3b82f6;">Poly Factored Form Min Coordinates</div>
<div class="bank-block coordinate-x-value" data-block-type="coordinate-x-value" style="background-color: #fae8ff; border: 1px solid #c026d3;">Coordinate x-value</div>
<div class="bank-block coordinate-y-value" data-block-type="coordinate-y-value"  style="background-color: #fce7f3; border: 1px solid #db2777;">Coordinate y-value</div>
<div class="bank-block if-condition" data-block-type="if-condition" style="background-color: #e3f2fd; border: 1px solid #42a5f5;">If Condition</div>
<div class="bank-block polynomial-zeros" data-block-type="polynomial-zeros" style="background-color:#e6ffee;border:1px solid #52c41a;"> Zeros of Polynomial</div>
<div class="bank-block text-block"data-block-type="text"style="background-color:#fffbe6;border:1px solid #ffd866;"> Text</div>
<div class="bank-block blank" data-block-type="blank" style="background-color:#f5f5f5;border:1px solid #cccccc;">Blank</div>
<div class="bank-block undefined" data-block-type="undefined" style="background-color:#eceff1;border:1px solid #b0bec5;">Undefined</div>
<div class="bank-block count"  data-block-type="count"  style="background-color:#e8f9ff;border:1px solid #90caf9;"> Count</div>
<div class="bank-block permutation" data-block-type="permutation"  style="background-color:#e3f2fd;border:1px solid #42a5f5;">Permutation</div>
<div class="bank-block combination" data-block-type="combination"  style="background-color:#e1f5fe;border:1px solid #4fc3f7;"> Combination</div>
<div class="bank-block synthetic-division" data-block-type="synthetic-division" style="background-color:#ffecb3;border:1px solid #ffd54f;"> Synthetic Division</div>
<div class="bank-block multiply-polynomials" data-block-type="multiply-polynomials" style="background-color:#e8f5e9;border:1px solid #66bb6a;">Multiply Polynomials</div>

</div>

</div>
    </div>
    </div>

    <!-- Add Variable Form -->
    <div class="add-variable-form">
      <input type="text" id="new-variable-name" placeholder="Name (e.g. x, y)">
      <button id="add-variable-btn">Add Variable</button>
    </div>

    <!-- Calculate Variables Button -->
    <button id="calculate-btn">Calculate Variables</button>

    <!-- Variable Definitions Container -->
    <div id="variable-definitions">
       <!-- Variable definitions will be added here -->
    </div>
  </div>

  <script>
// SECURITY: Strict limits to prevent DoS attacks
const MAX_EXPR_LENGTH = 50;    // Reduced from 100
const MAX_AST_NODES   = 25;    // Reduced from 500  
const MAX_VARIABLES   = 20;    // New: limit total variables
const MAX_EVAL_TIME   = 100;   // New: max evaluation time in ms
const MAX_RECURSION   = 10;    // New: max recursion depth

// Security validation counter
let validationWarnings = 0;
const MAX_VALIDATION_WARNINGS = 10;

// SECURITY: Rate limiting for expression evaluation
// SECURITY: Rate limiting for expression evaluation
const expressionRateLimit = (function() {
    // Private variables - hidden from console
    let requests = [];
    const maxRequests = 100;      // Max 100 evaluations
    const timeWindow = 60000;     // Per 60 seconds
    
    return {
        checkLimit: function() {
            const now = Date.now();
            
            // Remove old requests outside time window
            requests = requests.filter(time => now - time < timeWindow);
            
            // Check if limit exceeded
            if (requests.length >= maxRequests) {
                throw new Error('Rate limit exceeded. Please wait before evaluating more expressions.');
            }
            
            // Add current request
            requests.push(now);
        },
        
        // Remove the reset function - no one can reset it now
        getRemainingRequests: function() {
            const now = Date.now();
            requests = requests.filter(time => now - time < timeWindow);
            return maxRequests - requests.length;
        }
    };
})();

// Count the number of nodes in a parsed math.js AST
function countNodes(node) {
    // SECURITY: Prevent infinite recursion
    const MAX_RECURSION_DEPTH = 20;
    
    function countNodesRecursive(node, depth = 0) {
        if (depth > MAX_RECURSION_DEPTH) {
            throw new Error('AST too deeply nested');
        }
        
        let total = 1;
        
        // For OperatorNode, FunctionNode, etc.
        if (node.args && Array.isArray(node.args)) {
            for (const child of node.args) {
                total += countNodesRecursive(child, depth + 1);
            }
        }
        
        // For ParenthesisNode
        if (node.content) {
            total += countNodesRecursive(node.content, depth + 1);
        }
        
        // For FunctionNode
        if (node.fn && node.fn.args) {
            for (const child of node.fn.args) {
                total += countNodesRecursive(child, depth + 1);
            }
        }
        
        return total;
    }
    
    return countNodesRecursive(node);
}

    // --- State Variables ---
    let draggedElement = null;
    let placeholder = null;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      setupBankBlockClicks();
      document.getElementById('add-variable-btn').addEventListener('click', addVariable);
      document.getElementById('calculate-btn').addEventListener('click', calculateVariables);
      setupInteractiveElements(document.getElementById('variable-definitions'));
      setupGlobalListeners();
      setupDragDropContainer(document.getElementById('variable-definitions'));
    });

    // --- Global Setup ---
    function setupGlobalListeners() {
      document.addEventListener('click', function(event) {
        const activeBlock = document.querySelector('.building-block.active');
        if (activeBlock && !activeBlock.contains(event.target)) {
            const configPanel = activeBlock.querySelector('.block-config');
            if(!configPanel || !configPanel.contains(event.target)) {
               handleConfigCancel(activeBlock);
            }
        }
      }, true);
    }

    function setupDragDropContainer(container) {
        container.addEventListener('dragover', dragOver);
        container.addEventListener('drop', drop);
        container.addEventListener('dragenter', dragEnter);
        container.addEventListener('dragleave', dragLeave);
    }

    // --- Setup Element Handlers ---
    function setupInteractiveElements(parentElement) {
    // Equations
    parentElement.querySelectorAll('.equation-text[contenteditable="true"]:not([data-initialized-eq="true"])').forEach(span => {
        span.onclick = () => span.focus();
        span.dataset.initializedEq = 'true';
        
        // Add protection against paste
        span.addEventListener('paste', function(e) {
            e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            document.execCommand('insertText', false, text);
        });
        
        // Add protection against drop
        span.addEventListener('drop', function(e) {
            e.preventDefault();
            const text = e.dataTransfer.getData('text/plain');
            document.execCommand('insertText', false, text);
        });
        
        // Add protection against drag over
        span.addEventListener('dragover', function(e) {
            e.preventDefault();
        });
    });
        // Variable Names
    // Variable Names
    parentElement.querySelectorAll('.variable-name[contenteditable="true"]:not([data-initialized-name="true"])').forEach(span => {
        span.addEventListener('blur', handleVariableNameChange);
        span.addEventListener('keydown', handleVariableNameKeydown);
        span.dataset.previousValidName = span.textContent.trim();
        span.dataset.initializedName = 'true';
        
        // Add protection against paste
        span.addEventListener('paste', function(e) {
            e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            document.execCommand('insertText', false, text);
        });
        
        // Add protection against drop
        span.addEventListener('drop', function(e) {
            e.preventDefault();
            const text = e.dataTransfer.getData('text/plain');
            document.execCommand('insertText', false, text);
        });
        
        // Add protection against drag over
        span.addEventListener('dragover', function(e) {
            e.preventDefault();
        });
    });
        // Building Blocks
        parentElement.querySelectorAll('.building-block:not([data-initialized-block="true"])').forEach(block => {
            // Random Name doesn't use the standard listener setup
            if (!block.classList.contains('random-name') && !block.classList.contains('unknown')) {
                 addBlockEventListeners(block);
            }
            block.dataset.initializedBlock = 'true';
        });
        // Drag Handles
        parentElement.querySelectorAll('.drag-handle[draggable="true"]:not([data-initialized-drag="true"])').forEach(handle => {
            const parentDef = handle.closest('.variable-definition');
            if(parentDef) {
               handle.addEventListener('dragstart', (e) => dragStart(e, parentDef));
               handle.addEventListener('dragend', dragEnd);
               handle.dataset.initializedDrag = 'true';
            }
        });
        // Delete Buttons
        parentElement.querySelectorAll('.delete-btn:not([data-initialized-delete="true"])').forEach(btn => {
            const parentDef = btn.closest('.variable-definition');
            if(parentDef) {
               btn.onclick = () => deleteVariable(parentDef);
               btn.dataset.initializedDelete = 'true';
            }
        });
    }

    // --- Event Listeners for Blocks (Configurable ones) ---
     // ---------------------------------------------------------------------------
// Completely replace the old addBlockEventListeners with THIS version
// ---------------------------------------------------------------------------
function addBlockEventListeners(block) {

/* === open / activate on click ========================================= */
block.onclick = (e) => {
  e.stopPropagation();
  toggleBlockConfig(block);
};

/* === keyboard shortcuts =============================================== */
block.onkeydown = (e) => {

  /* 1)  Allow normal typing ONLY when…  
         – this block is a Text block,
         – its config panel is open (class 'active'),
         – the event target is INSIDE that panel (input / textarea).      */
         if (
     (block.classList.contains('text-block')   ||
      block.classList.contains('choose-text')) &&   // ← NEW
     block.classList.contains('active') &&
     e.target.closest('.block-config')
   ) {
  return;   // normal typing inside Text‑or‑Choose‑Text config
}

  /* 2)  Normal global shortcuts (unchanged)                              */
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    toggleBlockConfig(block);
  }
  if ((e.key === 'Delete' || e.key === 'Backspace') &&
      !block.classList.contains('active')) {
    removeBlock(block);
  }
};

/* === config‑panel buttons & keys ====================================== */
const config = block.querySelector('.block-config');
if (config) {
  const okBtn     = config.querySelector('.ok-btn');
  const cancelBtn = config.querySelector('.cancel-btn');

  if (okBtn)     okBtn.onclick     = (e) => { e.stopPropagation(); handleConfigOk(block); };
  if (cancelBtn) cancelBtn.onclick = (e) => { e.stopPropagation(); handleConfigCancel(block); };

  config.addEventListener('keydown', (event) => {
    if ((event.key === 'Backspace' || event.key === 'Delete') &&
        event.target.tagName === 'INPUT') {
      event.stopPropagation();           // keep delete/backspace inside input
    }
    if (event.key === 'Enter' && !event.target.closest('button')) {
      event.preventDefault();
      handleConfigOk(block);
    }
    if (event.key === 'Escape') {
      handleConfigCancel(block);
    }
  });

  config.onclick = (e) => e.stopPropagation();
}

/* === little “×” to remove the block =================================== */
const removeBtn = block.querySelector('.block-remove');
if (removeBtn) {
  removeBtn.onclick = (e) => { e.stopPropagation(); removeBlock(block); };
}
}


    // --- Drag and Drop ---
    function dragStart(event, element) { /* ... (unchanged) ... */
        draggedElement = element; event.dataTransfer.effectAllowed = 'move';
        placeholder = document.createElement('div'); placeholder.className = 'drag-placeholder';
        placeholder.style.height = `${element.offsetHeight}px`;
        setTimeout(() => element.classList.add('dragging'), 0);
    }
    function dragOver(event) { /* ... (unchanged) ... */
        event.preventDefault(); event.dataTransfer.dropEffect = 'move';
        const container = event.currentTarget; if (!draggedElement || !container.contains(draggedElement) || !placeholder) return;
        const afterElement = getDragAfterElement(container, event.clientY);
        if (afterElement == null) { if (container.lastChild !== placeholder) container.appendChild(placeholder); }
        else { if (afterElement !== placeholder && afterElement.previousSibling !== placeholder) container.insertBefore(placeholder, afterElement); }
    }
    function drop(event) { /* ... (unchanged) ... */
        event.preventDefault(); const container = event.currentTarget;
        if (draggedElement && placeholder && placeholder.parentNode === container) {
            container.insertBefore(draggedElement, placeholder); placeholder.parentNode.removeChild(placeholder);
        } cleanupDragState(container);
    }
    function dragEnd(event) { cleanupDragState(document.getElementById('variable-definitions')); }
    function cleanupDragState(container) { /* ... (unchanged) ... */
        if (draggedElement) draggedElement.classList.remove('dragging');
        if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
        draggedElement = null; placeholder = null;
        if (container) container.classList.remove('drag-over');
    }
    function dragEnter(event) { /* ... (unchanged) ... */ if (event.currentTarget.contains(draggedElement)) event.currentTarget.classList.add('drag-over'); }
    function dragLeave(event) { /* ... (unchanged) ... */ if (!event.currentTarget.contains(event.relatedTarget)) event.currentTarget.classList.remove('drag-over'); }
    function getDragAfterElement(container, y) { /* ... (unchanged) ... */
        const els = [...container.querySelectorAll('.variable-definition:not(.dragging):not(.drag-placeholder)')];
        return els.reduce((closest, child) => { const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2; if (offset < 0 && offset > closest.offset) return { offset: offset, element: child }; else return closest; }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // --- Block Insertion Logic ---
    function setupBankBlockClicks() { /* ... (unchanged) ... */
      const bankBlocks = document.querySelectorAll('.blocks-bank .bank-block');
      bankBlocks.forEach(block => {
        block.addEventListener('mousedown', function(event) {
          event.preventDefault(); const blockType = this.getAttribute('data-block-type');
          const inserted = insertBlockAtCursor(blockType);
          if (!inserted) { const equations = document.querySelectorAll('.editable-equation'); if (equations.length > 0) appendBlockToEndOfEquation(equations[equations.length - 1], blockType); else console.warn("No equation to append to."); }
        });
      });
    }
    function insertBlockAtCursor(blockType) { /* ... (unchanged) ... */
        const selection = window.getSelection(); if (!selection.rangeCount || !selection.isCollapsed) return false;
        const range = selection.getRangeAt(0); const container = range.commonAncestorContainer; let editableContainer = container.nodeType === Node.ELEMENT_NODE ? container : container.parentNode;
        let cursorSpan = editableContainer.closest('.equation-text[contenteditable="true"]'); let equationDiv = editableContainer.closest('.editable-equation'); if (!equationDiv) return false;
        const newBlock = createBlockFromType(blockType); if (!newBlock) return false; // Check if block creation failed
        const afterSpan = createEditableSpan();
        try {
            if (equationDiv === editableContainer || !cursorSpan) { range.insertNode(afterSpan); range.insertNode(newBlock); if (!afterSpan.textContent) afterSpan.textContent = '\u00A0'; }
            else if (container.nodeType === Node.TEXT_NODE && cursorSpan === container.parentNode) { const offset = range.startOffset; const textContent = container.nodeValue; afterSpan.textContent = textContent.substring(offset) || '\u00A0'; container.nodeValue = textContent.substring(0, offset); if (cursorSpan.nextSibling) { equationDiv.insertBefore(newBlock, cursorSpan.nextSibling); equationDiv.insertBefore(afterSpan, newBlock.nextSibling); } else { equationDiv.appendChild(newBlock); equationDiv.appendChild(afterSpan); } }
            else { range.insertNode(afterSpan); range.insertNode(newBlock); if (!afterSpan.textContent) afterSpan.textContent = '\u00A0'; }
            focusElement(afterSpan, 0); return true;
        } catch (e) { console.error("Error inserting block:", e); return false; }
    }
    function appendBlockToEndOfEquation(equation, blockType) { /* ... (unchanged) ... */
        const newBlock = createBlockFromType(blockType); if (!newBlock) return;
        const lastChild = equation.lastChild;
        if (lastChild && ((lastChild.nodeType === Node.ELEMENT_NODE && lastChild.classList.contains('equation-text')) || lastChild.nodeType === Node.TEXT_NODE) && lastChild.textContent.trim() && !/\s$/.test(lastChild.textContent)) { lastChild.textContent += ' '; }
        equation.appendChild(newBlock); const afterText = createEditableSpan('\u00A0'); equation.appendChild(afterText); focusElement(afterText, 0);
    }

    // --- Variable and Block Management ---
    function addVariable() {
  const nameInput = document.getElementById('new-variable-name');
  const name = nameInput.value.trim().replace(/=/g, '');
  // validate name as before
  if (!name || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
    return name
      ? alert("Invalid variable name. Must start with a letter or underscore, and contain only letters, numbers, or underscores.")
      : alert("Please enter a variable name.");
  }

  const existingNames = getAllVariableNames();
  if (existingNames.includes(name)) {
    return alert(`Variable "${name}" already exists.`);
  }

  const container = document.getElementById('variable-definitions');

  // 1) Create the outer wrapper
  const varDef = document.createElement('div');
  varDef.className = 'variable-definition';
  varDef.id = `var-${name}-${Date.now()}`;

  // 2) Build the header
  const header = document.createElement('div');
  header.className = 'var-header';

  //    • drag handle
  const dragHandle = document.createElement('div');
  dragHandle.className = 'drag-handle';
  dragHandle.draggable = true;
  dragHandle.textContent = '≡';
  header.appendChild(dragHandle);

  //    • variable name (escaped via textContent)
  const nameSpan = document.createElement('span');
  nameSpan.className = 'variable-name';
  nameSpan.contentEditable = true;
  nameSpan.spellcheck = false;
  nameSpan.textContent = name;
  header.appendChild(nameSpan);

  //    • equals sign
  const eqSpan = document.createElement('span');
  eqSpan.className = 'variable-name-equals';
  eqSpan.textContent = '=';
  header.appendChild(eqSpan);

  //    • delete button
  const delBtn = document.createElement('button');
  delBtn.className = 'delete-btn';
  delBtn.textContent = 'Delete';
  header.appendChild(delBtn);

  // 3) Build the expression/result area
  const exprWrapper = document.createElement('div');
  exprWrapper.className = 'variable-expression';

  const equationDiv = document.createElement('div');
  equationDiv.className = 'editable-equation';
  exprWrapper.appendChild(equationDiv);

  const resultDiv = document.createElement('div');
  resultDiv.className = 'variable-result';
  exprWrapper.appendChild(resultDiv);

  // 4) Assemble and insert
  varDef.appendChild(header);
  varDef.appendChild(exprWrapper);
  container.appendChild(varDef);

  // 5) Seed the equation with a blank editable span
  const initialText = createEditableSpan('\u00A0');
  equationDiv.appendChild(initialText);

  // 6) Wire up all the existing handlers
  setupInteractiveElements(varDef);

  // 7) Clean up the input and focus
  nameInput.value = '';
  focusElement(initialText, 0);
}


    // --- Variable Name Editing ---
    function handleVariableNameChange(event) {
    const nameSpan = event.target; 
    const newName = nameSpan.textContent.trim(); 
    const originalName = nameSpan.dataset.previousValidName; 
    const varDef = nameSpan.closest('.variable-definition');
    
    if (!newName) { 
        alert("Variable name cannot be empty."); 
        nameSpan.textContent = originalName; 
        return; 
    }
    
    // SECURITY: Limit variable name length
    if (newName.length > 30) {
        alert("Variable name too long (max 30 characters)."); 
        nameSpan.textContent = originalName; 
        return; 
    }
    
    // SECURITY: Enhanced variable name validation
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(newName)) { 
        alert("Invalid variable name. Must start with letter/underscore, contain only letters/numbers/underscores."); 
        nameSpan.textContent = originalName; 
        return; 
    }
    
    // SECURITY: Prevent dangerous variable names
    const dangerousNames = [
        '__proto__', 'constructor', 'prototype', 'hasOwnProperty',
        'toString', 'valueOf', 'eval', 'Function', 'Object',
        'window', 'document', 'location', 'alert', 'confirm'
    ];
    
    if (dangerousNames.includes(newName.toLowerCase())) {
        alert(`Security Error: "${newName}" is not allowed as a variable name.`);
        nameSpan.textContent = originalName;
        return;
    }
    
    // SECURITY: Limit variable name length
    if (newName.length > 50) {
        alert("Variable name too long (max 50 characters).");
        nameSpan.textContent = originalName;
        return;
    }
    
    const existingNames = getAllVariableNames(varDef);
    if (existingNames.includes(newName)) { 
        alert(`Variable name "${newName}" already exists.`); 
        nameSpan.textContent = originalName; 
        return; 
    }
    
    nameSpan.dataset.previousValidName = newName;
}

// SECURITY: Sanitize context object to prevent prototype pollution
function sanitizeContext(context) {
    if (!context || typeof context !== 'object') {
        return {};
    }
    
    const sanitized = {};
    const dangerousKeys = [
        '__proto__', 'constructor', 'prototype', 'hasOwnProperty',
        'toString', 'valueOf', '__defineGetter__', '__defineSetter__',
        '__lookupGetter__', '__lookupSetter__', 'isPrototypeOf',
        'propertyIsEnumerable'
    ];
    
    for (const key of Object.keys(context)) {
        // Skip dangerous keys
        if (dangerousKeys.includes(key.toLowerCase())) {
            console.warn(`Security: Skipped dangerous key in context: ${key}`);
            continue;
        }
        
        // Skip functions
      // Allow only your __compute… helpers, skip all other functions
// Allow only your __compute… helpers, skip all other functions
if (typeof context[key] === 'function') {
  if (key.startsWith('__compute')) {
    sanitized[key] = context[key];
  } else {
    console.warn(`Security: Skipped function in context: ${key}`);
  }
  continue;
}

        
        // Only copy safe values
        if (Object.prototype.hasOwnProperty.call(context, key)) {
            sanitized[key] = context[key];
        }
    }
    
    return sanitized;
}
    function handleVariableNameKeydown(event) { /* ... (unchanged) ... */
        const nameSpan = event.target;
        if (event.key === 'Enter') { event.preventDefault(); nameSpan.blur(); }
        else if (event.key === 'Escape') { nameSpan.textContent = nameSpan.dataset.previousValidName; nameSpan.blur(); }
    }
    function getAllVariableNames(excludeElement = null) { /* ... (unchanged) ... */
        const container = document.getElementById('variable-definitions');
        return [...container.querySelectorAll('.variable-definition')]
            .filter(def => def !== excludeElement)
            .map(def => def.querySelector('.variable-name[contenteditable="true"]')?.textContent.trim())
            .filter(name => name);
    }

    // --- Config Panel Logic ---
    function toggleBlockConfig(block) { /* ... (unchanged) ... */
        const currentlyActive = block.classList.contains('active'); const otherActiveBlock = document.querySelector('.building-block.active');
        if (otherActiveBlock && otherActiveBlock !== block) { handleConfigCancel(otherActiveBlock); }
        if (currentlyActive) { block.querySelector('.block-config input, .block-config select, .block-config textarea')?.focus(); return; }
        storeInitialConfig(block); block.classList.add('active'); block.focus();
        block.querySelector('.block-config input, .block-config select, .block-config textarea')?.focus(); // Focus first input/textarea
    }
    function storeInitialConfig(block) { /* ... (unchanged) ... */
        const config = block.querySelector('.block-config'); if (!config) return;
        config.querySelectorAll('[data-config-key]').forEach(input => { const key = input.dataset.configKey; if (key) { const storeKey = `initial${key.charAt(0).toUpperCase() + key.slice(1)}`; block.dataset[storeKey] = (input.type === 'checkbox') ? input.checked : input.value; } });
    }
    function restoreInitialConfig(block) { /* ... (unchanged) ... */
        const config = block.querySelector('.block-config'); if (!config) return;
        config.querySelectorAll('[data-config-key]').forEach(input => { const key = input.dataset.configKey; if (key) { const storeKey = `initial${key.charAt(0).toUpperCase() + key.slice(1)}`; const initialValue = block.dataset[storeKey]; if (initialValue !== undefined) { if (input.type === 'checkbox') { input.checked = (initialValue === 'true'); } else { input.value = initialValue; } } } });
    }
    function handleConfigOk(block) { /* ... (unchanged) ... */ block.classList.remove('active'); block.focus(); }
    function handleConfigCancel(block) { /* ... (unchanged) ... */ restoreInitialConfig(block); block.classList.remove('active'); block.focus(); }

    // --- Other Management ---
    function removeBlock(blockToRemove) { /* ... (unchanged) ... */
        const parent = blockToRemove.parentNode; if (!parent) return;
        const prevElement = blockToRemove.previousElementSibling; const nextElement = blockToRemove.nextElementSibling; let focusTarget = prevElement || parent;
        if (blockToRemove.classList.contains('active')) { handleConfigCancel(blockToRemove); }
        parent.removeChild(blockToRemove);
        if (prevElement && nextElement && prevElement.classList?.contains('equation-text') && prevElement.contentEditable === 'true' && nextElement.classList?.contains('equation-text') && nextElement.contentEditable === 'true') { const selection = window.getSelection(); let cursorPosition = -1; if(selection && selection.rangeCount > 0 && prevElement.contains(selection.anchorNode)) { const range = selection.getRangeAt(0).cloneRange(); range.selectNodeContents(prevElement); range.setEnd(selection.anchorNode, selection.anchorOffset); cursorPosition = range.toString().length; } prevElement.textContent += nextElement.textContent; parent.removeChild(nextElement); focusTarget = prevElement; if (cursorPosition !== -1) { focusElement(focusTarget, cursorPosition); return; }
        } else if (parent.children.length === 0 && parent.classList.contains('editable-equation')) { const newText = createEditableSpan('\u00A0'); parent.appendChild(newText); focusTarget = newText; }
        else { focusTarget = prevElement || parent.firstChild || parent; }
        if (focusTarget === parent && focusTarget.classList.contains('editable-equation')){ focusElement(focusTarget.lastChild || focusTarget, 0); }
        else { focusElement(focusTarget, focusTarget?.textContent?.length || 0); }
    }
    function deleteVariable(variableDef) { /* ... (unchanged) ... */ if (variableDef && variableDef.parentNode) { variableDef.remove(); } }

    // --- Block Creation Functions ---
        // --- Block Creation Functions ---

    // ... keep existing ...
    /**
     * Formats a math.js Fraction object for display, optionally as a mixed number.
     * @param {math.Fraction} frac The fraction object.
     * @param {boolean} [asMixed=false] Whether to format as a mixed number if possible.
     * @returns {string} The formatted fraction string.
     */
        /**
     * Formats a math.js Fraction object OR our custom UnsimplifiedMixedNumber object.
     * @param {math.Fraction | object | number | any} value The value to format.
     * @param {boolean} [forceImproper=false] If true, forces standard fractions to display as improper/proper ratio.
     * @returns {string} The formatted string.
     */
    /**
     * Formats a math.js Fraction object OR our custom UnsimplifiedMixedNumber object.
     * @param {math.Fraction | object | number | any} value The value to format.
     * @param {boolean} [forceImproper=false] If true, forces standard fractions to display as improper/proper ratio.
     * @returns {string} The formatted string.
     */


     async function safeEvaluateExpression(expr, context) {
    // SECURITY: Enhanced input validation
    if (typeof expr !== 'string') {
        throw new Error('Expression must be a string');
    }
    
    // SECURITY: Strict length limits
    const MAX_EXPR_LENGTH = 1000;
    if (expr.length > MAX_EXPR_LENGTH) {
        throw new Error(`Expression too long (max ${MAX_EXPR_LENGTH} characters)`);
    }
    
    // SECURITY: Check for dangerous patterns before parsing
    const dangerousPatterns = [
        /\b(eval|function|Function|constructor|prototype|__proto__)\b/i,
        /\$\{.*\}/,  // Template literals
        /\\x[0-9a-f]{2}/i,  // Hex escapes
        /\\u[0-9a-f]{4}/i,  // Unicode escapes
        /javascript:/i,
        /data:/i,
        /vbscript:/i,
        /<script/i,
        /on\w+\s*=/i,  // Event handlers
        /\[\s*['"]/,   // Array/object notation
        /\.\s*constructor/i,
        /import\s+/i,
        /require\s*\(/i
    ];
    
    for (const pattern of dangerousPatterns) {
        if (pattern.test(expr)) {
            throw new Error('Expression contains potentially dangerous content');
        }
    }
    
    // SECURITY: Sanitize context before use
    const sanitizedContext = sanitizeContext(context);
    
    let node;
    try {
        // Parse with timeout protection
        const parseStart = performance.now();
        node = math.parse(expr);
        const parseTime = performance.now() - parseStart;
        
        // SECURITY: Prevent slow parsing attacks
        if (parseTime > 100) { // 100ms limit
            throw new Error('Expression parsing took too long');
        }
    } catch (error) {
        throw new Error(`Invalid expression: ${error.message}`);
    }
    
    // SECURITY: Enhanced AST validation
    const MAX_AST_NODES = 50;  // Reduced from 500
    const totalNodes = countNodes(node);
    if (totalNodes > MAX_AST_NODES) {
        throw new Error(`Expression too complex (max ${MAX_AST_NODES} nodes)`);
    }
    
    // SECURITY: Stricter operator whitelist
    const allowedOps = ['+', '-', '*', '/', '^'];
    const allowedFunctions = [                  // <<< YOUR PASTED CODE STARTS HERE
      // Math.js built-ins that users might type directly:
      'abs', 'sqrt', 'cbrt', 'nthRoot', // cbrt and nthRoot might be typed
      'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'atan2',
      'log', 'log10', 'log2', 'log1p', 'exp', 'expm1',
      'pow', // Already covered by '^' operator, but good to be explicit if users type it
      'round', 'floor', 'ceil', 'fix', // Common rounding/truncation
      'gcd', 'lcm', 'mod', // Common math operations
      'min', 'max', 'mean', 'median', 'mode', 'std', 'variance', 'sum', 'prod', // Stats
      // Add any other *simple, direct math.js functions* users might type.
      // DO NOT add your __compute... functions here if users don't type them.

      // Condition‐block evaluators (these are called by your generated code):
      'evaluateConditionBlock',
      'evaluateConditionBlockById'
    ];


    let nodeCount = 0;
    
    node.traverse(n => {
        nodeCount++;
        
        // SECURITY: Prevent infinite loops in traversal
        if (nodeCount > MAX_AST_NODES) {
            throw new Error('AST traversal limit exceeded');
        }
        
        switch (n.type) {
            case 'OperatorNode':
                if (!allowedOps.includes(n.op)) {
                    throw new Error(`Operator "${n.op}" is not allowed`);
                }
                break;
                
                case 'FunctionNode':
  // allow any Math.js builtin or any helper that starts with "__compute"
  if (
    allowedFunctions.includes(n.name) ||
    n.name.startsWith('__compute')
  ) {
    break;
  }
  throw new Error(`Function "${n.name}" is not allowed`);

                
                case 'ConstantNode':
  // SECURITY: Validate constant values (number or JSON string)
  if (typeof n.value === 'number') {
    if (!isFinite(n.value)) {
      throw new Error('Invalid constant value');
    }
    if (Math.abs(n.value) > 1e15) {
      throw new Error('Constant value too large');
    }
  } else if (typeof n.value === 'string') {
    // OK: this is our embedded JSON config string
  } else {
    throw new Error('Invalid constant type');
  }
  break;

                
                case 'SymbolNode':
    // SECURITY: Enhanced symbol validation
    const symbolName = n.name;
    
    // Check if symbol exists in context
    if (!Object.prototype.hasOwnProperty.call(sanitizedContext, symbolName)) {
        throw new Error(`Unknown variable: "${symbolName}"`);
    }
    
    // Validate symbol name format
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(symbolName)) {
        throw new Error(`Invalid variable name format: "${symbolName}"`);
    }
    
    // Allow functions (your __compute… helpers)
    const value = sanitizedContext[symbolName];
    if (typeof value === 'function') {
        break;
    }
    
    // Otherwise only allow numbers or fraction/mixed-number objects
    const isValidType = (
        typeof value === 'number' ||
        (value && typeof value === 'object' && value.isFraction) ||
        (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber')
    );
    if (!isValidType) {
        throw new Error(`Invalid variable type: "${symbolName}"`);
    }
    break;

                
            case 'ParenthesisNode':
                // OK, but validate content
                break;
                
            default:
                throw new Error(`Unsupported AST node type: ${n.type}`);
        }
    });
    
    // SECURITY: Evaluate with timeout and error handling
// SECURITY: Evaluate with timeout and error handling
let result;
    let timeoutId;
    
    try {
        // Create a promise that rejects after timeout
        const timeoutPromise = new Promise((_, reject) => {
            timeoutId = setTimeout(() => {
                reject(new Error('Expression evaluation timeout (200ms limit exceeded)'));
            }, 200);
        });
        
        // Create evaluation promise
        const evalPromise = new Promise((resolve) => {
            const evalStart = performance.now();
            const evalResult = node.evaluate(sanitizedContext);
            const evalTime = performance.now() - evalStart;
            
            // SECURITY: Check evaluation time
            if (evalTime > 200) {
                throw new Error('Expression evaluation took too long');
            }
            
            resolve(evalResult);
        });
        
        // Race between evaluation and timeout
        result = await Promise.race([evalPromise, timeoutPromise]);
        clearTimeout(timeoutId);
        
    } catch (error) {
        clearTimeout(timeoutId);
        throw new Error(`Evaluation failed: ${error.message}`);
    }
    
    return result;
}

     // Function to evaluate fraction expressions
// Function to evaluate fraction expressions




function __evaluateFractionExpression(expr, context) {
  try {
    // Use our safe parser instead of math.evaluate
    const result = safeEvaluateExpression(expr, context);

    // If it’s a plain number, convert to a Fraction
    if (typeof result === 'number') {
      try {
        return math.fraction(result);
      } catch (e) {
        return result;
      }
    }
    return result;
  } catch (err) {
    console.error('Expression evaluation error:', err);
    return NaN;  // or however you want to signal a bad expression
  }
}

   // Helper function to count decimal places in a number
function countDecimals(value) {
    if (Math.floor(value) === value) return 0;
    const str = value.toString();
    if (str.includes('e')) return 0; // Scientific notation - too complex
    if (!str.includes('.')) return 0;
    return str.split('.')[1].length;
}

// Helper function to format a math.Fraction as a mixed number
function formatMixedNumberOutput(frac) {
    if (!frac || !frac.isFraction) return "Invalid fraction";
    
    const n = frac.n * frac.s; // Numerator with sign
    const d = frac.d;          // Denominator
    
    if (d === 1) return String(n); // Whole number
    
    if (Math.abs(n) >= d) {
        const wholePart = Math.trunc(n / d);
        const remainderNum = Math.abs(n % d);
        if (remainderNum === 0) return String(wholePart);
        return `${wholePart} ${remainderNum}/${d}`;
    } else {
        return `${n}/${d}`; // Proper fraction
    }
}


// Helper function to format a decimal number
function formatDecimalOutput(value) {
    // Format to a maximum of 9 decimal places for irrational numbers
    if (!Number.isInteger(value)) {
        return value.toFixed(9).replace(/\.?0+$/, '');
    }
    return String(value);
}
   
// Enhanced formatFraction function to handle UnsimplifiedFraction objects
function formatFraction(value, forceImproper = false) {
    // --- Check for our Custom Unsimplified Fraction Object FIRST ---
    if (value && typeof value === 'object' && value.type === 'UnsimplifiedFraction') {
        const { numerator, denominator } = value;
        if (isNaN(numerator) || isNaN(denominator) || denominator <= 0) return "Invalid Input";
        
        // Always display as the original fraction
        return `${numerator}/${denominator}`;
    }

    // --- Check for our Custom Unsimplified Mixed Number Object ---
    if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
        const { whole, num, den } = value;
        if (isNaN(whole) || isNaN(num) || isNaN(den) || den <= 0) return "Invalid Input";
        if (whole !== 0 && num !== 0) return `${whole} ${num}/${den}`;
        else if (whole === 0 && num !== 0) return `${num}/${den}`;
        else if (num === 0) return String(whole);
        else return `${whole} ${num}/${den}`; // Fallback
    }

    // --- If not custom object, proceed with standard Fraction formatting ---
    if (value && typeof value === 'object' && value.isFraction) {
        const frac = value; const n = frac.n * frac.s; const d = frac.d;
        if (d === 1) return String(n); // Whole number

        // --- DEFAULT: Format as Mixed Number if applicable ---
        if (!forceImproper && Math.abs(n) >= d) {
            const wholePart = Math.trunc(n / d);
            const remainderNum = Math.abs(n % d);
            if (remainderNum === 0) return String(wholePart);
            else return `${wholePart} ${remainderNum}/${d}`; // Mixed format
        } else {
             // --- Format as Improper/Proper ratio ---
             return math.format(frac, { fraction: 'ratio' });
        }
    }

    // --- Fallback for other types ---
    if (typeof value === 'number') {
        if (!isFinite(value)) return "NaN";
        if (Math.abs(value - Math.round(value)) > 1e-9 && Math.abs(value) < 1e10) {
            return Number(value.toFixed(4)).toString();
        }
         return String(Math.round(value * 1e10) / 1e10);
    }
    return String(value);
}

// Helper function to create element from HTML string
/**
 * Safely convert a (small) chunk of HTML into a DOM node.
 * We sanitize **before** ever touching .innerHTML.
 */
 function createElementFromHTML(htmlString) {
  // 1) Sanitize user content immediately
  const clean = DOMPurify.sanitize(htmlString, {
    // only allow these tags/attributes—tweak to your needs
    ALLOWED_TAGS: ['div','span','p','b','i','u','ul','ol','li','br','sup','sub'],
    ALLOWED_ATTR: ['id','class','data-*']
  });

  // 2) Use a template (no direct user innerHTML elsewhere)
  const template = document.createElement('template');
  template.innerHTML = clean.trim();
  return template.content.firstChild;
}


function createAddPolynomialsBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block add-polynomials';
    newBlock.style.backgroundColor = '#e3f2fd'; // Light blue
    newBlock.style.borderColor = '#42a5f5'; // Darker blue
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Add Polynomials'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-add-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="poly1-${uniqueIdBase}">First Polynomial:</label>
        <input type="text" id="poly1-${uniqueIdBase}" placeholder="e.g., x+y or (x+1)" data-config-key="poly1">
        
        <label for="poly2-${uniqueIdBase}">Second Polynomial:</label>
        <input type="text" id="poly2-${uniqueIdBase}" placeholder="e.g., x-y or (2x+3)" data-config-key="poly2">
        
        <div style="margin-top: 8px; font-size: 12px; color: #555;">
            <p><strong>Format Tips:</strong></p>
            <ul style="margin-top: 4px; padding-left: 20px;">
                <li>Use x and y as variables</li>
                <li>Use ^ for exponents (e.g., x^2)</li>
                <li>Use * for multiplication (e.g., 2*x or x*y)</li>
                <li>Examples: x+y, (x+1), 2x^2-3y+1</li>
            </ul>
        </div>
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createMultiplyPolynomialsBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block multiply-polynomials';
    newBlock.style.backgroundColor = '#e8f5e9'; // Light green
    newBlock.style.borderColor = '#66bb6a'; // Darker green
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Multiply Polynomials'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-mult-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
setSafeInnerHTML(config, `
  <label for="poly1-${uniqueIdBase}">First Polynomial:</label>
        <input type="text" id="poly1-${uniqueIdBase}" placeholder="e.g., x+y or (x+1)" data-config-key="poly1">
        
        <label for="poly2-${uniqueIdBase}">Second Polynomial:</label>
        <input type="text" id="poly2-${uniqueIdBase}" placeholder="e.g., x-y or (2x+3)" data-config-key="poly2">
        
        <div style="margin-top: 8px; font-size: 12px; color: #555;">
            <p><strong>Format Tips:</strong></p>
            <ul style="margin-top: 4px; padding-left: 20px;">
                <li>Use x and y as variables</li>
                <li>Use ^ for exponents (e.g., x^2)</li>
                <li>Use * for multiplication (e.g., 2*x or x*y)</li>
                <li>Examples: x+y, (x+1), 2x^2-3y+1</li>
            </ul>
        </div>
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}



function createPolynomialZerosBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block polynomial-zeros';
    newBlock.style.backgroundColor = '#e6ffee';
    newBlock.style.borderColor = '#52c41a';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Zeros of Polynomial'));

    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);

    const config = document.createElement('div');
    config.className = 'block-config';
    const id = `pz-${Date.now()}-${Math.random().toString(36).substr(2,5)}`;

    setSafeInnerHTML(config, `
      <label for="coeffs-${id}">Polynomial Coefficients (comma-separated):</label>
      <textarea id="coeffs-${id}" rows="2"
        placeholder="e.g. 1,0,-4 for x²−4"
        data-config-key="coeffs"></textarea>

      <label for="rootVar-${id}" style="margin-top:8px;">
        Store individual roots as variable prefix:
      </label>
      <input type="text" id="rootVar-${id}"
             placeholder="e.g. r"
             data-config-key="rootVar">
      <small style="display:block;color:#666;">
        Roots will be assigned to <em>r1</em>, <em>r2</em>, etc.
      </small>

      <div class="block-config-actions">
        <button type="button" class="cancel-btn">Cancel</button>
        <button type="button" class="ok-btn">OK</button>
      </div>
    `);
    newBlock.appendChild(config);
    return newBlock;
}



function createSyntheticDivisionBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block synthetic-division';
    newBlock.style.backgroundColor = '#ffecb3';
    newBlock.style.borderColor = '#ffd54f';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Synthetic Division'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `syndiv-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="coeffs-${uniqueIdBase}">Polynomial Coefficients (comma-separated):</label>
        <textarea id="coeffs-${uniqueIdBase}" rows="2" 
                  placeholder="e.g., 1,3,-4,2 for x³+3x²-4x+2" 
                  data-config-key="coeffs"></textarea>
        <small style="display: block; color: #666; margin-bottom: 8px;">List from highest to lowest power. Max degree: 100</small>
        
        <label for="root-${uniqueIdBase}">Value r (divide by x-r):</label>
        <input type="text" id="root-${uniqueIdBase}" placeholder="e.g., 2 for (x-2)" data-config-key="root">
        <small style="display: block; color: #666; margin-bottom: 8px;">Remember: for (x+2), enter -2</small>
        
        <label for="var-${uniqueIdBase}">Variable name (optional):</label>
        <input type="text" id="var-${uniqueIdBase}" placeholder="e.g., x (default)" value="x" maxlength="10" data-config-key="variable">
        <small style="display: block; color: #666; margin-bottom: 8px;">Single letter recommended, max 10 chars</small>
        
        <div style="background-color: #e6f7ff; padding: 8px; border-radius: 4px; margin: 10px 0; border-left: 3px solid #1890ff;">
            <label for="quotient-var-${uniqueIdBase}">Store Quotient in Variable:</label>
            <input type="text" id="quotient-var-${uniqueIdBase}" placeholder="e.g., q" pattern="[a-zA-Z_][a-zA-Z0-9_]*" data-config-key="quotientVar">
            <small style="display: block; margin-bottom: 5px;">Example: If you enter "q", you can use "q" in other blocks</small>

            <label for="remainder-var-${uniqueIdBase}">Store Remainder in Variable:</label>
            <input type="text" id="remainder-var-${uniqueIdBase}" placeholder="e.g., r" pattern="[a-zA-Z_][a-zA-Z0-9_]*" data-config-key="remainderVar">
            <small style="display: block; margin-bottom: 5px;">Example: If you enter "r", you can use "r" in other blocks</small>
            
            <div style="color: #d4380d; font-size: 11px; margin-top: 5px;">
                ⚠️ Variable names must start with a letter or underscore, and contain only letters, numbers, and underscores.
            </div>
        </div>
        
        <div style="margin-top: 8px; font-size: 12px; color: #333; background-color: #f0f0f0; padding: 6px; border-radius: 4px;">
            <strong>Synthetic Division:</strong><br>
            Divides P(x) by (x-r) to get Q(x) with remainder R<br>
            P(x) = Q(x)(x-r) + R<br>
            Example: (x²+3x+2) ÷ (x-2) = (x+5) + 12/(x-2)
        </div>
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    
    // Add client-side validation for variable names
    setTimeout(() => {
        const quotientVarInput = config.querySelector(`#quotient-var-${uniqueIdBase}`);
        const remainderVarInput = config.querySelector(`#remainder-var-${uniqueIdBase}`);
        
        if (quotientVarInput) {
            quotientVarInput.addEventListener('input', function() {
                validateVarInput(this);
            });
        }
        
        if (remainderVarInput) {
            remainderVarInput.addEventListener('input', function() {
                validateVarInput(this);
            });
        }
        
        function validateVarInput(input) {
            const value = input.value.trim();
            if (value === '') {
                input.setCustomValidity('');
                return;
            }
            
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)) {
                input.setCustomValidity('Invalid variable name. Must start with a letter or underscore, and contain only letters, numbers, and underscores.');
            } else {
                input.setCustomValidity('');
            }
        }
    }, 0);
    
    return newBlock;
}


function createPermutationBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block permutation';
    newBlock.style.backgroundColor = '#e3f2fd';
    newBlock.style.borderColor = '#42a5f5';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Permutation'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `perm-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="n-${uniqueIdBase}">n (total items):</label>
        <input type="text" id="n-${uniqueIdBase}" placeholder="e.g., 5 or var_n" data-config-key="n">
        <label for="r-${uniqueIdBase}">r (items to select):</label>
        <input type="text" id="r-${uniqueIdBase}" placeholder="e.g., 2 or var_r" data-config-key="r">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createCombinationBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block combination';
    newBlock.style.backgroundColor = '#e1f5fe';
    newBlock.style.borderColor = '#4fc3f7';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Combination'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `comb-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="n-${uniqueIdBase}">n (total items):</label>
        <input type="text" id="n-${uniqueIdBase}" placeholder="e.g., 5 or var_n" data-config-key="n">
        <label for="r-${uniqueIdBase}">r (items to select):</label>
        <input type="text" id="r-${uniqueIdBase}" placeholder="e.g., 2 or var_r" data-config-key="r">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPythTripleMultiplesBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block pyth-triple-multiples';
    newBlock.style.backgroundColor = '#e6f7ff';
    newBlock.style.borderColor = '#91d5ff';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Pyth Triple Multiples'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `pyth-multi-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    // Common Pythagorean triples
    const commonTriples = [
        [3, 4, 5],
        [5, 12, 13],
        [8, 15, 17],
        [7, 24, 25],
        [20, 21, 29],
        [12, 35, 37],
        [9, 40, 41],
        [28, 45, 53]
    ];
    
    // Create checkboxes for each triple
    let checkboxHtml = '<div style="margin-bottom: 10px;"><label>Select triples:</label><div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; margin-top: 5px;">';
    
    commonTriples.forEach((triple, index) => {
        const id = `triple-${index}-${uniqueIdBase}`;
        checkboxHtml += `
            <div>
                <input type="checkbox" id="${id}" value="${triple.join('-')}" 
                       data-config-key="triple${index}" ${index < 3 ? 'checked' : ''}>
                <label for="${id}">${triple[0]}-${triple[1]}-${triple[2]}</label>
            </div>`;
    });
    
    checkboxHtml += '</div></div>';
    
    // Factor range inputs
    const factorRangeHtml = `
        <div style="margin-bottom: 10px;">
            <label>Factor range:</label>
            <div style="display: flex; gap: 10px; margin-top: 5px;">
                <div style="flex: 1;">
                    <label for="min-factor-${uniqueIdBase}" style="font-size: 12px;">Min:</label>
                    <input type="number" id="min-factor-${uniqueIdBase}" 
                           data-config-key="minFactor" value="1" min="-100" max="100" style="width: 100%;">
                </div>
                <div style="flex: 1;">
                    <label for="max-factor-${uniqueIdBase}" style="font-size: 12px;">Max:</label>
                    <input type="number" id="max-factor-${uniqueIdBase}" 
                           data-config-key="maxFactor" value="5" min="-100" max="100" style="width: 100%;">
                </div>
            </div>
        </div>`;
    
    // Build the complete config panel
    setSafeInnerHTML(config, `
        ${checkboxHtml}
        ${factorRangeHtml}
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPythagoreanTripleBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block pythagorean-triple';
    newBlock.style.backgroundColor = '#e6f7ff';
    newBlock.style.borderColor = '#91d5ff';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Pythagorean Triple'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `pyth-triple-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="exclude-${uniqueIdBase}">Exclude (comma separated):</label>
        <input type="text" id="exclude-${uniqueIdBase}" placeholder="e.g., 3-4-5, 5-12-13" data-config-key="exclude">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createBlankBlock() {
  const b = document.createElement('div');
  b.className = 'building-block blank';
  b.style.backgroundColor = '#f5f5f5';
  b.style.borderColor   = '#cccccc';
  b.tabIndex = 0;
  b.appendChild(document.createTextNode('Blank'));
  b.appendChild(makeRemoveBtn());

  // — hint panel —
  const cfg = document.createElement('div');
  cfg.className = 'block-config';
  setSafeInnerHTML(cfg,`
    <div style="padding:4px; font-size:12px; color:#333;">
      <strong>Blank:</strong> Leaves this variable blank (erases it).
    </div>
    <div class="block-config-actions">
      <button type="button" class="cancel-btn">Cancel</button>
      <button type="button" class="ok-btn">OK</button>
    </div>`);
  b.appendChild(cfg);

  return b;
}

function createUndefinedBlock() {
  const b = document.createElement('div');
  b.className = 'building-block undefined';
  b.style.backgroundColor = '#eceff1';
  b.style.borderColor   = '#b0bec5';
  b.tabIndex = 0;
  b.appendChild(document.createTextNode('Undefined'));
  b.appendChild(makeRemoveBtn());

  // — hint panel —
  const cfg = document.createElement('div');
  cfg.className = 'block-config';
  setSafeInnerHTML(cfg, `
    <div style="padding:4px; font-size:12px; color:#333;">
      <strong>Undefined:</strong> Displays this variable as “undefined”.
    </div>
    <div class="block-config-actions">
      <button type="button" class="cancel-btn">Cancel</button>
      <button type="button" class="ok-btn">OK</button>
    </div>`);
  b.appendChild(cfg);

  return b;
}


/* ---------- Choose Text ---------- */
function createChooseTextBlock() {
  const b = document.createElement('div');
  b.className = 'building-block choose-text';
  b.style.backgroundColor = '#fff0e6';
  b.style.borderColor   = '#ffc099';
  b.tabIndex = 0;
  b.appendChild(document.createTextNode('Choose Text'));

  b.appendChild(makeRemoveBtn());

  const cfg = document.createElement('div');
  cfg.className = 'block-config';
  setSafeInnerHTML(cfg, `
   <label>Items (comma‑separated):</label>
<textarea rows="2" data-config-key="items"
          placeholder="Kids at the #place#, Dogs at the park"></textarea>

<label>Exclude (comma‑separated):</label>
<textarea rows="2" data-config-key="exclude"
          placeholder="#a#,Dogs"></textarea>

     <div class="block-config-actions">
        <button type="button" class="cancel-btn">Cancel</button>
        <button type="button" class="ok-btn">OK</button>
     </div>`);
  b.appendChild(cfg);
  return b;
}

/* ---------- Choose Alg Expression ---------- */
function createChooseExprBlock() {
  const b = document.createElement('div');
  b.className = 'building-block choose-expr';
  b.style.backgroundColor = '#e6f7ff';
  b.style.borderColor   = '#b3e0ff';
  b.tabIndex = 0;
  b.appendChild(document.createTextNode('Choose Expr'));

  b.appendChild(makeRemoveBtn());

  const cfg = document.createElement('div');
  cfg.className = 'block-config';
  setSafeInnerHTML(cfg, `
   <label>Expressions (comma‑separated):</label>
   <textarea rows="2" data-config-key="items"
             placeholder="sqrt(4), #a#x^2, x+5"></textarea>

   <label>Exclude (comma‑separated):</label>
   <textarea rows="2" data-config-key="exclude"
             placeholder="#a#,x^2"></textarea>

   <div class="block-config-actions">
      <button type="button" class="cancel-btn">Cancel</button>
      <button type="button" class="ok-btn">OK</button>
   </div>`);
  b.appendChild(cfg);
  return b;
}

/* ---------- Choose Number ---------- */
function createChooseNumBlock() {
  const b = document.createElement('div');
  b.className = 'building-block choose-num';
  b.style.backgroundColor = '#e6ffea';
  b.style.borderColor   = '#b3ffc6';
  b.tabIndex = 0;
  b.appendChild(document.createTextNode('Choose Number'));

  b.appendChild(makeRemoveBtn());

  const cfg = document.createElement('div');
  cfg.className = 'block-config';
  setSafeInnerHTML(cfg, `
     <label>Numbers (comma‑separated):</label>
     <input type="text" data-config-key="items" placeholder="2,4,6,#b#">
     <div class="block-config-actions">
        <button type="button" class="cancel-btn">Cancel</button>
        <button type="button" class="ok-btn">OK</button>
     </div>`);
  b.appendChild(cfg);
  return b;
}

/* helper for the “×” button */
function makeRemoveBtn(){
  const x = document.createElement('span');
  x.className = 'block-remove';
  x.textContent = '×';
  return x;
}



/* ---------- Text block ---------- */
function createTextBlock() {
  const block = document.createElement('div');
  block.className = 'building-block text-block';
  block.style.backgroundColor = '#fffbe6';
  block.style.borderColor   = '#ffd866';
  block.tabIndex = 0;
  block.appendChild(document.createTextNode('Text'));

  const close = document.createElement('span');
  close.className  = 'block-remove';
  close.textContent = '×';
  block.appendChild(close);

  const cfg = document.createElement('div');
  cfg.className = 'block-config';
  const uid = `text-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;

  setSafeInnerHTML(cfg, `
    <label for="val-${uid}">Text (keeps spaces):</label>
    <textarea id="val-${uid}" rows="2"
              placeholder="The cat is red"
              data-config-key="value"
              maxlength="200"></textarea>
    <small style="display:block;color:#666;">Max 200 characters</small>
    <div class="block-config-actions">
      <button type="button" class="cancel-btn">Cancel</button>
      <button type="button" class="ok-btn">OK</button>
    </div>`);
  block.appendChild(cfg);
  return block;
}


// Function to add an else-if block to a condition container
function addElseIfBlock(container) {
  // Find the parent if-block to ensure we don't add multiple else blocks
  const parentBlock = container.closest('.condition-block');
  
  // Create the elseif header
  const elseifHeader = document.createElement('div');
  elseifHeader.className = 'condition-row elseif-header';
  
  const elseifType = document.createElement('span');
  elseifType.className = 'condition-type';
  elseifType.textContent = 'else if';
  
  const leftInput = document.createElement('input');
  leftInput.type = 'text';
  leftInput.className = 'condition-input left-input';
  leftInput.placeholder = 'var or expr';
  
  const operatorSelect = document.createElement('select');
  operatorSelect.className = 'condition-operator';
  
  const operators = [
    { value: '==', text: '=' },
    { value: '!=', text: '≠' },
    { value: '>', text: '>' },
    { value: '<', text: '<' },
    { value: '>=', text: '≥' },
    { value: '<=', text: '≤' }
  ];
  
  operators.forEach(op => {
    const option = document.createElement('option');
    option.value = op.value;
    option.textContent = op.text;
    operatorSelect.appendChild(option);
  });
  
  const rightInput = document.createElement('input');
  rightInput.type = 'text';
  rightInput.className = 'condition-input right-input';
  rightInput.placeholder = 'value';
  
  // Create action div for elseif
  const actionDiv = document.createElement('div');
  actionDiv.className = 'condition-actions';

  const addAndBtn = document.createElement('button');
  addAndBtn.className = 'add-and-btn';
  addAndBtn.textContent = '+ AND';
  addAndBtn.onclick = (e) => {
    e.stopPropagation();
    addAndCondition(elseifHeader);
  };

  const addOrBtn = document.createElement('button');
  addOrBtn.className = 'add-or-btn';
  addOrBtn.textContent = '+ OR';
  addOrBtn.onclick = (e) => {
    e.stopPropagation();
    addOrCondition(elseifHeader);
  };

  actionDiv.appendChild(addAndBtn);
  actionDiv.appendChild(addOrBtn);
  
  const removeBtn = document.createElement('span');
  removeBtn.className = 'condition-remove';
  removeBtn.textContent = '×';
  removeBtn.onclick = (e) => {
    e.stopPropagation();
    elseifBlock.remove();
  };
  
  // Create the elseif container
  const elseifContainer = document.createElement('div');
  elseifContainer.className = 'condition-container elseif-container';
  
  // Create the "then" equation area
  const thenLabel = document.createElement('div');
  thenLabel.className = 'condition-row';
  thenLabel.innerHTML = '<span style="margin-left: 5px; color: #666;">then:</span>';
  
  const thenEquation = document.createElement('div');
  thenEquation.className = 'editable-equation';
  const initialText = createEditableSpan('\u00A0');
  thenEquation.appendChild(initialText);
  
  // Assemble the elseif block
  elseifHeader.appendChild(elseifType);
  elseifHeader.appendChild(leftInput);
  elseifHeader.appendChild(operatorSelect);
  elseifHeader.appendChild(rightInput);
  elseifHeader.appendChild(actionDiv);
  elseifHeader.appendChild(removeBtn);
  
  const elseifBlock = document.createElement('div');
  elseifBlock.className = 'elseif-block';
  elseifBlock.appendChild(elseifHeader);
  elseifBlock.appendChild(elseifContainer);
  
  elseifContainer.appendChild(thenLabel);
  elseifContainer.appendChild(thenEquation);
  
  // Add after any existing else-if blocks but before any else block
  const elseBlock = Array.from(container.children).find(child => 
    child.classList.contains('else-block') || 
    child.querySelector('.else-header')
  );
  
  if (elseBlock) {
    container.insertBefore(elseifBlock, elseBlock);
  } else {
    container.appendChild(elseifBlock);
  }
  
  // Setup editable areas within the new elseif block
  setupInteractiveElements(elseifBlock);
}

function addElseIfSection(wrapper) {
  // First check if there's already an else block
  const existingElse = wrapper.querySelector('.else-section');
  
  const elseIfSection = document.createElement('div');
  elseIfSection.className = 'condition-section elseif-section';
  
  // Create the elseif header
  const elseIfHeader = document.createElement('div');
  elseIfHeader.className = 'condition-row elseif-header';
  
  const elseIfType = document.createElement('span');
  elseIfType.className = 'condition-type';
  elseIfType.textContent = 'else if';
  
  const leftInput = document.createElement('input');
  leftInput.type = 'text';
  leftInput.className = 'condition-input left-input';
  leftInput.placeholder = 'var or expr';
  
  const operatorSelect = document.createElement('select');
  operatorSelect.className = 'condition-operator';
  
  const operators = [
    { value: '==', text: '=' },
    { value: '!=', text: '≠' },
    { value: '>', text: '>' },
    { value: '<', text: '<' },
    { value: '>=', text: '≥' },
    { value: '<=', text: '≤' }
  ];
  
  operators.forEach(op => {
    const option = document.createElement('option');
    option.value = op.value;
    option.textContent = op.text;
    operatorSelect.appendChild(option);
  });
  
  const rightInput = document.createElement('input');
  rightInput.type = 'text';
  rightInput.className = 'condition-input right-input';
  rightInput.placeholder = 'value';
  
  // Action buttons for else-if
  const actionDiv = document.createElement('div');
  actionDiv.className = 'condition-actions';
  
  const addAndBtn = document.createElement('button');
  addAndBtn.className = 'add-and-btn';
  addAndBtn.textContent = '+ AND';
  addAndBtn.onclick = (e) => {
    e.stopPropagation();
    addAndCondition(elseIfHeader);
  };
  
  const addOrBtn = document.createElement('button');
  addOrBtn.className = 'add-or-btn';
  addOrBtn.textContent = '+ OR';
  addOrBtn.onclick = (e) => {
    e.stopPropagation();
    addOrCondition(elseIfHeader);
  };
  
  actionDiv.appendChild(addAndBtn);
  actionDiv.appendChild(addOrBtn);
  
  const removeBtn = document.createElement('span');
  removeBtn.className = 'condition-remove';
  removeBtn.textContent = '×';
  removeBtn.onclick = (e) => {
    e.stopPropagation();
    elseIfSection.remove();
  };
  
  // Create the elseif "then" container
  const elseIfContainer = document.createElement('div');
  elseIfContainer.className = 'condition-container elseif-container';
  
  // Create the "then" label
  const thenLabel = document.createElement('div');
  thenLabel.className = 'condition-row';
  thenLabel.innerHTML = '<span style="margin-left: 5px; color: #666;">then:</span>';
  
  // Create the editable equation area
  const thenEquation = document.createElement('div');
  thenEquation.className = 'editable-equation';
  const initialText = createEditableSpan('\u00A0');
  thenEquation.appendChild(initialText);
  
  // Assemble the elseif section
  elseIfHeader.appendChild(elseIfType);
  elseIfHeader.appendChild(leftInput);
  elseIfHeader.appendChild(operatorSelect);
  elseIfHeader.appendChild(rightInput);
  elseIfHeader.appendChild(actionDiv);
  elseIfHeader.appendChild(removeBtn);
  
  elseIfSection.appendChild(elseIfHeader);
  elseIfSection.appendChild(elseIfContainer);
  
  elseIfContainer.appendChild(thenLabel);
  elseIfContainer.appendChild(thenEquation);
  
  // Insert before the else block if it exists
  if (existingElse) {
    wrapper.insertBefore(elseIfSection, existingElse);
  } else {
    wrapper.appendChild(elseIfSection);
  }
  
  // Initialize any interactive elements
  setupInteractiveElements(elseIfSection);
}

// Function to add else section
function addElseSection(wrapper) {
  // Check if there's already an else block
  if (wrapper.querySelector('.else-section')) {
    alert('Only one else block is allowed per condition');
    return;
  }
  
  const elseSection = document.createElement('div');
  elseSection.className = 'condition-section else-section';
  
  // Create the else header
  const elseHeader = document.createElement('div');
  elseHeader.className = 'condition-row else-header';
  
  const elseType = document.createElement('span');
  elseType.className = 'condition-type';
  elseType.textContent = 'else';
  
  const removeBtn = document.createElement('span');
  removeBtn.className = 'condition-remove';
  removeBtn.textContent = '×';
  removeBtn.onclick = (e) => {
    e.stopPropagation();
    elseSection.remove();
  };
  
  // Create the else container
  const elseContainer = document.createElement('div');
  elseContainer.className = 'condition-container else-container';
  
  // Create the editable equation area
  const elseEquation = document.createElement('div');
  elseEquation.className = 'editable-equation';
  const initialText = createEditableSpan('\u00A0');
  elseEquation.appendChild(initialText);
  
  // Assemble the else section
  elseHeader.appendChild(elseType);
  elseHeader.appendChild(removeBtn);
  
  elseSection.appendChild(elseHeader);
  elseSection.appendChild(elseContainer);
  
  elseContainer.appendChild(elseEquation);
  
  // Add to the wrapper
  wrapper.appendChild(elseSection);
  
  // Initialize any interactive elements
  setupInteractiveElements(elseSection);
}

// Function to add an else block to a condition container
function addElseBlock(container) {
  // Find the parent if-block to ensure we don't add multiple else blocks
  const parentBlock = container.closest('.condition-block');
  
  // Check if an else block already exists
  const existingElse = container.querySelector('.else-block, .else-header');
  if (existingElse) {
    alert('Only one else block is allowed per if statement');
    return;
  }
  
  // Create the else header
  const elseHeader = document.createElement('div');
  elseHeader.className = 'condition-row else-header';
  
  const elseType = document.createElement('span');
  elseType.className = 'condition-type';
  elseType.textContent = 'else';
  
  const removeBtn = document.createElement('span');
  removeBtn.className = 'condition-remove';
  removeBtn.textContent = '×';
  removeBtn.onclick = (e) => {
    e.stopPropagation();
    elseBlock.remove();
  };
  
  // Create the else container
  const elseContainer = document.createElement('div');
  elseContainer.className = 'condition-container else-container';
  
  // Create the equation area for the else block
  const elseEquation = document.createElement('div');
  elseEquation.className = 'editable-equation';
  const initialText = createEditableSpan('\u00A0');
  elseEquation.appendChild(initialText);
  
  // Assemble the else block
  elseHeader.appendChild(elseType);
  elseHeader.appendChild(removeBtn);
  
  const elseBlock = document.createElement('div');
  elseBlock.className = 'else-block';
  elseBlock.appendChild(elseHeader);
  elseBlock.appendChild(elseContainer);
  
  elseContainer.appendChild(elseEquation);
  
  // Add at the end of the container
  container.appendChild(elseBlock);
  
  // Setup editable areas within the new else block
  setupInteractiveElements(elseBlock);
}
function addAndCondition(header) {
  // create the row and its contents (including the operator dropdown)
  const andRow = document.createElement('div');
  andRow.className = 'condition-row and-condition';
  andRow.innerHTML = `
    <span class="condition-logical">AND</span>
    <input type="text" class="condition-input left-input" placeholder="var or expr">
    <select class="condition-operator">
      <option value="==">=</option>
      <option value="!=">≠</option>
      <option value=">">></option>
      <option value="<"><</option>
      <option value=">=">≥</option>
      <option value="<=">≤</option>
    </select>
    <input type="text" class="condition-input right-input" placeholder="value">
    <span class="condition-remove">×</span>
  `;

  // hook up the remove “×”
  andRow.querySelector('.condition-remove').onclick = e => {
    e.stopPropagation();
    andRow.remove();
  };

  // insert immediately after the header element
  header.insertAdjacentElement('afterend', andRow);
}

function addOrCondition(header) {
  const orRow = document.createElement('div');
  orRow.className = 'condition-row or-condition';
  orRow.innerHTML = `
    <span class="condition-logical">OR</span>
    <input type="text" class="condition-input left-input" placeholder="var or expr">
    <select class="condition-operator">
      <option value="==">=</option>
      <option value="!=">≠</option>
      <option value=">">></option>
      <option value="<"><</option>
      <option value=">=">≥</option>
      <option value="<=">≤</option>
    </select>
    <input type="text" class="condition-input right-input" placeholder="value">
    <span class="condition-remove">×</span>
  `;

  orRow.querySelector('.condition-remove').onclick = e => {
    e.stopPropagation();
    orRow.remove();
  };

  header.insertAdjacentElement('afterend', orRow);
}


function createIfConditionBlock() {
    const newBlock = document.createElement('div');
    // add condition-block here so addAndCondition/or can locate the parent
    newBlock.className = 'building-block if-condition condition-block';
    newBlock.style.backgroundColor = '#e3f2fd';
    newBlock.style.borderColor = '#42a5f5';
    newBlock.tabIndex = 0;
    
    // Main wrapper
    const conditionWrapper = document.createElement('div');
    conditionWrapper.className = 'condition-wrapper';
    
    // Create the if condition section
    const ifSection = document.createElement('div');
    ifSection.className = 'condition-section if-section';
    
    // If header
    const ifHeader = document.createElement('div');
    ifHeader.className = 'condition-row if-header';
    
    const ifType = document.createElement('span');
    ifType.className = 'condition-type';
    ifType.textContent = 'if';
    
    const leftInput = document.createElement('input');
    leftInput.type = 'text';
    leftInput.className = 'condition-input left-input';
    leftInput.placeholder = 'var or expr';
    
    const operatorSelect = document.createElement('select');
    operatorSelect.className = 'condition-operator';
    const operators = [
      { value: '==', text: '=' },
      { value: '!=', text: '≠' },
      { value: '>', text: '>' },
      { value: '<', text: '<' },
      { value: '>=', text: '≥' },
      { value: '<=', text: '≤' }
    ];
    operators.forEach(op => {
      const option = document.createElement('option');
      option.value = op.value;
      option.textContent = op.text;
      operatorSelect.appendChild(option);
    });
    
    const rightInput = document.createElement('input');
    rightInput.type = 'text';
    rightInput.className = 'condition-input right-input';
    rightInput.placeholder = 'value';
    
    // Action buttons
    const actionDiv = document.createElement('div');
    actionDiv.className = 'condition-actions';
    
    const addAndBtn = document.createElement('button');
    addAndBtn.className = 'add-and-btn';
    addAndBtn.textContent = '+ AND';
    addAndBtn.onclick = e => { e.stopPropagation(); addAndCondition(ifHeader); };
    
    const addOrBtn = document.createElement('button');
    addOrBtn.className = 'add-or-btn';
    addOrBtn.textContent = '+ OR';
    addOrBtn.onclick = e => { e.stopPropagation(); addOrCondition(ifHeader); };
    
    const addElseIfBtn = document.createElement('button');
    addElseIfBtn.className = 'add-elseif-btn';
    addElseIfBtn.textContent = '+ else if';
    addElseIfBtn.onclick = e => { e.stopPropagation(); addElseIfSection(conditionWrapper); };
    
    const addElseBtn = document.createElement('button');
    addElseBtn.className = 'add-else-btn';
    addElseBtn.textContent = '+ else';
    addElseBtn.onclick = e => { e.stopPropagation(); addElseSection(conditionWrapper); };
    
    actionDiv.append(addAndBtn, addOrBtn, addElseIfBtn, addElseBtn);
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'condition-remove';
    removeBtn.textContent = '×';
    removeBtn.onclick = e => { e.stopPropagation(); removeBlock(newBlock); };
    
    // Create the if "then" container
    const ifContainer = document.createElement('div');
    ifContainer.className = 'condition-container if-container';
    
    // "then" label + editable area
    const thenLabel = document.createElement('div');
    thenLabel.className = 'condition-row';
    thenLabel.innerHTML = '<span style="margin-left:5px;color:#666;">then:</span>';
    
    const thenEquation = document.createElement('div');
    thenEquation.className = 'editable-equation';
    thenEquation.appendChild(createEditableSpan('\u200B'));
    
    // Assemble
    ifHeader.append(ifType, leftInput, operatorSelect, rightInput, actionDiv, removeBtn);
    ifSection.append(ifHeader, ifContainer);
    ifContainer.append(thenLabel, thenEquation);
    conditionWrapper.appendChild(ifSection);
    newBlock.appendChild(conditionWrapper);
    
    return newBlock;
  }
  




function createCoordinateXValueBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block coordinate-x-value';
    newBlock.style.backgroundColor = '#fae8ff'; // Light purple color
    newBlock.style.borderColor = '#c026d3'; // Darker purple border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Coordinate x-value'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `coord-x-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="coordinate-${uniqueIdBase}">Coordinate (as string, e.g., "(3,4)"):</label>
        <input type="text" id="coordinate-${uniqueIdBase}" data-config-key="coordinate" placeholder="e.g., (3,4) or var_coord">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createCoordinateYValueBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block coordinate-y-value';
    newBlock.style.backgroundColor = '#fce7f3'; // Light pink color
    newBlock.style.borderColor = '#db2777'; // Darker pink border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Coordinate y-value'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `coord-y-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="coordinate-${uniqueIdBase}">Coordinate (as string, e.g., "(3,4)"):</label>
        <input type="text" id="coordinate-${uniqueIdBase}" data-config-key="coordinate" placeholder="e.g., (3,4) or var_coord">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPolyFactoredMinCoordinatesBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-factored-min-coords';
    newBlock.style.backgroundColor = '#dbeafe'; // Light blue color
    newBlock.style.borderColor = '#3b82f6'; // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Factored Form Min Coordinates'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-factored-min-coords-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="leading-${uniqueIdBase}">Leading coefficient (a):</label>
        <input type="text" id="leading-${uniqueIdBase}" data-config-key="leading" placeholder="e.g., 1, -2, etc.">
        
        <label for="factors-${uniqueIdBase}">Factors (comma-separated b values in (x+b)):</label>
        <textarea id="factors-${uniqueIdBase}" data-config-key="factors" rows="2" placeholder="e.g., -3, 2, 5 for (x-3)(x+2)(x+5)"></textarea>
        
        <label for="prefix-${uniqueIdBase}">Variable prefix for individual coordinates:</label>
        <input type="text" id="prefix-${uniqueIdBase}" data-config-key="prefix" placeholder="e.g., a (results in a1, a2, etc.)">
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPolyFactoredMinBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-factored-min';
    newBlock.style.backgroundColor = '#e0f2fe'; // Light blue color
    newBlock.style.borderColor = '#0ea5e9'; // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Factored Form Min'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-factored-min-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="leading-${uniqueIdBase}">Leading coefficient (a):</label>
        <input type="text" id="leading-${uniqueIdBase}" data-config-key="leading" placeholder="e.g., 1, -2, etc.">
        
        <label for="factors-${uniqueIdBase}">Factors (comma-separated b values in (x+b)):</label>
        <textarea id="factors-${uniqueIdBase}" data-config-key="factors" rows="2" placeholder="e.g., -3, 2, 5 for (x-3)(x+2)(x+5)"></textarea>
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPolyFactoredMaxCoordinatesBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-factored-max-coords';
    newBlock.style.backgroundColor = '#fef9c3'; // Light yellow color
    newBlock.style.borderColor = '#eab308'; // Darker yellow border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Factored Form Max Coordinates'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-factored-max-coords-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="leading-${uniqueIdBase}">Leading coefficient (a):</label>
        <input type="text" id="leading-${uniqueIdBase}" data-config-key="leading" placeholder="e.g., 1, -2, etc.">
        
        <label for="factors-${uniqueIdBase}">Factors (comma-separated b values in (x+b)):</label>
        <textarea id="factors-${uniqueIdBase}" data-config-key="factors" rows="2" placeholder="e.g., -3, 2, 5 for (x-3)(x+2)(x+5)"></textarea>
        
        <label for="prefix-${uniqueIdBase}">Variable prefix for individual coordinates:</label>
        <input type="text" id="prefix-${uniqueIdBase}" data-config-key="prefix" placeholder="e.g., a (results in a1, a2, etc.)">
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}



function createPolyFactoredMaxBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-factored-max';
    newBlock.style.backgroundColor = '#fef3c7'; // Light amber color
    newBlock.style.borderColor = '#d97706'; // Darker amber border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Factored Form Max'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-factored-max-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="leading-${uniqueIdBase}">Leading coefficient (a):</label>
        <input type="text" id="leading-${uniqueIdBase}" data-config-key="leading" placeholder="e.g., 1, -2, etc.">
        
        <label for="factors-${uniqueIdBase}">Factors (comma-separated b values in (x+b)):</label>
        <textarea id="factors-${uniqueIdBase}" data-config-key="factors" rows="2" placeholder="e.g., -3, 2, 5 for (x-3)(x+2)(x+5)"></textarea>
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPolyRelativeMinCoordinatesBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-relative-min-coords';
    newBlock.style.backgroundColor = '#fbcfe8'; // Light pink color
    newBlock.style.borderColor = '#ec4899'; // Darker pink border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Relative Min Coordinates'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-min-coords-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="coeffs-${uniqueIdBase}">Polynomial Coefficients (comma-separated, highest degree first):</label>
        <textarea id="coeffs-${uniqueIdBase}" data-config-key="coeffs" rows="2" placeholder="e.g., 1,2,0,1 for x³+2x²+1"></textarea>
        <label for="prefix-${uniqueIdBase}">Variable prefix for individual coordinates:</label>
        <input type="text" id="prefix-${uniqueIdBase}" data-config-key="prefix" placeholder="e.g., a (results in a1, a2, etc.)">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPolyRelativeMinBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-relative-min';
    newBlock.style.backgroundColor = '#ffe4e6'; // Light pink color
    newBlock.style.borderColor = '#f43f5e'; // Darker pink border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Relative Min (y values)'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-min-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="coeffs-${uniqueIdBase}">Polynomial Coefficients (comma-separated, highest degree first):</label>
        <textarea id="coeffs-${uniqueIdBase}" data-config-key="coeffs" rows="2" placeholder="e.g., 1,2,0,1 for x³+2x²+1"></textarea>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPolyRelativeMaxCoordinatesBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-relative-max-coords';
    newBlock.style.backgroundColor = '#dbeafe'; // Light blue color
    newBlock.style.borderColor = '#3b82f6'; // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Relative Max Coordinates'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-max-coords-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="coeffs-${uniqueIdBase}">Polynomial Coefficients (comma-separated, highest degree first):</label>
        <textarea id="coeffs-${uniqueIdBase}" data-config-key="coeffs" rows="2" placeholder="e.g., 1,2,0,1 for x³+2x²+1"></textarea>
        <label for="prefix-${uniqueIdBase}">Variable prefix for individual coordinates:</label>
        <input type="text" id="prefix-${uniqueIdBase}" data-config-key="prefix" placeholder="e.g., a (results in a1, a2, etc.)">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createPolyRelativeMaxBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block poly-relative-max';
    newBlock.style.backgroundColor = '#d1fae5'; // Light teal color
    newBlock.style.borderColor = '#10b981'; // Darker teal border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Poly Relative Max (y values)'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `poly-max-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="coeffs-${uniqueIdBase}">Polynomial Coefficients (comma-separated, highest degree first):</label>
        <textarea id="coeffs-${uniqueIdBase}" data-config-key="coeffs" rows="2" placeholder="e.g., 1,2,0,1 for x³+2x²+1"></textarea>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createLeastToGreatestBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block least-to-greatest';
    newBlock.style.backgroundColor = '#e0f7fa';
    newBlock.style.borderColor = '#80deea';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Least to Greatest'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `l2g-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="list-${uniqueIdBase}">List of values (comma/semicolon separated):</label>
        <textarea id="list-${uniqueIdBase}" data-config-key="list" rows="3" 
                  placeholder="e.g., 5, 3, 8, 1 or var_x"
                  maxlength="500"></textarea>
        <small style="display:block;color:#666;">Max 500 characters</small>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Greatest to Least block
function createGreatestToLeastBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block greatest-to-least';
    newBlock.style.backgroundColor = '#e0f7fa';
    newBlock.style.borderColor = '#80deea';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Greatest to Least'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `g2l-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="list-${uniqueIdBase}">List of values (comma/semicolon separated):</label>
        <textarea id="list-${uniqueIdBase}" data-config-key="list" rows="3" 
                  placeholder="e.g., 5, 3, 8, 1 or var_x"
                  maxlength="500"></textarea>
        <small style="display:block;color:#666;">Max 500 characters</small>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    newBlock.appendChild(config);
    return newBlock;
}

// Alphabetical block
function createAlphabeticalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block alphabetical';
    newBlock.style.backgroundColor = '#e0f7fa';
    newBlock.style.borderColor = '#80deea';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Alphabetical'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `alpha-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="list-${uniqueIdBase}">List of words (comma/semicolon separated):</label>
        <textarea id="list-${uniqueIdBase}" data-config-key="list" rows="3" 
                  placeholder="e.g., apple, zebra, banana or var_words"
                  maxlength="500"></textarea>
        <small style="display:block;color:#666;">Max 500 characters</small>
        <label for="case-sensitive-${uniqueIdBase}">Case sensitivity:</label>
        <select id="case-sensitive-${uniqueIdBase}" data-config-key="caseSensitive">
            <option value="false">Case-insensitive</option>
            <option value="true">Case-sensitive</option>
        </select>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// List Max block
function createListMaxBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block list-max';
    newBlock.style.backgroundColor = '#e0f7fa';
    newBlock.style.borderColor = '#80deea';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('List Max'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `max-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="list-${uniqueIdBase}">List of numbers (comma/semicolon separated):</label>
        <textarea id="list-${uniqueIdBase}" data-config-key="list" rows="3" 
                  placeholder="e.g., 5, 3, 8, 1 or var_x"
                  maxlength="500"></textarea>
        <small style="display:block;color:#666;">Max 500 characters</small>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// List Min block
function createListMinBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block list-min';
    newBlock.style.backgroundColor = '#e0f7fa';
    newBlock.style.borderColor = '#80deea';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('List Min'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `min-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="list-${uniqueIdBase}">List of numbers (comma/semicolon separated):</label>
        <textarea id="list-${uniqueIdBase}" data-config-key="list" rows="3" 
                  placeholder="e.g., 5, 3, 8, 1 or var_x"
                  maxlength="500"></textarea>
        <small style="display:block;color:#666;">Max 500 characters</small>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Random Order block
function createRandomOrderBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block random-order';
    newBlock.style.backgroundColor = '#e0f7fa';
    newBlock.style.borderColor = '#80deea';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Random Order'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `rand-ord-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="list-${uniqueIdBase}">List of items (comma/semicolon separated):</label>
        <textarea id="list-${uniqueIdBase}" data-config-key="list" rows="3" 
                  placeholder="e.g., apple, banana, cherry or var_list"
                  maxlength="500"></textarea>
        <small style="display:block;color:#666;">Max 500 characters</small>
        <label for="exclude-${uniqueIdBase}">Exclude these orders (variable names, comma separated):</label>
        <input type="text" id="exclude-${uniqueIdBase}" data-config-key="exclude" placeholder="e.g., var_a, var_b">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createLogBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block log-block';
    newBlock.style.backgroundColor = '#d1fae5'; // Light teal color
    newBlock.style.borderColor = '#10b981';    // Darker teal border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Log'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `log-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 100 or var_x" data-config-key="value">
        
        <label for="base-${uniqueIdBase}">Base:</label>
        <input type="text" id="base-${uniqueIdBase}" placeholder="Default: 10" value="10" data-config-key="base">
        
        <div>
            <input type="checkbox" id="round-${uniqueIdBase}" data-config-key="round">
            <label for="round-${uniqueIdBase}" style="display: inline-block;">Round result</label>
        </div>
        
        <div id="decimals-container-${uniqueIdBase}" style="margin-left: 20px; display: none;">
            <label for="decimals-${uniqueIdBase}">Decimal places:</label>
            <input type="number" id="decimals-${uniqueIdBase}" min="0" max="15" value="4" data-config-key="decimals">
        </div>
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    
    // Add event listener to show/hide decimals based on round checkbox
    setTimeout(() => {
        const roundCheckbox = config.querySelector(`#round-${uniqueIdBase}`);
        const decimalsContainer = config.querySelector(`#decimals-container-${uniqueIdBase}`);
        
        if (roundCheckbox && decimalsContainer) {
            roundCheckbox.addEventListener('change', function() {
                decimalsContainer.style.display = this.checked ? 'block' : 'none';
            });
        }
    }, 0);
    
    return newBlock;
}

// Natural Log function (base e)
function createLnBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block ln-block';
    newBlock.style.backgroundColor = '#e0f2fe'; // Light blue color
    newBlock.style.borderColor = '#0ea5e9';    // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Ln'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `ln-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 100 or var_x" data-config-key="value">
        
        <div>
            <input type="checkbox" id="round-${uniqueIdBase}" data-config-key="round">
            <label for="round-${uniqueIdBase}" style="display: inline-block;">Round result</label>
        </div>
        
        <div id="decimals-container-${uniqueIdBase}" style="margin-left: 20px; display: none;">
            <label for="decimals-${uniqueIdBase}">Decimal places:</label>
            <input type="number" id="decimals-${uniqueIdBase}" min="0" max="15" value="4" data-config-key="decimals">
        </div>
        
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    
    // Add event listener to show/hide decimals based on round checkbox
    setTimeout(() => {
        const roundCheckbox = config.querySelector(`#round-${uniqueIdBase}`);
        const decimalsContainer = config.querySelector(`#decimals-container-${uniqueIdBase}`);
        
        if (roundCheckbox && decimalsContainer) {
            roundCheckbox.addEventListener('change', function() {
                decimalsContainer.style.display = this.checked ? 'block' : 'none';
            });
        }
    }, 0);
    
    return newBlock;
}

function createPrimeFactorizationBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block prime-factorization';
    newBlock.style.backgroundColor = '#ffedd5'; // Light orange color
    newBlock.style.borderColor = '#f97316';    // Darker orange border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Prime Factorization'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `prime-fact-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value to factorize:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 50 or var_x" data-config-key="value">
        <p class="config-note" style="font-size: 11px; color: #666; margin-top: 4px;">
            Note: Values are limited to 100,000
        </p>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createArcsinBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block sin-inverse';
    newBlock.style.backgroundColor = '#e1bee7'; // Light purple color
    newBlock.style.borderColor = '#ba68c8';    // Darker purple border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Arcsin'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `arcsin-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 0.5 or var_x" data-config-key="value">
        <label for="mode-${uniqueIdBase}">Output Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createArccosBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block cos-inverse';
    newBlock.style.backgroundColor = '#b3e5fc'; // Light blue color
    newBlock.style.borderColor = '#4fc3f7';    // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Arccos'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `arccos-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 0.5 or var_x" data-config-key="value">
        <label for="mode-${uniqueIdBase}">Output Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createArctanBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block tan-inverse';
    newBlock.style.backgroundColor = '#c8e6c9'; // Light green color
    newBlock.style.borderColor = '#81c784';    // Darker green border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Arctan'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `arctan-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 1 or var_x" data-config-key="value">
        <label for="mode-${uniqueIdBase}">Output Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}


function createSinExactBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block sin-exact';
    newBlock.style.backgroundColor = '#e3f2fd'; // Light blue color
    newBlock.style.borderColor = '#90caf9';    // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Sin Exact'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `sin-exact-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, 45, 60, etc." data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places (if not exact):</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Cosine Exact block
function createCosExactBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block cos-exact';
    newBlock.style.backgroundColor = '#e8f5e9'; // Light green color
    newBlock.style.borderColor = '#a5d6a7';    // Darker green border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Cos Exact'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `cos-exact-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, 45, 60, etc." data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places (if not exact):</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Tangent Exact block
function createTanExactBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block tan-exact';
    newBlock.style.backgroundColor = '#fff8e1'; // Light amber color
    newBlock.style.borderColor = '#ffecb3';    // Darker amber border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Tan Exact'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `tan-exact-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, 45, 60, etc." data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places (if not exact):</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Cosecant Exact block
function createCscExactBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block csc-exact';
    newBlock.style.backgroundColor = '#f3e5f5'; // Light purple color
    newBlock.style.borderColor = '#ce93d8';    // Darker purple border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Csc Exact'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `csc-exact-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, 45, 60, etc." data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places (if not exact):</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Secant Exact block
function createSecExactBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block sec-exact';
    newBlock.style.backgroundColor = '#e8eaf6'; // Light indigo color
    newBlock.style.borderColor = '#c5cae9';    // Darker indigo border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Sec Exact'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `sec-exact-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, 45, 60, etc." data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places (if not exact):</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Cotangent Exact block
function createCotExactBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block cot-exact';
    newBlock.style.backgroundColor = '#fce4ec'; // Light pink color
    newBlock.style.borderColor = '#f8bbd0';    // Darker pink border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Cot Exact'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `cot-exact-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, 45, 60, etc." data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places (if not exact):</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Helper function to parse angle expressions including pi
// SAFER Helper function to parse angle expressions including pi
function safeParseAngleExpression(exprStr) {
    if (typeof exprStr === 'number') { // If it's already a number, just return it.
        return exprStr;
    }
    if (typeof exprStr !== 'string') {
        exprStr = String(exprStr); // Ensure it's a string for processing
    }

    try {
        const mathScope = { // Limited scope for math.js evaluation
            pi: Math.PI,
            PI: Math.PI,
            π: Math.PI
            // You can add other simple constants here if absolutely necessary for angles
            // e.g., e: Math.E
            // DO NOT add functions or complex objects to this scope.
        };

        // math.js will handle expressions like "3*pi/2", "pi", "30", "1.57" etc.
        // It will also handle simple arithmetic like "90/2 + 15"
        const node = math.parse(exprStr);
        const result = node.evaluate(mathScope);

        // Ensure the result is a usable, finite number
        if (typeof result === 'number' && isFinite(result)) {
            return result;
        } else if (result && typeof result.toNumber === 'function') {
            // Handle cases where math.js might return its own types (e.g., Fraction, BigNumber)
            const numResult = result.toNumber();
            if (isFinite(numResult)) {
                return numResult;
            }
        }
        
        // If the expression didn't evaluate to a finite number
        console.warn(`safeParseAngleExpression: Expression '${exprStr}' did not evaluate to a finite number. Result:`, result);
        return NaN;

    } catch (e) {
        // This catch block will handle errors from math.parse or math.evaluate,
        // such as syntax errors in the mathematical expression or undefined symbols not in mathScope.
        console.error(`Error parsing angle expression '${exprStr}' with math.js:`, e.message);
        return NaN;
    }
}


// Function to normalize an angle to [0, 360) degrees or [0, 2π) radians
function normalizeAngle(angle, mode) {
    if (mode === 'degrees') {
        return ((angle % 360) + 360) % 360;
    } else { // radians
        return ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    }
}


function createSinDecimalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block sin-decimal';
    newBlock.style.backgroundColor = '#bbdefb'; // Light blue color
    newBlock.style.borderColor = '#64b5f6';    // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Sin Decimal'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `sin-decimal-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, pi/2, 3pi/4" data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Cosine Decimal block
function createCosDecimalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block cos-decimal';
    newBlock.style.backgroundColor = '#c8e6c9'; // Light green color
    newBlock.style.borderColor = '#81c784';    // Darker green border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Cos Decimal'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `cos-decimal-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, pi/2, 3pi/4" data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Tangent Decimal block
function createTanDecimalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block tan-decimal';
    newBlock.style.backgroundColor = '#fff9c4'; // Light yellow color
    newBlock.style.borderColor = '#fff176';    // Darker yellow border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Tan Decimal'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `tan-decimal-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
  setSafeInnerHTML(config, `
        <label for="angle-${uniqueIdBase}">Angle:</label>
        <input type="text" id="angle-${uniqueIdBase}" placeholder="e.g., 30, pi/2, 3pi/4" data-config-key="angle">
        <label for="mode-${uniqueIdBase}">Mode:</label>
        <select id="mode-${uniqueIdBase}" data-config-key="mode">
            <option value="degrees">Degrees</option>
            <option value="radians">Radians</option>
        </select>
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 4" value="4" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Helper function to parse angle expressions including pi



function createQuadFormulaDecAns1Block() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block quad-form-dec-ans1';
    newBlock.style.backgroundColor = '#ffe0b2'; // Light orange color
    newBlock.style.borderColor = '#ffb74d';    // Darker orange border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Quad Form Dec Ans1'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `quad-ans1-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="a-${uniqueIdBase}">a value:</label>
        <input type="text" id="a-${uniqueIdBase}" placeholder="e.g., 1 or var_a" data-config-key="a">
        <label for="b-${uniqueIdBase}">b value:</label>
        <input type="text" id="b-${uniqueIdBase}" placeholder="e.g., -5 or var_b" data-config-key="b">
        <label for="c-${uniqueIdBase}">c value:</label>
        <input type="text" id="c-${uniqueIdBase}" placeholder="e.g., 6 or var_c" data-config-key="c">
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 2" value="2" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Quadratic Formula Decimal Answer 2 block (larger value)
function createQuadFormulaDecAns2Block() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block quad-form-dec-ans2';
    newBlock.style.backgroundColor = '#e6ee9c'; // Light yellow-green color
    newBlock.style.borderColor = '#d4e157';    // Darker yellow-green border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Quad Form Dec Ans2'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `quad-ans2-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="a-${uniqueIdBase}">a value:</label>
        <input type="text" id="a-${uniqueIdBase}" placeholder="e.g., 1 or var_a" data-config-key="a">
        <label for="b-${uniqueIdBase}">b value:</label>
        <input type="text" id="b-${uniqueIdBase}" placeholder="e.g., -5 or var_b" data-config-key="b">
        <label for="c-${uniqueIdBase}">c value:</label>
        <input type="text" id="c-${uniqueIdBase}" placeholder="e.g., 6 or var_c" data-config-key="c">
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 2" value="2" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createQuadraticFormulaRadicalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block quadratic-formula-radical';
    newBlock.style.backgroundColor = '#fff9c4'; // Light yellow color
    newBlock.style.borderColor = '#fff176';    // Darker yellow border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Quadratic Formula Radical'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `quad-formula-rad-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="a-${uniqueIdBase}">a value:</label>
        <input type="text" id="a-${uniqueIdBase}" placeholder="e.g., 1 or var_a" data-config-key="a">
        <label for="b-${uniqueIdBase}">b value:</label>
        <input type="text" id="b-${uniqueIdBase}" placeholder="e.g., -5 or var_b" data-config-key="b">
        <label for="c-${uniqueIdBase}">c value:</label>
        <input type="text" id="c-${uniqueIdBase}" placeholder="e.g., 6 or var_c" data-config-key="c">
        <div>
            <label for="format-${uniqueIdBase}">Output format:</label>
            <select id="format-${uniqueIdBase}" data-config-key="format">
                <option value="unified">Unified fraction</option>
                <option value="separate">Separate fractions</option>
            </select>
        </div>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}


function createQuadraticFormulaDecimalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block quadratic-formula-decimal';
    newBlock.style.backgroundColor = '#ffecb3'; // Light amber color
    newBlock.style.borderColor = '#ffd54f';    // Darker amber border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Quadratic Formula Decimal'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `quad-formula-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="a-${uniqueIdBase}">a value:</label>
        <input type="text" id="a-${uniqueIdBase}" placeholder="e.g., 1 or var_a" data-config-key="a">
        <label for="b-${uniqueIdBase}">b value:</label>
        <input type="text" id="b-${uniqueIdBase}" placeholder="e.g., -5 or var_b" data-config-key="b">
        <label for="c-${uniqueIdBase}">c value:</label>
        <input type="text" id="c-${uniqueIdBase}" placeholder="e.g., 6 or var_c" data-config-key="c">
        <label for="decimals-${uniqueIdBase}">Decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 2" value="2" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}


function createSimpRadCoefficientBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block simp-rad-coefficient';
    newBlock.style.backgroundColor = '#f8eeff'; // Light purple color
    newBlock.style.borderColor = '#d4b6ff';    // Darker purple border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Simp Rad Coefficient'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `simp-rad-coef-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value under radical:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 72 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Simplified Radical Radicand block
function createSimpRadRadicandBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block simp-rad-radicand';
    newBlock.style.backgroundColor = '#f0e6ff'; // Lighter purple color
    newBlock.style.borderColor = '#d0b8ff';    // Purple border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Simp Rad Radicand'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `simp-rad-rad-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value under radical:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 72 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Simplified Cube Root Coefficient block
function createSimpCubeRootCoefficientBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block simp-cbrt-coefficient';
    newBlock.style.backgroundColor = '#e3f2fd'; // Light blue color
    newBlock.style.borderColor = '#90caf9';    // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Simp Cube Root Coefficient'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `simp-cbrt-coef-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value under cube root:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 54 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Function to create the Simplified Cube Root Radicand block
function createSimpCubeRootRadicandBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block simp-cbrt-radicand';
    newBlock.style.backgroundColor = '#e1f5fe'; // Lighter blue color
    newBlock.style.borderColor = '#81d4fa';    // Blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Simp Cube Root Radicand'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `simp-cbrt-rad-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value under cube root:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 54 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createSimplifyNthRootBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block simplify-nth-root';
    newBlock.style.backgroundColor = '#e8f5e9'; // Light green color
    newBlock.style.borderColor = '#a5d6a7';    // Darker green border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Simplify Nth Root'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `simplify-nth-root-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value under root:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 32 or var_x" data-config-key="value">
        <label for="root-${uniqueIdBase}">Root degree:</label>
        <input type="text" id="root-${uniqueIdBase}" placeholder="e.g., 4 for 4th root" value="2" data-config-key="root">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function findLargestPerfectPower(n, root) {
    if (n === 0) return [0, 1];
    if (n === 1) return [1, 1];
    
    const absN = Math.abs(n);
    let coefficient = 1;
    let radicand = absN;
    
    // Try all potential factors up to the square root of the number
    for (let i = 2; i * i <= absN; i++) {
        let count = 0;
        // Count how many times i^root divides the number
        let testNum = absN;
        const iPowRoot = Math.pow(i, root);
        
        while (testNum % iPowRoot === 0) {
            testNum = Math.floor(testNum / iPowRoot);
            count++;
        }
        
        if (count > 0) {
            coefficient *= Math.pow(i, count);
            radicand = Math.floor(radicand / Math.pow(coefficient, root));
        }
    }
    
    return [coefficient, radicand];
}

// Helper function to check if a number is a perfect power
function isPerfectPower(n, power) {
    // For negative numbers, only odd powers can have negative bases
    if (n < 0 && power % 2 === 0) return false;
    
    const absN = Math.abs(n);
    const root = Math.pow(absN, 1/power);
    const roundedRoot = Math.round(root);
    
    // Check if roundedRoot^power equals n (within a small tolerance for floating point errors)
    return Math.abs(Math.pow(roundedRoot, power) - absN) < 1e-10;
}

// Function to get the root symbol for a given degree
function getRootSymbol(degree) {
    if (degree === 2) return '√'; // Square root
    if (degree === 3) return '∛'; // Cube root
    if (degree === 4) return '∜'; // Fourth root
    return `√[${degree}]`; // General notation for other roots
}


function createSimplifyCubeRootBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block simplify-cube-root';
    newBlock.style.backgroundColor = '#e1f5fe'; // Light blue color
    newBlock.style.borderColor = '#81d4fa';    // Darker blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Simplify Cube Root'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `simplify-cube-root-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value under cube root:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 54 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}


function createSimplifyRadicalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block simplify-radical';
    newBlock.style.backgroundColor = '#f3e5f5'; // Light purple color
    newBlock.style.borderColor = '#ce93d8';    // Darker purple border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Simplify Radical'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `simplify-radical-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value under radical:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 40 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createAlgebraicExpressionBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block algebraic-expr';
    newBlock.style.backgroundColor = '#c8e6c9';
    newBlock.style.borderColor = '#a5d6a7';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Algebraic Expression'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `algexpr-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="expression-${uniqueIdBase}">Expression:</label>
        <input type="text" id="expression-${uniqueIdBase}" placeholder="e.g., #a#x+#b#" data-config-key="expression">
        <div style="margin-top: 5px; font-size: 12px; color: #666;">
            <p>Tips:</p>
            <ul style="padding-left: 15px; margin-top: 3px;">
                <li>Use #x# for variables to be substituted</li>
               
                <li>Variables without ## will not replaced with values</li>
               
            </ul>
        </div>
        <div>
           
        </div>
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createNthRootBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block nth-root';
    newBlock.style.backgroundColor = '#d1c4e9';
    newBlock.style.borderColor = '#b39ddb';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Nth Root'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `nthroot-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 8 or var_x" data-config-key="value">
        <label for="root-${uniqueIdBase}">Root:</label>
        <input type="text" id="root-${uniqueIdBase}" placeholder="e.g., 3 for cube root" value="3" data-config-key="root">
        <label for="decimals-${uniqueIdBase}">Round to decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" min="0" max="15" value="6" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createSquareRootBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block square-root';
    newBlock.style.backgroundColor = '#f0e6ff';
    newBlock.style.borderColor = '#d9b3ff';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Square Root'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `sqrt-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
 setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 16 or var_x" data-config-key="value">
        <label for="decimals-${uniqueIdBase}">Round to decimal places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" min="0" max="15" value="6" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createRoundDownBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block round-down';
    newBlock.style.backgroundColor = '#e6f2ff';
    newBlock.style.borderColor = '#b3d9ff';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Round Down'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `rounddown-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 3.9 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createRoundUpBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block round-up';
    newBlock.style.backgroundColor = '#ffe6eb';
    newBlock.style.borderColor = '#ffb3c0';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Round Up'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `roundup-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
   setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 3.1 or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createConvertToDecimalBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block convert-decimal';
    newBlock.style.backgroundColor = '#e6f7ff';
    newBlock.style.borderColor = '#b3e0ff';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Convert to Decimal'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `convertdecimal-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
  setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value to convert:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 3/4, 2 1/2, or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createRoundBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block round';
    newBlock.style.backgroundColor = '#e6ffea';
    newBlock.style.borderColor = '#b3ffc6';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Round'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `round-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 3.14159 or var_x" data-config-key="value">
        <label for="decimals-${uniqueIdBase}">Decimal Places:</label>
        <input type="number" id="decimals-${uniqueIdBase}" value="2" min="0" max="15" data-config-key="decimals">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createConvertToImproperBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block convert-improper';
    newBlock.style.backgroundColor = '#ffece6';
    newBlock.style.borderColor = '#ffcbb3';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Convert to Improper'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `convertimproper-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
  setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value to convert:</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 2.5, 3 1/4, or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createMixedNumberWholeBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block mixed-num-whole';
    newBlock.style.backgroundColor = '#e6f9ff';  // Light blue background
    newBlock.style.borderColor = '#b3e0ff';      // Blue border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Mixed Num Whole'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `mixwhole-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value (mixed number or fraction):</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 2 3/5 or var_f" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

function createFormatMixedNumberBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block format-mixed-num';
    newBlock.style.backgroundColor = '#f0e6ff';  // Light purple
    newBlock.style.borderColor = '#d8c2ff';      // Darker purple border
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Format Mixed Number'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `formatmix-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value (number, fraction, or variable):</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 2.5, 7/3, or var_x" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}

// Helper function to count decimal places in a number
function countDecimals(value) {
    if (Math.floor(value) === value) return 0;
    const str = value.toString();
    if (str.includes('e')) return 0; // Scientific notation - too complex
    if (!str.includes('.')) return 0;
    return str.split('.')[1].length;
}

// Helper function to format a math.Fraction as a mixed number
function formatMixedNumberOutput(frac) {
    if (!frac || !frac.isFraction) return "Invalid fraction";
    
    const n = frac.n * frac.s; // Numerator with sign
    const d = frac.d;          // Denominator
    
    if (d === 1) return String(n); // Whole number
    
    if (Math.abs(n) >= d) {
        const wholePart = Math.trunc(n / d);
        const remainderNum = Math.abs(n % d);
        if (remainderNum === 0) return String(wholePart);
        return `${wholePart} ${remainderNum}/${d}`;
    } else {
        return `${n}/${d}`; // Proper fraction
    }
}



function createMixedNumberNumeratorBlock() {
    const newBlock = document.createElement('div');
    newBlock.className = 'building-block mixed-num-numerator';
    newBlock.style.backgroundColor = '#e6f9ff';
    newBlock.style.borderColor = '#b3e0ff';
    newBlock.tabIndex = 0;
    newBlock.appendChild(document.createTextNode('Mixed Num Numerator'));
    
    const removeBtn = document.createElement('span');
    removeBtn.className = 'block-remove';
    removeBtn.textContent = '×';
    newBlock.appendChild(removeBtn);
    
    const config = document.createElement('div');
    config.className = 'block-config';
    const uniqueIdBase = `mixnumr-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
 setSafeInnerHTML(config, `
        <label for="value-${uniqueIdBase}">Value (mixed number or fraction):</label>
        <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., 2 3/5 or var_f" data-config-key="value">
        <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
        </div>
    `);
    
    newBlock.appendChild(config);
    return newBlock;
}


    function createCreateFractionBlock() { // Name reflects action
        const newBlock = document.createElement('div'); newBlock.className = 'building-block create-fraction fraction'; // Re-use fraction style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Fraction'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `createfrac-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, `
            <label for="num-${uniqueIdBase}">Numerator (num/var):</label>
            <input type="text" id="num-${uniqueIdBase}" placeholder="e.g., 2" data-config-key="num">
            <label for="den-${uniqueIdBase}">Denominator (num/var):</label>
            <input type="text" id="den-${uniqueIdBase}" placeholder="e.g., 3" data-config-key="den">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createUnsimplifiedMixedNumBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block unsimp-mixed-num fraction';
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Unsimp Mixed Num'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `unsimpmix-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
       setSafeInnerHTML(config, `
             <label for="whole-${uniqueIdBase}">Whole (num/var):</label>
            <input type="text" id="whole-${uniqueIdBase}" placeholder="e.g., 2" data-config-key="whole">
            <label for="num-${uniqueIdBase}">Numerator (num/var):</label>
            <input type="text" id="num-${uniqueIdBase}" placeholder="e.g., 1" data-config-key="num">
            <label for="den-${uniqueIdBase}">Denominator (num/var):</label>
            <input type="text" id="den-${uniqueIdBase}" placeholder="e.g., 3" data-config-key="den">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createSimplifiedMixedNumBlock() { // Shares compute func with unsimplified
        const newBlock = document.createElement('div'); newBlock.className = 'building-block simp-mixed-num fraction';
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Simp Mixed Num'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `simpmix-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
       setSafeInnerHTML(config, `
            <label for="whole-${uniqueIdBase}">Whole (num/var):</label>
            <input type="text" id="whole-${uniqueIdBase}" placeholder="e.g., 2 (optional)" data-config-key="whole">
            <label for="num-${uniqueIdBase}">Numerator (num/var):</label>
            <input type="text" id="num-${uniqueIdBase}" placeholder="e.g., 4" data-config-key="num">
            <label for="den-${uniqueIdBase}">Denominator (num/var):</label>
            <input type="text" id="den-${uniqueIdBase}" placeholder="e.g., 6" data-config-key="den">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createReducedImproperFracBlock() { // Shares compute func
        const newBlock = document.createElement('div'); newBlock.className = 'building-block red-improper-frac fraction';
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Reduced Improper'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `redimp-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
         setSafeInnerHTML(config, `
            <label for="whole-${uniqueIdBase}">Whole (num/var):</label>
            <input type="text" id="whole-${uniqueIdBase}" placeholder="e.g., 2 (optional)" data-config-key="whole">
            <label for="num-${uniqueIdBase}">Numerator (num/var):</label>
            <input type="text" id="num-${uniqueIdBase}" placeholder="e.g., 5" data-config-key="num">
            <label for="den-${uniqueIdBase}">Denominator (num/var):</label>
            <input type="text" id="den-${uniqueIdBase}" placeholder="e.g., 3" data-config-key="den">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createFractionNumeratorBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block frac-num'; // Add specific class
        newBlock.style.backgroundColor = '#e6f9ff'; newBlock.style.borderColor = '#b3e0ff'; // Example style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Frac Numerator'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `fracnum-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, `
            <label for="value-${uniqueIdBase}">Fraction (frac obj/var):</label>
            <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., var_f" data-config-key="value">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createFractionDenominatorBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block frac-den'; // Add specific class
        newBlock.style.backgroundColor = '#e6f9ff'; newBlock.style.borderColor = '#b3e0ff';
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Frac Denominator'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `fracden-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
         config.innerHTML = `
            <label for="value-${uniqueIdBase}">Fraction (frac obj/var):</label>
            <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., var_f" data-config-key="value">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `;
        newBlock.appendChild(config); return newBlock;
    }
    
    
    function createBlockFromType(blockType) { // Added check for unknown block return
         let newBlock;
         if (blockType === 'random-int') { newBlock = createRandomIntBlock(); }
         else if (blockType === 'fraction') { newBlock = createFractionBlock(); }
         else if (blockType === 'random-float') { newBlock = createRandomFloatBlock(); }
         else if (blockType === 'choose') { newBlock = createChooseBlock(); }
         else if (blockType === 'random-name') { newBlock = createRandomNameBlock(); }
         else if (blockType === 'gcd') { newBlock = createGcdBlock(); }
     else if (blockType === 'lcm') { newBlock = createLcmBlock(); }
     else if (blockType === 'choose-prime') { newBlock = createChoosePrimeBlock(); }
     else if (blockType === 'abs') { newBlock = createAbsBlock(); }
     else if (blockType === 'quotient') { newBlock = createQuotientBlock(); }
     else if (blockType === 'remainder') { newBlock = createRemainderBlock(); }
     else if (blockType === 'create-fraction') { newBlock = createCreateFractionBlock(); }
         else if (blockType === 'unsimplified-mixed-number') { newBlock = createUnsimplifiedMixedNumBlock(); }
         else if (blockType === 'simplified-mixed-number') { newBlock = createSimplifiedMixedNumBlock(); }
         else if (blockType === 'reduced-improper-fraction') { newBlock = createReducedImproperFracBlock(); }
         else if (blockType === 'polynomial-zeros') { newBlock = createPolynomialZerosBlock();}
         else if (blockType === 'fraction-numerator') { newBlock = createFractionNumeratorBlock(); }
         else if (blockType === 'fraction-denominator') { newBlock = createFractionDenominatorBlock(); }
         else if (blockType === 'format-mixed-number') { newBlock = createFormatMixedNumberBlock(); }
         else if (blockType === 'mixed-number-numerator') {newBlock = createMixedNumberNumeratorBlock();  }
         else if (blockType === 'mixed-number-whole') { newBlock = createMixedNumberWholeBlock(); }
         else if (blockType === 'convert-improper') { newBlock = createConvertToImproperBlock();}
         else if (blockType === 'round') {newBlock = createRoundBlock();}
         else if (blockType === 'convert-decimal') {newBlock = createConvertToDecimalBlock();}
         else if (blockType === 'round-up') {newBlock = createRoundUpBlock();}
         else if (blockType === 'round-down') { newBlock = createRoundDownBlock();}
         else if (blockType === 'square-root') {newBlock = createSquareRootBlock();}
         else if (blockType === 'nth-root') {newBlock = createNthRootBlock();}
         else if (blockType === 'pyth-triple-multiples') {newBlock = createPythTripleMultiplesBlock(); }
         else if (blockType === 'algebraic-expr') {newBlock = createAlgebraicExpressionBlock();}
         else if (blockType === 'simplify-radical') {newBlock = createSimplifyRadicalBlock();}
         else if (blockType === 'simplify-cube-root') {newBlock = createSimplifyCubeRootBlock();}
         else if (blockType === 'simplify-nth-root') {newBlock = createSimplifyNthRootBlock();}
         else if (blockType === 'simp-rad-coefficient') {newBlock = createSimpRadCoefficientBlock();}
else if (blockType === 'simp-rad-radicand') {newBlock = createSimpRadRadicandBlock();}
else if (blockType === 'simp-cbrt-coefficient') {newBlock = createSimpCubeRootCoefficientBlock();}
else if (blockType === 'simp-cbrt-radicand') {newBlock = createSimpCubeRootRadicandBlock();}
else if (blockType === 'quadratic-formula-decimal') {newBlock = createQuadraticFormulaDecimalBlock();}
else if (blockType === 'quadratic-formula-radical') {newBlock = createQuadraticFormulaRadicalBlock();}
else if (blockType === 'pythagorean-triple') {newBlock = createPythagoreanTripleBlock();}
else if (blockType === 'quad-form-dec-ans1') {newBlock = createQuadFormulaDecAns1Block();}
else if (blockType === 'quad-form-dec-ans2') {newBlock = createQuadFormulaDecAns2Block();}
else if (blockType === 'sin-decimal') {newBlock = createSinDecimalBlock();}
else if (blockType === 'cos-decimal') {newBlock = createCosDecimalBlock();}
else if (blockType === 'tan-decimal') {newBlock = createTanDecimalBlock();}
else if (blockType === 'sin-exact') {newBlock = createSinExactBlock();}
else if (blockType === 'add-polynomials') {newBlock = createAddPolynomialsBlock();}
else if (blockType === 'cos-exact') {newBlock = createCosExactBlock();}
else if (blockType === 'tan-exact') {newBlock = createTanExactBlock();}
else if (blockType === 'csc-exact') {newBlock = createCscExactBlock();}
else if (blockType === 'sec-exact') {newBlock = createSecExactBlock();}
else if (blockType === 'cot-exact') {newBlock = createCotExactBlock();}
else if (blockType === 'permutation') { newBlock = createPermutationBlock();}
else if (blockType === 'combination') {newBlock = createCombinationBlock();}
else if (blockType === 'synthetic-division') {newBlock = createSyntheticDivisionBlock();}
else if (blockType === 'sin-inverse') {newBlock = createArcsinBlock();}
else if (blockType === 'cos-inverse') {newBlock = createArccosBlock();}
else if (blockType === 'tan-inverse') {newBlock = createArctanBlock();}
else if (blockType === 'prime-factorization') {newBlock = createPrimeFactorizationBlock();}
else if (blockType === 'log-block') {newBlock = createLogBlock();}
else if (blockType === 'ln-block') {newBlock = createLnBlock();}
else if (blockType === 'least-to-greatest') { newBlock = createLeastToGreatestBlock(); }
else if (blockType === 'greatest-to-least') { newBlock = createGreatestToLeastBlock(); }
else if (blockType === 'alphabetical') { newBlock = createAlphabeticalBlock(); }
else if (blockType === 'list-max') { newBlock = createListMaxBlock(); }
else if (blockType === 'list-min') { newBlock = createListMinBlock(); }
else if (blockType === 'random-order') { newBlock = createRandomOrderBlock(); }
// Add this to the if-else chain in createBlockFromType function
else if (blockType === 'poly-relative-max') {newBlock = createPolyRelativeMaxBlock();}
else if (blockType === 'poly-relative-max-coords') {newBlock = createPolyRelativeMaxCoordinatesBlock();
}
else if (blockType === 'poly-relative-min') {newBlock = createPolyRelativeMinBlock();}
else if (blockType === 'poly-relative-min-coords') {newBlock = createPolyRelativeMinCoordinatesBlock();}
else if (blockType === 'poly-factored-max') {newBlock = createPolyFactoredMaxBlock();}
else if (blockType === 'poly-factored-max-coords') { newBlock = createPolyFactoredMaxCoordinatesBlock();}
else if (blockType === 'poly-factored-min') {newBlock = createPolyFactoredMinBlock();}
else if (blockType === 'poly-factored-min-coords') {newBlock = createPolyFactoredMinCoordinatesBlock();}
else if (blockType === 'coordinate-x-value') { newBlock = createCoordinateXValueBlock();}
else if (blockType === 'coordinate-y-value') {newBlock = createCoordinateYValueBlock();}
else if (blockType === 'if-condition') {newBlock = createIfConditionBlock();}
else if (blockType === 'text') {newBlock = createTextBlock();}
else if (blockType === 'choose-text') {newBlock = createChooseTextBlock();}
else if (blockType === 'choose-expr') {newBlock = createChooseExprBlock();}
else if (blockType === 'choose-num') {newBlock = createChooseNumBlock();}
else if (blockType === 'blank') { newBlock = createBlankBlock();}
  else if (blockType === 'undefined') {newBlock = createUndefinedBlock(); }
  else if (blockType === 'count') { newBlock = createCountBlock(); }
  else if (blockType === 'multiply-polynomials') { newBlock = createMultiplyPolynomialsBlock();}





         else {
             newBlock = document.createElement('div');
             newBlock.className = 'building-block unknown';
             newBlock.style.backgroundColor = '#f8d7da'; newBlock.style.borderColor = '#f5c6cb';
             newBlock.textContent = `Unknown: ${blockType}`;
             const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×';
             removeBtn.onclick = (e) => { e.stopPropagation(); removeBlock(newBlock); };
             newBlock.appendChild(removeBtn);
             // Mark as initialized here for consistency, even if no listeners added
             newBlock.dataset.initializedBlock = 'true';
             return newBlock; // Return directly
        }

        // Initialize ONLY if block creation was successful (newBlock exists)
        if (newBlock) {
             // Add standard listeners only if it's NOT random-name (which sets its own)
             if (blockType !== 'random-name') {
                  addBlockEventListeners(newBlock);
             }
             // Mark as initialized (already done for unknown/random-name)
             newBlock.dataset.initializedBlock = 'true';
        }
        return newBlock;
     }

     function createCountBlock() {
        const b = document.createElement('div');
        b.className = 'building-block count';
        b.style.backgroundColor = '#e8f9ff';
        b.style.borderColor   = '#90caf9';
        b.tabIndex = 0;
        b.appendChild(document.createTextNode('Count'));
        b.appendChild(makeRemoveBtn());
      
        const cfg = document.createElement('div');
        cfg.className = 'block-config';
        const idBase = `count-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;
        setSafeInnerHTML(cfg, `
          <label for="items-${idBase}">Items (comma‑separated):</label>
          <textarea id="items-${idBase}" rows="2"
                    data-config-key="items"
                    placeholder="1,2,2,3,#x#"></textarea>
          <label for="target-${idBase}">Value to count:</label>
          <input type="text" id="target-${idBase}"
                 data-config-key="target"
                 placeholder="2 or var_y">
          <div class="block-config-actions">
            <button type="button" class="cancel-btn">Cancel</button>
            <button type="button" class="ok-btn">OK</button>
          </div>`);
        b.appendChild(cfg);
        return b;
      }
      



    function createRandomIntBlock() { // MODIFIED: text inputs
        const newBlock = document.createElement('div'); newBlock.className = 'building-block random-int'; newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Random Int'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `randint-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
      setSafeInnerHTML(config, ` <label for="min-${uniqueIdBase}">Min (number or variable):</label> <input type="text" id="min-${uniqueIdBase}" placeholder="e.g., 1 or var_x" value="1" data-config-key="min"> <label for="max-${uniqueIdBase}">Max (number or variable):</label> <input type="text" id="max-${uniqueIdBase}" placeholder="e.g., 10 or var_y" value="10" data-config-key="max"> <label for="exclude-${uniqueIdBase}">Exclude (comma/space separated numbers or variables):</label> <input type="text" id="exclude-${uniqueIdBase}" placeholder="e.g., 3, 5, var_z" data-config-key="exclude"> <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div> `);
        newBlock.appendChild(config); return newBlock;
    }

    function createFractionBlock() { // MODIFIED: text inputs
        const newBlock = document.createElement('div'); newBlock.className = 'building-block fraction'; newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Fraction'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `frac-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        const simplifiedId = `simplified-${uniqueIdBase}`;
       setSafeInnerHTML(config, ` <label>Numerator range (num or var):</label> <div class="range"> <input type="text" placeholder="Min" value="1" data-config-key="numMin" aria-label="Numerator Minimum"> <span>to</span> <input type="text" placeholder="Max" value="10" data-config-key="numMax" aria-label="Numerator Maximum"> </div> <label>Denominator range (num or var):</label> <div class="range"> <input type="text" placeholder="Min" value="2" data-config-key="denMin" aria-label="Denominator Minimum"> <span>to</span> <input type="text" placeholder="Max" value="10" data-config-key="denMax" aria-label="Denominator Maximum"> </div> <div> <input type="checkbox" id="${simplifiedId}" data-config-key="simplified" checked> <label for="${simplifiedId}">Simplified</label> </div> <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div> `);
        newBlock.appendChild(config); return newBlock;
    }

    function createRandomFloatBlock() { // NEW
        const newBlock = document.createElement('div'); newBlock.className = 'building-block random-float'; newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Random Float'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `randflt-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, ` <label for="min-${uniqueIdBase}">Min (number or variable):</label> <input type="text" id="min-${uniqueIdBase}" placeholder="e.g., 0.5 or var_x" value="0" data-config-key="min"> <label for="max-${uniqueIdBase}">Max (number or variable):</label> <input type="text" id="max-${uniqueIdBase}" placeholder="e.g., 9.9 or var_y" value="10" data-config-key="max"> <label for="decimals-${uniqueIdBase}">Decimal Places:</label> <input type="number" id="decimals-${uniqueIdBase}" placeholder="e.g., 2" value="2" data-config-key="decimals" min="0" step="1"> <label for="exclude-${uniqueIdBase}">Exclude (comma/space separated numbers or variables):</label> <input type="text" id="exclude-${uniqueIdBase}" placeholder="e.g., 1.5, 7, var_z" data-config-key="exclude"> <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div> `);
        newBlock.appendChild(config); return newBlock;
    }

    function createChooseBlock() { // NEW
        const newBlock = document.createElement('div'); newBlock.className = 'building-block choose'; newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Choose'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `choose-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
       setSafeInnerHTML(config, `<label for="items-${uniqueIdBase}">Items (comma/semicolon separated numbers, strings, or variables):</label> <textarea id="items-${uniqueIdBase}" placeholder="e.g., apple, 5, var_x; banana" data-config-key="items" rows="3"></textarea> <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div> `);
        newBlock.appendChild(config); return newBlock;
    }

    // --- Block Creation Functions ---

    // ... (keep createRandomIntBlock, createFractionBlock, createRandomFloatBlock, createChooseBlock, createRandomNameBlock) ...

    function createGcdBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block gcd'; // Add specific class
        newBlock.style.backgroundColor = '#f0f0f0'; newBlock.style.borderColor = '#cccccc'; // Example style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('GCD'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `gcd-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, `
            <label for="a-${uniqueIdBase}">Value A (num/var):</label>
            <input type="text" id="a-${uniqueIdBase}" placeholder="e.g., 12 or var_x" data-config-key="a">
            <label for="b-${uniqueIdBase}">Value B (num/var):</label>
            <input type="text" id="b-${uniqueIdBase}" placeholder="e.g., 18 or var_y" data-config-key="b">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

    function createLcmBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block lcm'; // Add specific class
        newBlock.style.backgroundColor = '#f5f5f5'; newBlock.style.borderColor = '#d9d9d9'; // Example style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('LCM'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `lcm-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, `
            <label for="a-${uniqueIdBase}">Value A (num/var):</label>
            <input type="text" id="a-${uniqueIdBase}" placeholder="e.g., 4 or var_x" data-config-key="a">
            <label for="b-${uniqueIdBase}">Value B (num/var):</label>
            <input type="text" id="b-${uniqueIdBase}" placeholder="e.g., 6 or var_y" data-config-key="b">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createChoosePrimeBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block choose-prime'; // Add specific class
        newBlock.style.backgroundColor = '#fffbe6'; newBlock.style.borderColor = '#ffe58f'; // Example style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Choose Prime'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `prime-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, `
            <label for="max-${uniqueIdBase}">Max Value (num/var, e.g., 100):</label>
            <input type="text" id="max-${uniqueIdBase}" placeholder="e.g., 100 or var_limit" value="100" data-config-key="max">
            <label for="exclude-${uniqueIdBase}">Exclude (comma/space separated nums/vars):</label>
            <input type="text" id="exclude-${uniqueIdBase}" placeholder="e.g., 7, 11, var_z" data-config-key="exclude">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createAbsBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block abs'; // Add specific class
        newBlock.style.backgroundColor = '#e6fffb'; newBlock.style.borderColor = '#b3f0e5'; // Example style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Abs Val'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `abs-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, `
            <label for="value-${uniqueIdBase}">Value (num/var):</label>
            <input type="text" id="value-${uniqueIdBase}" placeholder="e.g., -5 or var_x" data-config-key="value">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createQuotientBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block quotient'; // Add specific class
        newBlock.style.backgroundColor = '#f9f0ff'; newBlock.style.borderColor = '#e8c0ff'; // Example style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Quotient'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `quot-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
       setSafeInnerHTML(config, `
            <label for="dividend-${uniqueIdBase}">Dividend (num/var):</label>
            <input type="text" id="dividend-${uniqueIdBase}" placeholder="e.g., 10 or var_a" data-config-key="dividend">
            <label for="divisor-${uniqueIdBase}">Divisor (num/var):</label>
            <input type="text" id="divisor-${uniqueIdBase}" placeholder="e.g., 3 or var_b" data-config-key="divisor">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

     function createRemainderBlock() {
        const newBlock = document.createElement('div'); newBlock.className = 'building-block remainder'; // Add specific class
        newBlock.style.backgroundColor = '#fff2f0'; newBlock.style.borderColor = '#ffccc7'; // Example style
        newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Remainder'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×'; newBlock.appendChild(removeBtn);
        const config = document.createElement('div'); config.className = 'block-config';
        const uniqueIdBase = `rem-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        setSafeInnerHTML(config, `
            <label for="dividend-${uniqueIdBase}">Dividend (num/var):</label>
            <input type="text" id="dividend-${uniqueIdBase}" placeholder="e.g., 10 or var_a" data-config-key="dividend">
            <label for="divisor-${uniqueIdBase}">Divisor (num/var):</label>
            <input type="text" id="divisor-${uniqueIdBase}" placeholder="e.g., 3 or var_b" data-config-key="divisor">
            <div class="block-config-actions"> <button type="button" class="cancel-btn">Cancel</button> <button type="button" class="ok-btn">OK</button> </div>
        `);
        newBlock.appendChild(config); return newBlock;
    }

    function createRandomNameBlock() { // NEW
        const newBlock = document.createElement('div'); newBlock.className = 'building-block random-name'; newBlock.tabIndex = 0;
        newBlock.appendChild(document.createTextNode('Random Name'));
        const removeBtn = document.createElement('span'); removeBtn.className = 'block-remove'; removeBtn.textContent = '×';
        removeBtn.onclick = (e) => { e.stopPropagation(); removeBlock(newBlock); }; // Direct listener
        newBlock.appendChild(removeBtn);
        newBlock.onkeydown = (e) => { // Direct listener
             if ((e.key === 'Delete' || e.key === 'Backspace')) { removeBlock(newBlock); }
        };
        return newBlock;
    }

    // --- Helper Functions ---
    function createEditableSpan(initialContent = '') { /* ... (unchanged) ... */ const span = document.createElement('span'); span.className = 'equation-text'; span.contentEditable = true; span.onclick = () => span.focus(); span.textContent = initialContent; return span; }
    function focusElement(element, offset = 0) { /* ... (unchanged) ... */ if (!element) return; setTimeout(() => { const range = document.createRange(); const sel = window.getSelection(); const targetNode = element.firstChild || element; const maxOffset = (targetNode?.nodeType === Node.TEXT_NODE) ? targetNode.length : (element.childNodes ? element.childNodes.length : 0); const finalOffset = Math.min(Math.max(0, offset), maxOffset); try { if(targetNode) { range.setStart(targetNode, finalOffset); range.collapse(true); sel.removeAllRanges(); sel.addRange(range); } else { element.focus(); } if (element.focus && document.activeElement !== element) { element.focus({ preventScroll: true }); } } catch (e) { console.error("Error setting focus:", e); if (element.focus) element.focus(); } }, 0); }
    function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); while(b) {[a, b] = [b, a % b];} return a; }

    function computeGCD(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    while (b) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

function __computeAddPolynomials(config, context) {
    try {
        // Parse config JSON if needed
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("AddPolynomials: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }

        // Extract poly1 & poly2 (or resolve variables)
        let poly1 = parsedConfig.poly1 || '';
        let poly2 = parsedConfig.poly2 || '';
        
        // Carefully resolve variables from context
        if (context) {
            // First polynomial resolution
            const poly1Trimmed = poly1.trim();
            if (context.hasOwnProperty(poly1Trimmed)) {
                const resolvedValue = context[poly1Trimmed];
                // Convert whatever type to a string representation
                if (typeof resolvedValue === 'object' && resolvedValue !== null) {
                    // For objects that have a toString method, use it
                    poly1 = String(resolvedValue);
                } else {
                    // For primitive types
                    poly1 = String(resolvedValue);
                }
                console.log(`Resolved variable ${poly1Trimmed} to: ${poly1}`);
            }
            
            // Second polynomial resolution
            const poly2Trimmed = poly2.trim();
            if (context.hasOwnProperty(poly2Trimmed)) {
                const resolvedValue = context[poly2Trimmed];
                // Convert whatever type to a string representation
                if (typeof resolvedValue === 'object' && resolvedValue !== null) {
                    // For objects that have a toString method, use it
                    poly2 = String(resolvedValue);
                } else {
                    // For primitive types
                    poly2 = String(resolvedValue);
                }
                console.log(`Resolved variable ${poly2Trimmed} to: ${poly2}`);
            }
        }
        
        if (!poly1 || !poly2) {
            return "Error: Missing polynomial input";
        }

        // Helper function to parse a polynomial string into term objects
        function parsePolynomial(polyStr) {
            polyStr = polyStr.trim();
            
            // Handle empty string or just a number
            if (!polyStr) return [];
            if (/^[+-]?\d+(\.\d+)?$/.test(polyStr)) {
                // It's just a constant
                return [{
                    coefficient: parseFloat(polyStr),
                    xPower: 0,
                    yPower: 0
                }];
            }
            
            // Remove outer parentheses if present
            if (polyStr.startsWith('(') && polyStr.endsWith(')')) {
                polyStr = polyStr.slice(1, -1).trim();
            }
            
            // Handle special case - if it looks like a constant term wrapped in an object
            // E.g. if the value was returned from a previous calculation and is displayed like "[object Object]"
            if (polyStr.includes("[object Object]")) {
                console.warn("Received unexpected object notation:", polyStr);
                return [{
                    coefficient: 0,
                    xPower: 0,
                    yPower: 0
                }];
            }
            
            const terms = [];
            let curr = '', sign = '';
            for (let i = 0; i < polyStr.length; i++) {
                const ch = polyStr[i];
                if ((ch === '+' || ch === '-') && i > 0 && !'+-*/^('.includes(polyStr[i-1])) {
                    if (curr) terms.push((sign + curr).trim());
                    sign = ch; curr = '';
                } else {
                    if (i === 0 && (ch === '+' || ch === '-')) sign = ch;
                    else curr += ch;
                }
            }
            if (curr) terms.push((sign + curr).trim());

            return terms.map(term => {
                let coef = 1, xPow = 0, yPow = 0;
                
                // Handle empty term or just a sign
                if (!term || term === '+' || term === '-') {
                    return { coefficient: term === '-' ? -1 : 1, xPower: 0, yPower: 0 };
                }
                
                if (term.startsWith('-')) { coef = -1; term = term.slice(1).trim(); }
                else if (term.startsWith('+')) term = term.slice(1).trim();

                // If term is just a number
                if (/^[0-9.]+$/.test(term)) {
                    coef *= parseFloat(term);
                    term = '';
                } 
                // If term starts with a number followed by x or y
                else if (term.match(/^[0-9.]+[xy]/)) {
                    const m = term.match(/^([0-9.]+)(.*)$/);
                    coef *= parseFloat(m[1]);
                    term = m[2];
                }
                // If term is just 'x' or 'y' without coefficient
                else if (term === 'x') {
                    xPow = 1;
                    term = '';
                }
                else if (term === 'y') {
                    yPow = 1;
                    term = '';
                }

                // Parse x power
                const xm = term.match(/x\^?([0-9]*)/);
                if (xm) {
                    xPow = xm[1] ? parseInt(xm[1]) : 1;
                    // Remove the x term from the string to avoid double counting
                    term = term.replace(xm[0], '');
                }
                
                // Parse y power
                const ym = term.match(/y\^?([0-9]*)/);
                if (ym) {
                    yPow = ym[1] ? parseInt(ym[1]) : 1;
                }

                return { coefficient: coef, xPower: xPow, yPower: yPow };
            });
        }

        function addPolynomials(t1, t2) {
            // Combine all terms into one array
            const allTerms = [...t1, ...t2];
            
            // Group by powers and combine coefficients
            const combinedTerms = [];
            const termMap = new Map();
            
            for (const term of allTerms) {
                const key = `${term.xPower},${term.yPower}`;
                if (!termMap.has(key)) {
                    termMap.set(key, { ...term });
                    combinedTerms.push(termMap.get(key));
                } else {
                    termMap.get(key).coefficient += term.coefficient;
                }
            }
            
            // Remove terms with zero coefficients
            return combinedTerms.filter(t => Math.abs(t.coefficient) > 1e-10);
        }

        // Format a single term back to string
        function formatTerm(t) {
            // Skip terms with zero coefficient
            if (Math.abs(t.coefficient) < 1e-10) return '';
            
            const absCoef = Math.abs(t.coefficient);
            let s = '';
            
            // Determine if we need to show the coefficient
            const showCoef = absCoef !== 1 || (t.xPower === 0 && t.yPower === 0);
            
            if (showCoef) {
                // Format the coefficient to avoid scientific notation
                if (Number.isInteger(absCoef)) {
                    s += absCoef;
                } else {
                    // For decimal coefficients, limit to a reasonable precision
                    s += absCoef.toFixed(6).replace(/\.?0+$/, '');
                }
            }
            
            // Add x term if present
            if (t.xPower > 0) {
                if (s && s !== '1') s += '*';
                s += 'x' + (t.xPower > 1 ? '^' + t.xPower : '');
            }
            
            // Add y term if present
            if (t.yPower > 0) {
                if (s && s !== '1') s += '*';
                s += 'y' + (t.yPower > 1 ? '^' + t.yPower : '');
            }
            
            // If nothing was added but there's a non-zero coefficient
            if (s === '' && absCoef === 1) {
                return '1';
            }
            
            return s;
        }

        // Turn an array of terms into one polynomial string
        function formatPolynomial(terms) {
            if (!terms.length) return '0';
            
            // Sort terms by power (highest to lowest)
            terms.sort((a,b) => {
                // First sort by x power
                if (b.xPower !== a.xPower) return b.xPower - a.xPower;
                // Then by y power
                return b.yPower - a.yPower;
            });
            
            let res = '';
            for (let i = 0; i < terms.length; i++) {
                const t = terms[i];
                
                // Skip terms with zero coefficient
                if (Math.abs(t.coefficient) < 1e-10) continue;
                
                const ft = formatTerm(t);
                if (!ft) continue;
                
                // First term
                if (res === '') {
                    if (t.coefficient < 0) {
                        res = '-' + ft;
                    } else {
                        res = ft;
                    }
                } 
                // Subsequent terms
                else {
                    if (t.coefficient < 0) {
                        res += ' - ' + ft;
                    } else {
                        res += ' + ' + ft;
                    }
                }
            }
            
            return res || '0';
        }

        // Parse both polynomials
        try {
            const p1 = parsePolynomial(poly1);
            const p2 = parsePolynomial(poly2);
            
            console.log("Parsed polynomial 1:", p1);
            console.log("Parsed polynomial 2:", p2);
            
            // Add them and return the result
            const result = formatPolynomial(addPolynomials(p1, p2));
            console.log("Result:", result);
            return result;
        } catch (parseError) {
            console.error("Error parsing polynomials:", parseError);
            return `Error parsing: ${parseError.message}`;
        }

    } catch (err) {
        console.error("AddPolynomials error:", err);
        return "Error: " + err.message;
    }
}

function __computeMultiplyPolynomials(config, context) {
    try {
        // Parse config JSON if needed
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("MultiplyPolynomials: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }

        // Extract poly1 & poly2 (or resolve variables) - Enhanced resolution
        let poly1 = parsedConfig.poly1 || '';
        let poly2 = parsedConfig.poly2 || '';
        
        // Carefully resolve variables from context
        if (context) {
            // First polynomial resolution
            const poly1Trimmed = poly1.trim();
            if (context.hasOwnProperty(poly1Trimmed)) {
                const resolvedValue = context[poly1Trimmed];
                // Convert whatever type to a string representation
                if (typeof resolvedValue === 'object' && resolvedValue !== null) {
                    // For objects that have a toString method, use it
                    poly1 = String(resolvedValue);
                } else {
                    // For primitive types
                    poly1 = String(resolvedValue);
                }
                console.log(`Multiply Polynomials: Resolved variable ${poly1Trimmed} to: ${poly1}`);
            }
            
            // Second polynomial resolution
            const poly2Trimmed = poly2.trim();
            if (context.hasOwnProperty(poly2Trimmed)) {
                const resolvedValue = context[poly2Trimmed];
                // Convert whatever type to a string representation
                if (typeof resolvedValue === 'object' && resolvedValue !== null) {
                    // For objects that have a toString method, use it
                    poly2 = String(resolvedValue);
                } else {
                    // For primitive types
                    poly2 = String(resolvedValue);
                }
                console.log(`Multiply Polynomials: Resolved variable ${poly2Trimmed} to: ${poly2}`);
            }
        }
        
        if (!poly1 || !poly2) {
            return "Error: Missing polynomial input";
        }

        // Manual expansion helper (unlimited terms) - Enhanced parsing
        function expandPolynomials(a, b) {
            // Parse a single polynomial string into term objects - Enhanced version
            function parsePolynomial(polyStr) {
                polyStr = polyStr.trim();
                
                // Handle empty string or just a number
                if (!polyStr) return [];
                if (/^[+-]?\d+(\.\d+)?$/.test(polyStr)) {
                    // It's just a constant
                    return [{
                        coefficient: parseFloat(polyStr),
                        xPower: 0,
                        yPower: 0
                    }];
                }
                
                // Remove outer parentheses if present
                if (polyStr.startsWith('(') && polyStr.endsWith(')')) {
                    polyStr = polyStr.slice(1, -1).trim();
                }
                
                // Handle special case - if it looks like a constant term wrapped in an object
                if (polyStr.includes("[object Object]")) {
                    console.warn("Multiply Polynomials: Received unexpected object notation:", polyStr);
                    return [{
                        coefficient: 0,
                        xPower: 0,
                        yPower: 0
                    }];
                }
                
                const terms = [];
                let curr = '', sign = '';
                for (let i = 0; i < polyStr.length; i++) {
                    const ch = polyStr[i];
                    if ((ch === '+' || ch === '-') && i > 0 && !'+-*/^('.includes(polyStr[i-1])) {
                        if (curr) terms.push((sign + curr).trim());
                        sign = ch; curr = '';
                    } else {
                        if (i === 0 && (ch === '+' || ch === '-')) sign = ch;
                        else curr += ch;
                    }
                }
                if (curr) terms.push((sign + curr).trim());

                return terms.map(term => {
                    let coef = 1, xPow = 0, yPow = 0;
                    
                    // Handle empty term or just a sign
                    if (!term || term === '+' || term === '-') {
                        return { coefficient: term === '-' ? -1 : 1, xPower: 0, yPower: 0 };
                    }
                    
                    if (term.startsWith('-')) { coef = -1; term = term.slice(1).trim(); }
                    else if (term.startsWith('+')) term = term.slice(1).trim();

                    // If term is just a number
                    if (/^[0-9.]+$/.test(term)) {
                        coef *= parseFloat(term);
                        term = '';
                    } 
                    // If term starts with a number followed by x or y
                    else if (term.match(/^[0-9.]+[xy]/)) {
                        const m = term.match(/^([0-9.]+)(.*)$/);
                        coef *= parseFloat(m[1]);
                        term = m[2];
                    }
                    // If term is just 'x' or 'y' without coefficient
                    else if (term === 'x') {
                        xPow = 1;
                        term = '';
                    }
                    else if (term === 'y') {
                        yPow = 1;
                        term = '';
                    }

                    // Parse x power
                    const xm = term.match(/x\^?([0-9]*)/);
                    if (xm) {
                        xPow = xm[1] ? parseInt(xm[1]) : 1;
                        // Remove the x term from the string to avoid double counting
                        term = term.replace(xm[0], '');
                    }
                    
                    // Parse y power
                    const ym = term.match(/y\^?([0-9]*)/);
                    if (ym) {
                        yPow = ym[1] ? parseInt(ym[1]) : 1;
                    }

                    return { coefficient: coef, xPower: xPow, yPower: yPow };
                });
            }

            // Multiply two arrays of term objects
            function multiplyPolynomials(t1, t2) {
                const out = [];
                for (const a of t1) {
                    for (const b of t2) {
                        const nt = {
                            coefficient: a.coefficient * b.coefficient,
                            xPower: a.xPower + b.xPower,
                            yPower: a.yPower + b.yPower
                        };
                        let merged = false;
                        for (const ex of out) {
                            if (ex.xPower === nt.xPower && ex.yPower === nt.yPower) {
                                ex.coefficient += nt.coefficient;
                                merged = true;
                                break;
                            }
                        }
                        if (!merged && Math.abs(nt.coefficient) > 1e-10) out.push(nt);
                    }
                }
                return out.filter(t => Math.abs(t.coefficient) > 1e-10);
            }

            // Format a single term back to string - Enhanced version
            function formatTerm(t) {
                // Skip terms with zero coefficient
                if (Math.abs(t.coefficient) < 1e-10) return '';
                
                const absCoef = Math.abs(t.coefficient);
                let s = '';
                
                // Determine if we need to show the coefficient
                const showCoef = absCoef !== 1 || (t.xPower === 0 && t.yPower === 0);
                
                if (showCoef) {
                    // Format the coefficient to avoid scientific notation
                    if (Number.isInteger(absCoef)) {
                        s += absCoef;
                    } else {
                        // For decimal coefficients, limit to a reasonable precision
                        s += absCoef.toFixed(6).replace(/\.?0+$/, '');
                    }
                }
                
                // Add x term if present
                if (t.xPower > 0) {
                    if (s && s !== '1') s += '*';
                    s += 'x' + (t.xPower > 1 ? '^' + t.xPower : '');
                }
                
                // Add y term if present
                if (t.yPower > 0) {
                    if (s && s !== '1') s += '*';
                    s += 'y' + (t.yPower > 1 ? '^' + t.yPower : '');
                }
                
                // If nothing was added but there's a non-zero coefficient
                if (s === '' && absCoef === 1) {
                    return '1';
                }
                
                return s;
            }

            // Turn an array of terms into one polynomial string - Enhanced version
            function formatPolynomial(terms) {
                if (!terms.length) return '0';
                
                // Sort terms by power (highest to lowest)
                terms.sort((a,b) => {
                    // First sort by x power
                    if (b.xPower !== a.xPower) return b.xPower - a.xPower;
                    // Then by y power
                    return b.yPower - a.yPower;
                });
                
                let res = '';
                for (let i = 0; i < terms.length; i++) {
                    const t = terms[i];
                    
                    // Skip terms with zero coefficient
                    if (Math.abs(t.coefficient) < 1e-10) continue;
                    
                    const ft = formatTerm(t);
                    if (!ft) continue;
                    
                    // First term
                    if (res === '') {
                        if (t.coefficient < 0) {
                            res = '-' + ft;
                        } else {
                            res = ft;
                        }
                    } 
                    // Subsequent terms
                    else {
                        if (t.coefficient < 0) {
                            res += ' - ' + ft;
                        } else {
                            res += ' + ' + ft;
                        }
                    }
                }
                
                return res || '0';
            }

            // Parse both polynomials and multiply them
            try {
                const p1 = parsePolynomial(a);
                const p2 = parsePolynomial(b);
                
                console.log("Multiply Polynomials: Parsed polynomial 1:", p1);
                console.log("Multiply Polynomials: Parsed polynomial 2:", p2);
                
                const result = formatPolynomial(multiplyPolynomials(p1, p2));
                console.log("Multiply Polynomials: Result:", result);
                return result;
            } catch (parseError) {
                console.error("Multiply Polynomials: Error parsing polynomials:", parseError);
                return `Error parsing: ${parseError.message}`;
            }
        }

        // Run the expansion and return it
        return expandPolynomials(poly1, poly2);

    } catch (err) {
        console.error("MultiplyPolynomials error:", err);
        return "Error: " + err.message;
    }
}


function __computePolynomialZeros(config, context) {
  try {
    // 1) parse config:
    let pc = config;
    if (typeof config === 'string') {
      try { pc = JSON.parse(config); }
      catch (e) { return "Error: Invalid configuration"; }
    }
    const coeffsStr    = pc.coeffs    || '';
    const includeCplx  = pc.includeComplex === true;
    const rootVar      = (pc.rootVar || '').trim();   // ← the new prefix

    // 2) resolve from context var if needed:
    let cs = coeffsStr;
    if (context && context.hasOwnProperty(cs.trim())) {
      const v = context[cs.trim()];
      if (Array.isArray(v)) cs = v.join(',');
      else if (typeof v === 'string') cs = v;
    }

    // 3) parse numbers & drop leading zeros
    let coeffs = cs.split(/\s*,\s*/).map(c => {
      const n = parseFloat(c);
      if (!isFinite(n)) throw new Error("Bad coefficient: "+c);
      return n;
    });
    while (coeffs[0] === 0) coeffs.shift();

    if (coeffs.length < 2) {
      return coeffs.length===0
        ? "Error: No valid coefficients"
        : "Error: Constant polynomial has no zeros";
    }

    // 4) sanity checks
    if (coeffs.length > 7) return "Error: Degree too large (max 6)";
    if (coeffs.some(c=>Math.abs(c)>1e10))
      return "Error: Coeff too large";

    const deg = coeffs.length - 1;
    let zeros = [];

    // 5) handle deg 1 & 2:
    if (deg === 1) {
      const [a,b] = coeffs;
      if (a===0) return "Error: Leading zero";
      zeros.push(-b/a);
    }
    else if (deg === 2) {
      const [a,b,c] = coeffs;
      if (a===0) return "Error: Leading zero";
      const D = b*b - 4*a*c;
      if      (D>0) {
        const s = Math.sqrt(D);
        zeros.push((-b+s)/(2*a), (-b-s)/(2*a));
      }
      else if (Math.abs(D)<1e-10) {
        zeros.push(-b/(2*a));
      }
      else if (includeCplx) {
        const re = -b/(2*a), im = Math.sqrt(-D)/(2*a);
        zeros.push(formatComplexNumber(re, im),
                   formatComplexNumber(re,-im));
      }
      else {
        return "No real zeros. Enable complex.";
      }
    }

    // 6) deg ≥3: math.js → polynomial-roots → numeric real-only
    else {
      let libraryZeros = null;
      if (window.math?.roots) {
        libraryZeros = math.roots(coeffs);
      }
      else if (window.PolynomialRoots?.findRoots) {
        libraryZeros = PolynomialRoots.findRoots(coeffs);
      }
      else if (!includeCplx) {
        libraryZeros = findPolynomialRootsNumerically(coeffs, false);
      }
      else {
        return "Error: No complex-capable solver loaded.";
      }

      zeros = (libraryZeros||[]).map(z => {
        let re, im=0;
        if (typeof z==='number') re = z;
        else { re=z.re; im=z.im; }
        if (Math.abs(im)<1e-10)   return re;
        if (includeCplx)         return formatComplexNumber(re,im);
      }).filter(x=>x!==undefined);
    }

    // 7) sort
    zeros.sort((A,B)=>{
      const aC = String(A).includes('i'),
            bC = String(B).includes('i');
      if (!aC&&!bC) return A-B;
      if ( aC&& bC) return String(A).localeCompare(String(B));
      return aC?1:-1;
    });

    // 8) store into context:
    context.__result = zeros;
    zeros.forEach((r,i)=>{
      context[`__result${i+1}`] = r;
      if (rootVar) {
        context[`${rootVar}${i+1}`] = r;
      }
    });

    // 9) return display string
    return zeros
      .map(z=> typeof z==='string'? z : formatNumber(z))
      .join(", ");
  }
  catch(e){
    console.error(e);
    return "Error: "+e.message;
  }
}


// ── Helpers ── //

function formatComplexNumber(real, imag) {
  real = formatNumber(real);
  imag = formatNumber(Math.abs(imag));
  if (Math.abs(real) < 1e-10) {
    // pure imaginary
    if (Math.abs(imag - 1) < 1e-10) return imag >= 0 ? "i" : "-i";
    if (Math.abs(imag) < 1e-10)      return "0";
    return imag >= 0 ? imag + "i" : "-" + imag + "i";
  }
  if (Math.abs(imag) < 1e-10) {
    // pure real
    return real.toString();
  }
  // mixed
  const sign = imag >= 0 ? " + " : " - ";
  const mag  = Math.abs(imag);
  const part = Math.abs(mag - 1) < 1e-10 ? "i" : mag + "i";
  return real + sign + part;
}

function formatNumber(num) {
  if (Math.abs(num) < 1e-10)                return 0;
  if (Math.abs(num - Math.round(num)) < 1e-10) return Math.round(num);
  return parseFloat(num.toFixed(6));
}

function findPolynomialRootsNumerically(coeffs, includeComplex) {
  function evalPoly(x) {
    return coeffs.reduce((sum, c, i) => sum + c * Math.pow(x, coeffs.length - 1 - i), 0);
  }
  function findReal(min, max, steps = 1000) {
    const roots = [], step = (max - min) / steps, TOL = 1e-10;
    for (let i = 0; i < steps; i++) {
      const x1 = min + i*step, x2 = x1 + step;
      const y1 = evalPoly(x1), y2 = evalPoly(x2);
      if (Math.abs(y1) < TOL) {
        if (!roots.some(r => Math.abs(r - x1) < TOL)) roots.push(x1);
        continue;
      }
      if (y1 * y2 < 0) {
        let a = x1, b = x2, fa = y1, fb = y2, iter = 0;
        while (Math.abs(b - a) > TOL && iter++ < 100) {
          const c = 0.5*(a + b), fc = evalPoly(c);
          if (Math.abs(fc) < TOL) { a = b = c; break; }
          if (fa * fc < 0) { b = c; fb = fc; }
          else             { a = c; fa = fc; }
        }
        const root = 0.5*(a + b);
        if (!roots.some(r => Math.abs(r - root) < TOL)) roots.push(root);
      }
    }
    return roots;
  }

  if (!includeComplex) {
    const range = Math.max(10, 100 / Math.abs(coeffs[0]));
    return findReal(-range, range);
  }
  console.warn("Complex numerical solver not implemented");
  return findReal(-100, 100);
}


// Helper function to format numbers, avoiding scientific notation
function formatNumber(num, returnType = 'auto') {
    // For very small numbers close to zero, return 0
    if (Math.abs(num) < 1e-10) {
        return returnType === 'string' ? "0" : 0;
    }
    
    // For integers or numbers close to integers
    if (Math.abs(num - Math.round(num)) < 1e-10) {
        const rounded = Math.round(num);
        return returnType === 'string' ? rounded.toString() : rounded;
    }
    
    // For decimal numbers, limit to 6 decimal places
    if (returnType === 'string') {
        // Return as string with trailing zeros removed
        return num.toFixed(6).replace(/\.?0+$/, '');
    } else if (returnType === 'number') {
        // Return as number
        return parseFloat(num.toFixed(6));
    } else {
        // Auto mode - return string for better display formatting
        const formatted = num.toFixed(6).replace(/\.?0+$/, '');
        return formatted;
    }
}


function __computeSyntheticDivision(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("SyntheticDivision: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get coefficients, r, and variable name from config
        let coeffsStr = parsedConfig.coeffs || '';
        let rootStr = parsedConfig.root || '0';
        let variableName = (parsedConfig.variable || 'x').trim().substring(0, 10); // Limit variable name length for safety
        
        // Validate and sanitize variable names for output variables
        let quotientVarName = '';
        if (parsedConfig.quotientVar && typeof parsedConfig.quotientVar === 'string') {
            quotientVarName = parsedConfig.quotientVar.trim();
            // Only allow alphanumeric variable names with underscores
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(quotientVarName)) {
                console.warn("SyntheticDivision: Invalid quotient variable name, ignoring.");
                quotientVarName = '';
            }
        }
        
        let remainderVarName = '';
        if (parsedConfig.remainderVar && typeof parsedConfig.remainderVar === 'string') {
            remainderVarName = parsedConfig.remainderVar.trim();
            // Only allow alphanumeric variable names with underscores
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(remainderVarName)) {
                console.warn("SyntheticDivision: Invalid remainder variable name, ignoring.");
                remainderVarName = '';
            }
        }
        
        // Check if inputs are variable references and resolve them
        if (context && context.hasOwnProperty(coeffsStr.trim())) {
            const resolved = context[coeffsStr.trim()];
            if (Array.isArray(resolved)) {
                // If it's already an array, use it directly
                coeffsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                // If it's a string, use it as is (it'll be parsed later)
                coeffsStr = resolved;
            }
        }
        
        // Resolve the root value if it's a variable
        const rootVal = resolveValue(rootStr, context);
        if (typeof rootVal !== 'number' || !isFinite(rootVal)) {
            return "Error: Invalid root value";
        }
        
        // Parse the coefficients into an array of numbers
        let coeffs = [];
        try {
            coeffs = coeffsStr.split(/\s*,\s*/)
                .map(c => {
                    const val = parseFloat(c.trim());
                    if (isNaN(val) || !isFinite(val)) {
                        throw new Error("Invalid coefficient: " + c.trim());
                    }
                    return val;
                });
                
            // Remove leading zeros (coefficients of zero for highest powers)
            while (coeffs.length > 0 && Math.abs(coeffs[0]) < 1e-10) {
                coeffs.shift();
            }
            
        } catch (err) {
            return "Error parsing coefficients: " + err.message;
        }
        
        // Limit the size of the polynomial for performance and security
        const MAX_DEGREE = 100; // Maximum degree of polynomial to process
        if (coeffs.length > MAX_DEGREE + 1) {
            return `Error: Polynomial degree too large (max: ${MAX_DEGREE})`;
        }
        
        if (coeffs.length < 2) {
            return "Error: Need at least 2 coefficients for a valid polynomial";
        }
        
        // Check for extremely large coefficients that might cause numerical issues
        const MAX_COEFF_VALUE = 1e15; // Maximum absolute value for coefficients
        for (const coeff of coeffs) {
            if (Math.abs(coeff) > MAX_COEFF_VALUE) {
                return `Error: Coefficient value too large (max: ${MAX_COEFF_VALUE})`;
            }
        }
        
        // Performance timeout control for potentially expensive calculations
        const startTime = Date.now();
        const TIMEOUT_MS = 1000; // 1 second timeout
        
        // Perform synthetic division
        const n = coeffs.length;
        const result = new Array(n);
        result[0] = coeffs[0];
        
        for (let i = 1; i < n; i++) {
            // Check for timeout on each iteration for large polynomials
            if (n > 50 && (Date.now() - startTime > TIMEOUT_MS)) {
                return "Error: Calculation timeout - polynomial may be too large";
            }
            
            result[i] = coeffs[i] + rootVal * result[i-1];
            
            // Check for overflow in calculations
            if (!isFinite(result[i])) {
                return "Error: Numeric overflow in calculation";
            }
        }
        
        // Extract the quotient and remainder
        const quotient = result.slice(0, n-1);
        const remainder = result[n-1];
        
        // Format the quotient as a polynomial string
        let quotientStr = formatPolynomial(quotient, variableName);
        
        // Create the full result string including remainder term if non-zero
        let fullResult = quotientStr;
        if (Math.abs(remainder) > 1e-10) { // Use epsilon for floating point comparison
            // Format the remainder term with proper sign
            if (remainder > 0) {
                fullResult += ` + ${formatNumber(remainder)}`;
            } else {
                fullResult += ` - ${formatNumber(Math.abs(remainder))}`;
            }
            
            // Add the denominator (x-r)
            if (rootVal >= 0) {
                fullResult += `/(${variableName}-${formatNumber(rootVal)})`;
            } else {
                fullResult += `/(${variableName}+${formatNumber(Math.abs(rootVal))})`;
            }
        }
        
        // Store the quotient and remainder in the context if variable names are provided
        if (quotientVarName) {
            context[quotientVarName] = quotientStr;
        }
        
        if (remainderVarName) {
            context[remainderVarName] = remainder;
        }
        
        // Return the constructed result
        return fullResult;
    } catch (e) {
        console.error("SyntheticDivision: Error:", e);
        return "Error: " + e.message;
    }
}


// Helper function to format a coefficient array as a polynomial string
function formatPolynomial(coeffs, variableName) {
    if (!coeffs || coeffs.length === 0) return "0";
    
    // Safety check for non-finite values
    for (let i = 0; i < coeffs.length; i++) {
        if (!isFinite(coeffs[i])) {
            return "Error: Non-finite coefficient detected";
        }
    }
    
    let polyStr = '';
    for (let i = 0; i < coeffs.length; i++) {
        const coeff = coeffs[i];
        if (Math.abs(coeff) < 1e-10) continue; // Skip effectively zero coefficients
        
        const power = coeffs.length - i - 1;
        
        // Add plus sign if not the first term and coefficient is positive
        if (polyStr.length > 0 && coeff > 0) {
            polyStr += ' + ';
        } else if (polyStr.length > 0 && coeff < 0) {
            polyStr += ' - ';
        } else if (coeff < 0) {
            polyStr += '-';
        }
        
        // Add coefficient (absolute value if not the first term)
        const coeffAbs = Math.abs(coeff);
        
        // Format the coefficient to avoid scientific notation and excess decimals
        let formattedCoeff = formatNumber(coeffAbs);
            
        // Don't show coefficient 1 unless it's the constant term
        if (coeffAbs !== 1 || power === 0) {
            polyStr += formattedCoeff;
        }
        
        // Add variable and power
        if (power > 0) {
            polyStr += variableName;
            if (power > 1) {
                polyStr += `^${power}`;
            }
        }
    }
    
    // Handle case where all coefficients are zero (or effectively zero)
    if (polyStr === '') {
        polyStr = '0';
    }
    
    return polyStr;
}



function __computePermutation(n, r) {
    try {
        // Parse inputs to numbers
        const nVal = typeof n === 'number' ? n : parseFloat(n);
        const rVal = typeof r === 'number' ? r : parseFloat(r);
        
        // Validate inputs
        if (isNaN(nVal) || !Number.isInteger(nVal) || nVal < 0) {
            return "Error: n must be a non-negative integer";
        }
        
        if (isNaN(rVal) || !Number.isInteger(rVal) || rVal < 0) {
            return "Error: r must be a non-negative integer";
        }
        
        if (rVal > nVal) {
            return "Error: r cannot be greater than n";
        }
        
        // Add upper bounds to prevent integer overflow and performance issues
        const MAX_VALUE = 60; // Factorial limit for safe JavaScript integer calculations
        if (nVal > MAX_VALUE) {
            return `Error: n value too large (max: ${MAX_VALUE})`;
        }
        
        // Optimization: if r is 0, result is 1
        if (rVal === 0) return 1;
        
        // Calculate permutation: P(n,r) = n!/(n-r)!
        let result = 1;
        for (let i = nVal; i > nVal - rVal; i--) {
            result *= i;
            
            // Check for overflow
            if (!isFinite(result)) {
                return "Error: Calculation result too large";
            }
        }
        
        return result;
    } catch (e) {
        console.error("Permutation calculation error:", e);
        return "Error: " + e.message;
    }
}

function __computeCombination(n, r) {
    try {
        // Parse inputs to numbers
        const nVal = typeof n === 'number' ? n : parseFloat(n);
        const rVal = typeof r === 'number' ? r : parseFloat(r);
        
        // Validate inputs
        if (isNaN(nVal) || !Number.isInteger(nVal) || nVal < 0) {
            return "Error: n must be a non-negative integer";
        }
        
        if (isNaN(rVal) || !Number.isInteger(rVal) || rVal < 0) {
            return "Error: r must be a non-negative integer";
        }
        
        if (rVal > nVal) {
            return "Error: r cannot be greater than n";
        }
        
        const MAX_N_COMBINATION = 60; // You can adjust this value if needed (e.g., 50 or 70)
if (nVal > MAX_N_COMBINATION) {
    return `Error: n value too large for combination (max: ${MAX_N_COMBINATION})`;
}
        // Calculate combination: C(n,r) = n!/[r!(n-r)!]
        // Use the smaller of r and (n-r) to optimize calculation
        const k = Math.min(rVal, nVal - rVal);
        let result = 1;
        
        // Calculate the numerator and divide by the denominator simultaneously
        for (let i = 1; i <= k; i++) {
            result = result * (nVal - k + i) / i;
        }
        
        if (!isFinite(result) || result > Number.MAX_SAFE_INTEGER) {
    return "Error: Combination result too large";
}
return Math.round(result);
    } catch (e) {
        console.error("Combination calculation error:", e);
        return "Error: " + e.message;
    }
}

function __computePythTripleMultiples(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PythTripleMultiples: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Common Pythagorean triples
        const commonTriples = [
            [3, 4, 5],
            [5, 12, 13],
            [8, 15, 17],
            [7, 24, 25],
            [20, 21, 29],
            [12, 35, 37],
            [9, 40, 41],
            [28, 45, 53]
        ];
        
        // Get selected triples
        const selectedTriples = [];
        for (let i = 0; i < commonTriples.length; i++) {
            const key = `triple${i}`;
            if (parsedConfig[key] === true) {
                selectedTriples.push(commonTriples[i]);
            }
        }
        
        // If no triples selected, use the first one as default
        if (selectedTriples.length === 0) {
            selectedTriples.push(commonTriples[0]);
        }
        
        // Get factor range
        let minFactor = parseInt(parsedConfig.minFactor || '1');
        let maxFactor = parseInt(parsedConfig.maxFactor || '5');
        
        // Validate factor range
        if (isNaN(minFactor)) minFactor = 1;
        if (isNaN(maxFactor)) maxFactor = 5;
        
        // Ensure min <= max
        if (minFactor > maxFactor) {
            [minFactor, maxFactor] = [maxFactor, minFactor];
        }
        
        // Clamp to allowed range
        minFactor = Math.max(-100, Math.min(100, minFactor));
        maxFactor = Math.max(-100, Math.min(100, maxFactor));
        
        // Select a random triple from the selected ones
        const selectedTriple = selectedTriples[Math.floor(Math.random() * selectedTriples.length)];
        
        // Select a random factor
        const factor = Math.floor(Math.random() * (maxFactor - minFactor + 1)) + minFactor;
        
        // Calculate the scaled triple
        const scaledTriple = selectedTriple.map(val => val * factor);
        
        // Return an object with the triple values and formatted string
        return {
            type: 'PythagoreanTriple',
            a: scaledTriple[0],
            b: scaledTriple[1],
            c: scaledTriple[2],
            originalTriple: selectedTriple,
            factor: factor,
            toString: function() {
                return `${this.a}-${this.b}-${this.c}`;
            }
        };
    } catch (e) {
        console.error("PythTripleMultiples: Error:", e);
        return "Error: " + e.message;
    }
}

function __computePythagoreanTriple(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PythagoreanTriple: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // List of common Pythagorean triples (a, b, c) where a and b are legs and c is hypotenuse
        const commonTriples = [
            [3, 4, 5],
            [5, 12, 13],
            [8, 15, 17],
            [7, 24, 25],
            [9, 40, 41],
            [11, 60, 61],
            [12, 35, 37],
            [13, 84, 85],
            [16, 63, 65],
            [20, 21, 29],
            [28, 45, 53],
            [33, 56, 65],
            [36, 77, 85],
            [39, 80, 89],
            [48, 55, 73],
            [65, 72, 97]
        ];
        
        // Get exclusions
        const exclude = parsedConfig.exclude || '';
        const exclusions = exclude.split(',').map(item => item.trim()).filter(Boolean);
        
        // Filter out excluded triples
        const availableTriples = commonTriples.filter(triple => {
            const tripleStr = `${triple[0]}-${triple[1]}-${triple[2]}`;
            return !exclusions.includes(tripleStr);
        });
        
        if (availableTriples.length === 0) {
            return "Error: No available triples after exclusions";
        }
        
        // Select a random triple
        const selectedTriple = availableTriples[Math.floor(Math.random() * availableTriples.length)];
        
        // Return an object with the triple values and formatted string
        return {
            type: 'PythagoreanTriple',
            a: selectedTriple[0],
            b: selectedTriple[1],
            c: selectedTriple[2],
            toString: function() {
                return `${this.a}-${this.b}-${this.c}`;
            }
        };
    } catch (e) {
        console.error("PythagoreanTriple: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeCount(config, ctx) {
     if (typeof config === 'string') {
      try { config = JSON.parse(config); }
      catch (e) { console.error('Bad JSON in __computeCount:', config, e); return NaN; }
   }
  // 1) split on commas
  const rawItems = splitItems(config.items, ctx);
  // 2) substitute any #var# placeholders in each
  const items    = rawItems.map(item =>
    substituteHashes(item, ctx).trim()
  );
  // 3) also substitute placeholders in the "target" field
  const target   = substituteHashes(config.target, ctx).trim();
  // 4) tally string‐exact matches
  return items.reduce((count, v) =>
    v === target ? count + 1 : count
  , 0);
}

  

function __computeChooseText(config, ctx) {

       if (typeof config === 'string') {
     try { config = JSON.parse(config); }
      catch (e) { console.error('Bad JSON in __computeChooseText:', config, e); return ""; }
  }
  // 1) build full list and full exclude set
  const items   = splitItems(config.items,   ctx).map(s => substituteHashes(s, ctx).trim());
  const exclude = splitItems(config.exclude, ctx).map(s => substituteHashes(s, ctx).trim());

  // 2) filter out any excluded entries
  const pool = items.filter(s => !exclude.includes(s));
  if (pool.length === 0) return "";

  // 3) pick one
  const pick = pool[Math.floor(Math.random() * pool.length)];
  return pick;
}


function __computeChooseExpr(config, ctx) {

     if (typeof config === 'string') {
      try { config = JSON.parse(config); }
      catch (e) { console.error('Bad JSON in __computeChooseExpr:', config, e); return ""; }
   }
  const exprs   = splitItems(config.items,   ctx).map(s => substituteHashes(s, ctx).trim());
  const exclude = splitItems(config.exclude, ctx).map(s => substituteHashes(s, ctx).trim());
  const pool    = exprs.filter(s => !exclude.includes(s));
  if (pool.length === 0) return "";
  return pool[Math.floor(Math.random() * pool.length)];
}



function __computeChooseNum(config, ctx){
       if (typeof config === 'string') {
      try { config = JSON.parse(config); }
      catch (e) { console.error('Bad JSON in __computeChooseNum:', config, e); return NaN; }
   }
  const list = splitItems(config.items, ctx);
  if (list.length === 0) return NaN;
  const pick = list[Math.floor(Math.random()*list.length)];
  const value = resolveValue(pick.trim(), ctx);   // already in your utilities
  return Number(value);
}

/* --- tiny shared helpers -------------------------------------------- */
function splitItems(csv, ctx){
  if (!csv) return [];
  return csv.split(/[,;]/).map(s=>s.trim()).filter(Boolean);
}
function substituteHashes(str, ctx){
  return str.replace(/#([^#\s]+)#/g, (_,v)=>{
    return ctx.hasOwnProperty(v) ? ctx[v] : '#'+v+'#';
  });
}

// Helper function to simplify a fraction represented as [numerator, denominator]
function simplifyFraction(frac) {
    if (frac[1] === 0) return [0, 0]; // Handle division by zero
    
    const gcd = computeGCD(frac[0], frac[1]);
    
    // Simplify the fraction
    let num = frac[0] / gcd;
    let den = frac[1] / gcd;
    
    // Ensure the denominator is positive
    if (den < 0) {
        num = -num;
        den = -den;
    }
    
    return [num, den];
}

// Helper function to find the largest perfect square factor of a number
function findLargestPerfectSquareFactor(n) {
    if (n === 0 || n === 1) return n;
    
    // Find the largest perfect square factor
    let squarePart = 1;
    let nonSquarePart = n;
    
    for (let i = 2; i * i <= n; i++) {
        while (nonSquarePart % (i * i) === 0) {
            squarePart *= i;
            nonSquarePart /= (i * i);
        }
    }
    
    return [squarePart, nonSquarePart];
}

function parseListInput(listInput, context) {
    // If it's already an array, return it
    if (Array.isArray(listInput)) {
        return listInput;
    }
    
    // If it's a variable reference, try to resolve it from context
    if (typeof listInput === 'string' && context && context.hasOwnProperty(listInput.trim())) {
        const resolved = context[listInput.trim()];
        // If the resolved value is an array, return it
        if (Array.isArray(resolved)) {
            return resolved;
        }
        // If the resolved value is a string, parse it as a list
        if (typeof resolved === 'string') {
            listInput = resolved;
        }
    }
    
    // If it's a string, split by commas and/or semicolons
    if (typeof listInput === 'string') {
        const items = listInput.split(/[,;]+/).map(item => item.trim()).filter(item => item !== '');
        
        // Try to convert numeric strings to numbers
        return items.map(item => {
            const num = parseFloat(item);
            return !isNaN(num) && String(num) === item ? num : item;
        });
    }
    
    // If all else fails, return an empty array
    return [];
}

function evaluatePoly(coeffs, x) {
    return coeffs.reduce(
        (sum, c, i) => sum + c * Math.pow(x, coeffs.length - 1 - i),
        0
    );
}

/**
 * Evaluate a polynomial at x.
 * coeffs = [aₙ, aₙ₋₁, …, a₀] for aₙ·xⁿ + … + a₀
 */


/** Compute the coefficients of the first derivative. */
function derivativeCoeffs(coeffs) {
  // If coeffs = [aₙ, aₙ₋₁, …, a₀], returns [n·aₙ, (n-1)·aₙ₋₁, …, 1·a₁]
  return coeffs
    .slice(0, -1)
    .map((c, i) => c * (coeffs.length - 1 - i));
}

/**
 * Numerically find all real roots of a polynomial via bisection.
 * - coeffs: polynomial coefficients [aₙ…a₀]
 * - options.samples: how many evenly‐spaced sample intervals to scan
 * - options.tol: when to stop bisection
 * - options.maxIter: max bisection steps per bracket
 */
function findRealRootsBisection(
  coeffs,
  { samples = 1000, tol = 1e-8, maxIter = 50 } = {}
) {
  // 1) Cauchy bound: all real roots lie in [−M, M]
  const a_n = coeffs[0];
  const M =
    1 +
    Math.max(
      ...coeffs.slice(1).map(c => Math.abs(c / a_n))
    );

  const f = x => evaluatePoly(coeffs, x);
  const roots = [];

  // 2) Scan derivative on a grid for sign changes
  let x0 = -M,
    y0 = f(x0),
    dx = (2 * M) / samples;

  for (let i = 1; i <= samples; i++) {
    const x1 = -M + i * dx,
      y1 = f(x1);

    // bracket if y0 and y1 have opposite sign
    if (y0 === 0) {
      roots.push(x0);
    } else if (y0 * y1 < 0) {
      // bisection in [x0, x1]
      let lo = x0,
        hi = x1,
        mid,
        ymid;
      for (let iter = 0; iter < maxIter; iter++) {
        mid = 0.5 * (lo + hi);
        ymid = f(mid);
        if (Math.abs(ymid) < tol) break;
        if (y0 * ymid < 0) hi = mid;
        else {
          lo = mid;
          y0 = ymid;
        }
      }
      roots.push(mid);
    }

    x0 = x1;
    y0 = y1;
  }

  // 3) Deduplicate within tol
  roots.sort((a, b) => a - b);
  return roots.filter((r, i, A) => i === 0 || Math.abs(r - A[i - 1]) > tol);
}


function evaluateConditionHeader(header, context) {
  if (!header) return false;
  
  // Get main condition
  const leftInput = header.querySelector('.left-input');
  const operator = header.querySelector('.condition-operator');
  const rightInput = header.querySelector('.right-input');
  
  if (!leftInput || !operator || !rightInput) return false;
  
  // Resolve variables/expressions
  const leftVal = resolveValue(leftInput.value, context);
  const op = operator.value;
  const rightVal = resolveValue(rightInput.value, context);
  
  let conditionMet = evaluateCondition(leftVal, op, rightVal);
  
  // Check for AND conditions (all must be true)
  const parentSection = header.closest('.condition-section');
  if (parentSection) {
    const andConditions = parentSection.querySelectorAll('.and-condition');
    for (const andCond of andConditions) {
      const andLeft = andCond.querySelector('.left-input');
      const andOp = andCond.querySelector('.condition-operator');
      const andRight = andCond.querySelector('.right-input');
      
      if (!andLeft || !andOp || !andRight) continue;
      
      const andLeftVal = resolveValue(andLeft.value, context);
      const andOpVal = andOp.value;
      const andRightVal = resolveValue(andRight.value, context);
      
      const andResult = evaluateCondition(andLeftVal, andOpVal, andRightVal);
      conditionMet = conditionMet && andResult;
      
      // Short circuit if any AND condition is false
      if (!conditionMet) break;
    }
    
    // Check for OR conditions (any can be true)
    const orConditions = parentSection.querySelectorAll('.or-condition');
    if (orConditions.length > 0 && !conditionMet) {
      for (const orCond of orConditions) {
        const orLeft = orCond.querySelector('.left-input');
        const orOp = orCond.querySelector('.condition-operator');
        const orRight = orCond.querySelector('.right-input');
        
        if (!orLeft || !orOp || !orRight) continue;
        
        const orLeftVal = resolveValue(orLeft.value, context);
        const orOpVal = orOp.value;
        const orRightVal = resolveValue(orRight.value, context);
        
        if (evaluateCondition(orLeftVal, orOpVal, orRightVal)) {
          conditionMet = true;
          break;
        }
      }
    }
  }
  
  return conditionMet;
}

function evaluateConditionBlockById(id) {
  // Find the condition block by its ID
  const conditionBlock = document.querySelector(`.if-condition[data-condition-id="${id}"]`);
  if (!conditionBlock) {
    console.error(`Could not find condition block with ID: ${id}`);
    return null;
  }
  
  // Find all the input fields and conditions
  const leftInput = conditionBlock.querySelector('.left-input');
  const operator = conditionBlock.querySelector('.condition-operator');
  const rightInput = conditionBlock.querySelector('.right-input');
  
  if (!leftInput || !operator || !rightInput) {
    console.error('Missing required condition inputs');
    return null;
  }
  
  // Get the input values
  const leftVal = resolveValue(leftInput.value, evaluationScope);
  const op = operator.value;
  const rightVal = resolveValue(rightInput.value, evaluationScope);
  
  // Check if the condition is met
  const conditionMet = evaluateCondition(leftVal, op, rightVal);
  
  // Find the then/else sections
  const thenEquation = conditionBlock.querySelector('.if-container .editable-equation');
  const elseBlock = conditionBlock.querySelector('.else-block');
  const elseEquation = elseBlock ? elseBlock.querySelector('.editable-equation') : null;
  
  // Return the appropriate value based on condition
  if (conditionMet && thenEquation) {
    return getEquationExpression(thenEquation);
  } else if (!conditionMet && elseEquation) {
    return getEquationExpression(elseEquation);
  }
  
  return null;
}

// Function to evaluate a single condition
function evaluateCondition(leftVal, operator, rightVal) {
  // Convert string values to numbers if possible
  if (!isNaN(leftVal) && typeof leftVal === 'string') {
    leftVal = parseFloat(leftVal);
  }
  if (!isNaN(rightVal) && typeof rightVal === 'string') {
    rightVal = parseFloat(rightVal);
  }
  
  switch (operator) {
    case '==': return leftVal == rightVal;
    case '!=': return leftVal != rightVal;
    case '>': return leftVal > rightVal;
    case '<': return leftVal < rightVal;
    case '>=': return leftVal >= rightVal;
    case '<=': return leftVal <= rightVal;
    default: return false;
  }
}

// Function to evaluate a condition block (with possible AND/OR subconditions)
function evaluateConditionBlock(block, context) {
  if (!block || !block.querySelector) {
    console.error("Invalid block element provided to evaluateConditionBlock");
    return null;
  }
  
  // Get all condition sections
  const ifSection = block.querySelector('.if-section');
  const elseIfSections = block.querySelectorAll('.elseif-section');
  const elseSection = block.querySelector('.else-section');
  
  // First evaluate the 'if' condition
  if (ifSection) {
    const ifHeader = ifSection.querySelector('.if-header');
    if (ifHeader && evaluateConditionHeader(ifHeader, context)) {
      // If condition is true, evaluate the 'then' part
      const equation = ifSection.querySelector('.editable-equation');
      if (equation) {
        return getEquationExpression(equation);
      }
      return null;
    }
  }
  
  // Then check all 'else if' conditions in order
  for (const elseIfSection of elseIfSections) {
    const elseIfHeader = elseIfSection.querySelector('.elseif-header');
    if (elseIfHeader && evaluateConditionHeader(elseIfHeader, context)) {
      // If this 'else if' condition is true, evaluate its 'then' part
      const equation = elseIfSection.querySelector('.editable-equation');
      if (equation) {
        return getEquationExpression(equation);
      }
      return null;
    }
  }
  
  // If no conditions matched, check if there's an 'else' section
  if (elseSection) {
    const equation = elseSection.querySelector('.editable-equation');
    if (equation) {
      return getEquationExpression(equation);
    }
  }
  
  return null; // No conditions matched and no else block
}

function __computeText(config) {
  // returns the string exactly as typed
  return String(config.value ?? '');
}


function __computeCoordinateXValue(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("CoordinateXValue: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get coordinate string from config
        let coordStr = parsedConfig.coordinate || '';
        
        // Check if coordStr is a variable reference
        if (context && context.hasOwnProperty(coordStr.trim())) {
            coordStr = String(context[coordStr.trim()]);
        }
        
        if (!coordStr) {
            return "Error: No coordinate provided";
        }
        
        // Parse the coordinate - match pattern like (3,4) or (3, 4)
        const coordMatch = coordStr.match(/\s*\(\s*([+-]?\d*\.?\d+)\s*,\s*([+-]?\d*\.?\d+)\s*\)\s*/);
        
        if (!coordMatch) {
            return "Error: Invalid coordinate format. Expected (x,y)";
        }
        
        // Extract the x-value (first capture group)
        const xValue = parseFloat(coordMatch[1]);
        
        if (isNaN(xValue)) {
            return "Error: Invalid x-value";
        }
        
        return xValue;
    } catch (e) {
        console.error("CoordinateXValue: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeCoordinateYValue(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("CoordinateYValue: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get coordinate string from config
        let coordStr = parsedConfig.coordinate || '';
        
        // Check if coordStr is a variable reference
        if (context && context.hasOwnProperty(coordStr.trim())) {
            coordStr = String(context[coordStr.trim()]);
        }
        
        if (!coordStr) {
            return "Error: No coordinate provided";
        }
        
        // Parse the coordinate - match pattern like (3,4) or (3, 4)
        const coordMatch = coordStr.match(/\s*\(\s*([+-]?\d*\.?\d+)\s*,\s*([+-]?\d*\.?\d+)\s*\)\s*/);
        
        if (!coordMatch) {
            return "Error: Invalid coordinate format. Expected (x,y)";
        }
        
        // Extract the y-value (second capture group)
        const yValue = parseFloat(coordMatch[2]);
        
        if (isNaN(yValue)) {
            return "Error: Invalid y-value";
        }
        
        return yValue;
    } catch (e) {
        console.error("CoordinateYValue: Error:", e);
        return "Error: " + e.message;
    }
}



function __computePolyFactoredMinCoordinates(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyFactoredMinCoords: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get configuration values
        let leadingStr = parsedConfig.leading || '1';
        let factorsStr = parsedConfig.factors || '';
        const prefix = (parsedConfig.prefix || '').trim();
        
        if (!prefix) {
            return "Error: Variable prefix is required";
        }
        
        // Check if inputs are variable references
        if (context && context.hasOwnProperty(leadingStr.trim())) {
            leadingStr = String(context[leadingStr.trim()]);
        }
        
        if (context && context.hasOwnProperty(factorsStr.trim())) {
            const resolved = context[factorsStr.trim()];
            if (Array.isArray(resolved)) {
                factorsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                factorsStr = resolved;
            }
        }
        
        // Parse leading coefficient
        const leading = parseFloat(leadingStr);
        if (isNaN(leading) || !isFinite(leading) || leading === 0) {
            return "Error: Invalid leading coefficient";
        }
        
        // Parse factors
        const factors = factorsStr.split(/\s*,\s*/)
            .map(f => parseFloat(f))
            .filter(f => !isNaN(f) && isFinite(f));
        
        if (factors.length < 1) {
            return "Error: Need at least one factor";
        }
        
        // Convert from factored form to expanded form (coefficients)
        const expandedCoeffs = expandFactoredPolynomial(leading, factors);
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(expandedCoeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are minima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for minima
        const minima = [];
        const yValues = [];
        const coordinates = [];
        
        for (const x of criticalPoints) {
            // If second derivative is positive at this point, it's a minimum
            if (evaluatePoly(secondDerivCoeffs, x) > 0) {
                const xRounded = parseFloat(x.toFixed(6));
                const y = evaluatePoly(expandedCoeffs, x);
                const yRounded = parseFloat(y.toFixed(6));
                
                minima.push(xRounded);
                yValues.push(yRounded);
                coordinates.push(`(${xRounded}, ${yRounded})`);
            }
        }
        
        if (minima.length === 0) {
            return "No relative minima found";
        }
        
        // Create individual variables for each coordinate
        for (let i = 0; i < coordinates.length; i++) {
            const varName = `${prefix}${i+1}`;
            context[varName] = coordinates[i];
        }
        
        // Return the full list of coordinates as a string
        return coordinates.join(", ");
    } catch (e) {
        console.error("PolyFactoredMinCoords: Error:", e);
        return "Error: " + e.message;
    }
}

function __computePolyFactoredMin(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyFactoredMin: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get leading coefficient and factors from config
        let leadingStr = parsedConfig.leading || '1';
        let factorsStr = parsedConfig.factors || '';
        
        // Check if inputs are variable references
        if (context && context.hasOwnProperty(leadingStr.trim())) {
            leadingStr = String(context[leadingStr.trim()]);
        }
        
        if (context && context.hasOwnProperty(factorsStr.trim())) {
            const resolved = context[factorsStr.trim()];
            if (Array.isArray(resolved)) {
                factorsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                factorsStr = resolved;
            }
        }
        
        // Parse leading coefficient
        const leading = parseFloat(leadingStr);
        if (isNaN(leading) || !isFinite(leading) || leading === 0) {
            return "Error: Invalid leading coefficient";
        }
        
        // Parse factors
        const factors = factorsStr.split(/\s*,\s*/)
            .map(f => parseFloat(f))
            .filter(f => !isNaN(f) && isFinite(f));
        
        if (factors.length < 1) {
            return "Error: Need at least one factor";
        }
        
        // Convert from factored form to expanded form (coefficients)
        const expandedCoeffs = expandFactoredPolynomial(leading, factors);
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(expandedCoeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are minima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for minima
        const minima = [];
        const yValues = [];
        
        for (const x of criticalPoints) {
            // If second derivative is positive at this point, it's a minimum
            if (evaluatePoly(secondDerivCoeffs, x) > 0) {
                minima.push(x);
                yValues.push(evaluatePoly(expandedCoeffs, x));
            }
        }
        
        if (minima.length === 0) {
            return "No relative minima found";
        }
        
        // Return all y-values of the minima
        return yValues;
    } catch (e) {
        console.error("PolyFactoredMin: Error:", e);
        return "Error: " + e.message;
    }
}


function __computePolyFactoredMaxCoordinates(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyFactoredMaxCoords: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get configuration values
        let leadingStr = parsedConfig.leading || '1';
        let factorsStr = parsedConfig.factors || '';
        const prefix = (parsedConfig.prefix || '').trim();
        
        if (!prefix) {
            return "Error: Variable prefix is required";
        }
        
        // Check if inputs are variable references
        if (context && context.hasOwnProperty(leadingStr.trim())) {
            leadingStr = String(context[leadingStr.trim()]);
        }
        
        if (context && context.hasOwnProperty(factorsStr.trim())) {
            const resolved = context[factorsStr.trim()];
            if (Array.isArray(resolved)) {
                factorsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                factorsStr = resolved;
            }
        }
        
        // Parse leading coefficient
        const leading = parseFloat(leadingStr);
        if (isNaN(leading) || !isFinite(leading) || leading === 0) {
            return "Error: Invalid leading coefficient";
        }
        
        // Parse factors
        const factors = factorsStr.split(/\s*,\s*/)
            .map(f => parseFloat(f))
            .filter(f => !isNaN(f) && isFinite(f));
        
        if (factors.length < 1) {
            return "Error: Need at least one factor";
        }
        
        // Convert from factored form to expanded form (coefficients)
        const expandedCoeffs = expandFactoredPolynomial(leading, factors);
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(expandedCoeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are maxima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for maxima
        const maxima = [];
        const yValues = [];
        const coordinates = [];
        
        for (const x of criticalPoints) {
            // If second derivative is negative at this point, it's a maximum
            if (evaluatePoly(secondDerivCoeffs, x) < 0) {
                const xRounded = parseFloat(x.toFixed(6));
                const y = evaluatePoly(expandedCoeffs, x);
                const yRounded = parseFloat(y.toFixed(6));
                
                maxima.push(xRounded);
                yValues.push(yRounded);
                coordinates.push(`(${xRounded}, ${yRounded})`);
            }
        }
        
        if (maxima.length === 0) {
            return "No relative maxima found";
        }
        
        // Create individual variables for each coordinate
        for (let i = 0; i < coordinates.length; i++) {
            const varName = `${prefix}${i+1}`;
            context[varName] = coordinates[i];
        }
        
        // Return the full list of coordinates as a string
        return coordinates.join(", ");
    } catch (e) {
        console.error("PolyFactoredMaxCoords: Error:", e);
        return "Error: " + e.message;
    }
}


function __computePolyFactoredMax(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyFactoredMax: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get leading coefficient and factors from config
        let leadingStr = parsedConfig.leading || '1';
        let factorsStr = parsedConfig.factors || '';
        
        // Check if inputs are variable references
        if (context && context.hasOwnProperty(leadingStr.trim())) {
            leadingStr = String(context[leadingStr.trim()]);
        }
        
        if (context && context.hasOwnProperty(factorsStr.trim())) {
            const resolved = context[factorsStr.trim()];
            if (Array.isArray(resolved)) {
                factorsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                factorsStr = resolved;
            }
        }
        
        // Parse leading coefficient
        const leading = parseFloat(leadingStr);
        if (isNaN(leading) || !isFinite(leading) || leading === 0) {
            return "Error: Invalid leading coefficient";
        }
        
        // Parse factors
        const factors = factorsStr.split(/\s*,\s*/)
            .map(f => parseFloat(f))
            .filter(f => !isNaN(f) && isFinite(f));
        
        if (factors.length < 1) {
            return "Error: Need at least one factor";
        }
        
        // Convert from factored form to expanded form (coefficients)
        const expandedCoeffs = expandFactoredPolynomial(leading, factors);
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(expandedCoeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are maxima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for maxima
        const maxima = [];
        const yValues = [];
        
        for (const x of criticalPoints) {
            // If second derivative is negative at this point, it's a maximum
            if (evaluatePoly(secondDerivCoeffs, x) < 0) {
                maxima.push(x);
                yValues.push(evaluatePoly(expandedCoeffs, x));
            }
        }
        
        if (maxima.length === 0) {
            return "No relative maxima found";
        }
        
        // Return all y-values of the maxima
        return yValues;
    } catch (e) {
        console.error("PolyFactoredMax: Error:", e);
        return "Error: " + e.message;
    }
}

// Helper function to expand factored polynomial to standard form
function expandFactoredPolynomial(leading, factors) {
    // Start with the polynomial [leading]
    let result = [leading];
    
    // For each factor (x+b), multiply the current result by [1, b]
    for (const b of factors) {
        // Multiply by (x+b), which is [1, b] in coefficient form
        result = multiplyPolynomials(result, [1, b]);
    }
    
    return result;
}

// Helper function to multiply two polynomials represented as coefficient arrays
function multiplyPolynomials(poly1, poly2) {
    const result = new Array(poly1.length + poly2.length - 1).fill(0);
    
    for (let i = 0; i < poly1.length; i++) {
        for (let j = 0; j < poly2.length; j++) {
            result[i + j] += poly1[i] * poly2[j];
        }
    }
    
    return result;
}

function __computePolyRelativeMinCoordinates(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyRelativeMinCoords: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get coefficients and prefix from config
        let coeffsStr = parsedConfig.coeffs || '';
        const prefix = (parsedConfig.prefix || '').trim();
        
        if (!prefix) {
            return "Error: Variable prefix is required";
        }
        
        // Check if coeffsStr is a variable reference
        if (context && context.hasOwnProperty(coeffsStr.trim())) {
            const resolved = context[coeffsStr.trim()];
            if (Array.isArray(resolved)) {
                coeffsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                coeffsStr = resolved;
            }
        }
        
        // Parse coefficients
        const coeffs = coeffsStr.split(/\s*,\s*/)
            .map(c => parseFloat(c))
            .filter(c => !isNaN(c));
        
        if (coeffs.length < 2) {
            return "Error: Need at least 2 coefficients";
        }
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(coeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are minima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for minima
        const minima = [];
        const yValues = [];
        const coordinates = [];
        
        for (const x of criticalPoints) {
            // If second derivative is positive at this point, it's a minimum
            if (evaluatePoly(secondDerivCoeffs, x) > 0) {
                const xRounded = parseFloat(x.toFixed(6));
                const y = evaluatePoly(coeffs, x);
                const yRounded = parseFloat(y.toFixed(6));
                
                minima.push(xRounded);
                yValues.push(yRounded);
                coordinates.push(`(${xRounded}, ${yRounded})`);
            }
        }
        
        if (minima.length === 0) {
            return "No relative minima found";
        }
        
        // Create individual variables for each coordinate
        for (let i = 0; i < coordinates.length; i++) {
            const varName = `${prefix}${i+1}`;
            context[varName] = coordinates[i];
        }
        
        // Return the full list of coordinates as a string
        return coordinates.join(", ");
    } catch (e) {
        console.error("PolyRelativeMinCoords: Error:", e);
        return "Error: " + e.message;
    }
}

function __computePolyRelativeMin(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyRelativeMin: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get coefficients from config
        let coeffsStr = parsedConfig.coeffs || '';
        
        // Check if coeffsStr is a variable reference
        if (context && context.hasOwnProperty(coeffsStr.trim())) {
            const resolved = context[coeffsStr.trim()];
            if (Array.isArray(resolved)) {
                coeffsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                coeffsStr = resolved;
            }
        }
        
        // Parse coefficients
        const coeffs = coeffsStr.split(/\s*,\s*/)
            .map(c => parseFloat(c))
            .filter(c => !isNaN(c));
        
        if (coeffs.length < 2) {
            return "Error: Need at least 2 coefficients";
        }
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(coeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are minima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for minima
        const minima = [];
        const yValues = [];
        
        for (const x of criticalPoints) {
            // If second derivative is positive at this point, it's a minimum
            if (evaluatePoly(secondDerivCoeffs, x) > 0) {
                minima.push(x);
                yValues.push(evaluatePoly(coeffs, x));
            }
        }
        
        if (minima.length === 0) {
            return "No relative minima found";
        }
        
        // Always return an array of y-values
        return yValues;
    } catch (e) {
        console.error("PolyRelativeMin: Error:", e);
        return "Error: " + e.message;
    }
}

function __computePolyRelativeMaxCoordinates(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyRelativeMaxCoords: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get coefficients and prefix from config
        let coeffsStr = parsedConfig.coeffs || '';
        const prefix = (parsedConfig.prefix || '').trim();
        
        if (!prefix) {
            return "Error: Variable prefix is required";
        }
        
        // Check if coeffsStr is a variable reference
        if (context && context.hasOwnProperty(coeffsStr.trim())) {
            const resolved = context[coeffsStr.trim()];
            if (Array.isArray(resolved)) {
                coeffsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                coeffsStr = resolved;
            }
        }
        
        // Parse coefficients
        const coeffs = coeffsStr.split(/\s*,\s*/)
            .map(c => parseFloat(c))
            .filter(c => !isNaN(c));
        
        if (coeffs.length < 2) {
            return "Error: Need at least 2 coefficients";
        }
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(coeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are maxima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for maxima
        const maxima = [];
        const yValues = [];
        const coordinates = [];
        
        for (const x of criticalPoints) {
            // If second derivative is negative at this point, it's a maximum
            if (evaluatePoly(secondDerivCoeffs, x) < 0) {
                const xRounded = parseFloat(x.toFixed(6));
                const y = evaluatePoly(coeffs, x);
                const yRounded = parseFloat(y.toFixed(6));
                
                maxima.push(xRounded);
                yValues.push(yRounded);
                coordinates.push(`(${xRounded}, ${yRounded})`);
            }
        }
        
        if (maxima.length === 0) {
            return "No relative maxima found";
        }
        
        // Create individual variables for each coordinate
        for (let i = 0; i < coordinates.length; i++) {
            const varName = `${prefix}${i+1}`;
            context[varName] = coordinates[i];
        }
        
        // Return the full list of coordinates as a string
        return coordinates.join(", ");
    } catch (e) {
        console.error("PolyRelativeMaxCoords: Error:", e);
        return "Error: " + e.message;
    }
}

function __computePolyRelativeMax(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("PolyRelativeMax: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get coefficients from config
        let coeffsStr = parsedConfig.coeffs || '';
        
        // Check if coeffsStr is a variable reference
        if (context && context.hasOwnProperty(coeffsStr.trim())) {
            const resolved = context[coeffsStr.trim()];
            if (Array.isArray(resolved)) {
                coeffsStr = resolved.join(',');
            } else if (typeof resolved === 'string') {
                coeffsStr = resolved;
            }
        }
        
        // Parse coefficients
        const coeffs = coeffsStr.split(/\s*,\s*/)
            .map(c => parseFloat(c))
            .filter(c => !isNaN(c));
        
        if (coeffs.length < 2) {
            return "Error: Need at least 2 coefficients";
        }
        
        // Find critical points by calculating roots of the derivative
        const derivCoeffs = derivativeCoeffs(coeffs);
        
        // Find roots of the derivative (critical points)
        const criticalPoints = findRealRootsBisection(derivCoeffs);
        
        if (criticalPoints.length === 0) {
            return "No relative extrema found";
        }
        
        // Compute second derivative to determine which critical points are maxima
        const secondDerivCoeffs = derivativeCoeffs(derivCoeffs);
        
        // Evaluate y-values at the critical points and filter for maxima
        const maxima = [];
        const yValues = [];
        
        for (const x of criticalPoints) {
            // If second derivative is negative at this point, it's a maximum
            if (evaluatePoly(secondDerivCoeffs, x) < 0) {
                maxima.push(x);
                yValues.push(evaluatePoly(coeffs, x));
            }
        }
        
        if (maxima.length === 0) {
            return "No relative maxima found";
        }
        
        // Critical fix: Always return an array for consistent behavior
        return yValues;
    } catch (e) {
        console.error("PolyRelativeMax: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeLeastToGreatest(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("LeastToGreatest: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get the list of values
        const listStr = parsedConfig.list || '';
        const items = parseListInput(listStr, context);
        
        if (items.length === 0) {
            return "Empty list";
        }
        
        // Check if all items are numeric
        const allNumeric = items.every(item => typeof item === 'number');
        
        // Sort the items
        let sortedItems;
        if (allNumeric) {
            // For numeric sorting
            sortedItems = [...items].sort((a, b) => a - b);
        } else {
            // For mixed content, convert to strings for comparison
            sortedItems = [...items].sort((a, b) => String(a).localeCompare(String(b)));
        }
        
        // Return as an array
        return sortedItems;
    } catch (e) {
        console.error("LeastToGreatest: Error:", e);
        return "Error: " + e.message;
    }
}

// Greatest to Least computation function
function __computeGreatestToLeast(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("GreatestToLeast: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get the list of values
        const listStr = parsedConfig.list || '';
        const items = parseListInput(listStr, context);
        
        if (items.length === 0) {
            return "Empty list";
        }
        
        // Check if all items are numeric
        const allNumeric = items.every(item => typeof item === 'number');
        
        // Sort the items
        let sortedItems;
        if (allNumeric) {
            // For numeric sorting
            sortedItems = [...items].sort((a, b) => b - a);
        } else {
            // For mixed content, convert to strings for comparison
            sortedItems = [...items].sort((a, b) => String(b).localeCompare(String(a)));
        }
        
        // Return as an array
        return sortedItems;
    } catch (e) {
        console.error("GreatestToLeast: Error:", e);
        return "Error: " + e.message;
    }
}

// Alphabetical Order computation function
function __computeAlphabetical(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("Alphabetical: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get the list of words
        const listStr = parsedConfig.list || '';
        const items = parseListInput(listStr, context);
        
        if (items.length === 0) {
            return "Empty list";
        }
        
        // Determine case sensitivity
        const caseSensitive = parsedConfig.caseSensitive === 'true' || parsedConfig.caseSensitive === true;
        
        // Sort the items alphabetically
        let sortedItems;
        if (caseSensitive) {
            // Case-sensitive sorting
            sortedItems = [...items].sort((a, b) => String(a).localeCompare(String(b)));
        } else {
            // Case-insensitive sorting
            sortedItems = [...items].sort((a, b) => 
                String(a).toLowerCase().localeCompare(String(b).toLowerCase())
            );
        }
        
        // Return as an array
        return sortedItems;
    } catch (e) {
        console.error("Alphabetical: Error:", e);
        return "Error: " + e.message;
    }
}

// List Max computation function
function __computeListMax(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("ListMax: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get the list of numbers
        const listStr = parsedConfig.list || '';
        const items = parseListInput(listStr, context);
        
        if (items.length === 0) {
            return "Empty list";
        }
        
        // Convert all items to numbers where possible
        const numbers = items.map(item => {
            if (typeof item === 'number') return item;
            const num = parseFloat(item);
            return isNaN(num) ? -Infinity : num; // Non-numeric items become -Infinity
        });
        
        // Find the maximum value
        const max = Math.max(...numbers);
        
        // Check if no valid numbers were found
        if (max === -Infinity) {
            return "No valid numbers in list";
        }
        
        // Return the maximum value
        return max;
    } catch (e) {
        console.error("ListMax: Error:", e);
        return "Error: " + e.message;
    }
}

// List Min computation function
function __computeListMin(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("ListMin: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get the list of numbers
        const listStr = parsedConfig.list || '';
        const items = parseListInput(listStr, context);
        
        if (items.length === 0) {
            return "Empty list";
        }
        
        // Convert all items to numbers where possible
        const numbers = items.map(item => {
            if (typeof item === 'number') return item;
            const num = parseFloat(item);
            return isNaN(num) ? Infinity : num; // Non-numeric items become Infinity
        });
        
        // Find the minimum value
        const min = Math.min(...numbers);
        
        // Check if no valid numbers were found
        if (min === Infinity) {
            return "No valid numbers in list";
        }
        
        // Return the minimum value
        return min;
    } catch (e) {
        console.error("ListMin: Error:", e);
        return "Error: " + e.message;
    }
}

// Fisher-Yates shuffle algorithm for arrays
function shuffleArray(array) {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

// Check if two arrays have the same elements in the same order
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
    }
    return true;
}

// Random Order computation function
function __computeRandomOrder(config, context) {
    try {
        // Parse config if provided as a string (from math.evaluate)
        let parsedConfig = config;
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("RandomOrder: Error parsing config JSON:", config, e);
                return "Error: Invalid configuration";
            }
        }
        
        // Get the list of items
        const listStr = parsedConfig.list || '';
        const items = parseListInput(listStr, context);
        
        if (items.length === 0) {
            return "Empty list";
        }
        
        // Get the excluded orders
        const excludeStr = parsedConfig.exclude || '';
        const excludeVars = excludeStr.split(/[,;\s]+/).filter(s => s.trim() !== '');
        const excludedOrders = [];
        
        // Resolve each variable to get the excluded orders
        for (const varName of excludeVars) {
            const trimmedName = varName.trim();
            if (context && context.hasOwnProperty(trimmedName)) {
                const order = context[trimmedName];
                if (Array.isArray(order)) {
                    excludedOrders.push(order);
                }
            }
        }
        
        // Generate a new random order that's not in excludedOrders
        let newOrder;
        let attempts = 0;
        const MAX_ATTEMPTS = 100;
        
        do {
            newOrder = shuffleArray(items);
            attempts++;
            
            // Check if newOrder is different from all excluded orders
            const isDifferent = excludedOrders.every(order => !arraysEqual(newOrder, order));
            if (isDifferent || attempts >= MAX_ATTEMPTS) {
                break;
            }
        } while (attempts < MAX_ATTEMPTS);
        
        if (attempts >= MAX_ATTEMPTS) {
            console.warn(`RandomOrder: Could not find a unique order after ${MAX_ATTEMPTS} attempts.`);
        }
        
        // Return the randomized array
        return newOrder;
    } catch (e) {
        console.error("RandomOrder: Error:", e);
        return "Error: " + e.message;
    }
}



function __computeLog(value, base, round, decimals) {
    try {
        // Parse input value
        let numValue = value;
        let baseValue = base;
        
        // Process the value
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Process the base
        if (base && typeof base === 'object' && base.isFraction) {
            baseValue = base.n * base.s / base.d;
        }
        else if (base && typeof base === 'object' && base.type === 'UnsimplifiedMixedNumber') {
            if (base.value && base.value.isFraction) {
                baseValue = base.value.n * base.value.s / base.value.d;
            } else {
                const whole = base.whole;
                const num = base.num;
                const den = base.den;
                baseValue = whole + (num / den);
            }
        }
        else if (typeof base === 'string') {
            baseValue = parseFloat(base);
        }
        
        // Ensure valid values
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return "Error: Invalid input value";
        }
        
        if (numValue <= 0) {
            return "Error: Cannot calculate logarithm of zero or negative number";
        }
        
        if (typeof baseValue !== 'number' || isNaN(baseValue) || baseValue <= 0 || baseValue === 1) {
            return "Error: Base must be a positive number other than 1";
        }
        
        // Calculate logarithm
        let result = Math.log(numValue) / Math.log(baseValue);
        
        // Round if requested
        if (round === true) {
            let decimalPlaces = parseInt(decimals);
            if (isNaN(decimalPlaces) || decimalPlaces < 0) {
                decimalPlaces = 4; // Default to 4 decimal places
            }
            
            // Format to specified decimal places with trailing zeros
            return result.toFixed(decimalPlaces);
        }
        
        // Return unrounded result
        return result;
    } catch (e) {
        console.error("Log: Error:", e);
        return "Error: " + e.message;
    }
}

// Natural Logarithm (base e)
function __computeLn(value, round, decimals) {
    try {
        // Parse input value
        let numValue = value;
        
        // Process the value
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure valid values
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return "Error: Invalid input value";
        }
        
        if (numValue <= 0) {
            return "Error: Cannot calculate natural logarithm of zero or negative number";
        }
        
        // Calculate natural logarithm
        let result = Math.log(numValue);
        
        // Round if requested
        if (round === true) {
            let decimalPlaces = parseInt(decimals);
            if (isNaN(decimalPlaces) || decimalPlaces < 0) {
                decimalPlaces = 4; // Default to 4 decimal places
            }
            
            // Format to specified decimal places with trailing zeros
            return result.toFixed(decimalPlaces);
        }
        
        // Return unrounded result
        return result;
    } catch (e) {
        console.error("Ln: Error:", e);
        return "Error: " + e.message;
    }
}


function __computePrimeFactorization(value) {
    try {
        // Handle various input types
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid integer
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input value";
        }
        
        // Convert to integer if decimal
        if (!Number.isInteger(numValue)) {
            return `Error: Cannot factorize non-integer value ${numValue}`;
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // Handle negative numbers
        const isNegative = numValue < 0;
        let absValue = Math.abs(numValue);
        
        // Set a reasonable upper limit to prevent browser hanging
        const MAX_VALUE = 100000; // One million
        if (absValue > MAX_VALUE) {
            return `Error: Value too large (max: ${MAX_VALUE.toLocaleString()})`;
        }
        
        // Perform prime factorization
        const factorization = findPrimeFactorization(absValue);
        
        // Format the result
        let result = formatPrimeFactorization(factorization);
        
        // Add negative sign if needed
        if (isNegative) {
            result = "-" + result;
        }
        
        return result;
    } catch (e) {
        console.error(`PrimeFactorization: Error:`, e);
        return "Error: " + e.message;
    }
}

/**
 * Finds the prime factorization of a number.
 * @param {number} num The positive integer to factorize.
 * @returns {Object} An object where keys are prime factors and values are their exponents.
 */
function findPrimeFactorization(num) {
    const factors = {};
    
    // Handle factor of 2 specially (optimization)
    while (num % 2 === 0) {
        factors[2] = (factors[2] || 0) + 1;
        num = Math.floor(num / 2);
    }
    
    // Check odd factors
    for (let i = 3; i <= Math.sqrt(num); i += 2) {
        while (num % i === 0) {
            factors[i] = (factors[i] || 0) + 1;
            num = Math.floor(num / i);
        }
    }
    
    // If num is a prime number greater than 2
    if (num > 2) {
        factors[num] = (factors[num] || 0) + 1;
    }
    
    return factors;
}

/**
 * Formats a prime factorization object into a readable string.
 * @param {Object} factorization Object with prime factors as keys and exponents as values.
 * @returns {string} Formatted prime factorization string.
 */
function formatPrimeFactorization(factorization) {
    const parts = [];
    
    // Sort the factors in ascending order
    const primeFactors = Object.keys(factorization).map(Number).sort((a, b) => a - b);
    
    for (const factor of primeFactors) {
        const exponent = factorization[factor];
        
        if (exponent === 1) {
            parts.push(factor.toString());
        } else {
            parts.push(`${factor}^${exponent}`);
        }
    }
    
    return parts.join(" · "); // Using middle dot for multiplication
}

function __computeArcsin(value, mode, decimals) {
    try {
        // Parse input value
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return "Error: Invalid input value";
        }
        
        // Check domain: arcsin requires -1 ≤ x ≤ 1
        if (numValue < -1 || numValue > 1) {
            return "Error: Domain error (value must be between -1 and 1)";
        }
        
        // Calculate arcsin in radians
        const resultRadians = Math.asin(numValue);
        
        // Convert to degrees if needed
        let result = resultRadians;
        if (mode === 'degrees') {
            result = resultRadians * (180 / Math.PI);
        }
        
        // Format to specified decimal places
        let decimalPlaces = parseInt(decimals);
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 4; // Default to 4 decimal places
        }
        
        const formatted = result.toFixed(decimalPlaces);
        
        // Remove trailing zeros
        return parseFloat(formatted).toString();
    } catch (e) {
        console.error("Arcsin: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeArccos(value, mode, decimals) {
    try {
        // Parse input value
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return "Error: Invalid input value";
        }
        
        // Check domain: arccos requires -1 ≤ x ≤ 1
        if (numValue < -1 || numValue > 1) {
            return "Error: Domain error (value must be between -1 and 1)";
        }
        
        // Calculate arccos in radians
        const resultRadians = Math.acos(numValue);
        
        // Convert to degrees if needed
        let result = resultRadians;
        if (mode === 'degrees') {
            result = resultRadians * (180 / Math.PI);
        }
        
        // Format to specified decimal places
        let decimalPlaces = parseInt(decimals);
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 4; // Default to 4 decimal places
        }
        
        const formatted = result.toFixed(decimalPlaces);
        
        // Remove trailing zeros
        return parseFloat(formatted).toString();
    } catch (e) {
        console.error("Arccos: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeArctan(value, mode, decimals) {
    try {
        // Parse input value
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return "Error: Invalid input value";
        }
        
        // Calculate arctan in radians
        const resultRadians = Math.atan(numValue);
        
        // Convert to degrees if needed
        let result = resultRadians;
        if (mode === 'degrees') {
            result = resultRadians * (180 / Math.PI);
        }
        
        // Format to specified decimal places
        let decimalPlaces = parseInt(decimals);
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 4; // Default to 4 decimal places
        }
        
        const formatted = result.toFixed(decimalPlaces);
        
        // Remove trailing zeros
        return parseFloat(formatted).toString();
    } catch (e) {
        console.error("Arctan: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeCotExact(angle, mode) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Normalize the angle to standard range
        const normalizedAngle = normalizeAngle(angleValue, mode);
        
        // Create a small epsilon for floating-point comparisons
        const epsilon = 1e-10;
        
        // For checking special angles, convert to degrees for easier comparison
        let angleDegrees = normalizedAngle;
        if (mode === 'radians') {
            angleDegrees = (normalizedAngle * 180 / Math.PI) % 360;
        }
        
        // Check if the angle is close to 0° or 180° (cotangent is undefined)
        if (Math.abs(angleDegrees) < epsilon || Math.abs(angleDegrees - 180) < epsilon || 
            Math.abs(angleDegrees - 360) < epsilon) {
            return "undefined";
        }
        
        // Define the exact values for common angles
        const exactValues = {
            30: "√3",
            45: "1",
            60: "√3/3",
            90: "0",
            120: "-√3/3",
            135: "-1",
            150: "-√3",
            210: "√3",
            225: "1",
            240: "√3/3",
            270: "0",
            300: "-√3/3",
            315: "-1",
            330: "-√3",
        };
        
        // Check if the angle is close to one of the special angles
        for (const [specialAngle, exactValue] of Object.entries(exactValues)) {
            if (Math.abs(angleDegrees - parseFloat(specialAngle)) < epsilon || 
                Math.abs(angleDegrees - parseFloat(specialAngle) - 360) < epsilon) {
                return exactValue;
            }
        }
        
        // If not a special angle, we don't provide a non-exact answer
        // Instead, return "Not an exact value"
        return "Not an exact value";
    } catch (e) {
        console.error("CotExact: Error:", e);
        return "Error: " + e.message;
    }
}

// Computation function for exact sine values - modified to only show simplified radical answers
function __computeSinExact(angle, mode) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Normalize the angle to standard range
        const normalizedAngle = normalizeAngle(angleValue, mode);
        
        // Create a small epsilon for floating-point comparisons
        const epsilon = 1e-10;
        
        // For checking special angles, convert to degrees for easier comparison
        let angleDegrees = normalizedAngle;
        if (mode === 'radians') {
            angleDegrees = (normalizedAngle * 180 / Math.PI) % 360;
        }
        
        // Define the exact values for common angles
        const exactValues = {
            0: "0",
            30: "1/2",
            45: "√2/2",
            60: "√3/2",
            90: "1",
            120: "√3/2",
            135: "√2/2",
            150: "1/2",
            180: "0",
            210: "-1/2",
            225: "-√2/2",
            240: "-√3/2",
            270: "-1",
            300: "-√3/2",
            315: "-√2/2",
            330: "-1/2",
            360: "0"
        };
        
        // Check if the angle is close to one of the special angles
        for (const [specialAngle, exactValue] of Object.entries(exactValues)) {
            if (Math.abs(angleDegrees - parseFloat(specialAngle)) < epsilon || 
                Math.abs(angleDegrees - parseFloat(specialAngle) - 360) < epsilon) {
                return exactValue;
            }
        }
        
        // If not a special angle, we don't provide a non-exact answer
        // Instead, return "Not an exact value"
        return "Not an exact value";
    } catch (e) {
        console.error("SinExact: Error:", e);
        return "Error: " + e.message;
    }
}

// Computation function for exact cosine values - modified to only show simplified radical answers
function __computeCosExact(angle, mode) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Normalize the angle to standard range
        const normalizedAngle = normalizeAngle(angleValue, mode);
        
        // Create a small epsilon for floating-point comparisons
        const epsilon = 1e-10;
        
        // For checking special angles, convert to degrees for easier comparison
        let angleDegrees = normalizedAngle;
        if (mode === 'radians') {
            angleDegrees = (normalizedAngle * 180 / Math.PI) % 360;
        }
        
        // Define the exact values for common angles
        const exactValues = {
            0: "1",
            30: "√3/2",
            45: "√2/2",
            60: "1/2",
            90: "0",
            120: "-1/2",
            135: "-√2/2",
            150: "-√3/2",
            180: "-1",
            210: "-√3/2",
            225: "-√2/2",
            240: "-1/2",
            270: "0",
            300: "1/2",
            315: "√2/2",
            330: "√3/2",
            360: "1",
        };
        
        // Check if the angle is close to one of the special angles
        for (const [specialAngle, exactValue] of Object.entries(exactValues)) {
            if (Math.abs(angleDegrees - parseFloat(specialAngle)) < epsilon || 
                Math.abs(angleDegrees - parseFloat(specialAngle) - 360) < epsilon) {
                return exactValue;
            }
        }
        
        // If not a special angle, we don't provide a non-exact answer
        // Instead, return "Not an exact value"
        return "Not an exact value";
    } catch (e) {
        console.error("CosExact: Error:", e);
        return "Error: " + e.message;
    }
}

// Computation function for exact tangent values - modified to only show simplified radical answers
function __computeTanExact(angle, mode) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Normalize the angle to standard range
        const normalizedAngle = normalizeAngle(angleValue, mode);
        
        // Create a small epsilon for floating-point comparisons
        const epsilon = 1e-10;
        
        // For checking special angles, convert to degrees for easier comparison
        let angleDegrees = normalizedAngle;
        if (mode === 'radians') {
            angleDegrees = (normalizedAngle * 180 / Math.PI) % 360;
        }
        
        // Define the exact values for common angles - using simplified radicals
        const exactValues = {
            0: "0",
            30: "√3/3",
            45: "1",
            60: "√3",
            // 90: undefined
            120: "-√3",
            135: "-1",
            150: "-√3/3",
            180: "0",
            210: "√3/3",
            225: "1",
            240: "√3",
            // 270: undefined
            300: "-√3",
            315: "-1",
            330: "-√3/3",
            360: "0",
        };
        
        // Check if the angle is close to 90° or 270° (tangent is undefined)
        if (Math.abs(angleDegrees - 90) < epsilon || Math.abs(angleDegrees - 270) < epsilon) {
            return "undefined";
        }
        
        // Check if the angle is close to one of the special angles
        for (const [specialAngle, exactValue] of Object.entries(exactValues)) {
            if (Math.abs(angleDegrees - parseFloat(specialAngle)) < epsilon || 
                Math.abs(angleDegrees - parseFloat(specialAngle) - 360) < epsilon) {
                return exactValue;
            }
        }
        
        // If not a special angle, we don't provide a non-exact answer
        // Instead, return "Not an exact value"
        return "Not an exact value";
    } catch (e) {
        console.error("TanExact: Error:", e);
        return "Error: " + e.message;
    }
}

// Computation function for exact cosecant values - modified to only show simplified radical answers
function __computeCscExact(angle, mode) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Normalize the angle to standard range
        const normalizedAngle = normalizeAngle(angleValue, mode);
        
        // Create a small epsilon for floating-point comparisons
        const epsilon = 1e-10;
        
        // For checking special angles, convert to degrees for easier comparison
        let angleDegrees = normalizedAngle;
        if (mode === 'radians') {
            angleDegrees = (normalizedAngle * 180 / Math.PI) % 360;
        }
        
        // Check if the angle is close to 0° or 180° (cosecant is undefined)
        if (Math.abs(angleDegrees) < epsilon || Math.abs(angleDegrees - 180) < epsilon || 
            Math.abs(angleDegrees - 360) < epsilon) {
            return "undefined";
        }
        
        // Define the exact values for common angles - using simplified radicals
        const exactValues = {
            30: "2",
            45: "√2",
            60: "2√3/3",
            90: "1",
            120: "2√3/3",
            135: "√2",
            150: "2",
            210: "-2",
            225: "-√2",
            240: "-2√3/3",
            270: "-1",
            300: "-2√3/3",
            315: "-√2",
            330: "-2",
        };
        
        // Check if the angle is close to one of the special angles
        for (const [specialAngle, exactValue] of Object.entries(exactValues)) {
            if (Math.abs(angleDegrees - parseFloat(specialAngle)) < epsilon || 
                Math.abs(angleDegrees - parseFloat(specialAngle) - 360) < epsilon) {
                return exactValue;
            }
        }
        
        // If not a special angle, we don't provide a non-exact answer
        // Instead, return "Not an exact value"
        return "Not an exact value";
    } catch (e) {
        console.error("CscExact: Error:", e);
        return "Error: " + e.message;
    }
}

// Computation function for exact secant values - modified to only show simplified radical answers
function __computeSecExact(angle, mode) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Normalize the angle to standard range
        const normalizedAngle = normalizeAngle(angleValue, mode);
        
        // Create a small epsilon for floating-point comparisons
        const epsilon = 1e-10;
        
        // For checking special angles, convert to degrees for easier comparison
        let angleDegrees = normalizedAngle;
        if (mode === 'radians') {
            angleDegrees = (normalizedAngle * 180 / Math.PI) % 360;
        }
        
        // Check if the angle is close to 90° or 270° (secant is undefined)
        if (Math.abs(angleDegrees - 90) < epsilon || Math.abs(angleDegrees - 270) < epsilon) {
            return "undefined";
        }
        
        // Define the exact values for common angles - using simplified radicals
        const exactValues = {
            0: "1",
            30: "2√3/3",
            45: "√2",
            60: "2",
            120: "-2",
            135: "-√2",
            150: "-2√3/3",
            180: "-1",
            210: "-2√3/3",
            225: "-√2",
            240: "-2",
            300: "2",
            315: "√2",
            330: "2√3/3",
            360: "1",
        };
        
        // Check if the angle is close to one of the special angles
        for (const [specialAngle, exactValue] of Object.entries(exactValues)) {
            if (Math.abs(angleDegrees - parseFloat(specialAngle)) < epsilon || 
                Math.abs(angleDegrees - parseFloat(specialAngle) - 360) < epsilon) {
                return exactValue;
            }
        }
        
        // If not a special angle, we don't provide a non-exact answer
        // Instead, return "Not an exact value"
        return "Not an exact value";
    } catch (e) {
        console.error("SecExact: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeSinDecimal(angle, mode, decimals) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Convert angle to radians if in degrees
        if (mode === 'degrees') {
            angleValue = angleValue * Math.PI / 180;
        }
        
        // Calculate sine
        const result = Math.sin(angleValue);
        
        // Format to specified decimal places
        let decimalPlaces = parseInt(decimals);
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 4; // Default to 4 decimal places
        }
        
        const formatted = result.toFixed(decimalPlaces);
        
        // Remove trailing zeros
        return parseFloat(formatted).toString();
    } catch (e) {
        console.error("SinDecimal: Error:", e);
        return "Error: " + e.message;
    }
}

// Computation function for cosine
function __computeCosDecimal(angle, mode, decimals) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Convert angle to radians if in degrees
        if (mode === 'degrees') {
            angleValue = angleValue * Math.PI / 180;
        }
        
        // Calculate cosine
        const result = Math.cos(angleValue);
        
        // Format to specified decimal places
        let decimalPlaces = parseInt(decimals);
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 4; // Default to 4 decimal places
        }
        
        const formatted = result.toFixed(decimalPlaces);
        
        // Remove trailing zeros
        return parseFloat(formatted).toString();
    } catch (e) {
        console.error("CosDecimal: Error:", e);
        return "Error: " + e.message;
    }
}

// Computation function for tangent
function __computeTanDecimal(angle, mode, decimals) {
    try {
        // Validate inputs
        let angleValue = safeParseAngleExpression(angle);
        
        // Validate the parsed angle
        if (isNaN(angleValue) || !isFinite(angleValue)) {
            return "Error: Invalid angle value";
        }
        
        // Check for undefined tangent values (π/2 + nπ in radians or 90° + n*180° in degrees)
        let angleInRadians = angleValue;
        if (mode === 'degrees') {
            angleInRadians = angleValue * Math.PI / 180;
        }
        
        // Normalize to [0, 2π) and check for π/2 or 3π/2
        const normalizedAngle = angleInRadians % (2 * Math.PI);
        const epsilon = 1e-10; // Small tolerance for floating-point comparisons
        
        if (Math.abs(normalizedAngle - Math.PI/2) < epsilon || 
            Math.abs(normalizedAngle - 3*Math.PI/2) < epsilon) {
            return "undefined"; // Tangent is undefined at these points
        }
        
        // Calculate tangent
        const result = Math.tan(angleInRadians);
        
        // Check for very large values (approaching infinity)
        if (Math.abs(result) > 1e10) {
            return Math.sign(result) > 0 ? "∞" : "-∞";
        }
        
        // Format to specified decimal places
        let decimalPlaces = parseInt(decimals);
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 4; // Default to 4 decimal places
        }
        
        const formatted = result.toFixed(decimalPlaces);
        
        // Remove trailing zeros
        return parseFloat(formatted).toString();
    } catch (e) {
        console.error("TanDecimal: Error:", e);
        return "Error: " + e.message;
    }
}

function __computeQuadFormulaDecAns1(a, b, c, decimals) {
    try {
        // Parse inputs to numeric values
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        const numC = parseFloat(c);
        let decimalPlaces = parseInt(decimals);
        
        // Validate inputs
        if (isNaN(numA) || !isFinite(numA)) {
            return "Error: 'a' must be a valid number";
        }
        if (numA === 0) {
            return "Error: 'a' cannot be zero (not a quadratic equation)";
        }
        if (isNaN(numB) || !isFinite(numB)) {
            return "Error: 'b' must be a valid number";
        }
        if (isNaN(numC) || !isFinite(numC)) {
            return "Error: 'c' must be a valid number";
        }
        
        // Ensure decimal places is a valid number
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 2; // Default to 2 decimal places
        }
        decimalPlaces = Math.min(15, decimalPlaces); // Limit to 15 decimal places
        
        // Calculate the discriminant
        const discriminant = numB * numB - 4 * numA * numC;
        
        // Handle different cases based on discriminant
        if (discriminant < 0) {
            // Complex roots - return the real part with imaginary part
            const realPart = -numB / (2 * numA);
            const imaginaryPart = Math.sqrt(Math.abs(discriminant)) / (2 * numA);
            
            // Format to specified decimal places
            const realFormatted = realPart.toFixed(decimalPlaces);
            const imagFormatted = imaginaryPart.toFixed(decimalPlaces);
            
            // Remove trailing zeros
            const realClean = parseFloat(realFormatted).toString();
            const imagClean = parseFloat(imagFormatted).toString();
            
            return `${realClean} - ${imagClean}i`; // For Ans1, use the negative imaginary part
        } 
        else if (discriminant === 0) {
            // One real root (double root)
            const root = -numB / (2 * numA);
            
            // Format the root to the specified decimal places
            const formatted = root.toFixed(decimalPlaces);
            
            // Remove trailing zeros
            return parseFloat(formatted).toString();
        } 
        else {
            // Two distinct real roots
            const sqrtDiscriminant = Math.sqrt(discriminant);
            
            // Calculate both roots
            const root1 = (-numB - sqrtDiscriminant) / (2 * numA);
            const root2 = (-numB + sqrtDiscriminant) / (2 * numA);
            
            // Determine which is the smaller root
            const smallerRoot = Math.min(root1, root2);
            
            // Format to specified decimal places
            const formatted = smallerRoot.toFixed(decimalPlaces);
            
            // Remove trailing zeros
            return parseFloat(formatted).toString();
        }
    } catch (e) {
        console.error(`QuadFormulaDecAns1: Error:`, e);
        return "Error: " + e.message;
    }
}

// Computation function to get the larger solution of a quadratic equation
function __computeQuadFormulaDecAns2(a, b, c, decimals) {
    try {
        // Parse inputs to numeric values
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        const numC = parseFloat(c);
        let decimalPlaces = parseInt(decimals);
        
        // Validate inputs
        if (isNaN(numA) || !isFinite(numA)) {
            return "Error: 'a' must be a valid number";
        }
        if (numA === 0) {
            return "Error: 'a' cannot be zero (not a quadratic equation)";
        }
        if (isNaN(numB) || !isFinite(numB)) {
            return "Error: 'b' must be a valid number";
        }
        if (isNaN(numC) || !isFinite(numC)) {
            return "Error: 'c' must be a valid number";
        }
        
        // Ensure decimal places is a valid number
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 2; // Default to 2 decimal places
        }
        decimalPlaces = Math.min(15, decimalPlaces); // Limit to 15 decimal places
        
        // Calculate the discriminant
        const discriminant = numB * numB - 4 * numA * numC;
        
        // Handle different cases based on discriminant
        if (discriminant < 0) {
            // Complex roots - return the real part with imaginary part
            const realPart = -numB / (2 * numA);
            const imaginaryPart = Math.sqrt(Math.abs(discriminant)) / (2 * numA);
            
            // Format to specified decimal places
            const realFormatted = realPart.toFixed(decimalPlaces);
            const imagFormatted = imaginaryPart.toFixed(decimalPlaces);
            
            // Remove trailing zeros
            const realClean = parseFloat(realFormatted).toString();
            const imagClean = parseFloat(imagFormatted).toString();
            
            return `${realClean} + ${imagClean}i`; // For Ans2, use the positive imaginary part
        } 
        else if (discriminant === 0) {
            // One real root (double root)
            const root = -numB / (2 * numA);
            
            // Format the root to the specified decimal places
            const formatted = root.toFixed(decimalPlaces);
            
            // Remove trailing zeros
            return parseFloat(formatted).toString();
        } 
        else {
            // Two distinct real roots
            const sqrtDiscriminant = Math.sqrt(discriminant);
            
            // Calculate both roots
            const root1 = (-numB - sqrtDiscriminant) / (2 * numA);
            const root2 = (-numB + sqrtDiscriminant) / (2 * numA);
            
            // Determine which is the larger root
            const largerRoot = Math.max(root1, root2);
            
            // Format to specified decimal places
            const formatted = largerRoot.toFixed(decimalPlaces);
            
            // Remove trailing zeros
            return parseFloat(formatted).toString();
        }
    } catch (e) {
        console.error(`QuadFormulaDecAns2: Error:`, e);
        return "Error: " + e.message;
    }
}

function __computeQuadraticFormulaRadical(a, b, c, format) {
    try {
        // Parse inputs to numeric values
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        const numC = parseFloat(c);
        const outputFormat = format || 'unified';
        
        // Validate inputs
        if (isNaN(numA) || !isFinite(numA)) {
            return "Error: 'a' must be a valid number";
        }
        if (numA === 0) {
            return "Error: 'a' cannot be zero (not a quadratic equation)";
        }
        if (isNaN(numB) || !isFinite(numB)) {
            return "Error: 'b' must be a valid number";
        }
        if (isNaN(numC) || !isFinite(numC)) {
            return "Error: 'c' must be a valid number";
        }
        
        // Calculate the discriminant
        const discriminant = numB * numB - 4 * numA * numC;
        
        // Round small floating-point errors to zero
        const roundedDiscriminant = Math.abs(discriminant) < 1e-10 ? 0 : discriminant;
        
        // Handle the different cases based on the discriminant
        if (roundedDiscriminant < 0) {
            // Common values for all formats
            const commonRealPart = -numB;
            const imagPart = Math.sqrt(Math.abs(roundedDiscriminant));
            const denominator = 2 * numA;
            
            // Check if we can simplify the radical part
            const [sqrtCoef, radicand] = findLargestPerfectSquareFactor(Math.abs(roundedDiscriminant));
            
            if (outputFormat === 'unified') {
                // Unified fraction: Everything over one denominator
                // Find GCD to simplify
                const gcd = computeGCD(Math.abs(commonRealPart), denominator);
                const simplifiedRealPart = commonRealPart / gcd;
                const simplifiedDenom = denominator / gcd;
                
                if (sqrtCoef > 1) {
                    // With simplified radical
                    return `(${simplifiedRealPart} ± ${sqrtCoef}√${radicand})/${simplifiedDenom}i`;
                } else {
                    // Without simplified radical
                    return `(${simplifiedRealPart} ± √${radicand})/${simplifiedDenom}i`;
                }
            } else {
                // Separate fractions format
                // Simplify each fraction separately
                const [realNum, realDenom] = simplifyFraction([commonRealPart, denominator]);
                
                // Calculate radical coefficient fraction
                const radicalCoef = sqrtCoef > 1 ? sqrtCoef : 1;
                const [radicalNum, radicalDenom] = simplifyFraction([radicalCoef, denominator]);
                
                // Format the output
                let realPartStr = realNum === 0 ? "" : (realDenom === 1 ? 
                                                     `${realNum}` : 
                                                     `${realNum}/${realDenom}`);
                
                let radicalPartStr;
                if (radicalNum === 1) {
                    radicalPartStr = radicalDenom === 1 ? 
                                 `√${radicand}i` : 
                                 `√${radicand}/${radicalDenom}i`;
                } else {
                    radicalPartStr = radicalDenom === 1 ? 
                                 `${radicalNum}√${radicand}i` : 
                                 `${radicalNum}√${radicand}/${radicalDenom}i`;
                }
                
                // Put it all together
                if (realPartStr === "") {
                    return `±${radicalPartStr}`;
                } else {
                    return `${realPartStr} ± ${radicalPartStr}`;
                }
            }
        } 
        else if (roundedDiscriminant === 0) {
            // One real root (double root)
            const numerator = -numB;
            const denominator = 2 * numA;
            
            // Simplify the fraction
            const [simplifiedNum, simplifiedDen] = simplifyFraction([numerator, denominator]);
            
            // If the denominator is 1, just return the numerator
            if (simplifiedDen === 1) {
                return `${simplifiedNum}`;
            } else {
                return `${simplifiedNum}/${simplifiedDen}`;
            }
        } 
        else {
            // Two distinct real roots
            // Check if the discriminant is a perfect square
            const sqrtDiscriminant = Math.sqrt(roundedDiscriminant);
            const isPerfectSquare = Math.abs(sqrtDiscriminant - Math.round(sqrtDiscriminant)) < 1e-10;
            
            if (isPerfectSquare) {
                // Discriminant is a perfect square
                const realPart = -numB;
                const radicalPart = Math.round(sqrtDiscriminant);
                const denominator = 2 * numA;
                
                if (outputFormat === 'unified') {
                    // Find GCD and simplify
                    const gcd = computeGCD(computeGCD(Math.abs(realPart), radicalPart), denominator);
                    const simplifiedRealPart = realPart / gcd;
                    const simplifiedRadicalPart = radicalPart / gcd;
                    const simplifiedDenom = denominator / gcd;
                    
                    // Format with ± notation
                    if (simplifiedDenom === 1) {
                        return `${simplifiedRealPart} ± ${simplifiedRadicalPart}`;
                    } else {
                        return `(${simplifiedRealPart} ± ${simplifiedRadicalPart})/${simplifiedDenom}`;
                    }
                } else {
                    // Separate fractions
                    const [realNum, realDenom] = simplifyFraction([realPart, denominator]);
                    const [radicalNum, radicalDenom] = simplifyFraction([radicalPart, denominator]);
                    
                    // Format
                    const realPartStr = realDenom === 1 ? `${realNum}` : `${realNum}/${realDenom}`;
                    const radicalPartStr = radicalDenom === 1 ? `${radicalNum}` : `${radicalNum}/${radicalDenom}`;
                    
                    return `${realPartStr} ± ${radicalPartStr}`;
                }
            } else {
                // Discriminant is not a perfect square
                const [sqrtCoef, radicand] = findLargestPerfectSquareFactor(roundedDiscriminant);
                const realPart = -numB;
                const denominator = 2 * numA;
                
                if (outputFormat === 'unified') {
                    // Unified fraction: Everything over one denominator
                    // Find GCD to simplify
                    const gcd = computeGCD(computeGCD(Math.abs(realPart), sqrtCoef), denominator);
                    const simplifiedRealPart = realPart / gcd;
                    const simplifiedRadicalCoef = sqrtCoef / gcd;
                    const simplifiedDenom = denominator / gcd;
                    
                    // Format the radical term
                    let radicalTerm;
                    if (simplifiedRadicalCoef === 1) {
                        radicalTerm = `√${radicand}`;
                    } else {
                        radicalTerm = `${simplifiedRadicalCoef}√${radicand}`;
                    }
                    
                    // Format the whole expression
                    return `(${simplifiedRealPart} ± ${radicalTerm})/${simplifiedDenom}`;
                } else {
                    // Separate fractions format
                    const [realNum, realDenom] = simplifyFraction([realPart, denominator]);
                    
                    // Calculate radical coefficient fraction
                    const [radicalNum, radicalDenom] = simplifyFraction([sqrtCoef, denominator]);
                    
                    // Format the parts
                    const realPartStr = realDenom === 1 ? `${realNum}` : `${realNum}/${realDenom}`;
                    
                    let radicalPartStr;
                    if (radicalNum === 1) {
                        radicalPartStr = radicalDenom === 1 ? 
                                       `√${radicand}` : 
                                       `√${radicand}/${radicalDenom}`;
                    } else {
                        radicalPartStr = radicalDenom === 1 ? 
                                       `${radicalNum}√${radicand}` : 
                                       `${radicalNum}√${radicand}/${radicalDenom}`;
                    }
                    
                    // Put it all together
                    return `${realPartStr} ± ${radicalPartStr}`;
                }
            }
        }
    } catch (e) {
        console.error(`QuadraticFormulaRadical: Error:`, e);
        return "Error: " + e.message;
    }
}

    function __computeQuadraticFormulaDecimal(a, b, c, decimals) {
    try {
        // Parse inputs to numeric values
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        const numC = parseFloat(c);
        let decimalPlaces = parseInt(decimals);
        
        // Validate inputs
        if (isNaN(numA) || !isFinite(numA)) {
            return "Error: 'a' must be a valid number";
        }
        if (numA === 0) {
            return "Error: 'a' cannot be zero (not a quadratic equation)";
        }
        if (isNaN(numB) || !isFinite(numB)) {
            return "Error: 'b' must be a valid number";
        }
        if (isNaN(numC) || !isFinite(numC)) {
            return "Error: 'c' must be a valid number";
        }
        
        // Ensure decimal places is a valid number
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 2; // Default to 2 decimal places
        }
        decimalPlaces = Math.min(15, decimalPlaces); // Limit to 15 decimal places
        
        // Calculate the discriminant
        const discriminant = numB * numB - 4 * numA * numC;
        
        // Handle the different cases based on the discriminant
        if (discriminant < 0) {
            // Complex roots
            const realPart = -numB / (2 * numA);
            const imaginaryPart = Math.sqrt(Math.abs(discriminant)) / (2 * numA);
            
            // Format the complex roots
            const realFormatted = realPart.toFixed(decimalPlaces);
            const imagFormatted = imaginaryPart.toFixed(decimalPlaces);
            
            // Remove trailing zeros and unnecessary decimal points
            const realClean = parseFloat(realFormatted).toString();
            const imagClean = parseFloat(imagFormatted).toString();
            
            return `{${realClean} + ${imagClean}i, ${realClean} - ${imagClean}i}`;
        } 
        else if (discriminant === 0) {
            // One real root (double root)
            const root = -numB / (2 * numA);
            
            // Format the root to the specified decimal places
            const formatted = root.toFixed(decimalPlaces);
            
            // Remove trailing zeros and unnecessary decimal points
            const clean = parseFloat(formatted).toString();
            
            return `{${clean}, ${clean}}`;
        } 
        else {
            // Two distinct real roots
            const sqrtDiscriminant = Math.sqrt(discriminant);
            const root1 = (-numB + sqrtDiscriminant) / (2 * numA);
            const root2 = (-numB - sqrtDiscriminant) / (2 * numA);
            
            // Format the roots to the specified decimal places
            const formatted1 = root1.toFixed(decimalPlaces);
            const formatted2 = root2.toFixed(decimalPlaces);
            
            // Remove trailing zeros and unnecessary decimal points
            const clean1 = parseFloat(formatted1).toString();
            const clean2 = parseFloat(formatted2).toString();
            
            return `{${clean1}, ${clean2}}`;
        }
    } catch (e) {
        console.error(`QuadraticFormulaDecimal: Error:`, e);
        return "Error: " + e.message;
    }
}

    function __computeSimpRadCoefficient(value) {
    try {
        // Handle various input types
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input";
        }
        
        // For decimal inputs, we need to check if it's an integer
        if (!Number.isInteger(numValue)) {
            return `Cannot simplify radical of non-integer: ${numValue}`;
        }
        
        // Check for negative values - we can't have square roots of negative numbers
        if (numValue < 0) {
            return "Error: Cannot find square root of negative number";
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // Apply the simplification algorithm
        let a = 1;  // Coefficient
        let b = numValue;  // Radicand
        let i = 2;
        
        while (i * i <= b) {
            // While i^2 is a factor of b, divide out i^2 and multiply the coefficient by i
            while (b % (i * i) === 0) {
                b = Math.floor(b / (i * i));
                a *= i;
            }
            i++;
        }
        
        // Return just the coefficient
        return String(a);
    } catch (e) {
        console.error(`SimpRadCoefficient: Error:`, e);
        return "Error: " + e.message;
    }
}

// Computation function to get just the radicand of simplified square root
function __computeSimpRadRadicand(value) {
    try {
        // Handle various input types
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input";
        }
        
        // For decimal inputs, we need to check if it's an integer
        if (!Number.isInteger(numValue)) {
            return `Cannot simplify radical of non-integer: ${numValue}`;
        }
        
        // Check for negative values - we can't have square roots of negative numbers
        if (numValue < 0) {
            return "Error: Cannot find square root of negative number";
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // Apply the simplification algorithm
        let a = 1;  // Coefficient
        let b = numValue;  // Radicand
        let i = 2;
        
        while (i * i <= b) {
            // While i^2 is a factor of b, divide out i^2 and multiply the coefficient by i
            while (b % (i * i) === 0) {
                b = Math.floor(b / (i * i));
                a *= i;
            }
            i++;
        }
        
        // Return just the radicand
        return String(b);
    } catch (e) {
        console.error(`SimpRadRadicand: Error:`, e);
        return "Error: " + e.message;
    }
}

// Computation function to get just the coefficient of simplified cube root
function __computeSimpCubeRootCoefficient(value) {
    try {
        // Handle various input types
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input";
        }
        
        // For decimal inputs, we need to check if it's an integer
        if (!Number.isInteger(numValue)) {
            return `Cannot simplify cube root of non-integer: ${numValue}`;
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // For negative numbers, we can take cube roots (unlike square roots)
        const sign = numValue < 0 ? -1 : 1;
        let absValue = Math.abs(numValue);
        
        // Apply the simplification algorithm (similar to square roots but with cubes)
        let a = 1;  // Coefficient
        let b = absValue;  // Radicand
        let i = 2;
        
        while (i * i * i <= b) {
            // While i^3 is a factor of b, divide out i^3 and multiply the coefficient by i
            while (b % (i * i * i) === 0) {
                b = Math.floor(b / (i * i * i));
                a *= i;
            }
            i++;
        }
        
        // Apply the sign to the coefficient
        a *= sign;
        
        // Return just the coefficient
        return String(a);
    } catch (e) {
        console.error(`SimpCubeRootCoefficient: Error:`, e);
        return "Error: " + e.message;
    }
}

// Computation function to get just the radicand of simplified cube root
function __computeSimpCubeRootRadicand(value) {
    try {
        // Handle various input types
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input";
        }
        
        // For decimal inputs, we need to check if it's an integer
        if (!Number.isInteger(numValue)) {
            return `Cannot simplify cube root of non-integer: ${numValue}`;
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // For cube roots, we work with the absolute value and handle sign separately
        let absValue = Math.abs(numValue);
        
        // Apply the simplification algorithm (similar to square roots but with cubes)
        let a = 1;  // Coefficient
        let b = absValue;  // Radicand
        let i = 2;
        
        while (i * i * i <= b) {
            // While i^3 is a factor of b, divide out i^3 and multiply the coefficient by i
            while (b % (i * i * i) === 0) {
                b = Math.floor(b / (i * i * i));
                a *= i;
            }
            i++;
        }
        
        // Return just the radicand
        return String(b);
    } catch (e) {
        console.error(`SimpCubeRootRadicand: Error:`, e);
        return "Error: " + e.message;
    }
}


    function __computeSimplifyNthRoot(value, rootDegree) {
    try {
        // Parse the root degree
        let n = parseInt(rootDegree);
        if (isNaN(n) || !Number.isInteger(n) || n < 2) {
            return "Error: Root degree must be an integer ≥ 2";
        }
        
        // Handle various input types for the value
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input value";
        }
        
        // For decimal inputs, we need to check if it's an integer
        if (!Number.isInteger(numValue)) {
            return `Cannot simplify ${n}th root of non-integer: ${numValue}`;
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // Handle negative numbers (only possible with odd roots)
        const sign = numValue < 0 ? -1 : 1;
        if (sign === -1 && n % 2 === 0) {
            return `Error: Cannot find ${n}th root of negative number`;
        }
        
        const absValue = Math.abs(numValue);
        
        // Check if it's a perfect power
        if (isPerfectPower(absValue, n)) {
            const perfectRoot = sign * Math.round(Math.pow(absValue, 1/n));
            return String(perfectRoot);
        }
        
        // Apply the general simplification algorithm
        const [coefficient, radicand] = findLargestPerfectPower(absValue, n);
        
        // Apply the sign
        const signedCoefficient = sign < 0 && n % 2 === 1 ? -coefficient : coefficient;
        
        // Get the appropriate root symbol
        const rootSymbol = getRootSymbol(n);
        
        // Format the result based on the simplified form
        if (radicand === 1) {
            // If the radicand is 1, just return the coefficient
            return String(signedCoefficient);
        } else if (coefficient === 1) {
            // If the coefficient is 1, just return the nth root
            return `${rootSymbol}${radicand}`;
        } else if (coefficient === -1) {
            // If the coefficient is -1, return -√
            return `-${rootSymbol}${radicand}`;
        } else {
            // Return the full simplified form
            return `${signedCoefficient}${rootSymbol}${radicand}`;
        }
    } catch (e) {
        console.error(`SimplifyNthRoot: Error:`, e);
        return "Error: " + e.message;
    }
}

    function __computeSimplifyCubeRoot(value) {
    try {
        // Handle various input types
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal for simplification
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input";
        }
        
        // For decimal inputs, we need to check if it's an integer
        if (!Number.isInteger(numValue)) {
            return `Cannot simplify cube root of non-integer: ${numValue}`;
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // For negative numbers, we can take cube roots (unlike square roots)
        const sign = numValue < 0 ? -1 : 1;
        let absValue = Math.abs(numValue);
        
        // Apply the simplification algorithm (similar to square roots but with cubes)
        let a = 1;  // Coefficient
        let b = absValue;  // Radicand
        let i = 2;
        
        while (i * i * i <= b) {
            // While i^3 is a factor of b, divide out i^3 and multiply the coefficient by i
            while (b % (i * i * i) === 0) {
                b = Math.floor(b / (i * i * i));
                a *= i;
            }
            i++;
        }
        
        // Apply the sign to the coefficient
        a *= sign;
        
        // Format the result based on the simplified form
        if (b === 1) {
            // If the radicand is 1, just return the coefficient
            return String(a);
        } else if (a === 1) {
            // If the coefficient is 1, just return the cube root
            return `∛${b}`;
        } else if (a === -1) {
            // If the coefficient is -1, return -∛
            return `-∛${b}`;
        } else {
            // Return the full simplified form
            return `${a}∛${b}`;
        }
    } catch (e) {
        console.error(`SimplifyCubeRoot: Error:`, e);
        return "Error: " + e.message;
    }
}


// Computation function to simplify a radical
function __computeSimplifyRadical(value) {
    try {
        // Handle various input types
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal for simplification
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue) || !isFinite(numValue)) {
            return "Error: Invalid input";
        }
        
        // For decimal inputs, we need to check if it's an integer
        if (!Number.isInteger(numValue)) {
            return `Cannot simplify radical of non-integer: ${numValue}`;
        }
        
        // Check for negative values - we can't have square roots of negative numbers
        if (numValue < 0) {
            return "Error: Cannot simplify square root of negative number";
        }
        
        // Handle special cases
        if (numValue === 0) return "0";
        if (numValue === 1) return "1";
        
        // Apply the simplification algorithm
        let a = 1;  // Coefficient
        let b = numValue;  // Radicand
        let i = 2;
        
        while (i * i <= b) {
            // While i^2 is a factor of b, divide out i^2 and multiply the coefficient by i
            while (b % (i * i) === 0) {
                b = Math.floor(b / (i * i));
                a *= i;
            }
            i++;
        }
        
        // Format the result based on the simplified form
        if (b === 1) {
            // If the radicand is 1, just return the coefficient
            return String(a);
        } else if (a === 1) {
            // If the coefficient is 1, just return the square root
            return `√${b}`;
        } else {
            // Return the full simplified form
            return `${a}√${b}`;
        }
    } catch (e) {
        console.error(`SimplifyRadical: Error:`, e);
        return "Error: " + e.message;
    }
}  
   
    function __computeAlgebraicExpression(expressionStr, simplify, context) {
  // Ensure the expression is treated as a string.
  if (typeof expressionStr !== 'string') {
    expressionStr = String(expressionStr);
  }
  
  // Replace any token wrapped in '#' with its corresponding value.
  // The regex /#([^#]+)#/g matches a '#' character, then one or more characters that are not '#',
  // and then another '#' character.
  let result = expressionStr.replace(/#([^#]+)#/g, function(match, varName) {
    // If the variable exists in the context, return its string value.
    if (context.hasOwnProperty(varName)) {
      return String(context[varName]);
    }
    // If not found, return the original token (with the hash marks intact),
    // so you know that the variable wasn’t replaced.
    return match;
  });
  
  // In your current need you want to keep the rest of the expression (like "x")
  // unchanged. You can add further formatting if desired here.
  // (For example, if you want to remove any multiplication symbols between
  // a substituted number and a following letter, you could do that here.)
  result = result.replace(/(\d)\*([a-zA-Z])/g, '$1$2');

  // We ignore the 'simplify' parameter since you don't want any further evaluation or simplification.
  return result;
}


    function __computeNthRoot(value, root, decimals) {
        try {
            let numValue = value;
            let rootValue = root;
            let decimalPlaces = parseInt(decimals);
            
            // Ensure decimal places is a valid number
            if (isNaN(decimalPlaces) || decimalPlaces < 0) {
                decimalPlaces = 6; // Default to 6 if invalid
            }
            
            // Handle math.Fraction objects
            if (value && typeof value === 'object' && value.isFraction) {
                // Convert fraction to decimal
                numValue = value.n * value.s / value.d;
            } 
            // Handle UnsimplifiedMixedNumber objects
            else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
                if (value.value && value.value.isFraction) {
                    // Extract the numerical value from the fraction
                    numValue = value.value.n * value.value.s / value.value.d;
                } else {
                    // Calculate manually from parts
                    const whole = value.whole;
                    const num = value.num;
                    const den = value.den;
                    numValue = whole + (num / den);
                }
            }
            // Parse string input
            else if (typeof value === 'string') {
                numValue = parseFloat(value);
            }
            
            // Parse root value
            if (typeof root === 'string') {
                rootValue = parseFloat(root);
            }
            
            // Ensure we have valid numbers
            if (typeof numValue !== 'number' || isNaN(numValue) || 
                typeof rootValue !== 'number' || isNaN(rootValue)) {
                return NaN;
            }
            
            // Check for invalid input
            if (numValue < 0 && rootValue % 2 === 0) {
                return "Error: Cannot compute even root of a negative number";
            }
            
            if (rootValue === 0) {
                return "Error: Root cannot be zero";
            }
            
            // Calculate nth root
            const nthRootValue = Math.pow(numValue, 1/rootValue);
            
            // Round to specified number of decimal places
            const factor = Math.pow(10, decimalPlaces);
            const rounded = Math.round(nthRootValue * factor) / factor;
            
            // Format the number to show only needed decimal places
            if (Number.isInteger(rounded)) {
                return rounded.toString();
            } else {
                // Convert to string with fixed decimal places
                const fixed = rounded.toFixed(decimalPlaces);
                // Remove trailing zeros
                return parseFloat(fixed).toString();
            }
        } catch (e) {
            console.error(`NthRoot: Error:`, e);
            return NaN;
        }
    }

    function __computeSquareRoot(value, decimals) {
    try {
        let numValue = value;
        let decimalPlaces = parseInt(decimals);
        
        // Ensure decimal places is a valid number
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 6; // Default to 6 if invalid
        }
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return NaN;
        }
        
        // Check for negative input
        if (numValue < 0) {
            return "Error: Cannot compute square root of a negative number";
        }
        
        // Calculate square root
        const sqrtValue = Math.sqrt(numValue);
        
        // Round to specified number of decimal places
        const factor = Math.pow(10, decimalPlaces);
        const rounded = Math.round(sqrtValue * factor) / factor;
        
        // Format the number to show only needed decimal places
        // This will NOT show trailing zeros
        if (Number.isInteger(rounded)) {
            return rounded.toString();
        } else {
            // Convert to string with fixed decimal places
            const fixed = rounded.toFixed(decimalPlaces);
            // Remove trailing zeros
            return parseFloat(fixed).toString();
        }
    } catch (e) {
        console.error(`SquareRoot: Error:`, e);
        return NaN;
    }
}


    function __computeRoundDown(value) {
    try {
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return NaN;
        }
        
        // Use Math.floor to round down
        return Math.floor(numValue);
    } catch (e) {
        console.error(`RoundDown: Error:`, e);
        return NaN;
    }
}

    function __computeConvertToDecimal(value) {
    try {
        // Define number of decimal places for non-terminating decimals
        const MAX_DECIMALS = 9;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            const decimal = value.n * value.s / value.d;
            // Format to show appropriate number of decimals
            return formatDecimalOutput(decimal, MAX_DECIMALS);
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                const decimal = value.value.n * value.value.s / value.value.d;
                return formatDecimalOutput(decimal, MAX_DECIMALS);
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                const decimal = whole + (num / den);
                return formatDecimalOutput(decimal, MAX_DECIMALS);
            }
        }
        // Handle mixed numbers as strings, like "2 3/4"
        else if (typeof value === 'string' && value.includes(' ') && value.includes('/')) {
            const parts = value.trim().split(/\s+/);
            if (parts.length === 2 && parts[1].includes('/')) {
                const whole = parseInt(parts[0]);
                const fracParts = parts[1].split('/');
                const num = parseInt(fracParts[0]);
                const den = parseInt(fracParts[1]);
                if (!isNaN(whole) && !isNaN(num) && !isNaN(den) && den !== 0) {
                    const decimal = whole + (num / den);
                    return formatDecimalOutput(decimal, MAX_DECIMALS);
                }
            }
        }
        // Handle fractions as strings, like "3/4"
        else if (typeof value === 'string' && value.includes('/')) {
            const parts = value.split('/');
            if (parts.length === 2) {
                const num = parseInt(parts[0]);
                const den = parseInt(parts[1]);
                if (!isNaN(num) && !isNaN(den) && den !== 0) {
                    const decimal = num / den;
                    return formatDecimalOutput(decimal, MAX_DECIMALS);
                }
            }
        }
        // Handle numbers or numeric strings
        else if (typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)))) {
            const decimal = typeof value === 'number' ? value : parseFloat(value);
            return formatDecimalOutput(decimal, MAX_DECIMALS);
        }
        
        // If all else fails, return the original value as a string
        console.warn(`ConvertToDecimal: Could not process value:`, value);
        return String(value);
    } catch (e) {
        console.error(`ConvertToDecimal: Error:`, e);
        return String(value);
    }
}

// Helper function to format decimal output with appropriate precision
function formatDecimalOutput(value, maxDecimals = 9) {
    if (!isFinite(value)) return "NaN";
    
    // Format the number to the specified number of decimal places
    const formatted = value.toFixed(maxDecimals);
    
    // Remove trailing zeros if it's a terminating decimal
    // This step is optional - remove it if you want to always show all decimals
    if (Math.abs(value - Math.round(value)) < 1e-10) {
        // It's effectively an integer
        return String(Math.round(value));
    } else if (Math.abs(value * Math.pow(10, maxDecimals) - Math.round(value * Math.pow(10, maxDecimals))) < 1e-10) {
        // It's a terminating decimal with fewer than maxDecimals places
        return String(parseFloat(formatted));
    }
    
    return formatted;
}

function __computeRoundUp(value) {
    try {
        let numValue = value;
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return NaN;
        }
        
        // Use Math.ceil to round up
        return Math.ceil(numValue);
    } catch (e) {
        console.error(`RoundUp: Error:`, e);
        return NaN;
    }
}

    function __computeRound(value, decimals) {
    try {
        // Parse input values
        let numValue = value;
        let decimalPlaces = parseInt(decimals);
        
        // Ensure decimal places is a valid number
        if (isNaN(decimalPlaces) || decimalPlaces < 0) {
            decimalPlaces = 2; // Default to 2 if invalid
        }
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            // Convert fraction to decimal
            numValue = value.n * value.s / value.d;
        } 
        // Handle UnsimplifiedMixedNumber objects
        else if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            if (value.value && value.value.isFraction) {
                // Extract the numerical value from the fraction
                numValue = value.value.n * value.value.s / value.value.d;
            } else {
                // Calculate manually from parts
                const whole = value.whole;
                const num = value.num;
                const den = value.den;
                numValue = whole + (num / den);
            }
        }
        // Parse string input
        else if (typeof value === 'string') {
            numValue = parseFloat(value);
        }
        
        // Ensure we have a valid number
        if (typeof numValue !== 'number' || isNaN(numValue)) {
            return NaN;
        }
        
        // Round the number and format to the fixed number of decimal places
        const factor = Math.pow(10, decimalPlaces);
        const rounded = Math.round(numValue * factor) / factor;
        
        // Format to ensure trailing zeros are displayed
        return rounded.toFixed(decimalPlaces);
    } catch (e) {
        console.error(`Round: Error:`, e);
        return NaN;
    }
}

    function __computeConvertToImproper(value) {
    try {
        // Handle UnsimplifiedMixedNumber objects
        if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            // Convert mixed number directly to improper fraction
            const whole = value.whole;
            const num = value.num;
            const den = value.den;
            if (isNaN(whole) || isNaN(num) || isNaN(den) || den <= 0) return NaN;
            
            const sign = whole < 0 ? -1 : 1;
            const improperNum = sign * (Math.abs(whole) * den + num);
            return math.fraction(improperNum, den);
        }
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            return value; // Already a fraction object (will be formatted as improper later)
        }
        
        // Handle mixed numbers as strings, like "2 3/4"
        if (typeof value === 'string' && value.includes(' ') && value.includes('/')) {
            const parts = value.trim().split(/\s+/);
            if (parts.length === 2 && parts[1].includes('/')) {
                const whole = parseInt(parts[0]);
                const fracParts = parts[1].split('/');
                const num = parseInt(fracParts[0]);
                const den = parseInt(fracParts[1]);
                if (!isNaN(whole) && !isNaN(num) && !isNaN(den) && den !== 0) {
                    const sign = whole < 0 ? -1 : 1;
                    const improperNum = sign * (Math.abs(whole) * den + num);
                    return math.fraction(improperNum, den);
                }
            }
        }
        
        // Handle fractions as strings, like "3/4"
        if (typeof value === 'string' && value.includes('/')) {
            const parts = value.split('/');
            if (parts.length === 2) {
                const num = parseInt(parts[0]);
                const den = parseInt(parts[1]);
                if (!isNaN(num) && !isNaN(den) && den !== 0) {
                    return math.fraction(num, den);
                }
            }
        }
        
        // Handle numbers (both integers and decimals)
        if (typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)))) {
            const numValue = typeof value === 'number' ? value : parseFloat(value);
            
            // Try to convert to fraction
            try {
                return math.fraction(numValue);
            } catch (e) {
                // If conversion to fraction fails, it's likely irrational
                // Return the decimal value formatted to 9 decimals
                return numValue.toFixed(9);
            }
        }
        
        // Fallback for other cases
        console.warn(`ConvertToImproper: Could not process value:`, value);
        return typeof value === 'number' ? value.toFixed(9) : String(value);
    } catch (e) {
        console.error(`ConvertToImproper: Error:`, e);
        return typeof value === 'number' ? value.toFixed(9) : String(value);
    }
}

function formatImproperFraction(value) {
    // For non-fraction values, use the standard formatter then return
    if (!(value && typeof value === 'object' && value.isFraction)) {
        return typeof value === 'string' ? value : String(value);
    }
    
    // For fraction objects, always display in improper form (n/d)
    const frac = value;
    return `${frac.s * frac.n}/${frac.d}`;
}


    function __computeMixedNumberWhole(value) {
    try {
        // If it's an UnsimplifiedMixedNumber, return the whole part directly
        if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            return value.whole;
        }
        
        // If it's a math.Fraction object
        if (value && typeof value === 'object' && value.isFraction) {
            const n = value.n * value.s; // Numerator with sign
            const d = value.d;          // Denominator
            
            if (d === 1) return n; // Already a whole number
            
            return Math.trunc(n / d); // Get the whole part using integer division
        }
        
        // If it's a number, return its integer part
        if (typeof value === 'number') {
            if (!isFinite(value)) return NaN;
            return Math.trunc(value);
        }
        
        console.warn(`MixedNumberWhole: Could not process value:`, value);
        return NaN;
    } catch (e) {
        console.error(`MixedNumberWhole: Error:`, e);
        return NaN;
    }
}

    function __computeFormatMixedNumber(value) {
    try {
        // Handle UnsimplifiedMixedNumber objects
        if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            return formatMixedNumberOutput(value.value);
        }
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            return formatMixedNumberOutput(value);
        }
        
        // Handle numbers
        if (typeof value === 'number') {
            if (!isFinite(value)) return "NaN"; // Handle infinity/NaN
            
            // Try to convert to a fraction if possible
            try {
                // For simple numbers that can be easily converted to fractions
                if (Math.abs(value) < 10000 && countDecimals(value) <= 6) {
                    const frac = math.fraction(value);
                    return formatMixedNumberOutput(frac);
                }
            } catch (e) {
                // If conversion to fraction fails, fallback to decimal
                console.log("Couldn't convert to fraction:", e);
            }
            
            // If can't convert to fraction or too complex, format as decimal
            return formatDecimalOutput(value);
        }
        
        // If value is a string, try to parse it
        if (typeof value === 'string') {
            if (value.includes('/')) {
                try {
                    // Could be a mixed number like "2 3/4"
                    const parts = value.trim().split(/\s+/);
                    if (parts.length === 2 && parts[1].includes('/')) {
                        const whole = parseInt(parts[0]);
                        const fracParts = parts[1].split('/');
                        const num = parseInt(fracParts[0]);
                        const den = parseInt(fracParts[1]);
                        if (!isNaN(whole) && !isNaN(num) && !isNaN(den) && den !== 0) {
                            const sign = whole < 0 ? -1 : 1;
                            const improperNum = sign * (Math.abs(whole) * den + num);
                            const frac = math.fraction(improperNum, den);
                            return formatMixedNumberOutput(frac);
                        }
                    }
                    
                    // Simple fraction like "3/4"
                    if (parts.length === 1 && parts[0].includes('/')) {
                        const fracParts = parts[0].split('/');
                        const num = parseInt(fracParts[0]);
                        const den = parseInt(fracParts[1]);
                        if (!isNaN(num) && !isNaN(den) && den !== 0) {
                            const frac = math.fraction(num, den);
                            return formatMixedNumberOutput(frac);
                        }
                    }
                } catch (e) {
                    console.log("Error parsing fraction string:", e);
                }
            }
            
            // Try to parse as a number
            const parsedNum = parseFloat(value);
            if (!isNaN(parsedNum)) {
                return __computeFormatMixedNumber(parsedNum); // Recursively process as number
            }
        }
        
        console.warn(`FormatMixedNumber: Could not process value:`, value);
        return String(value); // Return as string if all else fails
    } catch (e) {
        console.error(`FormatMixedNumber: Error:`, e);
        return String(value);
    }
}


    function __computeMixedNumberNumerator(value) {
    try {
        // Handle UnsimplifiedMixedNumber objects
        if (value && typeof value === 'object' && value.type === 'UnsimplifiedMixedNumber') {
            return value.num; // Directly return the numerator part
        }
        
        // Handle math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            const frac = value;
            const n = frac.n * frac.s; // Get numerator with sign
            const d = frac.d;
            
            if (d === 1) return 0; // Whole number has no fractional part
            
            // Convert to mixed number format and return just the numerator
            if (Math.abs(n) >= d) {
                const remainderNum = Math.abs(n % d);
                return remainderNum; // Just the numerator of the fractional part
            } else {
                return Math.abs(n); // For proper fractions, return the numerator
            }
        }
        
        // Try to convert numbers to fractions
        if (typeof value === 'number' && isFinite(value)) {
            if (Number.isInteger(value)) return 0; // Whole number
            
            const frac = math.fraction(value);
            return __computeMixedNumberNumerator(frac); // Process the fraction
        }
        
        console.warn(`MixedNumberNumerator: Could not process value:`, value);
        return NaN;
    } catch (e) {
        console.error(`MixedNumberNumerator: Error:`, e);
        return NaN;
    }
}


    function __computeCreateFraction(numInput, denInput) {
        // Explicitly try to convert inputs to numbers.
        // Handle cases where inputs might be numbers already or strings representing numbers.
        const num = (typeof numInput === 'number') ? numInput : parseFloat(numInput);
        const den = (typeof denInput === 'number') ? denInput : parseFloat(denInput);

        // Validate the CONVERTED numbers
        if (isNaN(num) || isNaN(den) || !isFinite(num) || !isFinite(den)) {
             console.warn(`CreateFraction: Invalid number inputs after conversion. num=${numInput} -> ${num}, den=${denInput} -> ${den}`);
             return NaN; // Return NaN if conversion fails or results aren't finite
        }

        if (den === 0) {
             console.warn("CreateFraction: Denominator cannot be zero.");
             return NaN;
        }

        // Now create the fraction using the validated numbers
        try {
            return math.fraction(num, den); // Returns a math.Fraction object (simplified)
        } catch (e) {
             console.error(`CreateFraction: Error creating math.fraction(${num}, ${den})`, e);
             return NaN;
        }
    }

    function __computeCreateUnsimplifiedMixedNumber(wholeInput, numInput, denInput) {
        // Parse inputs to numbers, allowing for empty/0 whole part
        const whole = (typeof wholeInput === 'number') ? wholeInput : parseFloat(wholeInput || '0'); // Default whole to 0 if empty/missing
        const num = (typeof numInput === 'number') ? numInput : parseFloat(numInput);
        const den = (typeof denInput === 'number') ? denInput : parseFloat(denInput);

        // Validate DENOMINATOR first
        if (isNaN(den) || !Number.isInteger(den) || den <= 0) {
            console.warn(`CreateUnsimplifiedMixedNumber: Denominator must be a positive integer. Got: ${denInput} -> ${den}`);
            return NaN; // Return NaN if denominator invalid
        }
        // Validate other parts (ensure num is integer and non-negative for typical mixed numbers)
        if (isNaN(whole) || !isFinite(whole) || isNaN(num) || !Number.isInteger(num) || num < 0) {
             console.warn(`CreateUnsimplifiedMixedNumber: Invalid inputs after conversion. whole=${wholeInput}->${whole}, num=${numInput}->${num}, den=${denInput}->${den}`);
             return NaN; // Return NaN if other inputs invalid
        }

        // Calculate the actual numerical value (as a simplified math.Fraction)
        let calculatedValue;
        try {
             const sign = whole < 0 ? -1 : 1;
             // Calculate improper numerator, ensuring num is treated as positive relative to whole
             const improperNum = sign * (Math.abs(whole) * den + Math.abs(num));
             calculatedValue = math.fraction(improperNum, den); // Math.js handles simplification
        } catch(e) {
            console.error("Error calculating value for unsimplified mixed number", e);
            calculatedValue = NaN; // Set value to NaN on calculation error
        }

        // Return the custom object structure containing original parts and calculated value
        return {
            type: 'UnsimplifiedMixedNumber', // Identifier for formatting
            whole: whole,                    // Store original (parsed) whole
            num: num,                        // Store original (parsed) numerator
            den: den,                        // Store original (parsed) denominator
            value: calculatedValue           // Store the actual numerical value (math.Fraction or NaN)
        };
    }

    // ** Returns just the simplified math.Fraction object **
    function __computeCreateSimplifiedMixedNumber(wholeInput, numInput, denInput) {
        // Parse inputs to numbers, defaulting whole to 0 if not provided or invalid
        const whole = (typeof wholeInput === 'number') ? wholeInput : parseFloat(wholeInput || '0');
        const num = (typeof numInput === 'number') ? numInput : parseFloat(numInput);
        const den = (typeof denInput === 'number') ? denInput : parseFloat(denInput);

        // --- Input Validation ---
        if (isNaN(den) || !Number.isInteger(den) || den <= 0) {
             console.warn(`CreateSimplifiedMixedNumber: Denominator must be a positive integer. Got: ${denInput} -> ${den}`);
             return NaN; // Return Not-a-Number for invalid input
        }
        if (isNaN(whole) || !isFinite(whole) || isNaN(num) || !Number.isInteger(num) || num < 0) {
             console.warn(`CreateSimplifiedMixedNumber: Invalid inputs after conversion. whole=${wholeInput}->${whole}, num=${numInput}->${num}, den=${denInput}->${den}`);
             return NaN; // Return Not-a-Number for invalid input
        }
        // --- End Validation ---

        try {
             // Calculate the improper numerator, respecting the sign of the whole part
             const sign = whole < 0 ? -1 : 1;
             // Ensure numerator is treated as positive relative to the whole part during calculation
             const improperNumerator = sign * (Math.abs(whole) * den + Math.abs(num));

             // Create and return the math.js Fraction object. It handles simplification automatically.
             return math.fraction(improperNumerator, den); // <<< CORRECT: Returns the math.Fraction

        } catch(e) {
             // Catch potential errors during math.fraction creation (though unlikely with validation)
             console.error(`CreateSimplifiedMixedNumber: Error creating math.fraction(${whole}, ${num}, ${den})`, e);
             return NaN; // Return NaN on error
        }
    }



  // Enhanced __computeFractionNumerator to handle UnsimplifiedFraction objects
function __computeFractionNumerator(value) {
    try {
        // Handle UnsimplifiedFraction objects
        if (value && typeof value === 'object' && value.type === 'UnsimplifiedFraction') {
            return value.numerator; // Return the original numerator
        }
        
        // Handle standard math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            return value.s * value.n; // Numerator with sign
        }
        
        // Attempt to convert if not already a fraction
        const converted = math.fraction(value);
        return converted.s * converted.n;
    } catch (e) {
        console.warn(`FractionNumerator: Could not process value:`, value, e);
        return NaN;
    }
}

// Enhanced __computeFractionDenominator to handle UnsimplifiedFraction objects  
function __computeFractionDenominator(value) {
    try {
        // Handle UnsimplifiedFraction objects
        if (value && typeof value === 'object' && value.type === 'UnsimplifiedFraction') {
            return value.denominator; // Return the original denominator
        }
        
        // Handle standard math.Fraction objects
        if (value && typeof value === 'object' && value.isFraction) {
            return value.d; // Denominator (always positive)
        }
        
        // Attempt to convert if not already a fraction
        const converted = math.fraction(value);
        return converted.d;
    } catch (e) {
        console.warn(`FractionDenominator: Could not process value:`, value, e);
        return NaN;
    }
}

        // ** Returns just the simplified math.Fraction object **
        function __computeCreateReducedImproperFraction(wholeInput, numInput, denInput) {
        const whole = (typeof wholeInput === 'number') ? wholeInput : parseFloat(wholeInput || '0');
        const num = (typeof numInput === 'number') ? numInput : parseFloat(numInput);
        const den = (typeof denInput === 'number') ? denInput : parseFloat(denInput);
        if (isNaN(den) || !Number.isInteger(den) || den <= 0) { console.warn(`RedImpFrac: Invalid denominator ${denInput}`); return NaN; }
        if (isNaN(whole) || !isFinite(whole) || isNaN(num) || !Number.isInteger(num) || num < 0) { console.warn(`RedImpFrac: Invalid whole/num ${wholeInput}, ${numInput}`); return NaN; }
        try {
             const sign = whole < 0 ? -1 : 1;
             const improperNum = sign * (Math.abs(whole) * den + Math.abs(num));
             return math.fraction(improperNum, den); // RETURN math.Fraction directly
        } catch(e) { console.error(`RedImpFrac Error: ${e}`); return NaN; }
    }




        /**
     * Generates prime numbers up to a given limit using the Sieve of Eratosthenes.
     * @param {number} limit The upper bound (inclusive) to check for primes.
     * @returns {number[]} An array of prime numbers up to the limit.
     */
     function generatePrimesUpTo(limit) {
        if (limit < 2) return [];
        const isPrime = new Array(limit + 1).fill(true);
        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime
        for (let p = 2; p * p <= limit; p++) {
            if (isPrime[p]) {
                for (let i = p * p; i <= limit; i += p) {
                    isPrime[i] = false; // Mark multiples as not prime
                }
            }
        }
        const primes = [];
        for (let p = 2; p <= limit; p++) {
            if (isPrime[p]) {
                primes.push(p);
            }
        }
        return primes;
    }


    function __computeFractionNumerator(value) {
        // Assume value is resolved (number or math.Fraction)
        try {
            if (!(value && typeof value === 'object' && value.isFraction)) {
                 // Attempt to convert if not already a fraction
                 value = math.fraction(value);
            }
            return value.s * value.n; // Numerator with sign
        } catch (e) {
            console.warn(`FractionNumerator: Could not process value:`, value, e);
            return NaN;
        }
    }

    function __computeFractionDenominator(value) {
         // Assume value is resolved (number or math.Fraction)
        try {
            if (!(value && typeof value === 'object' && value.isFraction)) {
                 value = math.fraction(value);
            }
            return value.d; // Denominator (always positive)
        } catch (e) {
            console.warn(`FractionDenominator: Could not process value:`, value, e);
            return NaN;
        }
    }
        // --- Core Compute Functions (MUST be defined before calculateVariables) ---

    // ... (keep existing __computeRandomInt, __computeFraction, __computeRandomFloat, __computeRandomName) ...

    function __computeGcd(valA, valB) {
        if (typeof valA !== 'number' || !Number.isInteger(valA) || typeof valB !== 'number' || !Number.isInteger(valB)) {
            console.warn(`GCD: Inputs must be integers. Got a=${valA}, b=${valB}.`); return NaN;
        }
        return math.gcd(valA, valB); // Use Math.js gcd
    }

    function __computeLcm(valA, valB) {
         if (typeof valA !== 'number' || !Number.isInteger(valA) || typeof valB !== 'number' || !Number.isInteger(valB)) {
            console.warn(`LCM: Inputs must be integers. Got a=${valA}, b=${valB}.`); return NaN;
        }
        return math.lcm(valA, valB); // Use Math.js lcm
    }

    function __computeChoosePrime(config, context) {
        let parsedConfig;

        // 1. Parse the config input (it will be a string from math.evaluate)
        if (typeof config === 'string') {
            try {
                parsedConfig = JSON.parse(config);
            } catch (e) {
                console.error("ChoosePrime: Error parsing config JSON:", config, e);
                return NaN; // Cannot proceed without valid config
            }
        } else if (typeof config === 'object' && config !== null) {
            // Allow passing object directly (e.g., for testing), though math.evaluate sends string
            parsedConfig = config;
        } else {
            console.error("ChoosePrime: Invalid config input type:", typeof config);
            return NaN;
        }

        // 2. Resolve the 'max' value from the parsed config using the context
        // Provide a default value ('100') if 'max' is missing in the config
        const resolvedMax = resolveValue(parsedConfig.max ?? '100', context);

        // 3. Validate the RESOLVED max value
        if (typeof resolvedMax !== 'number' || !Number.isInteger(resolvedMax) || resolvedMax < 2) {
            // Log the problematic RESOLVED value for better debugging
            console.warn(`ChoosePrime: Max value must be an integer >= 2. Got max=${resolvedMax} (from input '${parsedConfig.max}')`);
            return NaN;
        }

        // 4. Generate primes up to the validated maximum
        const allPrimes = generatePrimesUpTo(resolvedMax);
        if (allPrimes.length === 0) {
            console.warn(`ChoosePrime: No primes found up to ${resolvedMax}.`);
            return NaN;
        }

        // 5. Resolve exclusions from the parsed config using the context
        const resolvedExclusions = resolveExclusions(parsedConfig.exclude ?? '', context);
        // Filter exclusions to only include valid integers
        const numericExclusions = resolvedExclusions.filter(e => typeof e === 'number' && Number.isInteger(e));

        // 6. Filter the generated primes based on exclusions
        const possiblePrimes = allPrimes.filter(p => !numericExclusions.includes(p));
        if (possiblePrimes.length === 0) {
            console.warn(`ChoosePrime: No primes available up to ${resolvedMax} after excluding [${numericExclusions.join(', ')}].`);
            return NaN;
        }

        // 7. Select and return a random prime from the available list
        return possiblePrimes[Math.floor(Math.random() * possiblePrimes.length)];
    }

    function __computeAbs(value) {
        if (typeof value !== 'number' || !isFinite(value)) {
            // Check if it's a fraction object
             if (value && typeof value === 'object' && value.isFraction) {
                 return math.abs(value); // Math.js handles abs for fractions
             }
             console.warn(`Abs: Input must be a finite number or Fraction. Got value=${value}.`); return NaN;
        }
        return Math.abs(value);
    }

    function __computeQuotient(dividend, divisor) {
         if (typeof dividend !== 'number' || !isFinite(dividend) || typeof divisor !== 'number' || !isFinite(divisor)) {
             console.warn(`Quotient: Inputs must be finite numbers. Got dividend=${dividend}, divisor=${divisor}.`); return NaN;
         }
         if (divisor === 0) { console.warn(`Quotient: Division by zero.`); return NaN; }
         return Math.trunc(dividend / divisor);
    }

    function __computeRemainder(dividend, divisor) {
        if (typeof dividend !== 'number' || !isFinite(dividend) || typeof divisor !== 'number' || !isFinite(divisor)) {
             console.warn(`Remainder: Inputs must be finite numbers. Got dividend=${dividend}, divisor=${divisor}.`); return NaN;
        }
        if (divisor === 0) { console.warn(`Remainder: Division by zero.`); return NaN; }
        return math.mod(dividend, divisor); // Use math.mod for consistency
    }

   

// --- Helper Functions (Keep these defined globally or where accessible) ---

/**
 * Resolves a string value which could be a literal number, a variable name, or a string.
 * @param {string|number|any} valueStr The string or value to resolve.
 * @param {object} context The current evaluation scope containing defined variables.
 * @returns {number|string|any} The resolved value (number, string, or the original value if not a string/variable).
 */
 function resolveValue(valueStr, context) {
  // If it's not a string, just return it (numbers, objects, etc.)
  if (typeof valueStr !== 'string') {
    return valueStr;
  }
  const trimmed = valueStr.trim();

  // **TREAT** empty string **AND** the literal "undefined" as JavaScript undefined
  if (!trimmed || trimmed === 'undefined') {
    return undefined;
  }

  // SECURITY: Prevent prototype pollution attacks
  const dangerousNames = [
    '__proto__', 
    'constructor', 
    'prototype',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toString',
    'valueOf',
    '__defineGetter__',
    '__defineSetter__',
    '__lookupGetter__',
    '__lookupSetter__'
  ];
  
  if (dangerousNames.includes(trimmed.toLowerCase())) {
    console.warn(`Security: Blocked dangerous property name: ${trimmed}`);
    return undefined;
  }

  // SECURITY: Only allow safe property access
  if (context && typeof context === 'object' && context !== null) {
    // Use Object.prototype.hasOwnProperty.call to avoid prototype pollution
    if (Object.prototype.hasOwnProperty.call(context, trimmed)) {
      const value = context[trimmed];
      
      // SECURITY: Don't return functions (could be malicious)
      if (typeof value === 'function') {
        console.warn(`Security: Blocked function access: ${trimmed}`);
        return undefined;
      }
      
      return value;
    }
  }

  // Otherwise, try to parse as a number
  const num = parseFloat(trimmed);
  if (!isNaN(num) && isFinite(num) &&
      String(num) === trimmed.replace(/^\+/, '')) {
    return num;
  }

  // Fallback: return as plain string
  return trimmed;
}

/**
 * Resolves a comma/space/semicolon-separated string of exclusions into an array of values.
 * @param {string} excludeStr The string containing exclusions.
 * @param {object} context The current evaluation scope.
 * @returns {Array<number|string|any>} An array of resolved exclusion values.
 */
 function resolveExclusions(excludeStr, context) {
    if (!excludeStr || typeof excludeStr !== 'string') {
        return [];
    }
    
    // SECURITY: Limit total exclusions to prevent DoS
    const MAX_EXCLUSIONS = 100;
    
    // Split by comma, semicolon, or one or more whitespace characters
    const parts = excludeStr.split(/[,;\s]+/)
        .filter(s => s.trim() !== '')
        .slice(0, MAX_EXCLUSIONS); // Limit number of exclusions
    
    const resolved = parts.map(part => {
        // SECURITY: Limit exclusion string length
        const trimmedPart = part.trim();
        if (trimmedPart.length > 50) {
            console.warn(`Security: Exclusion too long, truncating: ${trimmedPart.slice(0, 20)}...`);
            return undefined;
        }
        
        return resolveValue(trimmedPart, context);
    });
    
    // Filter out undefined results which might occur from empty strings after splitting
    return resolved.filter(val => val !== undefined);
}
    // --- Calculation Logic ---

    // Function to get config data from a block element
    function getBlockConfig(block) {
        const config = {};
        const configElem = block.querySelector('.block-config');
        if (configElem) {
            configElem.querySelectorAll('[data-config-key]').forEach(input => {
                const key = input.dataset.configKey; if (!key) return;
                if (input.type === 'checkbox') { config[key] = input.checked; }
                // Read value directly for text, number, textarea
                else { config[key] = input.value; }
            });
        }
        // Add default values *if needed* (compute functions should handle defaults preferably)
        // Example: if (block.classList.contains('random-int') && !config.hasOwnProperty('min')) { config.min = '1'; }
        return config;
    }
    // Function to get the expression string from an equation container
        // Function to get the expression string from an equation container
    
        function getEquationExpression(equationElem) {

            // 0) First, scrub any leftover HTML in those contenteditable spans:
equationElem.querySelectorAll('.equation-text').forEach(span => {
  span.innerHTML = DOMPurify.sanitize(span.innerHTML, {
    ALLOWED_TAGS: [],    // no tags at all
    ALLOWED_ATTR: []     // no attributes
  });
});

  // 1) Quick math‐only path: if there are no building‐blocks, treat as plain text math
  let hasOnlyText = true;
  for (const ch of equationElem.childNodes) {
    if (ch.nodeType === Node.ELEMENT_NODE && ch.classList.contains('building-block')) {
      hasOnlyText = false;
      break;
    }
  }
  if (hasOnlyText) {
    let txt = '';
    equationElem.childNodes.forEach(c => {
      if (c.nodeType === Node.TEXT_NODE ||
          (c.nodeType === Node.ELEMENT_NODE && c.classList.contains('equation-text'))) {
        txt += c.textContent;
      }
    });
    txt = txt.replace(/\u00A0/g, ' ').trim();
    if (txt && /[+\-*/^()]/.test(txt)) {
      const esc = txt.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
      return `__evaluateFractionExpression("${esc}")`;
    }
  }

  // 2) Otherwise break into parts: text, if-conditions, and all building-blocks
  const parts = [];
  equationElem.childNodes.forEach(child => {
    // Plain text node
    if (child.nodeType === Node.TEXT_NODE) {
      const t = child.textContent.replace(/\u00A0/g,' ').trim();
      if (t) parts.push(t);
    }
    // <span class="equation-text">
    else if (child.nodeType === Node.ELEMENT_NODE &&
             child.classList.contains('equation-text')) {
      const t = child.textContent.replace(/\u00A0/g,' ').trim();
      if (t) parts.push(t);
    }
    // if-condition block
    else if (child.nodeType === Node.ELEMENT_NODE &&
             child.classList.contains('if-condition')) {
      let id = child.getAttribute('data-condition-id');
      if (!id) {
        id = 'cond_' + Date.now() + '_' + Math.random().toString(36).slice(2,9);
        child.setAttribute('data-condition-id', id);
      }
      parts.push(`evaluateConditionBlockById("${id}")`);
    }
    // any other building-block
    else if (child.nodeType === Node.ELEMENT_NODE &&
             child.classList.contains('building-block')) {
      const config = getBlockConfig(child);
      let funcName = '';
      let args = [];

      if (child.classList.contains('create-fraction')) {
        funcName = '__computeCreateFraction';
        args = [config.num ?? '0', config.den ?? '1'];
      }
      else if (child.classList.contains('unsimp-mixed-num')) {
        funcName = '__computeCreateUnsimplifiedMixedNumber';
        args = [config.whole ?? '0', config.num ?? '0', config.den ?? '1'];
      }
      else if (child.classList.contains('simp-mixed-num')) {
        funcName = '__computeCreateSimplifiedMixedNumber';
        args = [config.whole ?? '0', config.num ?? '0', config.den ?? '1'];
      }
      else if (child.classList.contains('red-improper-frac')) {
        funcName = '__computeCreateReducedImproperFraction';
        args = [config.whole ?? '0', config.num ?? '0', config.den ?? '1'];
      }
      else if (child.classList.contains('frac-num')) {
        funcName = '__computeFractionNumerator';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('frac-den')) {
        funcName = '__computeFractionDenominator';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('pyth-triple-multiples')) {
        funcName = '__computePythTripleMultiples';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
    }
    else if (child.classList.contains('random-int')) {
  funcName = '__computeRandomInt';
  // Embed the config as a JSON string literal:
  const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
  args = [ `'${cfgString}'` ];
}

      else if (child.classList.contains('fraction')) {
        funcName = '__computeFraction';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('random-float')) {
        funcName = '__computeRandomFloat';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('choose')) {
        funcName = '__computeChoose';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('random-name')) {
        funcName = '__computeRandomName';
        args = [];
      }
      else if (child.classList.contains('add-polynomials')) {
        funcName = '__computeAddPolynomials';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
    }
      else if (child.classList.contains('gcd')) {
        funcName = '__computeGcd';
        args = [config.a ?? '0', config.b ?? '0'];
      }
      else if (child.classList.contains('lcm')) {
        funcName = '__computeLcm';
        args = [config.a ?? '0', config.b ?? '0'];
      }
      else if (child.classList.contains('choose-prime')) {
        funcName = '__computeChoosePrime';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('abs')) {
        funcName = '__computeAbs';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('quotient')) {
        funcName = '__computeQuotient';
        args = [config.dividend ?? '0', config.divisor ?? '1'];
      }
      else if (child.classList.contains('remainder')) {
        funcName = '__computeRemainder';
        args = [config.dividend ?? '0', config.divisor ?? '1'];
      }
      else if (child.classList.contains('mixed-num-numerator')) {
        funcName = '__computeMixedNumberNumerator';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('format-mixed-num')) {
        funcName = '__computeFormatMixedNumber';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('mixed-num-whole')) {
        funcName = '__computeMixedNumberWhole';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('convert-improper')) {
        funcName = '__computeConvertToImproper';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('round')) {
        funcName = '__computeRound';
        args = [config.value ?? '0', config.decimals ?? '2'];
      }
      else if (child.classList.contains('convert-decimal')) {
        funcName = '__computeConvertToDecimal';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('round-up')) {
        funcName = '__computeRoundUp';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('round-down')) {
        funcName = '__computeRoundDown';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('square-root')) {
        funcName = '__computeSquareRoot';
        args = [config.value ?? '0', config.decimals ?? '6'];
      }
      else if (child.classList.contains('multiply-polynomials')) {
    funcName = '__computeMultiplyPolynomials';
    const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
    args = [ `'${cfgString}'` ];
}
      else if (child.classList.contains('nth-root')) {
        funcName = '__computeNthRoot';
        args = [config.value ?? '0', config.root ?? '3', config.decimals ?? '6'];
      }
      else if (child.classList.contains('algebraic-expr')) {
        funcName = '__computeAlgebraicExpression';
        args = [JSON.stringify(config.expression || ''), config.simplify === true];
      }
      else if (child.classList.contains('simplify-radical')) {
        funcName = '__computeSimplifyRadical';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('simplify-cube-root')) {
        funcName = '__computeSimplifyCubeRoot';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('simplify-nth-root')) {
        funcName = '__computeSimplifyNthRoot';
        args = [config.value ?? '0', config.root ?? '2'];
      }
      else if (child.classList.contains('simp-rad-coefficient')) {
        funcName = '__computeSimpRadCoefficient';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('simp-rad-radicand')) {
        funcName = '__computeSimpRadRadicand';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('simp-cbrt-coefficient')) {
        funcName = '__computeSimpCubeRootCoefficient';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('simp-cbrt-radicand')) {
        funcName = '__computeSimpCubeRootRadicand';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('quadratic-formula-decimal')) {
        funcName = '__computeQuadraticFormulaDecimal';
        args = [config.a ?? '1', config.b ?? '0', config.c ?? '0', config.decimals ?? '2'];
      }
      else if (child.classList.contains('quadratic-formula-radical')) {
        funcName = '__computeQuadraticFormulaRadical';
        args = [config.a ?? '1', config.b ?? '0', config.c ?? '0', `"${config.format ?? 'unified'}"`];
      }
      else if (child.classList.contains('quad-form-dec-ans1')) {
        funcName = '__computeQuadFormulaDecAns1';
        args = [config.a ?? '1', config.b ?? '0', config.c ?? '0', config.decimals ?? '2'];
      }
      else if (child.classList.contains('quad-form-dec-ans2')) {
        funcName = '__computeQuadFormulaDecAns2';
        args = [config.a ?? '1', config.b ?? '0', config.c ?? '0', config.decimals ?? '2'];
      }
      else if (child.classList.contains('sin-decimal')) {
        funcName = '__computeSinDecimal';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`, config.decimals ?? '4'];
      }
      else if (child.classList.contains('cos-decimal')) {
        funcName = '__computeCosDecimal';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`, config.decimals ?? '4'];
      }
      else if (child.classList.contains('tan-decimal')) {
        funcName = '__computeTanDecimal';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`, config.decimals ?? '4'];
      }
      else if (child.classList.contains('sin-exact')) {
        funcName = '__computeSinExact';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`];
      }
      else if (child.classList.contains('cos-exact')) {
        funcName = '__computeCosExact';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`];
      }
      else if (child.classList.contains('tan-exact')) {
        funcName = '__computeTanExact';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`];
      }
      else if (child.classList.contains('csc-exact')) {
        funcName = '__computeCscExact';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`];
      }
      else if (child.classList.contains('sec-exact')) {
        funcName = '__computeSecExact';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`];
      }
      else if (child.classList.contains('cot-exact')) {
        funcName = '__computeCotExact';
        args = [config.angle ?? '0', `"${config.mode ?? 'degrees'}"`];
      }
      else if (child.classList.contains('sin-inverse')) {
        funcName = '__computeArcsin';
        args = [config.value ?? '0', `"${config.mode ?? 'degrees'}"`, config.decimals ?? '4'];
      }
      else if (child.classList.contains('cos-inverse')) {
        funcName = '__computeArccos';
        args = [config.value ?? '0', `"${config.mode ?? 'degrees'}"`, config.decimals ?? '4'];
      }
      else if (child.classList.contains('tan-inverse')) {
        funcName = '__computeArctan';
        args = [config.value ?? '0', `"${config.mode ?? 'degrees'}"`, config.decimals ?? '4'];
      }
      else if (child.classList.contains('prime-factorization')) {
        funcName = '__computePrimeFactorization';
        args = [config.value ?? '0'];
      }
      else if (child.classList.contains('log-block')) {
        funcName = '__computeLog';
        args = [
          config.value ?? '0',
          config.base ?? '10',
          config.round === true,
          config.decimals ?? '4'
        ];
      }
      else if (child.classList.contains('ln-block')) {
        funcName = '__computeLn';
        args = [
          config.value ?? '0',
          config.round === true,
          config.decimals ?? '4'
        ];
      }
      else if (child.classList.contains('least-to-greatest')) {
        funcName = '__computeLeastToGreatest';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('greatest-to-least')) {
        funcName = '__computeGreatestToLeast';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('alphabetical')) {
        funcName = '__computeAlphabetical';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('list-max')) {
        funcName = '__computeListMax';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('list-min')) {
        funcName = '__computeListMin';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('random-order')) {
        funcName = '__computeRandomOrder';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('poly-relative-max')) {
        funcName = '__computePolyRelativeMax';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('poly-relative-max-coords')) {
        funcName = '__computePolyRelativeMaxCoordinates';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('poly-relative-min')) {
        funcName = '__computePolyRelativeMin';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('poly-relative-min-coords')) {
        funcName = '__computePolyRelativeMinCoordinates';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('poly-factored-max')) {
        funcName = '__computePolyFactoredMax';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('poly-factored-max-coords')) {
        funcName = '__computePolyFactoredMaxCoordinates';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('poly-factored-min')) {
        funcName = '__computePolyFactoredMin';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('pythagorean-triple')) {
        funcName = '__computePythagoreanTriple';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
    }
      else if (child.classList.contains('poly-factored-min-coords')) {
        funcName = '__computePolyFactoredMinCoordinates';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
        args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('coordinate-x-value')) {
        funcName = '__computeCoordinateXValue';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('coordinate-y-value')) {
        funcName = '__computeCoordinateYValue';
        const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
      }
      else if (child.classList.contains('text-block')) {
  funcName = '__computeText';
  const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
  args = [ `'${cfgString}'` ];
}

else if (child.classList.contains('choose-text')) {
    funcName = '__computeChooseText';
    const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
}
else if (child.classList.contains('choose-expr')) {
    funcName = '__computeChooseExpr';
    const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
    args = [ `'${cfgString}'` ];
}
else if (child.classList.contains('choose-num')) {
    funcName = '__computeChooseNum';
    const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
    args = [ `'${cfgString}'` ];
}
else if (child.classList.contains('blank')) {
  funcName = '__computeBlank';
  args = [];
}
else if (child.classList.contains('undefined')) {
  funcName = '__computeUndefined';
  args = [];
}
else if (child.classList.contains('count')) {
  funcName = '__computeCount';
  // we pass the entire config so the compute helper can read both items and target
  const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
  args = [ `'${cfgString}'` ];
}
else if (child.classList.contains('permutation')) {
    funcName = '__computePermutation';
    args = [config.n ?? '0', config.r ?? '0'];
}
else if (child.classList.contains('combination')) {
    funcName = '__computeCombination';
    args = [config.n ?? '0', config.r ?? '0'];
}
else if (child.classList.contains('synthetic-division')) {
    funcName = '__computeSyntheticDivision';
    const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
}
else if (child.classList.contains('polynomial-zeros')) {
    funcName = '__computePolynomialZeros';
    const cfgString = JSON.stringify(config).replace(/'/g, "\\'");
args = [ `'${cfgString}'` ];
}
      // Push the function call if we found one
      if (funcName) {
        parts.push(`${funcName}(${args.join(', ')})`);
      }
    }
  });

  return parts.join(' ');
}

    function __computeRandomInt(config, context) {
    // If config is a string (JSON), parse it
    if (typeof config === 'string') {
        try {
            config = JSON.parse(config);
        } catch (e) {
            console.error("Error parsing config:", e);
            return NaN;
        }
    }
    
    const resolvedMin = resolveValue(config.min ?? '1', context);
    const resolvedMax = resolveValue(config.max ?? '10', context);
    const exclusions = resolveExclusions(config.exclude ?? '', context);

    if (typeof resolvedMin !== 'number' || !Number.isInteger(resolvedMin)) { 
        console.warn(`RandomInt: Invalid Min: ${config.min}`); 
        return NaN; 
    }
    if (typeof resolvedMax !== 'number' || !Number.isInteger(resolvedMax)) { 
        console.warn(`RandomInt: Invalid Max: ${config.max}`); 
        return NaN; 
    }
    
    let min = Math.ceil(resolvedMin), max = Math.floor(resolvedMax);
    if (min > max) [min, max] = [max, min];

    const numericExclusions = exclusions.filter(e => typeof e === 'number' && Number.isInteger(e) && e >= min && e <= max);
    let possible = []; 
    for (let i = min; i <= max; i++) { 
        if (!numericExclusions.includes(i)) possible.push(i); 
    }
    
    if (possible.length === 0) { 
        console.warn(`RandomInt: No possible values...`); 
        return NaN; 
    }
    
    return possible[Math.floor(Math.random() * possible.length)];
}

      // RESTORED/CORRECTED Random Fraction Generator (No Context/Variable Resolution for ranges here)
    // This function is called by the block with data-block-type="fraction"
    function __computeFraction(config) {
    
        // If the runtime passed JSON as a string, convert it back to an object
if (typeof config === 'string') {
  try {
    config = JSON.parse(config);
  } catch (e) {
    console.error('⚠️  Bad JSON in config:', config, e);
    return NaN;           // or "" if the helper returns text
  }
}


    // 1) Parse your four bounds
    const numMin     = parseInt(config.numMin ?? '1', 10);
    const numMax     = parseInt(config.numMax ?? '10', 10);
    const denMin     = parseInt(config.denMin ?? '2', 10);
    const denMax     = parseInt(config.denMax ?? '10', 10);
    const simplified = config.simplified ?? true;

    // 2) If both ranges collapse to a single fraction, just return it
    if (numMin === numMax && denMin === denMax) {
        if (simplified) {
            return math.fraction(numMin, denMin);
        } else {
            return {
                type:        'UnsimplifiedFraction',
                numerator:   numMin,
                denominator: denMin,
                value:       math.fraction(numMin, denMin)
            };
        }
    }

    // 3) Validate numeric inputs
    if ([numMin, numMax, denMin, denMax].some(v => isNaN(v))) {
        console.warn('__computeFraction: invalid config ranges', config);
        return NaN;
    }

    // 4) Clamp to integers and ensure valid ranges
    let nMin = Math.ceil(numMin),
        nMax = Math.floor(numMax),
        dMin = Math.ceil(denMin),
        dMax = Math.floor(denMax);

    if (nMin > nMax) [nMin, nMax] = [nMax, nMin];
    if (dMin > dMax) [dMin, dMax] = [dMax, dMin];
    dMin = Math.max(1, dMin);

    // 5) Generate a (possibly simplified) random fraction
    let numerator, denominator, attempts = 0;
    const MAX_ATTEMPTS = 100;
    do {
        numerator   = Math.floor(Math.random() * (nMax - nMin + 1)) + nMin;
        denominator = Math.floor(Math.random() * (dMax - dMin + 1)) + dMin;
        attempts++;
        if (denominator === 0) continue;
        if (!simplified || math.gcd(Math.abs(numerator), Math.abs(denominator)) === 1) {
            break;
        }
    } while (attempts < MAX_ATTEMPTS);

    if (denominator === 0) {
        console.error('__computeFraction: zero denominator!', config);
        return NaN;
    }

    // 6) Return the result
    if (simplified) {
        return math.fraction(numerator, denominator);
    } else {
        return {
            type:        'UnsimplifiedFraction',
            numerator:   numerator,
            denominator: denominator,
            value:       math.fraction(numerator, denominator)
        };
    }
}

    function __computeRandomFloat(config, context) {
        
        // If the runtime passed JSON as a string, convert it back to an object
if (typeof config === 'string') {
  try {
    config = JSON.parse(config);
  } catch (e) {
    console.error('⚠️  Bad JSON in config:', config, e);
    return NaN;           // or "" if the helper returns text
  }
}

        // CORRECTED version with logging
        // console.log("Entering __computeRandomFloat. Config received:", JSON.stringify(config));
        const resolvedMin = resolveValue(config.min ?? '0', context);
        const resolvedMax = resolveValue(config.max ?? '10', context);
        const resolvedDecimals = resolveValue(config.decimals ?? '2', context);
        const exclusions = resolveExclusions(config.exclude ?? '', context);
        // console.log(`Resolved values: min=${resolvedMin}, max=${resolvedMax}, decimals=${resolvedDecimals}, exclusions=[${exclusions.join(',')}]`);

        if (typeof resolvedMin !== 'number' || !isFinite(resolvedMin)) { console.warn(`RandomFloat: Invalid Min: ${config.min}`); return NaN; }
        if (typeof resolvedMax !== 'number' || !isFinite(resolvedMax)) { console.warn(`RandomFloat: Invalid Max: ${config.max}`); return NaN; }
        if (typeof resolvedDecimals !== 'number' || !Number.isInteger(resolvedDecimals) || resolvedDecimals < 0) { console.warn(`RandomFloat: Invalid Decimals: ${config.decimals}`); return NaN; }

        let min = resolvedMin, max = resolvedMax; if (min > max) [min, max] = [max, min];
        const decimals = resolvedDecimals;
        const numericExclusions = exclusions.filter(e => typeof e === 'number' && isFinite(e));
        const tolerance = decimals > 0 ? Math.pow(10, -(decimals + 1)) : 1e-9;

        let attempts = 0; const MAX_ATTEMPTS = 100; let randomVal;
        do {
            const rawRand = Math.random() * (max - min) + min;
            const fixedString = rawRand.toFixed(decimals);
            randomVal = parseFloat(fixedString); // Crucial: parse the fixed string back to number
            // console.log(`Attempt ${attempts + 1}: rawRand=${rawRand}, fixedString="${fixedString}", randomVal=${randomVal}`);

            const isExcluded = numericExclusions.some(ex => Math.abs(randomVal - ex) < tolerance);
            if (!isExcluded) { /* console.log(`Returning valid value: ${randomVal}`); */ return randomVal; }
            // console.log(`Value ${randomVal} is excluded.`);
            attempts++;
        } while (attempts < MAX_ATTEMPTS);
        console.warn(`RandomFloat: Could not find non-excluded value...`); return randomVal;
    }

    function __computeChoose(config, context) { 
        
    
   if (typeof config === 'string') {
       try { config = JSON.parse(config); }
       catch (e) {                 // bad JSON → give up gracefully
           console.error('Bad JSON in __computeChoose:', config, e);
           return undefined;
       }
   }
  // 
        // CORRECTED version
        const itemsStr = config.items ?? '';
        if (typeof itemsStr !== 'string') { console.warn('Choose: Invalid items config', config); return undefined;}
        const parts = itemsStr.split(/[,;]\s*/).filter(s => s.trim() !== '');
        const resolvedItems = parts.map(part => resolveValue(part.trim(), context)).filter(item => item !== undefined);
        if (resolvedItems.length === 0) { console.warn(`Choose: No valid items...`); return undefined; }
        return resolvedItems[Math.floor(Math.random() * resolvedItems.length)];
    }

    const __usEuroTopNames = ["Olivia", "Emma", "Charlotte", "Amelia", "Sophia", "Isabella", "Ava", "Mia", "Evelyn", "Luna", "Noah", "Liam", "Oliver", "Elijah", "Mateo", "Lucas", "Levi", "Asher", "James", "Leo", "Sophie", "Marie", "Lea", "Lina", "Anna", "Maria", "Sofia", "Julia", "Chloé", "Alice", "Gabriel", "Adam", "Louis", "Raphaël", "Arthur", "Mohamed", "Jules", "Hugo", "Noah", "Léo" ];
    function __computeRandomName(config, context) { // CORRECTED version
        if (!__usEuroTopNames || __usEuroTopNames.length === 0) { console.error("RandomName: Name list is empty!"); return "ErrorNoNames"; }
        return __usEuroTopNames[Math.floor(Math.random() * __usEuroTopNames.length)];
    }

        // --- Main Calculation Function ---
          // --- Main Calculation Function ---
      // --- Main Calculation Function ---
    // --- Main Calculation Function ---
   // --- Main Calculation Function ---
   async function calculateVariables(currentDepth = 0) {

    if (currentDepth > MAX_RECURSION) { // Uses MAX_RECURSION from line 35
    console.error("Max recursion depth reached in calculateVariables. Aborting.");
    alert("Error: Calculation is too deeply nested. Please simplify your variable dependencies.");
    document.querySelectorAll('#variable-definitions .variable-result').forEach(el => {
        if (el.textContent === "Calculating...") el.textContent = "Error: Too deep";
    });
    return;
}
    // Security check for production use
    if (window.location.protocol !== 'file:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        console.warn('SECURITY WARNING: This tool is running in production without server-side validation. All security checks are client-side and can be bypassed.');
    }
    const evaluationScope = Object.create(null);// Initialize fresh scope for this run

    // --- Define Wrappers to Inject Scope ---
    const computeFuncs = {
        __computeRandomInt: (config) => __computeRandomInt(config, evaluationScope),
        __computeFraction: (config) => __computeFraction(config),
        __computeRandomFloat: (config) => __computeRandomFloat(config, evaluationScope),
        __computeChoose: (config) => __computeChoose(config, evaluationScope),
        __computeRandomName: () => __computeRandomName(),
        __computeChoosePrime: (config) => __computeChoosePrime(config, evaluationScope),
        __computeGcd: (a, b) => __computeGcd(a, b),
        __computeLcm: (a, b) => __computeLcm(a, b),
        __computeAbs: (val) => __computeAbs(val),
        __computeAddPolynomials: (config) => __computeAddPolynomials(config, evaluationScope),
        __computePythTripleMultiples: (config) => __computePythTripleMultiples(config, evaluationScope),
        __computeQuotient: (dvd, dvr) => __computeQuotient(dvd, dvr),
        __computeRemainder: (dvd, dvr) => __computeRemainder(dvd, dvr),
        __computeCreateFraction: (n, d) => __computeCreateFraction(n, d),
        __computeCreateUnsimplifiedMixedNumber: (w, n, d) => __computeCreateUnsimplifiedMixedNumber(w, n, d),
        __computeCreateSimplifiedMixedNumber: (w, n, d) => __computeCreateSimplifiedMixedNumber(w, n, d),
        __computeCreateReducedImproperFraction: (w, n, d) => __computeCreateReducedImproperFraction(w, n, d),
        __computeFractionNumerator: (val) => __computeFractionNumerator(val),
        __computeFractionDenominator: (val) => __computeFractionDenominator(val),
        __computeMixedNumberNumerator: (val) => __computeMixedNumberNumerator(val),
        __computeFormatMixedNumber: (val) => __computeFormatMixedNumber(val),
        __computeMixedNumberWhole: (val) => __computeMixedNumberWhole(val),
        __evaluateFractionExpression: (expr) => __evaluateFractionExpression(expr, evaluationScope),
        __computeConvertToImproper: (val) => __computeConvertToImproper(val),
        __computeRound: (val, decimals) => __computeRound(val, decimals),
        __computeConvertToDecimal: (val) => __computeConvertToDecimal(val),
        __computeRoundUp: (val) => __computeRoundUp(val),
        __computeRoundDown: (val) => __computeRoundDown(val),
        __computeSquareRoot: (val, decimals) => __computeSquareRoot(val, decimals),
        __computeNthRoot: (val, root, decimals) => __computeNthRoot(val, root, decimals),
        __computeAlgebraicExpression: (expr, simplify) => __computeAlgebraicExpression(expr, simplify, evaluationScope),
        __computeSimplifyRadical: (val) => __computeSimplifyRadical(val),
        __computeSimplifyCubeRoot: (val) => __computeSimplifyCubeRoot(val),
        __computeSimplifyNthRoot: (val, root) => __computeSimplifyNthRoot(val, root),
        __computeSimpRadCoefficient: (val) => __computeSimpRadCoefficient(val),
        __computeSimpRadRadicand: (val) => __computeSimpRadRadicand(val),
        __computeSimpCubeRootCoefficient: (val) => __computeSimpCubeRootCoefficient(val),
        __computeSimpCubeRootRadicand: (val) => __computeSimpCubeRootRadicand(val),
        __computeQuadraticFormulaDecimal: (a, b, c, decimals) => __computeQuadraticFormulaDecimal(a, b, c, decimals),
        __computeQuadraticFormulaRadical: (a, b, c, format) => __computeQuadraticFormulaRadical(a, b, c, format),
        __computeQuadFormulaDecAns1: (a, b, c, decimals) => __computeQuadFormulaDecAns1(a, b, c, decimals),
        __computeQuadFormulaDecAns2: (a, b, c, decimals) => __computeQuadFormulaDecAns2(a, b, c, decimals),
        __computeSinDecimal: (angle, mode, decimals) => __computeSinDecimal(angle, mode, decimals),
        __computeCosDecimal: (angle, mode, decimals) => __computeCosDecimal(angle, mode, decimals),
        __computeTanDecimal: (angle, mode, decimals) => __computeTanDecimal(angle, mode, decimals),
        __computeSinExact: (angle, mode) => __computeSinExact(angle, mode),
        __computeCosExact: (angle, mode) => __computeCosExact(angle, mode),
        __computeTanExact: (angle, mode) => __computeTanExact(angle, mode),
        __computeCscExact: (angle, mode) => __computeCscExact(angle, mode),
        __computeSecExact: (angle, mode) => __computeSecExact(angle, mode),
        __computeCotExact: (angle, mode) => __computeCotExact(angle, mode),
        __computeArcsin: (val, mode, decimals) => __computeArcsin(val, mode, decimals),
        __computeArccos: (val, mode, decimals) => __computeArccos(val, mode, decimals),
        __computeArctan: (val, mode, decimals) => __computeArctan(val, mode, decimals),
        __computePrimeFactorization: (val) => __computePrimeFactorization(val),
        __computeLog: (val, base, round, decimals) => __computeLog(val, base, round, decimals),
        __computeLn: (val, round, decimals) => __computeLn(val, round, decimals),
        __computeLeastToGreatest: (config) => __computeLeastToGreatest(config, evaluationScope),
        __computeGreatestToLeast: (config) => __computeGreatestToLeast(config, evaluationScope),
        __computeAlphabetical: (config) => __computeAlphabetical(config, evaluationScope),
        __computeListMax: (config) => __computeListMax(config, evaluationScope),
        __computeListMin: (config) => __computeListMin(config, evaluationScope),
        __computeRandomOrder: (config) => __computeRandomOrder(config, evaluationScope),
        __computePolyRelativeMax: (config) => __computePolyRelativeMax(config, evaluationScope),
        __computePolyRelativeMaxCoordinates: (config) => __computePolyRelativeMaxCoordinates(config, evaluationScope),
        __computePolyRelativeMin: (config) => __computePolyRelativeMin(config, evaluationScope),
        __computePolyRelativeMinCoordinates: (config) => __computePolyRelativeMinCoordinates(config, evaluationScope),
        __computePolyFactoredMax: (config) => __computePolyFactoredMax(config, evaluationScope),
        __computePolyFactoredMaxCoordinates: (config) => __computePolyFactoredMaxCoordinates(config, evaluationScope),
        __computePolyFactoredMin: (config) => __computePolyFactoredMin(config, evaluationScope),
        __computePolyFactoredMinCoordinates: (config) => __computePolyFactoredMinCoordinates(config, evaluationScope),
        __computeCoordinateXValue: (config) => __computeCoordinateXValue(config, evaluationScope),
        __computeCoordinateYValue: (config) => __computeCoordinateYValue(config, evaluationScope),
        __computeText: (cfg) => __computeText(cfg),
        __computeChooseText : (c)=>__computeChooseText(c,evaluationScope),
__computeChooseExpr : (c)=>__computeChooseExpr(c,evaluationScope),
__computeChooseNum  : (c)=>__computeChooseNum(c,evaluationScope),
__computeBlank: () => "",        // blank → empty string
__computeUndefined: () => undefined,
__computeCount: (cfg) => __computeCount(cfg, evaluationScope),
__computePythagoreanTriple: (config) => __computePythagoreanTriple(config, evaluationScope),
__computePermutation: (n, r) => __computePermutation(n, r),
__computeCombination: (n, r) => __computeCombination(n, r),
__computeSyntheticDivision: (config) => __computeSyntheticDivision(config, evaluationScope),
__computePolynomialZeros: (config) => __computePolynomialZeros(config, evaluationScope),
__computeMultiplyPolynomials: (config) => __computeMultiplyPolynomials(config, evaluationScope),


        evaluateConditionBlock: (blockHtml) => {
            const element = createElementFromHTML(blockHtml);
            return evaluateConditionBlock(element, evaluationScope);
        },
        evaluateConditionBlockById: (id) => {
            const element = document.querySelector(`[data-condition-id="${id}"]`);
            if (!element) {
                console.warn(`No condition block found with id "${id}"`);
                return NaN;
            }
            return evaluateConditionBlock(element, evaluationScope);
        }
    };

    // Inject all computeFuncs into the evaluation scope for math.js
    Object.assign(evaluationScope, computeFuncs);

    // --- Collect and validate variable definitions ---
    const finalContext = Object.create(null);
    const varDefs = document.querySelectorAll('#variable-definitions .variable-definition');
    const calculationSteps = [];
    const namesInOrder = [];
    let nameErrorFound = false;
    
    // Check variable count limit
    if (varDefs.length > MAX_VARIABLES) {
        alert(`Security Warning: Too many variables (${varDefs.length}). Maximum allowed is ${MAX_VARIABLES}.`);
        console.error(`Variable count exceeds limit: ${varDefs.length} > ${MAX_VARIABLES}`);
        return;
    }

    varDefs.forEach(varDef => {
        if (nameErrorFound) return;
        const nameElem = varDef.querySelector('.variable-name[contenteditable="true"]');
        const eqElem = varDef.querySelector('.editable-equation');
        const resultElem = varDef.querySelector('.variable-result');
        if (!nameElem || !eqElem || !resultElem) {
            console.error("Variable definition structure incomplete:", varDef);
            if (resultElem) {
                resultElem.textContent = "Error: Incomplete structure.";
                resultElem.style.color = 'red';
            }
            nameErrorFound = true;
            return;
        }
        const varName = nameElem.textContent.trim();
        resultElem.textContent = "";
        if (!varName || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(varName)) {
            resultElem.textContent = "Error: Invalid name.";
            resultElem.style.color = 'red';
            nameErrorFound = true;
            return;
        }
        if (namesInOrder.includes(varName)) {
            resultElem.textContent = "Error: Duplicate name.";
            resultElem.style.color = 'red';
            nameErrorFound = true;
            return;
        }
        namesInOrder.push(varName);
        resultElem.textContent = "Calculating...";
        resultElem.style.color = '#555';

        let exprStr = '0';
        try {
            exprStr = getEquationExpression(eqElem) || '0';
        } catch (e) {
            console.error(`Error getting expression for ${varName}:`, e);
            resultElem.textContent = "Error: Cannot parse equation.";
            resultElem.style.color = 'red';
            nameErrorFound = true;
            return;
        }

        calculationSteps.push({
            name: varName,
            expression: exprStr,
            resultElem: resultElem,
            originalExpr: exprStr
        });
    });

    if (nameErrorFound) {
        console.warn("Calculation aborted due to errors.");
        calculationSteps.forEach(item => {
            if (item.resultElem.textContent === "Calculating...") {
                item.resultElem.textContent = "";
            }
        });
        return;
    }

    // --- Evaluate each expression in order ---
    for (const item of calculationSteps) {
        let result;
        try {
         // Sanitize the raw expression string to strip any HTML that slipped through
const safeExpr = DOMPurify.sanitize(item.expression, {
  ALLOWED_TAGS: [],
  ALLOWED_ATTR: []
});
// Compile and evaluate only the cleaned string
// SECURITY: Apply rate limiting
// SECURITY: Apply rate limiting
expressionRateLimit.checkLimit();

// SECURITY: Use our secure evaluation
result = await safeEvaluateExpression(safeExpr, evaluationScope);


let valueForScope;
if (result && typeof result === 'object' && result.type === 'UnsimplifiedMixedNumber') {
    valueForScope = result.value;
    finalContext[item.name] = result;
} else if (result && typeof result === 'object' && result.type === 'UnsimplifiedFraction') {
    valueForScope = result.value;  // Use the simplified fraction for calculations
    finalContext[item.name] = result;  // Keep the original object for display
} else {
    valueForScope = result;
    finalContext[item.name] = result;
}
evaluationScope[item.name] = valueForScope;

            // Create accessor variables immediately after a variable is calculated
// Create accessor variables immediately after a variable is calculated
if (result && typeof result === 'object' && result.type === 'PythagoreanTriple') {
    // Create accessors for Pythagorean Triple immediately
    evaluationScope[item.name + 'a'] = result.a;
    evaluationScope[item.name + 'b'] = result.b;
    evaluationScope[item.name + 'c'] = result.c;
    
    finalContext[item.name + 'a'] = result.a;
    finalContext[item.name + 'b'] = result.b;
    finalContext[item.name + 'c'] = result.c;
}
            const isReducedImproperFraction = item.originalExpr.includes('__computeCreateReducedImproperFraction');
            const isConvertToImproper = item.originalExpr.includes('__computeConvertToImproper');
            let displayResult;
            if (result && typeof result === 'object' && result.type === 'PythagoreanTriple') {
                // Special handling for Pythagorean Triple objects
                displayResult = `${result.a}-${result.b}-${result.c}`;
            } else if (isConvertToImproper) {
                displayResult = formatImproperFraction(result);
            } else {
                displayResult = formatFraction(result, isReducedImproperFraction);
            }
            if (Array.isArray(result)) {
                displayResult = "[" + result
                    .map(el => typeof el === 'string' ? `"${el}"` : String(el))
                    .join(", ") + "]";
            }

            item.resultElem.textContent = `Result: ${displayResult}`;
            item.resultElem.style.color = '#333';

        } catch (e) {
            console.error(`Error evaluating ${item.name}:`, e);
            evaluationScope[item.name] = undefined;
            finalContext[item.name] = undefined;
            const msg = e.message.length > 70 ? e.message.slice(0, 70) + '...' : e.message;
            item.resultElem.textContent = `Error: ${msg}`;
            item.resultElem.style.color = 'red';
        }
    }

    // Process any accessor variables for PythagoreanTriple objects
Object.entries(finalContext).forEach(([varName, value]) => {
    if (value && typeof value === 'object' && value.type === 'PythagoreanTriple') {
        // Create accessor variables (va, vb, vc)
        evaluationScope[varName + 'a'] = value.a;
        evaluationScope[varName + 'b'] = value.b;
        evaluationScope[varName + 'c'] = value.c;
        
        // Also add to finalContext for consistency
        finalContext[varName + 'a'] = value.a;
        finalContext[varName + 'b'] = value.b;
        finalContext[varName + 'c'] = value.c;
    }
});

console.log("Final context (raw results/objects):", finalContext);

    console.log("Final context (raw results/objects):", finalContext);
}

  </script>
</body>
</html>


// TODO: Add a strict Content Security Policy (CSP) via meta tag or HTTP headers
// TODO: Pin all external scripts/styles with Subresource Integrity (SRI) and crossorigin="anonymous"
// TODO: Self-host any remaining third-party libs (math.js, DOMPurify, etc.) instead of CDN
// TODO: Serve security headers: X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security, Referrer-Policy, Permissions-Policy
// TODO: Move all inline <script> and <style> blocks into external files to tighten CSP
// TODO: Sandbox the math evaluator in a Web Worker and enforce a timeout on long‐running tasks
// TODO: Rate-limit or throttle expression submissions to further guard against DoS
// TODO: Periodically audit and update dependencies to address new CVEs
